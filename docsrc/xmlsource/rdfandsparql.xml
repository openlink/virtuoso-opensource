<chapter label="rdfandsparql.xml" id="rdfandsparql"><title>RDF Data Access and Data Management</title>
<abstract>
<para>
Starting with version 4.5, Virtuoso provides built-in support for SPARQL, the standard query language for RDF and the semantic web.

Adoption of SPARQL with Virtuoso is effortless, as any  existing SQL client applications and stored procedures can take advantage of SPARQL simply by using it in the place of or inside SQL queries.  Additionally, Virtuoso offers the standard SPARQL protocol to HTTP clients.
From version 5.0.7, Virtuoso can be used  as the RDF store/query processor of the Jena and Sesame RDF frameworks.
</para>

<para>
This chapter discusses Virtuoso's RDF triple storage and query capabilities. 
This discusses storing RDF data as well as mappping existing relational data into RDF for SPARQL access.  Numerous  SPARQL language extensions and standard compliance are coverd.
</para>
</abstract>
<sect1 id="rdfoverview"><title>Overview</title>
<para>The support of SPARQL in Virtuoso consists of two &quot;layers&quot; -- RDF support in SQL engine and SPARQL front-end compiler that translates SPARQL queries to SQL.</para>
<para>In its core, Virtuoso extends relational storage and SQL language with datatypes and language constructs required for handling RDF data like any &quot;traditional&quot; SQL datatype. There exist datatypes for RDF references (IRIs and blank nodes) and for RDF literals with types and languages. These datatypes are widely supported by built-in functions and there exists convenient conversions between RDF literals and other SQL datatypes.</para>
<para>SQL query language is extended with constructs that are convenient for &quot;very heterogeneous&quot; data of RDF graph. In traditional SQL queries, data types of retrieved values are mostly known in advance from the database schema via explicitly declared column types and types of return values of functions. An RDF graph contains mix of literals of all types, so cast errors are very frequent and a typical query should not terminate after some occasional type error in a huge data set.</para>
<para>SQL &quot;user-defined aggregate&quot; feature is used to support SPARQL DESCRIBE and CONSTRUCT statements, so many RDF triples about a subject can be converted into single &quot;dictionary of triples&quot; or can be written into single RDF/XML or TURTLE document.</para>
<para>SQL query language is also extended with BREAKUP construct that is somewhat &quot;inverse&quot; to aggregate functions. While aggregate functions are useful to convert big number of table rows into one or few rows of aggregated data, BREAKUP turns each &quot;wide&quot; and complete row of a relational table into many &quot;narrow&quot; rows of RDF result set.</para>
<para>

The listed features form a solid background for second part of
implementation -- a preprocessor that is called as soon as an input of
SQL compiler contains SPARQL keyword. The preprocessor expects that
the fragment after SPARQL keyword with well-parenthesized code is a
SPARQL query (or SPARUL statement). SPARQL front-end compiler creates
a text of SQL SELECT statement that replaces the original SPARQL
fragment and SQL compiler continues to read its input without seeing
any difference between the replaced part and any other SQL SELECT, so
one may not only send SPARQL queries over all supported protocols like
ODBC and JDBC but place them inside Virtuoso?PL stored procedures or
use them inside SQL SELECT statements where subqueries are allowed by
syntax.</para>


<para>RDF data can be added to the storage by parsing texts of RDF documents (functions
<link linkend="fn_rdf_load_rdfxml"><function>DB.DBA.RDF_LOAD_RDFXML</function></link>,
<link linkend="fn_rdf_load_rdfxml_mt"><function>DB.DBA.RDF_LOAD_RDFXML_MT</function></link>,
<link linkend="fn_ttlp"><function>DB.DBA.TTLP</function></link>,
<link linkend="fn_ttlp_mt"><function>DB.DBA.TTLP_MT</function></link>), by loading remote RDF resources by SPARUL <link linkend="rdfinsertmethodsload">LOAD</link> statement, by extracting and storing metadata while <link linkend="rdfinsertmethodvirtuosocrawler">crawling non-RDF resources</link> and many other <link linkend="rdfinsertmethods">RDF insert methods</link>. After bulk loading, RDF data can be edited using <link linkend="rdfsparul">SPARUL</link> update language.</para>
<para>The most important feature of Virtuoso SPARQL is that relational data may stay unchanged and not be loaded into RDF storage and they still can be accessed by SPARQL queries after creating appropriate <link linkend="rdfviews">RDF Views</link>. This is the best tool for adding RDF capabilities to existing database applications.</para>
<para>

Virtuoso is a &quot;quad store&quot;, not a &quot;triple
store&quot;. Instead of storing subject-predicate-object triples of
each individual graph in a separate storage (and the storage is
explicitly created before first use), Virtuoso stores
graph-subject-predicate-object quads in one common table (<link
linkend="rdfquadtables">DB.DBA.RDF_QUAD</link>). This simplifies
querying when &quot;interesting&quot; graphs are not known in
advance. E.g., while a SPARQL query is running, Virtuoso <link
linkend="virtuososponger">Sponger</link> can iteratively download
additional data in order to provide as complete an answer as
possible.</para>


<para>Quads stored in DB.DBA.RDF_QUAD are usually referred to as
&quot;physical quads&quot; as opposed to &quot;mapped quads&quot; that
are not really stored in any table at all but still are accessible by
SPARQL queries via RDF views.  The SPARQL processor sees no great  difference
between querying physical and mapped quads so a query may operate with
mix of data of all sorts. Thus, an application can easily provide both
access to relational data for SPARQL clients (HTTP and WSDL via <link
linkend="rdfsparqlprotocolendpoint">SPARQL protocol endpoint</link>)
and access to RDF data for traditional RDBMS clients (by passing
SPARQL queries via ODBC, JDBC and the like).</para>


<para>RDF is for data integration. This implies the need of resolving
both inconsistencies in RDF data that comes from various sources of
different nature and problems with queries that work fine on some
sample data from local data warehouse but fail on massive and/or
unexpected data from third party sources. <link
linkend="rdfsparqlrule">RDF inference</link> helps to support variety
of synonyms when different data sources uses different names for same
classes, properties and subjects. Queries can be debugged using all
methods that are traditional for SQL (what's executed is SQL), with
paying some attention to RDF-specific <link
linkend="rdfperformancetuning">performance tuning</link>.</para>

<para>

The whole purpose of SPARQL is to let application developers write
 queries faster than equivalent SQL code. A short SPARQL query
on a mix of physical quads and RDF views of a number of  applications may
sometimes replace pages of SQL text. On the other hand, SQL has more
expressive power than SPARQL so complicated business intelligence
queries should be written in a mixed style, as an SQL query with
SPARQL subqueries. Debugging of mixed-style queries is inconvenient,
reducing overall benefit in development time, so <link
linkend="sparqlbi">Business Intelligence Extensions for SPARQL</link>
can be used in order to greatly reduce the need for wrapping SQL
around SPARQL. Further, SPARQL protocol clients get access to the functionality, without needing SQL privileges. <link linkend="rdfsparqlrulefulltext">Full-text search
in SPARQL</link> eliminates one more reason for mixing SQL and
SPARQL. In addition, extending SPARQL let SPARQL clients to delegate
more business intelligence calculations to the server without any
changes in the infrastructure; this is especially important for web
applications that use AJAX tools (say, <ulink
url="http://oat.openlinksw.com">OAT OpenLink AJAX
Toolkit</ulink>).</para>

</sect1>
<sect1 id="rdfdatarepresentation"><title>Data Representation</title>
<para>This section covers how Virtuoso stores RDF triples. The IRI_ID built-in data type is introduced, along with the default table structures used for triple persistency.
These details are mostly hidden from users of RDF, thus this section is not necessary reading for typical use of Virtuoso with RDF.
</para>
<sect2 id="rdfiriidtype"><title>IRI_ID Type</title>
<para>The central notion of RDF is the IRI, or URI, which serves as the globally unique label of named nodes. The subject and predicate of a triple are always IRI's and the object may be an IRI or any other XML Schema scalar data type. In any case, an IRI is always distinct from any instance of any other data type.</para>
<para>Virtuoso supports a native IRI_ID data type, internally an unsigned 32 bit or unsigned 64 bit integer value.
Small databases can use 32 bit values but if database becomes big then the administrator should execute
<function>DB.DBA.RDF_64BIT_UPGRADE</function>() procedure that will switch to 64-bit values. This procedure takes time so if it is known in advance that the database will grow to billions of nodes then it could be convenient to upgrade it while it is empty.
An IRI_ID is never equal to any instance of any other type.</para>
<para>Thus, the object column of a table storing triples can be declared as ANY and IRI values will be distinguishable without recourse to any extra flag and IRI's will naturally occupy their own contiguous segment in the ANY type collation sequence. Indices can be defined over such columns. An IRI_ID is never automatically cast into any other type nor any other type into IRI_ID.</para>
<para>The functions iri_id_num (in i IRI_ID) and iri_id_from_num (in n INT) convert between signed integers and IRI_ID's. The function isiri_id (in i any) returns nonzero if the argument is of type IRI_ID, zero otherwise.</para>
<para>The syntax for an IRI_ID literal is <emphasis>#i&lt;NNN&gt;</emphasis> or <emphasis>#ib&lt;NNN&gt;</emphasis>, where <emphasis>&lt;NNN&gt;</emphasis> is up to 20 decimal digits. <emphasis>#i12345</emphasis> is equal to <emphasis>iri_id_from_num (12345)</emphasis> and <emphasis>#ib12345</emphasis> is equal to <emphasis>iri_id_from_num (12345) + min_64bit_bnode_iri_id ()</emphasis>.</para>	
<para>When received by a SQL client application, the ODBC driver or
interactive SQL will bind an IRI_ID to a character buffer, producing
the <emphasis>#i&lt;NNN&gt;</emphasis> syntax. When passing IRI_ID's from a client, one can pass an
integer and use the iri_id_from_num () function in the statement to
convert server side. A SQL client will normally not be exposed to
IRI_ID's since the SPARQL implementation returns IRI's in their text
form, not as internal id's. These will however be seen if reading the
internal tables directly.</para>
<note><para>Nobody, even DBA, should write directly to internal RDF tables, because some data from that tables are cached in a special way and cache is not automatically updated when content of tables has changed.</para></note>
</sect2>
<sect2 id="rdfboxtype"><title>RDF_BOX Type</title>
<para>While strings, numbers, dates and XML entities are &quot;native&quot; SQL datatypes,
RDF literal with non-default type or language have no exact matches among standard SQL types.
Virtuoso introduces a special data type called "RDF_BOX" in order to handle that cases.
Instance of RDF_BOX consists of data type, language, the content (or beginning characters of a long content)
and a possible reference to DB.DBA.RDF_OBJ table if the object is too long to be held in-line in some table or should be outlined for free-text indexing.</para>
<para>Usually applications do not need to access internals of an RDF boxes. This datatype is used in system tables but almost all SPARQL and RDF operations use standard SQL datatypes for arguments and return values.</para>
</sect2>
<sect2 id="rdfquadtables"><title>RDF_QUAD and other tables</title>
<para>The main tables of the default RDF storage system are:</para>
<programlisting>
create table DB.DBA.RDF_QUAD (
  G IRI_ID,
  S IRI_ID,
  P IRI_ID,
  O any,
  primary key (G,S,P,O) );
create bitmap index RDF_QUAD_OGPS on DB.DBA.RDF_QUAD (O, G, P, S);
</programlisting>
<para>Each triple (more correctly, each quad) is represented by one row in RDF_QUAD.
The columns represent the graph, subject, predicate and object.
The IRI_ID type columns reference RDF_IRI, which translates the internal id to the external name of the IRI.
The O column is of type ANY.
If the O value is a non-string SQL scalar, such as a number or date or IRI, it is stored in its native binary representation.
If it is a "very short" string (20 characters or less), it is also stored "as is".
Long strings and RDF literal with non-default type or language are stored as RDF_BOX values.
Instance of rdf_box consists of data type, language, the content (or beginning characters of a long content)
and a possible reference to RDF_OBJ if the object is too long to be held in-line in this table or should be outlined for free-text indexing.
</para>
<programlisting>
create table DB.DBA.RDF_PREFIX (
  RP_NAME varchar primary key,
  RP_ID int not null unique );
create table DB.DBA.RDF_IRI (
  RI_NAME varchar primary key,
  RI_ID IRI_ID not null unique );
</programlisting>
<para>These two tables store a mapping between internal IRI id's and their external string form.
A memory-resident cache contains recently used IRIs to reduce access to this table.
Function id_to_iri (in id IRI_ID) returns the IRI by its ID.
Function iri_to_id (in iri varchar, in may_create_new_id) returns an IRI_ID for given string;
if the string is not used before as an IRI then either NULL is returned or a new ID is allocated, depending on the second argument.
</para>
<programlisting>
create table DB.DBA.RDF_OBJ (
  RO_ID integer primary key,
    RO_VAL varchar,
  RO_LONG long varchar,
  RO_DIGEST any
)
create index RO_VAL on DB.DBA.RDF_OBJ (RO_VAL)
create index RO_DIGEST on DB.DBA.RDF_OBJ (RO_DIGEST)
;
</programlisting>
<para>When an O value of RDF_QUAD is longer than a certain limit or should be free-text indexed, the value is stored in this table.
Depending on the length of the value, it goes into the varchar or the long varchar column.
The RO_ID is contained in rdf_box object that is stored in the O column.
Still, the truncated value of O can be used for determining equality and range matching,
even if &lt; and &gt; of closely matching values need to look at the real string in RDF_OBJ.
When RO_LONG is used to store very long value, RO_VAL contains a simple checksum of the value, to accelerate search for identical values when the table is populated by new values.
</para>
<programlisting>
create table DB.DBA.RDF_DATATYPE (
    RDT_IID IRI_ID not null primary key,
    RDT_TWOBYTE integer not null unique,
    RDT_QNAME varchar );
</programlisting>
<para>The XML Schema data type of a typed string O represented as 2 bytes in the O varchar value. This table maps this into the broader IRI space where the type URI is given an IRI number.</para>
<programlisting>
create table DB.DBA.RDF_LANGUAGE (
    RL_ID varchar not null primary key,
    RL_TWOBYTE integer not null unique );
</programlisting>
<para>The varchar representation of a O which is a string with language has a two byte field for language. This table maps the short integer language id to the real language name such as 'en', 'en-US' or 'x-any'.</para>
<para><emphasis>Note that unlike datatype names, language names are not URIs.</emphasis></para>
<para>A short integer value can be used in both RDF_DATATYPE and RDF_LANGUAGE tables for two different purposes. E.g. an integer 257 is for 'unspecified datatype' as well as for 'unspecified language'.</para>
</sect2>
<sect2 id="rdfsqlmodes"><title>Short, Long and SQL Values</title>
<para>When processing an O, the SPARQL implementation may have it in one of three internal formats, called "valmodes". The below cases apply for strings:</para>
<para>The short format is the format where an O is stored in RDF_QUAD.</para>
<para>The long value is similar to short one but an rdf_box object, that consists of six fields:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem>short integer id of type referencing RDT_TWOBYTE, 257   if the type is not specified,</listitem>
<listitem>the string as inlined in O or as stored in RO_VAL or   RO_LONG,</listitem>
<listitem>the RO_ID if the string is from RDF_OBJ (otherwise   zero),</listitem>
<listitem>the short integer id of language referencing RL_TWOBYTE, 257 if the language is not specified,</listitem>
<listitem>flag whether the stored string value is complete or it is only the beginning that is inlined in O.</listitem>
</itemizedlist>
<para>The SQL value is the string as a narrow string representing the UTF8 encoding of the value, stripped of data type and language tag.</para>
<para>The SQL form of an IRI is the string. The long and short forms are the IRI_ID referencing RU_IRI_ID of RDF_URL.</para>
<para>For all non-string, non-IRI types, the short, long and SQL values are the same SQL scalar of the appropriate native SQL type. A SQL host variable meant to receive an O should be of the ANY type.</para>
<para>The SPARQL implementation will usually translate results to the SQL format before returning them.
Internally, it uses the shortest possible form suited to the operation. For equalities and joining, the
short form is always good. For range comparisons, the long form is needed etc. For arithmetic,
all three forms will do since the arguments are expected to be numbers which are stored as their binary
selves in O, thus the O column unaltered and uncast will do as an argument of arithmetic or numeric
comparison with, say, SQL literal constants.</para>
</sect2>
<sect2 id="rdfxmlschemacompat"><title>Special Cases and XML Schema Compatibility</title>
<para>We note that since we store numbers as the equivalent SQL binary type, we do not preserve the distinction of byte, boolean etc. These all become integer. If preserving such detail is for some reason important, then storage as a typed string is possible but is not done at present for reasons of compactness and performance.</para>
</sect2>
<sect2 id="rdfquietcast"><title>SQL Compiler Support - QUIETCAST option</title>
<para>The type cast behaviors of SQL and SPARQL are different. SQL will generally signal an error when an automatic cast fails. For example, a string can be compared to a date column if the string can be parsed as a date but otherwise the comparison should signal an error. In SPARQL, such situations are supposed to silently fail. Generally, SPARQL is much more relaxed with respect to data types.</para>
<para>These differences will be specially noticed if actual SQL data is processed with SPARQL via some sort of schema mapping translating references to triples into native tables and columns.</para>
<para>Also, even when dealing with the triple-oriented RDF_QUAD table, there are cases of joining between S and O such that the O can be a heterogeneous set of IRI's and other data whereas the S is always an IRI. The non-IRI to IRI comparison should not give cast errors but should silently fail. Also, in order to keep queries simple and easily optimizable, it should not be necessary to introduce extra predicates for testing if the O is n IRI before comparing with the S.</para>
<para>Due to these considerations, Virtuoso introduces a SQL statement option called QUIETCAST. When given in the OPTION clause of a SELECT, it switches to silent fail mode for automatic type casting.</para>
<para>The syntax is as follows:</para>
<programlisting>
select ... from .... option (QUIETCAST)
</programlisting>
<para>This option is automatically added by the SPARQL to SQL translator. The scope is the enclosing procedure body.</para>
</sect2>
<sect2 id="rdfdynamiclocal"><title>Dynamic Renaming of Local IRI's</title>
<para>
    There are cases where it is desirable to have IRI's in RDF storage
    that will change to reflect a change of the host name of the containing
    store.  This is specifically true of DAV resource metadata for local
    DAV resources.
    Such IRI's must be stored prefixed with <computeroutput>local:</computeroutput>.  
</para>
<para>
    If a user application makes statements with such a URI, then these statements will be returned with local:
    substituted with a prefix taken from the context as described below.
</para>
<para>
    When returning IRI's from id's, this prefix is replaced by the Host header of the HTTP request 
    and if not running with HTTP, with the DefaultHost from URIQA.  This behavior is always in effect.
</para>

<para>
    When converting strings to IRI id's, the <computeroutput>local:</computeroutput> prefix may or may not be introduced depending on ini file and other context factors.
    If <link linkend="VIRTINI">DynamicLocal</link> defined in the [URIQA] section of the Virtuoso INI file is on and the host part of the IRI matches the Host header of the HTTP request in context or the DefaultHost if outside of HTTP context, then this is replaced with local: before looking up the IRI ID.  Even if DynamicLocal is not on and the <computeroutput>local:</computeroutput> prefix occurs in the IRI string being translated to id, the translating the IRI_ID back to the IRI name will depend on the context as described above.
</para>
<para>
    The effects of DynamicLocal = 1 can be very confusing since many names
    can refer to the exact same thing.  For example, if the DefaultHost is
    dbpedia.org,
    <computeroutput>iri_to_id ('http://dbpedia.org/resource/Paris') = iri_to_id ('local:///resource/Paris) </computeroutput>
    is true and so is  
    <computeroutput>'http://dbpedia.org/resource/Paris' = id_to_iri (iri_to_id ('local://resource/Paris'))</computeroutput>
    These hold in a SQL client context, i.e. also when connected through RDF frameworks like Jena or Sesame.
    When running a SPARQL protocol request, the Host: header influences the behavior, likewise when using web interactive SQL in Conductor.
    Also be careful when loading RDF files that may have URI's corresponding to the local host name.
</para>
</sect2>
</sect1>
<sect1 id="rdfapiandsql"><title>RDF and SPARQL API and SQL</title>
<para>
SPARQL can be used inline wherever SQL can be used.  
The only API functions that one needs to know are the ones for loading RDF data into the store.
Dynamic SQL client applications can issue SPARQL queries against Virtuoso through the regular SQL client API, ODBC, JDBC or other, simply by prefixing the SPARQL query with the SPARQL keyword.  Parameters work just as with dynamic SQL.
Stored procedures can have SPARQL expressions inline and can declare cursors over SPARQL result sets.
</para>

<para>
Value conversions between SQL and SPARQL are most often automatic and
invisible.  In some cases one needs to be aware of the different
SPARQL value representations (valmodes). SPARQL offers declarations
for determining if graphs to be returned are to be represented as XML
or Turtle text serialization or whether these will be hash tables of
triples. See <link linkend="fn_dict_new"><function>dict_new()</function></link> and related functions for a description of the hash table SQL data type.
The use of dict's is convenient for further programmatic processing of graphs.
</para>

<para>RDF-related procedures use Virtuoso/PL vectors
and dictionaries to represent RDF triples and sets of triples.</para>
<para><emphasis>Valmode</emphasis> means the "format of values returned by an
expression", i.e. 'short', 'long' or 'SQL value'.</para>
<para><emphasis>Triple vector</emphasis> is a vector (array) of S, P and O, where all values are in
'long' formats, i.e. IRI_ID's for IRI values, numbers or datetimes for corresponding XMLSchema types, special &quot;RDF box&quot; objects if O is neither string nor IRI.</para>
<para><emphasis>Dictionary of triples</emphasis> or <emphasis>Hash table of triples</emphasis> is an
dictionary object made by the SQL function <emphasis>dict_new ()</emphasis> whose keys are
triple vectors and values are not specified; this is a good storage
format for an unordered set of distinct triples.</para>
<para><emphasis>Dictionary of blank node names</emphasis> is a dictionary used for tricky
processing of a number of TURTLE or RDF /XML descriptions of subgraphs
that come from a common graph. Imagine a situation where  different
descriptions actually refer to the same blank nodes of the original graph
and, moreover, the application that generates these descriptions always
generates the same blank node id string for the same node. A reader of
descriptions can correctly  join described subgraphs into one big
subgraph by filling in a dictionary that contains blank node id strings
as keys and IRI_ID's assigned to that strings as dependent data. As
soon as all readers of an application share the same dictionary of
nodes created before, no blank node is created twice;</para>

<sect2 id="rdfsparqlinline"><title>SPARQL Inline in SQL</title>
<para>Virtuoso extends the SQL 92 syntax with SPARQL queries and subqueries. Instead of writing a SQL SELECT query or subquery, one can write the SPARQL keyword and a SPARQL query after the keyword.</para>
<programlisting>
SQL>sparql select distinct ?p where { graph ?g { ?s ?p ?o } };
p
varchar
----------
http://example.org/ns#b
http://example.org/ns#d
http://xmlns.com/foaf/0.1/name
http://xmlns.com/foaf/0.1/mbox
...


SQL>select distinct subseq ("p", strchr ("p", '#')) as fragment
  from (sparql select distinct ?p where { graph ?g { ?s ?p ?o } } ) as all_predicates
  where "p" like '%#%';
fragment
varchar
----------
#query
#data
#name
#comment
...
</programlisting>
<para>Note that names of variables returned from SPARQL are always case-sensitive and no case mode rules apply to them.
Depending on CaseMode parameter in the virtuoso configuration file, double quotes should be used to refer to them in surrounding SQL code.
</para>
<para>
It is possible to pass parameters to a  SPARQL query via a Virtuoso-specific syntax extension.
<emphasis>??</emphasis> or <emphasis>$?</emphasis> indicates a positional parameter similar to <emphasis>?</emphasis> in plain SQL. <emphasis>??</emphasis> can be used in graph patterns or anywhere in the place of a SPARQL variable.
The value of a parameter should be passed in SQL form, i.e. this should be a number or a untyped string.
An IRI ID can be passed in all cases where an absolute IRI can, except the obvious case when the variable is an argument of a function that requires string.
If the parameter is used in 'graph', 'subject' or 'object' position of the sparql pattern, the string parameter is converted into IRI automatically.
In other cases, IRI string is indistinguishable from string literal, so there is a need in call of <emphasis>iri()</emphasis> built-in SPARQL function, like <emphasis>iri (??)</emphasis>.
Using this notation, any dynamic SQL client, whether ODBC, JDBC or other can execute parametrized SPARQL queries, binding parameters just as with dynamic SQL.
</para>
<programlisting><![CDATA[
SQL> create function param_passing_demo ()
{
  declare stat, msg varchar;
  declare mdata, rset any;
  exec ('sparql select ?s where { graph ?g { ?s ?? ?? }}',
    stat, msg,
    vector ( /* Vector of two parameters */
      'http://www.w3.org/2001/sw/DataAccess/tests/data/Sorting/sort-0#int1',
      4 ),
    10, /* Max no of rows */
    mdata, /* Variable to get metadata */
    rset ); /* Variable to get result-set */
  if (length (rset) = 0)
    signal ('23000',
      'No data found, try demo database with installed Virtuoso tutorials');
  return rset[0][0];
}

SQL> select param_passing_demo ();
callret
VARCHAR
_______________________________________________________________________________

http://www.w3.org/2001/sw/DataAccess/tests/data/Sorting/sort-0#four

1 Rows. -- 00000 msec.
]]></programlisting>
<para>An inline  SPARQL query can refer to SQL variables that are in scope in the SQL query or stored procedure containing it.
Virtuoso extends the SPARQL syntax with a special notation to this effect. A reference to SQL variable X can be written as <emphasis>?:X</emphasis> or <emphasis>$:X</emphasis>.
A reference to column <emphasis>C</emphasis> of table or sub-select with alias <emphasis>T</emphasis> can be written as <emphasis>?:T.C</emphasis> or <emphasis>$:T.C</emphasis>.
Both notations can be used in any place where a variable name is allowed, except 'AS' clause described below.
</para>
<para>A column of a result set of a SPARQL SELECT can be used in SQL code inside a for statement just like any column from a SQL select.
</para>
<para>SQL rules about double-quoted names are applicable to variables that are passed to a SPARQL query or selected  from one.
If a variable name contains unusual characters or should not be normalized according to SQL conventions then the
name should use double quotes for escaping. E.g., the notation <emphasis>?:"OrderLine"</emphasis> will always refer to variable or column
titled <emphasis>OrderLine</emphasis> whereas <emphasis>?:OrderLine</emphasis> can be converted to <emphasis>ORDERLINE</emphasis> or <emphasis>orderline</emphasis>.
</para>
<para>It is safer to avoid using variable names that conflict with column names of RDF system tables, esp. <emphasis>G</emphasis>, <emphasis>S</emphasis>, <emphasis>P</emphasis> and <emphasis>O</emphasis>.
These names are not reserved now but they may cause subtle bugs when an incorrect SPARQL subquery is compiled into SQL code that refers to table columns of same names.
Some of these names may be rejected as syntax errors by future Virtuoso versions.
</para>
<programlisting><![CDATA[
SQL> create procedure sql_vars_demo ()
{
#pragma prefix sort0: <http://www.w3.org/2001/sw/DataAccess/tests/data/Sorting/sort-0#>
  declare RES varchar;
  declare obj integer;
  result_names (RES);
  obj := 4;
  for (sparql select ?subj where { graph ?g { ?subj sort0:int1 ?:obj } } ) do
    result ("subj");
}

SQL> sql_vars_demo ();
RES
VARCHAR
_______________________________________________________________________________

http://www.w3.org/2001/sw/DataAccess/tests/data/Sorting/sort-0#four

1 Rows. -- 00000 msec.
]]></programlisting>
<para>The example also demonstrates the Virtuoso/PL pragma line for procedure-wide declarations of namespace prefixes.
This makes the code more readable and eliminates duplicate declarations of namespace prefixes when the procedure
contains many SPARQL fragments that refer to a common set of namespaces.
</para>
<para>SPARQL ASK query can be used as an argument of the SQL EXISTS predicate.
</para>
<programlisting><![CDATA[
create function sparql_ask_demo () returns varchar
{
  if (exists (sparql ask where { graph ?g { ?s ?p 4}}))
    return 'YES';
  else
    return 'NO';
}

SQL> select sparql_ask_demo ();
_______________________________________________________________________________

YES
]]>
</programlisting>
<sect3 id="rdfcontrollingsparqloutputtypes"><title>Controlling SPARQL Output Data Types</title>
<para>The compilation of a SPARQL query may depend on environment that is usually provided by the SPARQL protocol, including name of default graph URI. Environment settings that come from protocol may override settings in the text of SPARQL query. To let an application configure the environment for a query,
 SPARQL syntax is extended with the 'define' clause:</para>
<programlisting>
define parameter-qname parameter-value
</programlisting>
<para>Examples of supported parameters are <emphasis>output:valmode</emphasis> and <emphasis>output:format</emphasis></para>
<para><emphasis>output:valmode</emphasis> sets the SQL representation used for values in the result set.
In most cases applications need SQL values to be returned by SPARQL.
By default the query returns a result set of values in SQL format and behaves as a typical SQL select.
To compose triple vectors in Virtuoso/PL code application may need data in long format.
If the query contains a</para>
<programlisting>
define output:valmode 'LONG'
</programlisting>
<para>clause then all returned values are in long format. E.g., the following query returns IRI_ID's instead of IRI strings.</para>
<programlisting>
SQL>sparql define output:valmode 'LONG' select distinct ?p where { graph ?g { ?s ?p ?o } };
p
----------
#i1000001
#i1000003
#i1000005
#i1000006
...
</programlisting>
<para><emphasis>output:format</emphasis> instruct SPARQL compiler that the result of the query should be serialized into an RDF document;
that document will be returned as  a single column  of a single  row result set.
<emphasis>output:format</emphasis> is especially useful if SPARQL CONSTRUCT or SPARQL DESCRIBE query is executed directly via ODBC or JDBC database connection
and the client can not receive the resulting dictionary of triples (there's no way to transfer such an object via ODBC).
Using this option, the  client can receive the document that contains the whole result set of a SELECT or the dictionary of triples of a CONSTRUCT/DESCRIBE, and parse it locally.
</para>
<para>
Supported values for <emphasis>output:format</emphasis> are <emphasis>RDF/XML</emphasis> and <emphasis>TURTLE</emphasis> (or <emphasis>TTL</emphasis>).
If both <emphasis>output:valmode</emphasis> and <emphasis>output:format</emphasis> are specified, <emphasis>output:format</emphasis> has higher priority,
raising an error if <emphasis>output:valmode</emphasis> is set to a value other than <emphasis>LONG</emphasis>.
</para>
<para>
When a SPARQL query is compiled, the compiler checks whether the result set is sent to the remote ODBC/JDBC client or used in some other way.
The compiler will automatically set <emphasis>output:format</emphasis> to <emphasis>TURTLE</emphasis> if compiling for execution by an SQL client.
</para>
<para>
The example below demonstrates how different values of <emphasis>output:format</emphasis> affect the result of SPARQL SELECT.
Note 10 rows and 4 columns in the first result, and single LONG VARCHAR in two others.
Using the ISQL  client, use 'set blobs on;' directive to fetch long texts without 'data truncated' warning.
</para>
<programlisting><![CDATA[
SQL> sparql select * where {graph ?g { ?s ?p ?o }} limit 10;
g                                            s                    p                              o
VARCHAR                                      VARCHAR              VARCHAR                        VARCHAR
______________________________________________________________________

http://local.virt/DAV/bound/manifest.rdf     nodeID://1000000000  http://example.com/test#query  http://local.virt/DAV/bound/bound1.rq
. . .
http://local.virt/DAV/examples/manifest.rdf  nodeID://1000000019  http://example.com/test#query  http://local.virt/DAV/examples/ex11.2.3.1_1.rq

10 Rows. -- 00000 msec.

SQL> sparql define output:format "TTL" select * where {graph ?g { ?s ?p ?o }} limit 10;
callret-0
LONG VARCHAR
_______________________________________________________________________________

@prefix :rdf <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix :rs <http://www.w3.org/2005/sparql-results#> .
@prefix :xsd <http://www.w3.org/2001/XMLSchema#> .
[ rdf:type rs:results ;
  rs:result [
      rs:binding [ rs:name "g" ; rs:value <http://local.virt/DAV/bound/manifest.rdf> ] ;
      rs:binding [ rs:name "s" ; rs:value _:nodeID1000000000 ] ;
      rs:binding [ rs:name "p" ; rs:value <http://example.com/test#query> ] ;
      rs:binding [ rs:name "o" ; rs:value <http://local.virt/DAV/bound/bound1.rq> ] ;
      ] ;

. . .

  rs:result [
      rs:binding [ rs:name "g" ; rs:value <http://local.virt/DAV/examples/manifest.rdf> ] ;
      rs:binding [ rs:name "s" ; rs:value _:nodeID1000000019 ] ;
      rs:binding [ rs:name "p" ; rs:value <http://example.com/test#query> ] ;
      rs:binding [ rs:name "o" ; rs:value <http://local.virt/DAV/examples/ex11.2.3.1_1.rq> ] ;
      ] ;
    ] .

1 Rows. -- 00000 msec.

SQL> sparql define output:format "RDF/XML" select * where {graph ?g { ?s ?p ?o }} limit 10;
callret-0
LONG VARCHAR
_______________________________________________________________________________

<rdf:RDF
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:rs="http://www.w3.org/2005/sparql-results#"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema#" >
   <rs:results rdf:nodeID="rset">
  <rs:result rdf:nodeID="sol206">
   <rs:binding rdf:nodeID="sol206-0" rs:name="g"><rs:value rdf:resource="http://local.virt/DAV/bound/manifest.rdf"/></rs:binding>
   <rs:binding rdf:nodeID="sol206-1" rs:name="s"><rs:value rdf:nodeID="1000000000"/></rs:binding>
   <rs:binding rdf:nodeID="sol206-2" rs:name="p"><rs:value rdf:resource="http://example.com/test#query"/></rs:binding>
   <rs:binding rdf:nodeID="sol206-3" rs:name="o"><rs:value rdf:resource="http://local.virt/DAV/bound/bound1.rq"/></rs:binding>
  </rs:result>

. . .

  <rs:result rdf:nodeID="sol5737">
   <rs:binding rdf:nodeID="sol5737-0" rs:name="g"><rs:value rdf:resource="http://local.virt/DAV/examples/manifest.rdf"/></rs:binding>
   <rs:binding rdf:nodeID="sol5737-1" rs:name="s"><rs:value rdf:nodeID="1000000019"/></rs:binding>
   <rs:binding rdf:nodeID="sol5737-2" rs:name="p"><rs:value rdf:resource="http://example.com/test#query"/></rs:binding>
   <rs:binding rdf:nodeID="sol5737-3" rs:name="o"><rs:value rdf:resource="http://local.virt/DAV/examples/ex11.2.3.1_1.rq"/></rs:binding>
  </rs:result>
 </rs:results>
</rdf:RDF>

1 Rows. -- 00000 msec. 
]]></programlisting>
<para>SPARQL CONSTRUCT and SPARQL DESCRIBE results are serialized as one would expect:</para>
<programlisting><![CDATA[
SQL> sparql define output:format "TTL" construct { ?s ?p "004" } where {graph ?g { ?s ?p 4 }};
callret-0
LONG VARCHAR
_______________________________________________________________________________

<http://www.w3.org/2001/sw/DataAccess/tests/data/Sorting/sort-0#four> <http://www.w3.org/2001/sw/DataAccess/tests/data/Sorting/sort-0#int1> "004" .
_:b1000000913 <http://www.w3.org/2001/sw/DataAccess/tests/result-set#index> "004" .


1 Rows. -- 00000 msec.

SQL> sparql define output:format "RDF/XML" construct { ?s ?p "004" } where {graph ?g { ?s ?p 4 }};
callret-0
LONG VARCHAR
_______________________________________________________________________________

<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<rdf:Description about="http://www.w3.org/2001/sw/DataAccess/tests/data/Sorting/sort-0#four"><ns0pred:int1 xmlns:ns0pred="http://www.w3.org/2001/sw/DataAccess/tests/data/Sorting/sort-0#">004</ns0pred:int1></rdf:Description>
<rdf:Description rdf:nodeID="b1000000913"><ns0pred:index xmlns:ns0pred="http://www.w3.org/2001/sw/DataAccess/tests/result-set#">004</ns0pred:index></rdf:Description>
</rdf:RDF>

1 Rows. -- 00000 msec. 
]]></programlisting>
<para>SPARQL ASK returns a non-empty result set if the match is found for graph pattern, empty result-set otherwise. If <emphasis>output:format</emphasis> is specified then the query makes a 'boolean result' document instead:</para>
<programlisting><![CDATA[
SQL> sparql ask where {graph ?g { ?s ?p 4 }};
__ask_retval
INTEGER
_______________________________________________________________________________

1

1 Rows. -- 00000 msec.

SQL> sparql ask where {graph ?g { ?s ?p "no such" }};
__ask_retval
INTEGER
_______________________________________________________________________________


0 Rows. -- 00000 msec.

SQL> sparql define output:format "TTL" ask where {graph ?g { ?s ?p 4 }};
callret
VARCHAR
_______________________________________________________________________________

@prefix :rdf <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
 @prefix :rs <http://www.w3.org/2005/sparql-results#> .
[ rdf:type rs:results ; rs:boolean TRUE ]

1 Rows. -- 00000 msec.

SQL> sparql define output:format "RDF/XML" ask where {graph ?g { ?s ?p 4 }};
callret
VARCHAR
_______________________________________________________________________________

<rdf:RDF
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:rs="http://www.w3.org/2005/sparql-results#"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema#" >
   <rs:results rdf:nodeID="rset">
    <rs:boolean rdf:datatype="http://www.w3.org/2001/XMLSchema#boolean">1</rs:boolean></results></rdf:RDF>

1 Rows. -- 00000 msec.
]]></programlisting>
</sect3>
</sect2>



<sect2 id="rdfapi">
<title>API Functions</title> 

<sect3
id="rdfapidataimport"><title>Data Import</title>
<para>DB.DBA.TTLP() parses TTL (TURTLE or N3 resource) and places its triples into DB.DBA.RDF_QUAD.</para>
<programlisting>
create procedure DB.DBA.TTLP (
    in strg any,       -- text of the resource
    in base varchar,  -- base IRI to resolve relative IRIs to absolute
    in graph varchar, -- target graph IRI, parsed triples will appear in that graph.
    in flags int)   -- bitmask of flags that permit some sorts of syntax errors in resource, use 0.
</programlisting>
<para>For loading a file of any greater length, it is most practical to use
the file_to_string_output function.
</para>
<para>It is important the file to be accessible for the Virtuoso server. You need to have set properly the
<emphasis>DirsAllowed</emphasis> parameter value in section [Parameters] of the Virtuoso database INI file.
For example on Windows it could be:
</para>
<programlisting>
virtuoso.ini file:
[Parameters]
...
DirsAllowed =  .\tmp
...
</programlisting>
<para>So in the example the file you want to import from, should be in the tmp folder or in its subfolder.
Note that this example folder is a subfolder of the Virtuoso Server working directory.
</para>
<programlisting>
SQL> DB.DBA.TTLP (file_to_string_output ('.\tmp\data.ttl'), '', 'http://my_graph', 0);
</programlisting>
<para>The DB.DBA.TTLP_MT() procedure is like DB.DBA.TTLP() but loads the file on multiple threads,
using parallel I/O and multiprocessing if available. The functions does not leave a transaction log.
Hence, after successful load, one should execute the checkpoint statement to make sure that a
server restart does not wipe out the results.
</para>
<programlisting>
create procedure DB.DBA.TTLP_MT (
    in strg any,       -- text of the resource
    in base varchar,   -- base IRI to resolve relative IRIs to absolute
    in graph varchar,  -- target graph IRI, parsed triples will appear in that graph.
    in flags int) -- flags, use 0
</programlisting>
<para>For loading large resources when transactional integrity is not important (loading of a single resource may take more than one transaction)
you can use also the <emphasis>DB.DBA.RDF_LOAD_RDFXML_MT()</emphasis> procedure:</para>
<programlisting>
create procedure DB.DBA.RDF_LOAD_RDFXML_MT (
    in strg varchar,  -- text of the resource
    in base varchar,  -- base IRI to resolve relative IRIs to absolute
    in graph varchar) -- target graph IRI, parsed triples will appear in that graph.
</programlisting>
<para>The following example demonstrates importing data from the rdf resource with URI: http://www.w3.org/People/Berners-Lee/card</para>
<programlisting><![CDATA[
SQL>create procedure MY_LOAD_FILE (in full_uri varchar, in in_resultset integer := 0)
{
  declare REPORT varchar;
  declare graph_uri, dattext varchar;
  declare app_env any;
  app_env := null;
  whenever sqlstate '*' goto err_rep;
  if (not in_resultset)
    result_names (REPORT);
  dattext := cast (XML_URI_GET_AND_CACHE (full_uri) as varchar);
  MY_SPARQL_REPORT (sprintf ('Downloading %s: %d bytes',
      full_uri, length (dattext) ) );
  graph_uri := full_uri;
  delete from RDF_QUAD where G = DB.DBA.RDF_MAKE_IID_OF_QNAME (graph_uri);
  DB.DBA.RDF_LOAD_RDFXML_MT (dattext, full_uri, graph_uri);
  return graph_uri;
err_rep:
  result (sprintf ('%s: %s', __SQL_STATE, __SQL_MESSAGE));
  return graph_uri;
}
;

Done. -- 0 msec.

SQL>create procedure MY_SPARQL_REPORT(in strg varchar)
{
  if (__tag(strg) <> 182)
    strg := cast (strg as varchar) || sprintf (' -- not a string, tag=%d', __tag(strg));
  strg := replace (strg, 'SPARQL_DAV_DATA_URI()', '\044{SPARQL_DAV_DATA_URI()}');
  strg := replace (strg, 'SPARQL_DAV_DATA_PATH()', '\044{SPARQL_DAV_DATA_PATH()}');
  strg := replace (strg, 'SPARQL_FILE_DATA_ROOT()', '\044{SPARQL_FILE_DATA_ROOT()}');
  result (strg);
}
;

Done. -- 0 msec.

SQL> MY_LOAD_FILE('http://www.w3.org/People/Berners-Lee/card');
REPORT
VARCHAR
_______________________________________________________________________________

Downloading http://www.w3.org/People/Berners-Lee/card: 17773 bytes

1 Rows. -- 4046 msec.

SQL>sparql
select *
from <http://www.w3.org/People/Berners-Lee/card>
where {?s ?p ?o} ;

s                                             p                                               o
VARCHAR                                       VARCHAR                                         VARCHAR
__________________________________________________________________________________________________________

http://bblfish.net/people/henry/card#me       http://xmlns.com/foaf/0.1/name                  Henry Story
http://www.w3.org/People/Berners-Lee/card#i   http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://xmlns.com/foaf/0.1/Person
http://www.w3.org/People/Berners-Lee/card#i   http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://www.w3.org/2000/10/swap/pim/contact#Male
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/nick                  TimBL
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/nick                  timbl
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/mbox                  mailto:timbl@w3.org
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/mbox_sha1sum          965c47c5a70db7407210cef6e4e6f5374a525c5c
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/knows                 http://bblfish.net/people/henry/card#me
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/knows                 http://hometown.aol.com/chbussler/foaf/chbussler.foaf#me
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/knows                 http://danbri.org/foaf#danbri
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/knows                 http://norman.walsh.name/knows/who#norman-walsh
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/knows                 http://www.aaronsw.com/about.xrdf#aaronsw
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/knows                 http://www.ivan-herman.net/foaf.rdf#me
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/knows                 http://www.w3.org/People/Berners-Lee/card#amy
http://www.w3.org/People/Berners-Lee/card#i   http://xmlns.com/foaf/0.1/knows                 http://dig.csail.mit.edu/People/RRS
..........

]]></programlisting>
<para>The DB.DBA.RDF_TTL2HASH() does not load TTL content, instead it returns a dict of triples in 'long valmode'.</para>
<programlisting>
create function DB.DBA.RDF_TTL2HASH (
    in strg any,
    in base varchar,
    in graph varchar ) returns any
</programlisting>
<para>Parameter <emphasis>flags</emphasis> is useful when syntax of resource is TURTLE-like but not correct TURTLE.
By default, use zero value.
Add 1 to let string literals contain end-of-line characters.
Add 2 to suppress error messages on blank node verbs.
Add 4 to let variables instead of blank nodes.
Add 8 to silently skip triples with literal subjects.
</para>
<para>The DB.DBA.RDF_LOAD_RDFXML() procedure parses RDF/XML and places its triples into DB.DBA.RDF_QUAD.</para>
<programlisting>
create procedure DB.DBA.RDF_LOAD_RDFXML (
    in strg any,           -- text of and XML document
    in base_iri varchar,   -- base IRI to resolve relative IRIs
    in graph_iri varchar ) -- the IRI of destination graph
</programlisting>
<para>To insert a single quad into DB.DBA.RDF_QUAD() table, use one of these procedures:</para>
<programlisting>
-- Simple insertion of a quad where object is a node
create procedure DB.DBA.RDF_QUAD_URI (
  in g_uri varchar, in s_uri varchar, in p_uri varchar,
  in o_uri varchar ) -- IRI string or IRI_ID

-- Simple insertion of a quad where object is a literal value in 'SQL valmode'
create procedure DB.DBA.RDF_QUAD_URI_L (
  in g_uri varchar, in s_uri varchar, in p_uri varchar,
  in o_lit any ) -- string, number or datetime, NULL is not allowed

create procedure DB.DBA.RDF_QUAD_URI_L_TYPED (
  in g_uri varchar, in s_uri varchar, in p_uri varchar,
  in o_lit any,     -- string value of the literal
  in dt any,        -- datatype as IRI string or IRI_ID, can be NULL
  in lang varchar ) -- language as string or NULL
</programlisting>
<para>Arguments g_uri, s_uri and p_uri of these three functions should be IRI strings or IRI_IDs.
All string arguments should be in UTF-8 encoding, otherwise they will be stored but are not queryable via SPARQL.</para>
</sect3>
<sect3 id="rdfapidataexport"><title>Data Export</title>
<para>These two procedures serializes vector of triples into a session, in TURTLE or RDF/XML syntax.
In current version, every triple is printed in separate top-level record (say, in rdf:Description tag), without any pretty-print or nesting optimization.
</para>
<programlisting>
create procedure DB.DBA.RDF_TRIPLES_TO_TTL (
    inout triples any, -- vector of triples in 'long valmode'.
    inout ses any )    -- an output stream in server default encoding

create procedure DB.DBA.RDF_TRIPLES_TO_RDF_XML_TEXT (
    inout triples any,          -- vector of triples in 'long valmode'.
    in print_top_level integer, -- zero if only rdf:Description tags should be written,
      -- non-zero if the rdf:RDF top-level element should also be written
    inout ses any )             -- an output stream in server default encoding
</programlisting>
</sect3>
<sect3 id="rdfapidataquery"><title>Data query</title>
<programlisting>
-- Local execution of SPARQL via SPARQL protocol, produces a result set of SQL values.
create procedure DB.DBA.SPARQL_EVAL (
    in query varchar,      -- text of SPARQL query to execute
    in dflt_graph varchar, -- default graph IRI, if not NULL then this overrides what's specified in query
    in maxrows integer )   -- limit on numbers of rows that should be returned.

-- Similar to SPARQL_EVAL, but returns a vector of vectors of SQL values.
create function DB.DBA.SPARQL_EVAL_TO_ARRAY (
    in query varchar,      -- text of SPARQL query to execute
    in dflt_graph varchar, -- default graph IRI, if not NULL then this overrides what's specified in query
    in maxrows integer )   -- limit on numbers of rows that should be returned.
returns any
</programlisting>
<programlisting>
-- Remote execution of SPARQL via SPARQL protocol, produces a result set of SQL values.
create procedure DB.DBA.SPARQL_REXEC (
    in service varchar,    -- service URI to call via HTTP
    in query varchar,      -- text of SPARQL query to execute
    in dflt_graph varchar, -- default graph IRI, if not NULL then this overrides what's specified in query
    in named_graphs any,   -- vector of named graph IRIs, if not NULL then this overrides what's specified in query
    in req_hdr any,        -- additional HTTP header lines that should be passed to the service; 'Host: ...' is most popular.
    in maxrows integer,    -- limit on numbers of rows that should be returned.
    in bnode_dict any )    -- dictionary of bnode ID references.

-- Similar to SPARQL_REXEC (), but returns a vector of vectors of SQL values.
-- All arguments are the same.
create function DB.DBA.SPARQL_REXEC_TO_ARRAY (
    in service varchar, in query varchar, in dflt_graph varchar, in named_graphs any,
    in req_hdr any, in maxrows integer, in bnode_dict any)
returns any

-- Similar to SPARQL_REXEC (), but fills in output parameters with metadata (like exec metadata) and a vector of vector
s of 'long valmode' values.
-- First seven arguments are the same.
create procedure DB.DBA.SPARQL_REXEC_WITH_META (
    in service varchar, in query varchar, in dflt_graph varchar, in named_graphs any,
    in req_hdr any, in maxrows integer, in bnode_dict any,
    out metadata any,  -- metadata like exec () returns.
    out resultset any) -- results as 'long valmode' value.
</programlisting>
<para>If the query is a CONSTRUCT or DESCRIBE then the result set consists of a single row and single column, the value inside is a dict of triples in 'long valmode'.</para>
</sect3>
</sect2>
<sect2 id="rdfinternalfunctions"><title>Useful Internal Functions</title>
<sect3 id="rdfinternalconversion"><title>Conversion Functions for XMLSchema/RDF Data Serialization Syntax</title>
<para>These functions emulate constructor functions from XQuery Core Function Library.</para>
<programlisting>
create function DB.DBA."http://www.w3.org/2001/XMLSchema#boolean" (in strg any) returns integer
create function DB.DBA."http://www.w3.org/2001/XMLSchema#dateTime" (in strg any) returns datetime
create function DB.DBA."http://www.w3.org/2001/XMLSchema#double" (in strg varchar) returns double precision
create function DB.DBA."http://www.w3.org/2001/XMLSchema#float" (in strg varchar) returns float
create function DB.DBA."http://www.w3.org/2001/XMLSchema#integer" (in strg varchar) returns integer
</programlisting>
</sect3>
<sect3 id="rdfinternalpredicates"><title>RDF-specific Predicates</title>
<programlisting>
-- Returns 1 if string s matches pattern p, 0 otherwise
create function DB.DBA.RDF_REGEX (
    in s varchar,            -- source string to check
    in p varchar,            -- regular expression pattern string
    in coll varchar := null) -- unused for now (modes are not yet implemented)

-- Returns 1 if language identifier r matches lang pattern t
create function DB.DBA.RDF_LANGMATCHES (
  in r varchar, -- language identifies (string or NULL)
  in t varchar) -- language pattern (exact name, first two letters or '*')
</programlisting>
</sect3>
</sect2>
<sect2 id="rdfdefaultgraph"><title>Default and Named Graphs</title>
<para>Sometimes the default graph IRI is not known when the SPARQL query is composed. It can be added at the very last moment by providing the IRI in 'define' clause as follows:</para>
<programlisting>
define input:default-graph-uri &lt;http://example.com&gt;
</programlisting>
<para>Such a definition overrides the default graph URI set in query by 'FROM ...' clause (if any).</para>
<para>The query may contain more than one <emphasis>define input:default-graph-uri</emphasis>.
The set of values of <emphasis>input:default-graph-uri</emphasis> has the highest possible priority and can not be redefined in the rest of the text of the query by FROM clauses.</para>
<para>FROM NAMED clauses can be used multiple in one query:</para>
<programlisting><![CDATA[
SELECT ?id
    FROM NAMED <http://example.com/user1.ttl>
    OPTION (get:soft "soft", get:method "GET")
    FROM NAMED <http://example.com/user2.ttl>
    OPTION (get:soft "soft", get:method "GET")
    WHERE { GRAPH ?g { ?id a ?o } };
]]></programlisting>
<para>Similarly, <emphasis>define input:named-graph-uri &lt;http://example.com&gt;</emphasis> is a replacement for FROM NAMED clause</para>
<para>
When Virtuoso receives a SPARQL request via HTTP, the value of default graph can be set in protocol as <emphasis>default-graph-uri</emphasis> HTTP parameter.
Multiple occurrences of this parameter are allowed. This HTTP parameter is converted into <emphasis>define input:default-graph-uri</emphasis>.
There's similar support for <emphasis>named-graph-uri</emphasis> HTTP parameter.
For debugging purposes, graph names set in protocol are sent back in the reply header as <emphasis>X-SPARQL-default-graph: ...</emphasis> and <emphasis>X-SPARQL-named-graph: ...</emphasis> header lines, one line per graph.
</para>
<para>
Web service endpoint may provide different default configurations for different host names mentioned in HTTP request.
This is configured via table <emphasis>DB.DBA.SYS_SPARQL_HOST</emphasis>.
</para>
<programlisting>
create table DB.DBA.SYS_SPARQL_HOST (
  SH_HOST	varchar not null primary key, -- host mask
  SH_GRAPH_URI	varchar,      -- 'default default' graph uri
  SH_USER_URI	varchar,      -- reserved for any use in applications
  SH_DEFINES	long varchar  -- additional defines for requests
)
</programlisting>
<para>
When the SPARQL web service endpoint receives a request it checks the <emphasis>Host</emphasis> HTTP header line.
This line contains zero or more target host names, delimited by commas.
For every host name in the line the service scans the <emphasis>DB.DBA.SYS_SPARQL_HOST</emphasis> in search of row such that host name is like <emphasis>SH_HOST</emphasis>.
The <emphasis>SH_HOST</emphasis> acts as 'pattern' argument for SQL string operator LIKE. If the row is found then the text of SPARQL request is extended.
If default graph is not explicitly set by HTTP parameters and <emphasis>SH_GRAPH_URI</emphasis> is not null then default graph is set to <emphasis>SH_GRAPH_URI</emphasis>.
If <emphasis>SH_DEFINES</emphasis> is not null then it is added in front of query so this field is a good place for text for any <emphasis>define</emphasis> options.
</para>
<para>
The search in <emphasis>DB.DBA.SYS_SPARQL_HOST</emphasis> stops at the first found row, other possible matches are silently ignored.
</para>
</sect2>
<sect2 id="rdfsqlfromsparql"><title>Calling SQL from SPARQL </title>
<para>A SPARQL expression can contain calls of Virtuoso/PL functions
and built-in SQL functions in both the WHERE clause and in
result set. Two namespace prefixes, <emphasis>bif</emphasis> and <emphasis>sql</emphasis> are reserved for
these purposes. When a function name starts with <emphasis>bif:</emphasis> namespace
prefix, the rest of name is treated as a name of SQL BIF (Built-In
Function). When a function name starts with <emphasis>sql:</emphasis> namespace prefix,
the rest of name is treated as a name of Virtuoso/PL function owned by
DBA with database qualifier DB, e.g. <emphasis>sql:example(...)</emphasis> is
converted into <emphasis>DB.DBA."example"(...)</emphasis>.</para>

<para>In both cases,
the function receives arguments in SQL format ('SQL valmode') and
returns the result also in SQL format.  The SPARQL compiler will
automatically add code for format conversion into the resulting SQL
code so SQL functions can be used even if <emphasis>define output:valmode
'LONG'</emphasis> forces the use of internal RDF representation in the
result set.</para>
<para><emphasis>Example:</emphasis></para>
<programlisting><![CDATA[
SQL>create procedure DB.DBA.ComposeInfo (
  in pname varchar,
  in pnick varchar := '',
  in pbox  varchar := '')
{
   declare ss varchar;
   ss := concat(pname, ' ', pnick, ' ', pbox);
   ss := rtrim (ss, ' ');
   return ss;

};
Done. -- 0 msec.

SQL>sparql
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select (sql:ComposeInfo (?name, ?nick, ?box))
from <http://www.w3.org/People/Berners-Lee/card>
where
  {
    ?s rdf:type foaf:Person .
    optional{?s foaf:name ?name }.
    optional{?s foaf:nick ?nick }.
    optional{?s foaf:box ?box }.
    filter (?nick like '%TimBL%') .
  };
callret-0
VARCHAR
_______________________________________________________________________________

Timothy Berners-Lee TimBL

1 Rows. -- 30 msec.
]]></programlisting>
</sect2>
<sect2 id="rdfsqlfromsparqldescribe"><title>SPARQL DESCRIBE</title>
  <para>SPARQL spec does not define the precise output of DESCRIBE, so different
applications may need different result for the same subject. Some
applications needs quick generation of short and incomplete results
whereas may need detailed reports composed from multiple sources.
  </para>
  <para>If define <emphasis>sql:describe-mode "xxx"</emphasis> is specified then the generated SQL
code will use procedures named:
  </para>
<programlisting><![CDATA[
DB.DBA.SPARQL_DESC_DICT_xxx (in subj_dict any, in consts any, in graphs
any, in storage_name any, in options any)
]]></programlisting>
  <para>and
  </para>
<programlisting><![CDATA[
DB.DBA.SPARQL_DESC_DICT_xxx_PHYSICAL (in subj_dict any, in consts any,
in graphs any, in storage_name any, in options any)
]]></programlisting>
  <para>In the blank new database, only one pair of such procedures is created,
<emphasis>DB.DBA.SPARQL_DESC_DICT_SPO</emphasis> and <emphasis>DB.DBA.SPARQL_DESC_DICT_SPO_PHYSICAL</emphasis>, so
only define <emphasis>sql:describe-mode "SPO"</emphasis> makes sense. This pair of procedures
searches for all triples where input IRIs are used as subjects; it is a bit faster than the default
routine that performs better search for related triples.
  </para>
  <para>Both procedures have same semantics but the second one is used if and
only if the SPARQL compiler can prove that all subjects to process are
from physical storage <emphasis>(DB.DBA.RDF_QUAD)</emphasis>. Thus the second procedure may
omit search for subject in RDF Views.
  </para>
  <para>Both procedures should return dictionary with triples as keys and
integer 1 as values. So the dictionary is filled by calls like:
  </para>
<programlisting><![CDATA[
dict_put (resulting_dict,
          vector (subj_iri_id, pred_iri_id, obj_iri_id_or_rdf_box),
          1);
]]></programlisting>
  <para>Procedure arguments are as follows:
  </para>
  <itemizedlist mark="bullet">
     <listitem><emphasis>subj_dict</emphasis> - a dictionary whose keys are IRI IDs and maybe values of
other types, esp. RDF boxes. Keys are subjects to be described, so
values other than IRI IDs should usually be ignored. Values should be
ignored.</listitem>
     <listitem><emphasis>consts</emphasis> - vector of IRI IDs and values of other types. Items of vector
are subjects to be described, like keys of subj_dict.</listitem>
     <listitem><emphasis>graphs</emphasis> - vector of IRI IDs of graphs that can be used for DESCRIBE. The
vector may contain garbage, like in two previous cases. A NULL can be
passed instead of vector indicating that source graphs are not specified
in the source query.</listitem>
     <listitem><emphasis>storage_name</emphasis> -  the value of "define input:storage" from the original
SPARQL query, NULL if missing.</listitem>
     <listitem><emphasis>options</emphasis> - reserved for future use, can be ignored.</listitem>
   </itemizedlist>
  <para>One should grant execute on both procedures to SPARQL_SELECT before referring to them in SPARQL.</para>
  <para>Example:
  </para>
<programlisting><![CDATA[
SQL>set blobs on;
SQL>sparql
sparql
define sql:describe-mode "SPO"
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX sioct: <http://rdfs.org/sioc/types#>

DESCRIBE ?forum
FROM <http://demo.openlinksw.com/dataspace>
WHERE {
  ?forum rdf:type sioct:Weblog .
}
LIMIT 1;

callret-0
LONG VARCHAR
_______________________________________________________________________________

<http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://rdfs.org/sioc/types#Weblog> ,
                <http://atomowl.org/ontologies/atomrdf#Feed> ;
        <http://rdfs.org/sioc/ns#description> "XML templates demo's Weblog" ;
        <http://rdfs.org/sioc/ns#has_space> <http://demo.openlinksw.com/dataspace/bloguser/space#this> ;
        <http://rdfs.org/sioc/ns#container_of> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog/20> ,
                <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog/21> ;
        <http://rdfs.org/sioc/ns#id> "bloguser_blog" ;
        <http://xmlns.com/foaf/0.1/maker> <http://demo.openlinksw.com/dataspace/person/bloguser#this> ;
        <http://rdfs.org/sioc/ns#link> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> ;
        <http://atomowl.org/ontologies/atomrdf#entry> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog/20> ,
                <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog/21> ;
        <http://atomowl.org/ontologies/atomrdf#contains> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog/21> ,
                <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog/20> ;
        <http://atomowl.org/ontologies/atomrdf#title> "bloguser_blog" ;
        <http://www.w3.org/2000/01/rdf-schema#label> "XML templates demo's Weblog" ;
        <http://rdfs.org/sioc/ns#scope_of> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog#owner> ;
        <http://rdfs.org/sioc/ns#has_owner> <http://demo.openlinksw.com/dataspace/bloguser#this> ;
        <http://www.w3.org/2000/01/rdf-schema#isDefinedBy> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog/sioc.rdf> ;
        <http://purl.org/dc/elements/1.1/identifier> "62"^^<http://www.w3.org/2001/XMLSchema#integer> ;
        <http://rdfs.org/sioc/services#has_service> <http://demo.openlinksw.com/RPC2> ,
                <http://demo.openlinksw.com/mt-tb> ,
                <http://demo.openlinksw.com/Atom/bloguser-blog-0> ,
                <http://demo.openlinksw.com/GData/bloguser-blog-0> .
<http://demo.openlinksw.com/RPC2> <http://rdfs.org/sioc/services#service_of> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> .
<http://demo.openlinksw.com/mt-tb> <http://rdfs.org/sioc/services#service_of> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> .
<http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog#owner> <http://rdfs.org/sioc/ns#has_scope> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> .
<http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog/20> <http://rdfs.org/sioc/ns#has_container> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> ;
        <http://atomowl.org/ontologies/atomrdf#source> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> .
<http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog/21> <http://rdfs.org/sioc/ns#has_container> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> ;
        <http://atomowl.org/ontologies/atomrdf#source> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> .
<http://demo.openlinksw.com/dataspace/bloguser#this> <http://rdfs.org/sioc/ns#owner_of> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> .
<http://demo.openlinksw.com/dataspace/bloguser/space#this> <http://rdfs.org/sioc/ns#space_of> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> .
<http://demo.openlinksw.com/dataspace/person/bloguser#this> <http://xmlns.com/foaf/0.1/made> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> .
<http://demo.openlinksw.com/Atom/bloguser-blog-0> <http://rdfs.org/sioc/services#service_of> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> .
<http://demo.openlinksw.com/GData/bloguser-blog-0> <http://rdfs.org/sioc/services#service_of> <http://demo.openlinksw.com/dataspace/bloguser/weblog/bloguser_blog> .


1 Rows. -- 240 msec.

]]></programlisting>
</sect2>
</sect1>
   <sect1 id="rdfsparul"><title>SPARUL -- an Update Language For RDF Graphs</title>
     <sect2 id="rdfsparulintro"><title>Introduction</title>
       <para>Starting from version 5.0, Virtuoso supports
<ulink url="http://jena.hpl.hp.com/~afs/SPARQL-Update.html">SPARQL/Update</ulink> extension of SPARQL.
This is sufficient for most of routine data manipulation operations. If <emphasis>SPARQL_UPDATE</emphasis>
role is granted to <emphasis>SPARQL</emphasis> user then data manipulation statements may be
executed via SPARQL web service endpoint as well as data querying.
       </para>
     </sect2>
     <sect2 id="rdfsparulfunc"><title>Manage RDF Storage</title>
       <para>Two functions allow the user to alter RDF storage by inserting or deleting all
triples listed in some vector. Both functions receive an IRI of a graph that should be altered and
a vector of triples that should be added or removed. The graph IRI can be either IRI ID or a string.
The third optional argument of these functions control transactional behavior: the value of parameter is
passed to <link linkend="fn_log_enable"><function>log_enable</function></link> function.
The return values of functions are not defined and should not be used by applications.
       </para>
       <programlisting>
create function DB.DBA.RDF_INSERT_TRIPLES (in graph_iri any, in triples any, in log_mode integer := null)
create function DB.DBA.RDF_DELETE_TRIPLES (in graph_iri any, in triples any, in log_mode integer := null)
       </programlisting>
       <para>Simple operations may be faster if written as low-level SQL code instead of using SPARUL.
E.g, the use of SPARQL DELETE is redundant when the application should delete from RDF_QUAD
by using simple filters like:
       </para>
       <programlisting>
delete from DB.DBA.RDF_QUAD
where G = DB.DBA.RDF_MAKE_IID_OF_QNAME (
    'http://local.virt/DAV/sparql_demo/data/data-xml/source-simple2/source-data-01.rdf' );
       </programlisting>
       <para>On the other hand, simple filters does not work when search criteria refer to triples
that are affected by the modification. Consider a function that deletes all triples whose subjects
are nodes of type 'http://xmlns.com/foaf/0.1/Person'. Type information is stored in triples that
will be deleted, so the simplest function is something like this:
       </para>
<programlisting><![CDATA[
create procedure DELETE_PERSONAL_DATA (in foaf_graph varchar)
{
  declare pdata_dict, pdata_array any;
-- Step 1: select everything that should be deleted
  pdata_dict := ((
      sparql construct { ?s ?p ?o }
      where { graph ?:foaf_graph {
              ?s ?p ?o . ?s rdf:type <http://xmlns.com/foaf/0.1/Person>
            } }
      ));
-- Step 2: delete all found triples
  pdata_array := dict_list_keys (pdata_dict, 1);
  RDF_DELETE_TRIPLES (foaf_graph, pdata_array);
};

DELETE_PERSONAL_DATA (
  'http://local.virt/DAV/sparql_demo/data/data-xml/source-simple2/source-data-01.rdf' );
]]></programlisting>
       <para>Starting from Virtuoso 5.0, application may use SPARUL to do the same in a convenient way:
       </para>
<programlisting><![CDATA[
create procedure DELETE_PERSONAL_DATA (in foaf_graph varchar)
{
  sparql delete { ?s ?p ?o }
      where { graph ?:foaf_graph {
              ?s ?p ?o . ?s rdf:type <http://xmlns.com/foaf/0.1/Person>
           } }
};
]]></programlisting>
     </sect2>
     <sect2 id="rdfsparulexamples"><title>Examples</title>
       <para>The graph where changes take place may be specified by an option in front of query, instead
of being specified in 'insert into graph' clause.
       </para>
<programlisting><![CDATA[
sparql define input:default-graph-uri <A-Named-Graph>
insert { <http://myopenlink.net/dataspace/Kingsley#this>
         <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
         <http://rdfs.org/sioc/ns#User> };
]]></programlisting>
       <para>The following two statements are equivalent but the latter may work faster, especially
if there are many RDF views in the system or if some RDF views may contain triples for the graph
in question. Note that neither of these two affect data that might come from RDF views.
       </para>
<programlisting><![CDATA[
sparql delete from graph <A-Named-Graph> { ?s ?p ?o } from <A-Named-Graph> where { ?s ?p ?o };
sparql clear graph <A-Named-Graph>;
]]></programlisting>
       <para>Keywords 'insert in' and 'insert into' are interchangeable in Virtuoso for backward
compatibility but SPARUL spec lists only 'insert into':
       </para>
<programlisting><![CDATA[
sparql insert into graph <A-Named-Graph> {  <http://myopenlink.net/dataspace/Kingsley#this>
                                            <http://rdfs.org/sioc/ns#id>
                                            <Kingsley> };
sparql insert into graph <A-Named-Graph> {  <http://myopenlink.net/dataspace/Caroline#this>
                                            <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
                                            <http://rdfs.org/sioc/ns#User> };
]]></programlisting>
       <para>It is possible to use various expressions to calculate fields of new triples. This is
 very convenient, even if not a part of the original spec.
       </para>
<programlisting><![CDATA[
sparql insert into graph <A-Named-Graph> { ?s <http://rdfs.org/sioc/ns#id> `iri (bif:concat (str (?o), "Idehen"))` }
where { ?s <http://rdfs.org/sioc/ns#id> ?o };
]]></programlisting>
       <para>'Modify graph' may be used as a sort of 'update' operation.
       </para>
<programlisting><![CDATA[
sparql modify graph <A-Named-Graph> delete { ?s <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> ?o } insert { ?s <http://www.w3.org/1999/02/22-rdf-syntax-ns#type1> ?o } where { ?s <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> ?o };
sparql delete from graph <A-Named-Graph> { <http://myopenlink.net/dataspace/Caroline#this> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type1> <http://rdfs.org/sioc/ns#User> };
]]></programlisting>
       <para>The RDF information resource URI can be generated via a string expression.</para>
<programlisting><![CDATA[
sparql load bif:concat ("http://", bif:registry_get("URIQADefaultHost"), "/inputs/SparqlDawg/data-xml/Expr1/manifest.rdf")
   into graph <A-Named-Graph>;
]]></programlisting>
       <para>Number of operations can be sent to a web service endpoint as a single statement and
executed in sequence.
       </para>
<programlisting><![CDATA[
sparql
  insert in graph <A-Named-Graph> { <http://myopenlink.net/dataspace/Kingsley#this>
                                    <http://rdfs.org/sioc/ns#id>
                                    <Kingsley> }
  insert into graph <A-Named-Graph> { <http://myopenlink.net/dataspace/Caroline#this>
                                      <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
                                      <http://rdfs.org/sioc/ns#User> }
  insert into graph <A-Named-Graph> { ?s <http://rdfs.org/sioc/ns#id> `iri (bif:concat (str (?o), "Idehen"))` }
              where { ?s <http://rdfs.org/sioc/ns#id> ?o };
  modify graph <A-Named-Graph> delete { ?s <p2> ?o } insert { ?s <p2new> ?o } where { ?s <p2> ?o }
  delete from graph <A-Named-Graph> { <http://myopenlink.net/dataspace/Caroline#this> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type1> <http://rdfs.org/sioc/ns#User> };
  load bif:concat ("http://", bif:registry_get("URIQADefaultHost"), "/inputs/SparqlDawg/data-xml/Expr1/manifest.rdf") into graph <A-Named-Graph>
;
]]></programlisting>

<para>In case of huge RDF data ( for ex. 600 million triples ) loaded in the Virtuoso sever in a single graph,
the fastest operation to drop the graph is:</para>
<programlisting><![CDATA[
sparql clear graph <graph-iri>;
]]></programlisting>
<para>The operation may be accelerated using log_enable (0) or even log_enable (2),
with log_enable(1) after the operation.
</para>
      </sect2>
   <sect2 id="rdfsparulexamples"><title>More Detailed Examples</title>
<para>Adding triples to graph</para>
<programlisting><![CDATA[
sparql
INSERT INTO GRAPH <http://BookStore.com>
{ <http://www.dajobe.org/foaf.rdf#i> <http://purl.org/dc/elements/1.1/title>  "SPARQL and RDF" .
  <http://www.dajobe.org/foaf.rdf#i> <http://purl.org/dc/elements/1.1/date> <1999-01-01T00:00:00>.
  <http://www.w3.org/People/Berners-Lee/card#i> <http://purl.org/dc/elements/1.1/title> "Design notes" .
  <http://www.w3.org/People/Berners-Lee/card#i> <http://purl.org/dc/elements/1.1/date> <2001-01-01T00:00:00>.
  <http://www.w3.org/People/Connolly/#me> <http://purl.org/dc/elements/1.1/title> "Fundamentals of Compiler Design" .
  <http://www.w3.org/People/Connolly/#me> <http://purl.org/dc/elements/1.1/date> <2002-01-01T00:00:00>. };
]]></programlisting>
<para>Adding triples to graph</para>
<programlisting><![CDATA[
]]></programlisting>
<para>A SPARQL/Update request that contains a triple to be deleted and a triple to be added (used here to correct a book title).
</para>
<programlisting><![CDATA[
SPARQL
MODIFY GRAPH <http://BookStore.com>
DELETE
 { <http://www.w3.org/People/Connolly/#me>  <http://purl.org/dc/elements/1.1/title>  "Fundamentals of Compiler Design" }
INSERT
 { <http://www.w3.org/People/Connolly/#me>  <http://purl.org/dc/elements/1.1/title>  "Fundamentals" };
callret-0
VARCHAR
_______________________________________________________________________________

Modify <http://BookStore.com>, delete 1 and insert 1 triples -- done

1 Rows. -- 20 msec.
]]></programlisting>
<para>The example below has a request to delete all records of old books (with date before year 2000)
</para>
<programlisting><![CDATA[
sparql
PREFIX dc:  <http://purl.org/dc/elements/1.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
DELETE FROM GRAPH <http://BookStore.com> { ?book ?p ?v }
WHERE
  { GRAPH  <http://BookStore.com>
   { ?book dc:date ?date
     FILTER ( xsd:dateTime(?date) < xsd:dateTime("2000-01-01T00:00:00")).
    ?book ?p ?v.
   }
  };
_______________________________________________________________________________

Delete from <http://BookStore.com>, 6 triples -- done

1 Rows. -- 10 msec.
]]></programlisting>
<para>This snippet copies records from one named graph to another named graph based on a pattern:
</para>
<programlisting><![CDATA[
sparql
PREFIX dc:  <http://purl.org/dc/elements/1.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
INSERT INTO GRAPH <http://NewBookStore.com> { ?book ?p ?v }
WHERE
  { GRAPH  <http://BookStore.com>
   { ?book dc:date ?date
     FILTER ( xsd:dateTime(?date) > xsd:dateTime("2000-01-01T00:00:00")).
     ?book ?p ?v.
   }
  };
callret-0
VARCHAR
_______________________________________________________________________________

Insert into <http://NewBookStore.com>, 6 triples -- done

1 Rows. -- 30 msec.
]]></programlisting>
<para>An example to move records from one named graph to another named graph based on a pattern:
</para>
<programlisting><![CDATA[
sparql
PREFIX dc:  <http://purl.org/dc/elements/1.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

INSERT INTO GRAPH <http://NewBookStore.com>
 { ?book ?p ?v }
WHERE
  { GRAPH  <http://BookStore.com>
     { ?book dc:date ?date .
       FILTER ( xsd:dateTime(?date) > xsd:dateTime("2000-01-01T00:00:00")).
       ?book ?p ?v.
     }
  };
_______________________________________________________________________________

Insert into <http://NewBookStore.com>, 6 triples -- done

1 Rows. -- 10 msec.

sparql
PREFIX dc:  <http://purl.org/dc/elements/1.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
DELETE FROM GRAPH <http://BookStore.com>
 { ?book ?p ?v }
WHERE
  { GRAPH  <http://BookStore.com>
      { ?book dc:date ?date .
        FILTER ( xsd:dateTime(?date) > xsd:dateTime("2000-01-01T00:00:00")).
        ?book ?p ?v.
      }
  };
_______________________________________________________________________________

Delete from <http://BookStore.com>, 3 triples -- done

1 Rows. -- 10 msec.
]]></programlisting>
   </sect2>
   </sect1>
<sect1 id="rdfinsertmethods"><title>RDF Insert Methods in Virtuoso</title>
    <sect2 id="rdfinsertmethodshttppost"><title>HTTP Post using Content-Type: application/sparql-query</title>
	<para>With POST can be accomplished SPARQL Insert/Update etc.</para>
	<para>The result is in the rdf_quad.</para>
	<para>With GET Methods you can get the triples which are saved.</para>
        <para><emphasis>Examples:</emphasis></para>
        <para><emphasis>Example 1:</emphasis></para>
        <para>Create a DAV collection xx for user demo with password demo.</para>
        <para>Execute the following command:</para>
<programlisting><![CDATA[
curl -i -d "INSERT {<http://demo.openlinksw.com/DAV/home/demo_about.rdf>
<http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://rdfs.org/sioc/ns#User>}" -u "demo:demo"
-H "Content-Type: application/sparql-query" http://localhost:8890/DAV/xx/yy
]]></programlisting>
        <para>The response should be:</para>
<programlisting><![CDATA[
HTTP/1.1 201 Created
Server: Virtuoso/05.00.3023 (Win32) i686-generic-win-32  VDB
Connection: Keep-Alive
Content-Type: text/html; charset=ISO-8859-1
Date: Fri, 28 Dec 2007 12:50:12 GMT
Accept-Ranges: bytes
MS-Author-Via: SPARQL
Content-Length: 0
]]></programlisting>
        <para>The result in the DAV/xx location will be a new WebDAV resource with name "yy" containing the inserted RDF:</para>
<programlisting><![CDATA[
<?xml version="1.0" encoding="utf-8" ?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">
<rdf:Description
rdf:about="http://demo.openlinksw.com/DAV/home/demo_about.rdf">
<ns0pred:type xmlns:ns0pred="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
rdf:resource="http://rdfs.org/sioc/ns#User"/>
</rdf:Description>
</rdf:RDF>
]]></programlisting>
        <para><emphasis>Example 2:</emphasis></para>
        <para>Create a DAV collection, for ex. with name "test" for user ( for ex. demo).</para>
        <para>Execute the following command:</para>
<programlisting><![CDATA[
curl -i -d "INSERT IN GRAPH <http://mygraph.com>
{ <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com#this>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
  <http://rdfs.org/sioc/ns#User> .
  <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com#this>
  <http://www.w3.org/2000/01/rdf-schema#label>
  <Kingsley Uyi Idehen> .
  <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com#this>
  <http://rdfs.org/sioc/ns#creator_of>

<http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1300>
  } " -u "demo:demo" -H "Content-Type: application/sparql-query" http://localhost:8890/DAV/home/demo/test/myrq
]]></programlisting>
        <para>As result the response will be:</para>
<programlisting><![CDATA[
HTTP/1.1 201 Created
Server: Virtuoso/05.00.3023 (Win32) i686-generic-win-32  VDB
Connection: Keep-Alive
Content-Type: text/html; charset=ISO-8859-1
Date: Thu, 20 Dec 2007 16:25:25 GMT
Accept-Ranges: bytes
MS-Author-Via: SPARQL
Content-Length: 0
]]></programlisting>
        <para>Now let's check the inserted triples. Go to the sparql endpoint, i.e. http://localhost:8890/sparql and:</para>
<itemizedlist>
<listitem>Enter for Default Graph URI:
<programlisting><![CDATA[
http://mygraph.com
]]></programlisting>
</listitem>
<listitem>Enter in the Query area:
<programlisting><![CDATA[
SELECT * WHERE {?s ?p ?o}
]]></programlisting>
</listitem>
<listitem>Click the button "Run Query"</listitem>
<listitem>As result will be shown the inserted triples:
<programlisting><![CDATA[
s  	                                                          p                                                 o
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com#this   http://www.w3.org/1999/02/22-rdf-syntax-ns#type   http://rdfs.org/sioc/ns#User
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com#this   http://www.w3.org/2000/01/rdf-schema#label 	    Kingsley
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com#this   http://rdfs.org/sioc/ns#creator_of                http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1300
]]></programlisting>
</listitem>
</itemizedlist>
</sect2>
     <sect2 id="rdfinsertmethodshttpput"><title>HTTP PUT using Content-Type: application/rdf+xml</title>
	<para>The URI in a PUT request identifies the entity enclosed with the request. Therefore using HTTP PUT is a more useful and meaningful command than using POST (which is more about submitting data to a script).</para>
        <para><emphasis>Example:</emphasis></para>
        <para>Suppose there is myfoaf.rdf file with the following content:</para>
<programlisting><![CDATA[
<rdf:RDF xmlns="http://www.example/jose/foaf.rdf#"
    xmlns:foaf="http://xmlns.com/foaf/0.1/"
    xmlns:log="http://www.w3.org/2000/10/swap/log#"
    xmlns:myfoaf="http://www.example/jose/foaf.rdf#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">

    <foaf:Person rdf:about="http://www.example/jose/foaf.rdf#jose">
        <foaf:homepage rdf:resource="http://www.example/jose/"/>
        <foaf:knows rdf:resource="http://www.example/jose/foaf.rdf#juan"/>
        <foaf:name>Jose Jimen~ez</foaf:name>
        <foaf:nick>Jo</foaf:nick>
        <foaf:workplaceHomepage rdf:resource="http://www.corp.example/"/>
    </foaf:Person>

    <foaf:Person rdf:about="http://www.example/jose/foaf.rdf#juan">
        <foaf:mbox rdf:resource="mailto:juan@mail.example"/>
    </foaf:Person>

    <foaf:Person rdf:about="http://www.example/jose/foaf.rdf#julia">
        <foaf:mbox rdf:resource="mailto:julia@mail.example"/>
    </foaf:Person>

    <rdf:Description rdf:about="http://www.example/jose/foaf.rdf#kendall">
        <foaf:knows rdf:resource="http://www.example/jose/foaf.rdf#edd"/>
    </rdf:Description>
</rdf:RDF>
]]></programlisting>
        <para>Now let's upload the myfoaf.rdf file to destination server demo.openlinksw.com for user demo:</para>
<programlisting><![CDATA[
curl -T myfoaf.rdf http://demo.openlinksw.com/DAV/home/demo/rdf_sink/myfoaf.rdf -u demo:demo
]]></programlisting>
        <para>As result the response should be:</para>
<programlisting><![CDATA[
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
  <TITLE>201 Created</TITLE>
</HEAD>
<BODY>
  <H1>Created</H1>
  Resource /DAV/home/demo/rdf_sink/ myfoaf.rdf has been created.
</BODY>
</HTML>
]]></programlisting>
    <para>Then you can execute:</para>
<programlisting><![CDATA[
curl -F "query=SELECT DISTINCT ?p FROM <http://demo.openlinksw.com/DAV/home/demo/rdf_sink/> WHERE {?s ?p ?o}" http://demo.openlinksw.com/sparql
]]></programlisting>
    <para>The result should be:</para>
<programlisting><![CDATA[
<?xml version="1.0" ?>
<sparql xmlns="http://www.w3.org/2005/sparql-results#" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2001/sw/DataAccess/rf1/result2.xsd">
 <head>
  <variable name="p"/>
 </head>
 <results distinct="false" ordered="true">
  <result>
   <binding name="p"><uri>http://www.w3.org/1999/02/22-rdf-syntax-ns#type</uri></binding>
  </result>
  <result>
   <binding name="p"><uri>http://xmlns.com/foaf/0.1/nick</uri></binding>
  </result>
  <result>
   <binding name="p"><uri>http://xmlns.com/foaf/0.1/name</uri></binding>
  </result>
  <result>
   <binding name="p"><uri>http://xmlns.com/foaf/0.1/homepage</uri></binding>
  </result>
  <result>
   <binding name="p"><uri>http://xmlns.com/foaf/0.1/knows</uri></binding>
  </result>
  <result>
   <binding name="p"><uri>http://xmlns.com/foaf/0.1/workplaceHomepage</uri></binding>
  </result>
  <result>
   <binding name="p"><uri>http://xmlns.com/foaf/0.1/mbox</uri></binding>
  </result>
 </results>
</sparql>
]]></programlisting>
    </sect2>
     <sect2 id="rdfinsertmethodsload"><title>SPARQL Insert using LOAD</title>
        <para>SPARQL INSERT operation can be done using the LOAD feature.</para>
        <para><emphasis>Example:</emphasis></para>
        <para>Execute from ISQL:</para>
<programlisting><![CDATA[
sparql insert in graph <http://mygraph.com>
{
  <http://myopenlink.net/dataspace/Kingsley#this>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
  <http://rdfs.org/sioc/ns#User> .

  <http://myopenlink.net/dataspace/Kingsley#this>
  <http://rdfs.org/sioc/ns#id>
  <Kingsley> .

  <http://myopenlink.net/dataspace/Caroline#this>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
  <http://rdfs.org/sioc/ns#User> .

 <http://myopenlink.net/dataspace/Caroline#this>
  <http://rdfs.org/sioc/ns#id>
  <Caroline> .

   <http://myopenlink.net/dataspace/Matt#this>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
  <http://rdfs.org/sioc/ns#User> .

  <http://myopenlink.net/dataspace/Matt#this>
  <http://rdfs.org/sioc/ns#id>
  <Matt> .

   <http://myopenlink.net/dataspace/demo#this>
  <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
  <http://rdfs.org/sioc/ns#User> .

  <http://myopenlink.net/dataspace/demo#this>
  <http://rdfs.org/sioc/ns#id>
  <demo> .};
]]></programlisting>
        <para>Create DAV collection which is visible to public, for ex: http://localhost:8890/DAV/tmp</para>
        <para>Upload to the DAV collection the following file for ex. with name listall.rq and with the following content:</para>
<programlisting><![CDATA[
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX sioc: <http://rdfs.org/sioc/ns#>
SELECT ?x ?p ?o
FROM <http://mygraph.com>
WHERE
  {
    ?x rdf:type sioc:User .
    ?x ?p ?o.
    ?x sioc:id ?id .
    FILTER REGEX(str(?id), "^King")
  }
ORDER BY ?x
]]></programlisting>
        <para>Now from ISQL execute the following command:</para>
<programlisting><![CDATA[
sparql
load bif:concat ("http://", bif:registry_get("URIQADefaultHost"), "/DAV/tmp/listall.rq") into graph <http://myNewGraph.com>;
]]></programlisting>
        <para>As result should be shown:</para>
<programlisting><![CDATA[
callret-0
VARCHAR
_______________________________________________________________________________

Load <http://localhost:8890/DAV/tmp/listall.rq> into graph <http://myNewGraph.com> -- done

1 Rows. -- 321 msec.
]]></programlisting>
    </sect2>
     <sect2 id="rdfindertmethodsparqlendpoint"><title>SPARQL Insert via /sparql endpoint</title>
        <para>SPARQL INSERT operation can be sent to a web service endpoint as a single statement and executed in sequence.</para>
        <para><emphasis>Example:</emphasis></para>
        <para>Using the Virtuoso ISQL tool or using the /sparql UI at http://host:port/sparql, execute the following:</para>
<itemizedlist>
<listitem>Insert into graph http://BookStore.com 3 triples:
<programlisting><![CDATA[
sparql insert in graph <http://BookStore.com>
{ <http://www.dajobe.org/foaf.rdf#i> <http://purl.org/dc/elements/1.1/date> <1999-04-01T00:00:00> .
  <http://www.w3.org/People/Berners-Lee/card#i> <http://purl.org/dc/elements/1.1/date> <1998-05-03T00:00:00> .
  <http://www.w3.org/People/Connolly/#me> <http://purl.org/dc/elements/1.1/date> <2001-02-08T00:00:00> };
]]></programlisting>
</listitem>
<listitem>As result will be shown the message:
<programlisting><![CDATA[
Insert into <http://BookStore.com>, 3 triples -- done
]]></programlisting>
</listitem>
<listitem>Next we will select all triples from the graph http://BookStore.com:
<programlisting><![CDATA[
sparql select * from <http://BookStore.com> where {?s ?p ?o};
]]></programlisting>
</listitem>
<listitem>As result will be shown:
<programlisting><![CDATA[
s                                              p                                       o
VARCHAR                                        VARCHAR                                 VARCHAR
_______________________________________________________________________________

http://www.w3.org/People/Berners-Lee/card#i    http://purl.org/dc/elements/1.1/date    1998-05-03T00:00:00
http://www.w3.org/People/Connolly/#me          http://purl.org/dc/elements/1.1/date    2001-02-08T00:00:00
http://www.dajobe.org/foaf.rdf#i               http://purl.org/dc/elements/1.1/date    1999-04-01T00:00:00

3 Rows. -- 0 msec.

]]></programlisting>
</listitem>
<listitem>Now let's insert into graph another http://NewBookStore.com graph's values:
<programlisting><![CDATA[
sparql
PREFIX dc:  <http://purl.org/dc/elements/1.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
INSERT INTO GRAPH <http://NewBookStore.com> { ?book ?p ?v }
WHERE
  { GRAPH  <http://BookStore.com>
   { ?book dc:date ?date
     FILTER ( xsd:dateTime(?date) < xsd:dateTime("2000-01-01T00:00:00")).
     ?book ?p ?v.
   }
  };
]]></programlisting>
</listitem>
<listitem>As result will be shown:
<programlisting><![CDATA[
callret-0
VARCHAR
_______________________________________________________________________________

Insert into <http://NewBookStore.com>, 2 triples -- done
]]></programlisting>
</listitem>
<listitem>Finally we will check the triples from the graph NewBookStore.com:
<programlisting><![CDATA[
SQL> sparql select * from <http://NewBookStore.com> where {?s ?p ?o};
]]></programlisting>
</listitem>
<listitem>As result will be shown:
<programlisting><![CDATA[
s                                             p                                      o
VARCHAR                                                 VARCHAR    VARCHAR
_______________________________________________________________________________

http://www.w3.org/People/Berners-Lee/card#i   http://purl.org/dc/elements/1.1/date   1998-05-03T00:00:00
http://www.dajobe.org/foaf.rdf#i              http://purl.org/dc/elements/1.1/date   1999-04-01T00:00:00

2 Rows. -- 10 msec.
]]></programlisting>
</listitem>
</itemizedlist>
</sect2>
     <sect2 id="rdfinsertmethodsparqlqueryandodswiki"><title>SPARQL Insert via HTTP Post using Content-Type: application/sparql-query and ODS wiki</title>
        <para>With HTTP Post and ODS wiki can be written an rdf document and respectively to be performed over it INSERT/UPDATE action.</para>
        <para>You can write to a file using SIOC terms for ODS-Wiki</para>
        <para>You can check with sparql the inserted / updated triples in the Quad Store.</para>
        <para><emphasis>Example:</emphasis></para>
        <para>Suppose there is ODS user test3 with ODS password 1, which has testWiki wiki instance.</para>
        <para>Execute the following:</para>
<programlisting><![CDATA[
curl -i -d "INSERT {<http://localhost:8890/dataspace/test3/wiki/testWiki> <http://atomowl.org/ontologies/atomrdf#contains> <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> . <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> <http://rdfs.org/sioc/ns#has_container> <http://localhost:8890/dataspace/test3/wiki/testWiki> . <http://localhost:8890/dataspace/test3/wiki/testWiki> <http://atomowl.org/ontologies/atomrdf#entry> <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> . <http://localhost:8890/dataspace/test3/wiki/testWiki> <http://rdfs.org/sioc/ns#container_of> <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> . <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> <http://rdfs.org/sioc/ns#topic>  <http://localhost:8890/dataspace/test3/wiki/testWiki> . <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> <http://atomowl.org/ontologies/atomrdf#source> <http://localhost:8890/dataspace/test3/wiki/testWiki> . <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://rdfs.org/sioc/types#Comment> . <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://atomowl.org/ontologies/atomrdf#Entry> . <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> <http://www.w3.org/2000/01/rdf-schema#label> 'MyTest' . <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://atomowl.org/ontologies/atomrdf#Link> . <http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> <http://rdfs.org/sioc/ns#content> <test>}" -u "test3:1" -H "Content-Type: application/sparql-query" http://localhost:8890/DAV/home/test3/wiki/testWiki/MyTest
]]></programlisting>
        <para>As result we should have 2 files created:</para>
<itemizedlist>
<listitem>In the user DAV folder "DAV/home/test3/wiki/testWiki/" will be created a file "MyTest" with type "application/sparql-query". You can view the content of this file from from the Conductor UI or from the user's Briefcase UI, path "DAV/home/test3/wiki/testWiki". Its content will be:
<programlisting><![CDATA[
<?xml version="1.0" encoding="utf-8" ?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki"><ns0pred:entry xmlns:ns0pred="http://atomowl.org/ontologies/atomrdf#" rdf:resource="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"/></rdf:Description>
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"><ns0pred:label xmlns:ns0pred="http://www.w3.org/2000/01/rdf-schema#">MyTest</ns0pred:label></rdf:Description>
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"><ns0pred:type xmlns:ns0pred="http://www.w3.org/1999/02/22-rdf-syntax-ns#" rdf:resource="http://atomowl.org/ontologies/atomrdf#Link"/></rdf:Description>
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"><ns0pred:type xmlns:ns0pred="http://www.w3.org/1999/02/22-rdf-syntax-ns#" rdf:resource="http://rdfs.org/sioc/types#Comment"/></rdf:Description>
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"><ns0pred:type xmlns:ns0pred="http://www.w3.org/1999/02/22-rdf-syntax-ns#" rdf:resource="http://atomowl.org/ontologies/atomrdf#Entry"/></rdf:Description>
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"><ns0pred:has_container xmlns:ns0pred="http://rdfs.org/sioc/ns#" rdf:resource="http://localhost:8890/dataspace/test3/wiki/testWiki"/></rdf:Description>
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki"><ns0pred:container_of xmlns:ns0pred="http://rdfs.org/sioc/ns#" rdf:resource="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"/></rdf:Description>
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki"><ns0pred:contains xmlns:ns0pred="http://atomowl.org/ontologies/atomrdf#" rdf:resource="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"/></rdf:Description>
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"><ns0pred:content xmlns:ns0pred="http://rdfs.org/sioc/ns#">test</ns0pred:content></rdf:Description>
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"><ns0pred:topic xmlns:ns0pred="http://rdfs.org/sioc/ns#" rdf:resource="http://localhost:8890/dataspace/test3/wiki/testWiki"/></rdf:Description>
<rdf:Description rdf:about="http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest"><ns0pred:source xmlns:ns0pred="http://atomowl.org/ontologies/atomrdf#" rdf:resource="http://localhost:8890/dataspace/test3/wiki/testWiki"/></rdf:Description>
</rdf:RDF>
]]></programlisting>
</listitem>
<listitem>To the user's wiki instance will be added a new WikiWord "MyTest" with content the value of the SIOC term attribute "content":
<programlisting><![CDATA[
<http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest> <http://rdfs.org/sioc/ns#content> <test>
i.e. the content will be "test".
]]></programlisting>
</listitem>
</itemizedlist>
        <para>Now let's check what data was inserted in the Quad Store:</para>
<itemizedlist>
<listitem>Go to the sparql endpoint, i.e. for ex. to http://localhost:8890/sparql</listitem>
<listitem>Enter for Default Graph URI:
<programlisting><![CDATA[
http://localhost:8890/DAV/home/test3/wiki/testWiki/MyTest
]]></programlisting>
</listitem>
<listitem>Enter for Query text:
<programlisting><![CDATA[
SELECT * WHERE {?s ?p ?o}
]]></programlisting>
</listitem>
<listitem>Click the "Run Query" button.</listitem>
<listitem>As result will be shown the inserted triples:
<programlisting><![CDATA[
s                                 p                                           o
http://localhost:8890/dataspace/test3/wiki/testWiki 	    http://rdfs.org/sioc/ns#container_of 	     http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest
http://localhost:8890/dataspace/test3/wiki/testWiki 	    http://atomowl.org/ontologies/atomrdf#entry      http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest
http://localhost:8890/dataspace/test3/wiki/testWiki 	    http://atomowl.org/ontologies/atomrdf#contains   http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest
http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest  http://www.w3.org/1999/02/22-rdf-syntax-ns#type  http://rdfs.org/sioc/types#Comment
http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest  http://www.w3.org/1999/02/22-rdf-syntax-ns#type  http://atomowl.org/ontologies/atomrdf#Entry
http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest  http://www.w3.org/1999/02/22-rdf-syntax-ns#type  http://atomowl.org/ontologies/atomrdf#Link
http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest  http://www.w3.org/2000/01/rdf-schema#label 	     MyTest
http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest  http://rdfs.org/sioc/ns#has_container 	     http://localhost:8890/dataspace/test3/wiki/testWiki
http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest  http://rdfs.org/sioc/ns#content 	             test
http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest  http://rdfs.org/sioc/ns#topic 	             http://localhost:8890/dataspace/test3/wiki/testWiki
http://localhost:8890/dataspace/test3/wiki/testWiki/MyTest  http://atomowl.org/ontologies/atomrdf#source     http://localhost:8890/dataspace/test3/wiki/testWiki
]]></programlisting>
</listitem>
</itemizedlist>
    </sect2>
    <sect2 id="rdfinsertmethodwebdav">
      <title>Using WebDAV</title>
      <para> Example using WebDAV (mount folder to DAV and dump; if this is the rdf_sink
the Quad Store is updated automatically, or you can load from DAV manually to quad store)</para>
      <para><emphasis>Example:</emphasis></para>
      <para><emphasis>Example 1: Using ODS Briefcase</emphasis></para>
      <itemizedlist>
        <listitem>Go to your ods location, for ex. http://localhost:8890/ods</listitem>
        <listitem>Register user, for ex. user test1</listitem>
        <listitem>Login if not already in ods</listitem>
        <listitem>Go to ODS -> Briefcase</listitem>
        <listitem>Go to ODS -> Briefcase</listitem>
        <listitem>Click the "New folder" icon from the Main Briefcase horizontal navigation</listitem>
        <listitem>Enter for name for ex. "mytest" and click the "Create" button.
          <figure id="uc6" float="1">
	    <title>Using Briefcase UI</title>
	    <graphic fileref="ui/uc6.png"/>
          </figure>
        </listitem>
        <listitem>Go to folder "mytest" and click the click the "Upload" icon from the Main Briefcase horizontal navigation</listitem>
        <listitem>Enter for name for ex. "mytest" and click the "Create" button.
          <figure id="uc7" float="1">
	    <title>Using Briefcase UI</title>
	    <graphic fileref="ui/uc7.png"/>
          </figure>
        </listitem>
        <listitem>In the shown form set:
          <itemizedlist>
            <listitem>Destination: RDF Store</listitem>
            <listitem>RDF graph name for ex. with the value: http://localhost:8890/DAV/home/test2/mytest/</listitem>
            <listitem>Select URL or File. For ex. you can select the following file with name jose.rdf:
<programlisting><![CDATA[
<rdf:RDF xmlns="http://www.example/jose/foaf.rdf#"
    xmlns:foaf="http://xmlns.com/foaf/0.1/"
    xmlns:log="http://www.w3.org/2000/10/swap/log#"
    xmlns:myfoaf="http://www.example/jose/foaf.rdf#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">

    <foaf:Person rdf:about="http://www.example/jose/foaf.rdf#jose">
        <foaf:homepage rdf:resource="http://www.example/jose/"/>
        <foaf:knows rdf:resource="http://www.example/jose/foaf.rdf#juan"/>
        <foaf:name>Jose Jimen~ez</foaf:name>
        <foaf:nick>Jo</foaf:nick>
        <foaf:workplaceHomepage rdf:resource="http://www.corp.example/"/>
    </foaf:Person>

    <foaf:Person rdf:about="http://www.example/jose/foaf.rdf#juan">
        <foaf:mbox rdf:resource="mailto:juan@mail.example"/>
    </foaf:Person>

    <foaf:Person rdf:about="http://www.example/jose/foaf.rdf#julia">
        <foaf:mbox rdf:resource="mailto:julia@mail.example"/>
    </foaf:Person>

    <rdf:Description rdf:about="http://www.example/jose/foaf.rdf#kendall">

        <foaf:knows rdf:resource="http://www.example/jose/foaf.rdf#edd"/>
    </rdf:Description>
</rdf:RDF>
]]></programlisting>
            </listitem>
      </itemizedlist>
        </listitem>
        <listitem>You can also perform the steps from above by uploading the file in the rdf_sink
folder i.e. in Briefcase it will be with this path: DAV/home/test2/rdf_sink and respectively the "RDF graph name"
will have this value: http://host:port/DAV/home/username/rdf_sink/</listitem>
      </itemizedlist>
      <para>Execute from ISQL or from the SPARQL endpoint the following query:</para>
<programlisting><![CDATA[
select * from <>
where {?s ?p ?o}
]]></programlisting>
      <para>As result should be shown:</para>
<programlisting><![CDATA[
s  	                                  p  	                                            o
http://www.example/jose/foaf.rdf#jose 	  http://www.w3.org/1999/02/22-rdf-syntax-ns#type   http://xmlns.com/foaf/0.1/Person
http://www.example/jose/foaf.rdf#jose 	  http://xmlns.com/foaf/0.1/nick 	            Jo
http://www.example/jose/foaf.rdf#jose 	  http://xmlns.com/foaf/0.1/name 	            Jose Jimen~ez
http://www.example/jose/foaf.rdf#jose 	  http://xmlns.com/foaf/0.1/knows 	            http://www.example/jose/foaf.rdf#juan
http://www.example/jose/foaf.rdf#jose 	  http://xmlns.com/foaf/0.1/homepage 	            http://www.example/jose/
http://www.example/jose/foaf.rdf#jose 	  http://xmlns.com/foaf/0.1/workplaceHomepage 	    http://www.corp.example/
http://www.example/jose/foaf.rdf#kendall  http://xmlns.com/foaf/0.1/knows 	            http://www.example/jose/foaf.rdf#edd
http://www.example/jose/foaf.rdf#julia 	  http://www.w3.org/1999/02/22-rdf-syntax-ns#type   http://xmlns.com/foaf/0.1/Person
http://www.example/jose/foaf.rdf#julia 	  http://xmlns.com/foaf/0.1/mbox 	            mailto:julia@mail.example
http://www.example/jose/foaf.rdf#juan 	  http://www.w3.org/1999/02/22-rdf-syntax-ns#type   http://xmlns.com/foaf/0.1/Person
http://www.example/jose/foaf.rdf#juan 	  http://xmlns.com/foaf/0.1/mbox 	            mailto:juan@mail.example
]]></programlisting>
      <para><emphasis>Example 2: Using Conductor UI</emphasis></para>
      <itemizedlist>
        <listitem>Go to Conductor UI, for ex. at http://localhost:8890/conductor</listitem>
        <listitem>Login as dba user</listitem>
        <listitem>Go to Web Application Server
          <figure id="uc1" float="1">
	    <title>Using Conductor UI</title>
	    <graphic fileref="ui/uc1.png"/>
          </figure>
        </listitem>
        <listitem>Click the "New Folder" button.</listitem>
        <listitem>Enter for name for ex. test and click the "Create" button.
          <figure id="uc2" float="1">
	    <title>Using Conductor UI</title>
	    <graphic fileref="ui/uc2.png"/>
          </figure>
        </listitem>
        <listitem>Click the new folder "test" name link.
          <figure id="uc3" float="1">
	    <title>Using Conductor UI</title>
	    <graphic fileref="ui/uc3.png"/>
          </figure>
        </listitem>
        <listitem>Click the "Upload" button and in the shown form select Destination: RDF Store.
        <figure id="uc4" float="1">
	    <title>Using Conductor UI</title>
	    <graphic fileref="ui/uc4.png"/>
          </figure>
        </listitem>
        <listitem>In the shown form click the "Browse" button in order to select a file, for ex. the file jose.rdf
and set the "RDF IRI*"
          <figure id="uc5" float="1">
	    <title>Using Conductor UI</title>
	    <graphic fileref="ui/uc5.png"/>
          </figure>
         </listitem>
         <listitem>Click the "Upload" button.</listitem>
      </itemizedlist>
    </sect2>
    <sect2 id="rdfinsertmethodvirtuosocrawler">
      <title>Using Virtuoso Crawler</title>
      <para>Using Virtuoso Crawler (which includes the Sponger options so you crawl
non-RDF but get RDF and this can go to the Quad Store)</para>
      <para><emphasis>Example:</emphasis></para>
      <para>Go to Conductor UI. For ex. at http://localhost:8890/conductor</para>
      <para>Login as dba user</para>
      <para>Go to tab Web Application Server</para>
      <para>Go to tab Content Imports</para>
      <para>Click the "New Target" button</para>
      <para>In the shown form:</para>
      <itemizedlist>
        <listitem>Enter for "Target description": Tim Berners-Lee's electronic Business Card</listitem>
        <listitem>Enter for "Target URL": http://www.w3.org/People/Berners-Lee</listitem>
        <listitem>Enter for "Copy to local DAV collection" for ex.: /DAV/home/demo/rdf_sink/</listitem>
        <listitem>Choose from the list "Local resources owner": demo</listitem>
        <listitem>Check the check.box with label "Store metadata".</listitem>
        <listitem>Check all the check-boxes shown below the check-box "Store metadata".</listitem>
        <listitem>Click the button "Create".
          <figure id="rdfinsertwebdav1" float="1">
	    <title>Using Virtuoso Crawler</title>
	    <graphic fileref="ui/rdfinsert1.png"/>
          </figure>
        </listitem>
      </itemizedlist>
      <para>Click the button "Import Queues".</para>
      <para>For "Robot target" with label "Tim Berners-Lee's electronic Business Card"
click the start link.</para>
      <para>As result should be shown t he number of the pages retrieved.</para>
      <figure id="rdfinsertwebdav2" float="1">
        <title>Using Virtuoso Crawler</title>
	<graphic fileref="ui/rdfinsert2.png"/>
      </figure>
      <para>Now using the sparql endpoint with sponger option "Use only local data"
enter for Default Graph URI: http://www.w3.org/People/Berners-Lee and execute the following query: </para>
<programlisting><![CDATA[
select *
where {?s ?p ?o}
]]></programlisting>
      <para>As result should be shown the following triples:</para>
<programlisting><![CDATA[
s                                                      p                                                 o
http://www.w3.org/People/Berners-Lee 	http://www.w3.org/1999/02/22-rdf-syntax-ns#type     http://xmlns.com/foaf/0.1/Document
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Answers for young people - Tim Berners-Lee
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Berners-Lee: Weaving the Web
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Declaration by Tim BL 28 Feb 1996 w.r.t. CDA challenge
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Errata - Berners-Lee: Weaving the Web
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Frequently asked questions by the Press - Tim BL
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Glossary - Weaving the Web - Berners-Lee
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Longer Bio for Tim Berners-Lee
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Michael Dertouzos has left us
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            The Future of the Web and Europe
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            The World Wide Web: Past, Present and Future
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            The World Wide Web: A very short personal history
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Tim Berners-Lee
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Tim Berners-Lee - 3Com Founders chair
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Tim Berners-Lee: Disclosures
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Tim Berners-Lee: WWW and UU and I
http://www.w3.org/People/Berners-Lee 	http://purl.org/dc/elements/1.1/title 	            Tim Berners-Lee: WorldWideWeb, the first Web client
]]></programlisting>
    </sect2>
    <sect2 id="rdfinsertmethodsparqlqueryandsponger">
      <title>Using SPARQL Query and Sponger (i.e. we Sponge the Resources in the FROM Clause or values for the graph-uri parameter in SPARQL protocol URLs)</title>
      <para><emphasis>Example:</emphasis></para>
      <para>Execute the following query: </para>
<programlisting><![CDATA[
sparql
SELECT ?id
FROM NAMED <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/sioc.ttl>
 OPTION (get:soft "soft", get:method "GET")
WHERE { GRAPH ?g { ?id a ?o } }
limit 10;
]]></programlisting>
      <para>As result will be shown the retrieved triples:</para>
<programlisting><![CDATA[
id
VARCHAR
_______________________________________________________________________________

http://www.openlinksw.com/dataspace/kidehen@openlinksw.com#this
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D
http://www.openlinksw.com/dataspace/person/kidehen@openlinksw.com#this
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/612
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/612
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/610
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/610
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/856
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/856

10 Rows. -- 20 msec.
]]></programlisting>
    </sect2>
    <sect2 id="rdfinsertmethodplapis">
      <title>Using Virtuoso PL APIs</title>
      <para><emphasis>Example:</emphasis></para>
      <para>In the example script we implement a basic mapper which maps a text/plain mime type
to an imaginary ontology, which extends the class Document from FOAF with properties 'txt:UniqueWords'
and 'txt:Chars', where the prefix 'txt:' we specify as 'urn:txt:v0.0:'.</para>
<programlisting><![CDATA[
use DB;

create procedure DB.DBA.RDF_LOAD_TXT_META
	(
	 in graph_iri varchar,
	 in new_origin_uri varchar,
	 in dest varchar,
         inout ret_body any,
	 inout aq any,
	 inout ps any,
	 inout ser_key any
	 )
{
  declare words, chars int;
  declare vtb, arr, subj, ses, str any;
  declare ses any;
  -- if any error we just say nothing can be done
  declare exit handler for sqlstate '*'
 {
      return 0;
 };
  subj := coalesce (dest, new_origin_uri);
  vtb := vt_batch ();
  chars := length (ret_body);
  -- using the text index procedures we get a list of words
  vt_batch_feed (vtb, ret_body, 1);
  arr := vt_batch_strings_array (vtb);
  -- the list has 'word' and positions array , so we must divide by 2
  words := length (arr) / 2;
  ses := string_output ();
  -- we compose a N3 literal
  http (sprintf ('<%s> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://xmlns.com/foaf/0.1/Document> .\n', subj), ses);
  http (sprintf ('<%s> <urn:txt:v0.0:UniqueWords> "%d" .\n', subj, words), ses);
  http (sprintf ('<%s> <urn:txt:v0.0:Chars> "%d" .\n', subj, chars), ses);
  str := string_output_string (ses);
  -- we push the N3 text into the local store
  DB.DBA.TTLP (str, new_origin_uri, subj);
  return 1;
}
;

--
delete from DB.DBA.SYS_RDF_MAPPERS where RM_HOOK = 'DB.DBA.RDF_LOAD_TXT_META';

insert soft DB.DBA.SYS_RDF_MAPPERS (RM_PATTERN, RM_TYPE, RM_HOOK, RM_KEY, RM_DESCRIPTION)
    values ('(text/plain)', 'MIME', 'DB.DBA.RDF_LOAD_TXT_META', null, 'Text Files (demo)');

-- here we set order to some large number so don't break existing mappers
update DB.DBA.SYS_RDF_MAPPERS set RM_ID = 2000 where RM_HOOK = 'DB.DBA.RDF_LOAD_TXT_META';
]]></programlisting>
      <para>To test the mapper we just use /sparql endpoint with option 'Retrieve remote
RDF data for all missing source graphs' to execute:</para>
<programlisting><![CDATA[
select * from <http://demo.openlinksw.com:8890/tutorial/hosting/ho_s_30/WebCalendar/tools/summary.txt>
where { ?s ?p ?o }
]]></programlisting>
      <para>To check the results:</para>
      <itemizedlist>
        <listitem>Make sure the initial state of tutorial <ulink url="http://demo.openlinksw.com/tutorial/rdf/rd_s_1/rd_s_1.vsp">RD_S_1</ulink> is set.</listitem>
        <listitem>Go to http://demo.openlinksw.com/sparql</listitem>
        <listitem>Enter for Default Graph URI this value:</listitem>
<programlisting><![CDATA[
http://localhost:80/tutorial/hosting/ho_s_30/WebCalendar/tools/summary.txt
]]></programlisting>
        <listitem>Enter for Query text:</listitem>
<programlisting><![CDATA[
select *
where {?s ?p ?o}
]]></programlisting>
        <listitem>Click the "Run Query" button.</listitem>
        <listitem>As result should be shown the following triples:</listitem>
<programlisting><![CDATA[
s  	                                                                    p  	                                            o
http://localhost:80/tutorial/hosting/ho_s_30/WebCalendar/tools/summary.txt  http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://xmlns.com/foaf/0.1/Document
http://localhost:80/tutorial/hosting/ho_s_30/WebCalendar/tools/summary.txt  urn:txt:v0.0:UniqueWords 	                    47
http://localhost:80/tutorial/hosting/ho_s_30/WebCalendar/tools/summary.txt  urn:txt:v0.0:Chars 	                            625
]]></programlisting>
      </itemizedlist>
      <para><emphasis>Important: Setting Sponger Permissions</emphasis></para>
      <para>In order to allow the Sponger to update the local RDF quad store with triples
constituting the sponged structured data, the role "SPARQL_SPONGE" must be granted to the
account "SPARQL", i.e., to the owner account of /sparql web service endpoint.
This should normally be the case. If not, you must manually grant this
permission. As with most Virtuoso DBA tasks, the Conductor provides the simplest means of
doing this.</para>
    </sect2>
    <sect2 id="rdfinsertmethodsimilerdfbankapi">
      <title>Using SIMILE RDF Bank API</title>
      <para>Virtuoso implements the HTTP-based Semantic Bank API that enables client
applications to post to its RDF Triple Store. This method offers an alternative to
using Virtuoso/PL functions or WebDAV uploads as the triples-insertion mechanism.</para>
      <para><emphasis>Example:</emphasis></para>
      <para>From your machine go to Firefox->Tools->PiggyBank->My Semantic Bank Accounts</para>
      <para>Add in the shown form:</para>
      <itemizedlist>
        <listitem>For bank: address: http://demo.openlinksw.com/bank</listitem>
        <listitem>For account id: demo</listitem>
        <listitem>For password: demo</listitem>
      </itemizedlist>
      <para>Go to http://demo.openlinksw.com/ods</para>
      <para>Log in as user demo, password: demo</para>
      <para>Go to the Weblog tab from the main ODS Navigation</para>
      <para>Click on weblog instance name, for ex. "demo's Weblog".</para>
      <para>When the weblog home page is loaded, click Alt + P.</para>
      <para>As result is shown the "My PiggyBank" page with all the collected information
presented in items.</para>
      <para>For several of the items add Tags from the form "Tag" shown for each of them.</para>
      <para>As result should be shown the message "Last updated: [here goes the date value].</para>
      <para>You can also click "Save" and "Publish" for these items.</para>
      <para>Go to http://demo.openlinksw.com/sparql</para>
      <para>Enter for the "Default Graph URI" field: http://simile.org/piggybank/demo</para>
      <para>Enter for the "Query text" text-area:</para>
<programlisting><![CDATA[
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix sioc: <http://rdfs.org/sioc/ns#>
select *
from <http://simile.org/piggybank/demo>
where {?s ?p  ?o}
]]></programlisting>
      <para>Click "Run Query".</para>
      <para>As results are shown the found results.</para>
    </sect2>
    <sect2 id="rdfinsertmethodrdfnet">
      <title>Using RDF NET</title>
      <para><emphasis>Example:</emphasis></para>
      <para>Execute the following query:</para>
<programlisting><![CDATA[
SQL> select DB.DBA.HTTP_RDF_NET ('sparql load
"http://www.openlinksw.com/dataspace/person/kidehen@openlinksw.com"
into graph <http://www.openlinksw.com/>');
]]></programlisting>
      <para>As result should be shown:</para>
<programlisting><![CDATA[
callret
VARCHAR
_______________________________________________________

<?xml version="1.0" ?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns:vcard="http://www.w3.org/2001/vcard-rdf/3.0#"
xmlns="http://example.org/book/" xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:ns="http://example.org/ns#">
<rdf:Description>
<callret-0>Load <http://www.openlinksw.com/dataspace/person/kidehen@openlinksw.com>
into graph <http://www.openlinksw.com/> -- done</callret-0>
</rdf:Description>
</rdf:RDF>

1 Rows. -- 1982 msec.
]]></programlisting>
    </sect2>
    <sect2 id="rdfinsertmethodproxy">
      <title>Using the RDF proxy service</title>
    <para>Triples can be inserted also using the RDF proxy service. For more information and examples see <link linkend="rdfproxyservice">here</link>.</para>
    </sect2>
</sect1>
<sect1 id="virtuososponger"><title>Virtuoso Sponger</title>
<sect2 id="virtuosospongerintro"><title>Introduction</title>
<para>The Virtuoso Sponger is a middleware component of Virtuoso that generates RDF Linked Data from
a variety of data sources. The sponger is transparently integrated into the Virtuoso SPARQL Query
Processor, where it serves as part of the URI/IRI dereferencing functionality. It is also optionally
used by the Virtuoso Content Crawler.
</para>
<figure id="virtuosospongerdiagram" float="1">
		<title>Virtuoso Sponger</title>
		<graphic fileref="linked_data_gen_opts3.png"/>
        </figure>
<para>
A majority of the worlds data naturally resides in non RDF form at the current time. The Sponger
delivers middleware that accelerates the bootstrap of the Semantic Data Web by generating RDF
from non RDF data sources, unobtrusively.
</para>
<para>
When an RDF aware client requests data from a network accessible resource via the Sponger
the following events occur:
</para>
<itemizedlist>
<listitem>A requests in made for data in RDF form, and if RDF is returned nothing further happens</listitem>
<listitem>If RDF isn't returned, then the Sponger passes the data through a Metadata Extraction
Pipeline process (using Metadata Extractors)</listitem>
<listitem>The extracted data is transformed to RDF via a Mapping Pipeline process (RDF is extracted by way
of Ontology matching and mapping) that results in RDF Entities (instance data) generation</listitem>
<listitem>RDF Entities are returned to the client</listitem>
</itemizedlist>
<para>The imported data forms a local cache and its invalidation rules conform to those of traditional
HTTP clients (Web Browsers). Thus, expiration time is determined based on subsequent data fetches of
the same resource (note: the first data load will record the 'expires' header) with current time
compared to expiration time stored in the local cache. If HTTP 'expires' header data isn't returned
by the source data server, then the "Sponger" will derive it's own invalidation time frame by
evaluating the 'date' header and 'last-modified' HTTP headers. Irrespective of path taken,
local cache invalidation is driven by an assessment of current time relative to recorded expiration time.
</para>
<para>Designed with a pluggable architecture, the Sponger's core functionality is provided by Catridges.
Each catridge includes Data Extractors which extract data from one or more data sources, and Ontology
Mappers which map the extracted data to one or more ontologies/schemas, and route to producing RDF
Linked Data.
</para>
<para>The Schema Mappers are typically XSLT (e.g. GRDDL and other OpenLink Mapping Schemes) or
Virtuoso PL based. The Metadata Extractors may be developed in Virtuoso PL, C/C++, Java, or any
other language that can be integrated into the Virtuoso via it's server extensions APIs.
</para>
<para>
The Sponger also includes a pluggable name resolution mechanism that enables the development of
Custom Resolvers for naming schemes (e.g. URNs) associated with protocols beyond HTTP.
Examples of custom resolvers include:
</para>
<itemizedlist>
<listitem>LSID</listitem>
<listitem>DOI</listitem>
</itemizedlist>
</sect2>
<sect2 id="virtuosospongercartridwh"><title>What is a Cartridge?</title>
<para>The Sponger is comprised of cartridges which are themselves comprised of an entity extractor
and an ontology mapper. Entities extracted from non-RDF resources are used as the basis for generating
structured data by mapping them to a suitable ontology. A cartridge is invoked through its cartridge
hook, a Virtuoso/PL procedure entry point and binding to the cartridge's entity extractor and
ontology mapper.</para>
</sect2>
<sect2 id="virtuosospongercartridges"><title>Virtuoso Cartridge-Supported Data Sources</title>
<itemizedlist>
<listitem>RDF that doesn't contain Linked Data URIs</listitem>
<listitem>Non-RDF Data Sources
  <itemizedlist>
    <listitem>Open Standard data spaces
<table>
<tgroup cols="4">
<thead>
  <row>
    <entry>Cartridge</entry><entry>Sample URI</entry><entry>Resource Description</entry><entry>Linked Data Graph</entry>
  </row>
</thead>
<tbody>
<row><entry>APML  	</entry><entry>   <ulink url="https://apml.engagd.com/apml/danielabarbosa.myopenid.com.apml">Example   	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/https://apml.engagd.com/apml/danielabarbosa.myopenid.com.apml">Description of URI</ulink> </entry><entry> <ulink url="http://linkeddata.uriburner.com/ode/?uri=https://apml.engagd.com/apml/danielabarbosa.myopenid.com.apml">Linked Data from URI</ulink> </entry></row>
<row><entry>ATOM 	</entry><entry>   <ulink url="http://www.openlinksw.com/weblog/oerling/gems/atom.xml">example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.openlinksw.com/weblog/oerling/gems/atom.xml">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.openlinksw.com/weblog/oerling/gems/atom.xml">Linked Data from URI</ulink> </entry></row>
<row><entry>eRDF 	</entry><entry>   <ulink url="http://www.w3.org/2001/sw/grddl-wg/doc29/hotel-data.html">sample eRDF test </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.w3.org/2001/sw/grddl-wg/doc29/hotel-data.html">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.w3.org/2001/sw/grddl-wg/doc29/hotel-data.html">Linked Data from URI</ulink> </entry></row>
<row><entry>GRDDL 	</entry><entry>   <ulink url="http://www.w3.org/2001/sw/grddl-wg/doc29/hotel-data.html">sample GRDDL test</ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.w3.org/2001/sw/grddl-wg/doc29/hotel-data.html">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.w3.org/2001/sw/grddl-wg/doc29/hotel-data.html">Linked Data from URI</ulink> </entry></row>
<row><entry>hAudio 	</entry><entry>   <ulink url="http://openmediaweb.org/index.php/2008/01/13/publishing-my-workout-music-in-haudio/">Example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://openmediaweb.org/index.php/2008/01/13/publishing-my-workout-music-in-haudio/">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://openmediaweb.org/index.php/2008/01/13/publishing-my-workout-music-in-haudio/">Linked Data from URI</ulink> </entry></row>
<row><entry>hCalendar   </entry><entry>   <ulink url="http://www.maine.gov/portal/government/calendar.shtml">hCalendar 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.maine.gov/portal/government/calendar.shtml">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.maine.gov/portal/government/calendar.shtml">Linked Data from URI</ulink> </entry></row>
<row><entry>hCard 	</entry><entry>   <ulink url="http://www.lawyer-directory.net/lawyer/Grand-Rapids-Bar-Association-Grand-Rapids-law434032.htm">hcard-example    </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.lawyer-directory.net/lawyer/Grand-Rapids-Bar-Association-Grand-Rapids-law434032.htm">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.lawyer-directory.net/lawyer/Grand-Rapids-Bar-Association-Grand-Rapids-law434032.htm">Linked Data from URI</ulink> </entry></row>
<row><entry>hReview     </entry><entry>   <ulink url="http://www.concertbuzz.net/genres/classic-rock/jethro-tull.html">sample hreview   </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.concertbuzz.net/genres/classic-rock/jethro-tull.html">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.concertbuzz.net/genres/classic-rock/jethro-tull.html">Linked Data from URI</ulink> </entry></row>
<row><entry>iCalendar   </entry><entry>   <ulink url="http://kidehen.idehen.net/DAV/home/kidehen/Public/LDP-Spring2008.ics">iCal 	         </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://kidehen.idehen.net/DAV/home/kidehen/Public/LDP-Spring2008.ics">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://kidehen.idehen.net/DAV/home/kidehen/Public/LDP-Spring2008.ics">Linked Data from URI</ulink> </entry></row>
<row><entry>Images 	</entry><entry>   <ulink url="http://farm4.static.flickr.com/3067/2590298570_304a594899_t.jpg">JPG example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://farm4.static.flickr.com/3067/2590298570_304a594899_t.jpg">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://farm4.static.flickr.com/3067/2590298570_304a594899_t.jpg">Linked Data from URI</ulink> </entry></row>
<row><entry>OPML 	</entry><entry>   <ulink url="http://news.bbc.co.uk/rss/feeds.opml">example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://news.bbc.co.uk/rss/feeds.opml">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://news.bbc.co.uk/rss/feeds.opml">Linked Data from URI</ulink> </entry></row>
<row><entry>RDFa 	</entry><entry>   <ulink url="http://virtuoso.openlinksw.com/presentations/Creating_Deploying_Exploiting_Linked_Data2/Creating_Deploying_Exploiting_Linked_Data2_TimBL_v3.html">example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://virtuoso.openlinksw.com/presentations/Creating_Deploying_Exploiting_Linked_Data2/Creating_Deploying_Exploiting_Linked_Data2_TimBL_v3.html">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://virtuoso.openlinksw.com/presentations/Creating_Deploying_Exploiting_Linked_Data2/Creating_Deploying_Exploiting_Linked_Data2_TimBL_v3.html">Linked Data from URI</ulink> </entry></row>
<row><entry>RSS 	</entry><entry>   <ulink url="http://microformats.org/feed/">example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://microformats.org/feed/">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://microformats.org/feed/">Linked Data from URI</ulink> </entry></row>
<row><entry>Slidy 	</entry><entry>   <ulink url="http://slideshow.rubyforge.org/microformats.html">example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://slideshow.rubyforge.org/microformats.html">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://slideshow.rubyforge.org/microformats.html">Linked Data from URI</ulink> </entry></row>
<row><entry>vCalendar   </entry><entry>   <ulink url="http://upcoming.org/event/130719/">event 	         </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://upcoming.org/event/130719/">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://upcoming.org/event/130719/">Linked Data from URI</ulink> </entry></row>
<row><entry>vCard 	</entry><entry>   <ulink url="http://tech.yahoo.com/pr/apple-ipod-video-30gb-black-mp3-player/1992981873">ipod example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://tech.yahoo.com/pr/apple-ipod-video-30gb-black-mp3-player/1992981873">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://tech.yahoo.com/pr/apple-ipod-video-30gb-black-mp3-player/1992981873">Linked Data from URI</ulink> </entry></row>
<row><entry>XBEL 	</entry><entry>   <ulink url="http://xbel.sourceforge.net/bookmarks/xbel.xbel">example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://xbel.sourceforge.net/bookmarks/xbel.xbel">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://xbel.sourceforge.net/bookmarks/xbel.xbel">Linked Data from URI</ulink> </entry></row>
<row><entry>XBRL 	</entry><entry>   <ulink url="http://www.sec.gov/Archives/edgar/data/51143/000110465908059468/ibm-20080429.xml">example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.sec.gov/Archives/edgar/data/51143/000110465908059468/ibm-20080429.xml">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.sec.gov/Archives/edgar/data/51143/000110465908059468/ibm-20080429.xml">Linked Data from URI</ulink> </entry></row>
<row><entry>XFN 	</entry><entry>   <ulink url="http://www.molly.com/people.php">example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.molly.com/people.php">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.molly.com/people.php">Linked Data from URI</ulink> </entry></row>
<row><entry>XHTML 	</entry><entry>   <ulink url="http://www.lespetitescases.net/semantique-et-xhtml">xhtml cases 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.lespetitescases.net/semantique-et-xhtml">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.lespetitescases.net/semantique-et-xhtml">Linked Data from URI</ulink> </entry></row>
<row><entry>XR-XML 	</entry><entry>   <ulink url="http://ns.hr-xml.org/2_5/HR-XML-2_5/SEP/ResumeExample.xml">Example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://ns.hr-xml.org/2_5/HR-XML-2_5/SEP/ResumeExample.xml">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://ns.hr-xml.org/2_5/HR-XML-2_5/SEP/ResumeExample.xml">Linked Data from URI</ulink> </entry></row>
<row><entry>xslt 	</entry><entry>   <ulink url="http://www.w3.org/2003/12/rdf-in-xhtml-xslts/complete-example.html">example 	 </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.w3.org/2003/12/rdf-in-xhtml-xslts/complete-example.html">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.w3.org/2003/12/rdf-in-xhtml-xslts/complete-example.html">Linked Data from URI</ulink> </entry></row>
</tbody>
</tgroup>
</table>
    </listitem>
    <listitem>Vendor-specific data spaces

<table>
<tgroup cols="4">
<thead>
  <row>
    <entry>Cartridge</entry><entry>Sample URI</entry><entry>Resource Description</entry><entry>Linked Data Graph</entry>
  </row>
</thead>
<tbody>
<row><entry>Amazon  	            </entry><entry>   <ulink url="http://www.amazon.co.uk/Owl-Representing-Information-Ontology-Language/dp/1412034485/ref=sr_1_1/203-3289794-0348766?ie=UTF8&amp;s=books&amp;qid=1177155160&amp;sr=1-1">Amazon book entry                </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.amazon.co.uk/Owl-Representing-Information-Ontology-Language/dp/1412034485/ref=sr_1_1/203-3289794-0348766?ie=UTF8&amp;s=books&amp;qid=1177155160&amp;sr=1-1">Description of URI</ulink> </entry><entry> <ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.amazon.co.uk/Owl-Representing-Information-Ontology-Language/dp/1412034485/ref=sr_1_1/203-3289794-0348766?ie=UTF8&amp;s=books&amp;qid=1177155160&amp;sr=1-1">Linked Data from URI</ulink> </entry></row>
<row><entry>Apple 	            </entry><entry>   <ulink url="http://www.apple.com/">Apple Website 	             </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.apple.com/">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.apple.com/">Linked Data from URI</ulink> </entry></row>
<row><entry>Bugzilla 	            </entry><entry>   <ulink url="https://bugzilla.mozilla.org/show_bug.cgi?id=251714">Bugzilla entry from Mozilla      </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/https://bugzilla.mozilla.org/show_bug.cgi?id=251714">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=https://bugzilla.mozilla.org/show_bug.cgi?id=251714">Linked Data from URI</ulink> </entry></row>
<row><entry>CrunchBase 	            </entry><entry>   <ulink url="http://www.crunchbase.com/person/sergey-brin">Sergey Brin on CrunchBase 	     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.crunchbase.com/person/sergey-brin">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.crunchbase.com/person/sergey-brin">Linked Data from URI</ulink> </entry></row>
<row><entry>Del.icio.us 	    </entry><entry>   <ulink url="http://delicious.com/popular/blog">Popular blog Bookmarks 	     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://delicious.com/popular/blog">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://delicious.com/popular/blog">Linked Data from URI</ulink> </entry></row>
<row><entry>Digg 	            </entry><entry>   <ulink url="http://digg.com/general_sciences/at_last-stem_cells_without_side_effects_">Example 	                     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://digg.com/general_sciences/at_last-stem_cells_without_side_effects_">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://digg.com/general_sciences/at_last-stem_cells_without_side_effects_">Linked Data from URI</ulink> </entry></row>
<row><entry>Discogs 	            </entry><entry>   <ulink url="http://www.discogs.com/release/634302">album page 	                     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.discogs.com/release/634302">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.discogs.com/release/634302">Linked Data from URI</ulink> </entry></row>
<row><entry>Disqus 	            </entry><entry>   <ulink url="http://blog.disqus.net/2008/08/25/reblog-comments-can-be-blog-posts/">Blog Comments can be Blog Posts  </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://blog.disqus.net/2008/08/25/reblog-comments-can-be-blog-posts/">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://blog.disqus.net/2008/08/25/reblog-comments-can-be-blog-posts/">Linked Data from URI</ulink> </entry></row>
<row><entry>eBay 	            </entry><entry>   <ulink url="http://cgi.ebay.com/Eclipse-by-Stephenie-Meyer-2007_W0QQitemZ250283828939QQcmdZViewItem?hash=item250283828939&amp;_trkparms=240%3A1318&amp;_trksid=p4295">eBay Auction Item 	             </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://cgi.ebay.com/Eclipse-by-Stephenie-Meyer-2007_W0QQitemZ250283828939QQcmdZViewItem?hash=item250283828939&amp;_trkparms=240%3A1318&amp;_trksid=p4295">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://cgi.ebay.com/Eclipse-by-Stephenie-Meyer-2007_W0QQitemZ250283828939QQcmdZViewItem?hash=item250283828939&amp;_trkparms=240%3A1318&amp;_trksid=p4295">Linked Data from URI</ulink> </entry></row>
<row><entry>Flickr 	            </entry><entry>   <ulink url="http://farm1.static.flickr.com/212/496684670_7122c831ed.jpg">Flickr Image 	             </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://farm1.static.flickr.com/212/496684670_7122c831ed.jpg">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://farm1.static.flickr.com/212/496684670_7122c831ed.jpg">Linked Data from URI</ulink> </entry></row>
<row><entry>Freebase 	            </entry><entry>   <ulink url="http://www.freebase.com/view/en/abraham_lincoln">Abraham Lincoln on Freebase      </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.freebase.com/view/en/abraham_lincoln">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.freebase.com/view/en/abraham_lincoln">Linked Data from URI</ulink> </entry></row>
<row><entry>FriendFeed 	            </entry><entry>   <ulink url="http://friendfeed.com/search?q=linked+data">Linked Data on FriendFeed 	     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://friendfeed.com/search?q=linked+data">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://friendfeed.com/search?q=linked+data">Linked Data from URI</ulink> </entry></row>
<row><entry>Get Satisfaction        </entry><entry>   <ulink url="http://getsatisfaction.com/mozilla/topics/ubiquity_mostly_fails_on_mac_ppc">Get Satisfaction issue thread    </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://getsatisfaction.com/mozilla/topics/ubiquity_mostly_fails_on_mac_ppc">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://getsatisfaction.com/mozilla/topics/ubiquity_mostly_fails_on_mac_ppc">Linked Data from URI</ulink> </entry></row>
<row><entry>GoogleBase 	            </entry><entry>   <ulink url="http://www.google.com/base/feeds/snippets?bq=%20%5bemployer:%20Hewlett-Packard%5d%20%20%5bjob%20type:full-time%5d">GoogleBase snippet 	             </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.google.com/base/feeds/snippets?bq=%20%5bemployer:%20Hewlett-Packard%5d%20%20%5bjob%20type:full-time%5d">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.google.com/base/feeds/snippets?bq=%20%5bemployer:%20Hewlett-Packard%5d%20%20%5bjob%20type:full-time%5d">Linked Data from URI</ulink> </entry></row>
<row><entry>ISBN DB 	            </entry><entry>   <ulink url="http://isbndb.com/d/person/berners_lee_tim.html">ISBN author entry 	             </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://isbndb.com/d/person/berners_lee_tim.html">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://isbndb.com/d/person/berners_lee_tim.html">Linked Data from URI</ulink> </entry></row>
<row><entry>LSID 	            </entry><entry>   <ulink url="urn:lsid:ubio.org:namebank:12292">LSID entry 	                     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/urn:lsid:ubio.org:namebank:12292">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=urn:lsid:ubio.org:namebank:12292">Linked Data from URI</ulink> </entry></row>
<row><entry>Magnolia 	            </entry><entry>   <ulink url="http://ma.gnolia.com/people/apartness">example 	                     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://ma.gnolia.com/people/apartness">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://ma.gnolia.com/people/apartness">Linked Data from URI</ulink> </entry></row>
<row><entry>MusicBrainz 	    </entry><entry>   <ulink url="http://musicbrainz.org/release/37e955d4-a53c-45aa-a812-1b23b88dbc13.html">MusicBrainz album entry 	     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://musicbrainz.org/release/37e955d4-a53c-45aa-a812-1b23b88dbc13.html">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://musicbrainz.org/release/37e955d4-a53c-45aa-a812-1b23b88dbc13.html">Linked Data from URI</ulink> </entry></row>
<row><entry>OAI 	            </entry><entry>   <ulink url="oai:dcmi.ischool.washington.edu:article/8">OAI paper entry 	             </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/oai:dcmi.ischool.washington.edu:article/8">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=oai:dcmi.ischool.washington.edu:article/8">Linked Data from URI</ulink> </entry></row>
<row><entry>Open Library 	    </entry><entry>   <ulink url="http://openlibrary.org/b/OL7983950M">OpenLibrary book entry 	     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://openlibrary.org/b/OL7983950M">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://openlibrary.org/b/OL7983950M">Linked Data from URI</ulink> </entry></row>
<row><entry>Open Social 	    </entry><entry>   <ulink url="http://socialgraph.apis.google.com/otherme?pretty=1&amp;q=www.openlinksw.com/blog/~kidehen/">SocialGraph person page 	     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://socialgraph.apis.google.com/otherme?pretty=1&amp;q=www.openlinksw.com/blog/~kidehen/">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://socialgraph.apis.google.com/otherme?pretty=1&amp;q=www.openlinksw.com/blog/~kidehen/">Linked Data from URI</ulink> </entry></row>
<row><entry>SVG 	            </entry><entry>   <ulink url="http://upload.wikimedia.org/wikipedia/commons/b/b0/Hydroxide_lone_pairs-2D.svg">SVG picture of a molecule 	     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://upload.wikimedia.org/wikipedia/commons/b/b0/Hydroxide_lone_pairs-2D.svg">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://upload.wikimedia.org/wikipedia/commons/b/b0/Hydroxide_lone_pairs-2D.svg">Linked Data from URI</ulink> </entry></row>
<row><entry>They Work For You       </entry><entry>   <ulink url="http://www.theyworkforyou.com/mp/diane_abbott/hackney_north_and_stoke_newington">TheyWorkForYou page 	     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.theyworkforyou.com/mp/diane_abbott/hackney_north_and_stoke_newington">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.theyworkforyou.com/mp/diane_abbott/hackney_north_and_stoke_newington">Linked Data from URI</ulink> </entry></row>
<row><entry>Twine 	            </entry><entry>   <ulink url="http://www.twine.com/twine/1p2dqhdx-1jg/nova-spivack-my-public-twine">my public twine 	             </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.twine.com/twine/1p2dqhdx-1jg/nova-spivack-my-public-twine">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.twine.com/twine/1p2dqhdx-1jg/nova-spivack-my-public-twine">Linked Data from URI</ulink> </entry></row>
<row><entry>Twitter 	            </entry><entry>   <ulink url="http://twitter.com/statuses/user_timeline/633273.rss">example 	                     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://twitter.com/statuses/user_timeline/633273.rss">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://twitter.com/statuses/user_timeline/633273.rss">Linked Data from URI</ulink> </entry></row>
<row><entry>US SEC EDGAR archives   </entry><entry>   <ulink url="http://www.sec.gov/Archives/edgar/data/789019/000119312507259490/msft-20070930.xml">msft-20070930 	             </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.sec.gov/Archives/edgar/data/789019/000119312507259490/msft-20070930.xml">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.sec.gov/Archives/edgar/data/789019/000119312507259490/msft-20070930.xml">Linked Data from URI</ulink> </entry></row>
<row><entry>Wikipedia 	            </entry><entry>   <ulink url="http://en.wikipedia.org/wiki/London">Wikipedia page on London 	     </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://en.wikipedia.org/wiki/London">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://en.wikipedia.org/wiki/London">Linked Data from URI</ulink> </entry></row>
<row><entry>Yahoo! Finance 	    </entry><entry>   <ulink url="http://finance.yahoo.com/q?s=AAPL">Yahoo! Finance on AAPL (Apple)   </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://finance.yahoo.com/q?s=AAPL">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://finance.yahoo.com/q?s=AAPL">Linked Data from URI</ulink> </entry></row>
<row><entry>Yahoo! Maps 	    </entry><entry>   <ulink url="http://local.yahooapis.com/MapsService/V1/trafficData?appid=Jz0wAU7V34Ff7gCzblxD.86qjGTEn._H3KA3PEajNE3xBMIbQtEZqIqHRh0G&amp;street=701+First+Street&amp;city=Sunnyvale&amp;state=CA">Yahoo! Traffic map 	             </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://local.yahooapis.com/MapsService/V1/trafficData?appid=Jz0wAU7V34Ff7gCzblxD.86qjGTEn._H3KA3PEajNE3xBMIbQtEZqIqHRh0G&amp;street=701+First+Street&amp;city=Sunnyvale&amp;state=CA">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://local.yahooapis.com/MapsService/V1/trafficData?appid=Jz0wAU7V34Ff7gCzblxD.86qjGTEn._H3KA3PEajNE3xBMIbQtEZqIqHRh0G&amp;street=701+First+Street&amp;city=Sunnyvale&amp;state=CA">Linked Data from URI</ulink> </entry></row>
<row><entry>Yahoo! Weather 	    </entry><entry>   <ulink url="http://xml.weather.yahoo.com/forecastrss?p=USCA1116&amp;u=f">Yahoo! Weather forecast          </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://xml.weather.yahoo.com/forecastrss?p=USCA1116&amp;u=f">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://xml.weather.yahoo.com/forecastrss?p=USCA1116&amp;u=f">Linked Data from URI</ulink> </entry></row>
<row><entry>Youtube                 </entry><entry>   <ulink url="http://www.youtube.com/watch?v=6eGcsGPgUTw">example                          </ulink> </entry><entry>   <ulink url="http://linkeddata.uriburner.com/about/html/http://www.youtube.com/watch?v=6eGcsGPgUTw">Description of URI</ulink> </entry><entry>	<ulink url="http://linkeddata.uriburner.com/ode/?uri=http://www.youtube.com/watch?v=6eGcsGPgUTw">Linked Data from URI</ulink> </entry></row>
</tbody>
</tgroup>
</table>
    </listitem>
  </itemizedlist>
</listitem>
</itemizedlist>
</sect2>
<sect2 id="virtuosospongercartridgetypes"><title>Types of Cartridges</title>
<para><emphasis>Basic</emphasis></para>
<para>Sponger cartridges are invoked as follows:</para>
<para>When the SPARQL processor dereferences a URI, it plays the role of an HTTP user agent (client)
that makes a content type specific request to an HTTP server via the HTTP request's Accept headers.
The following then occurs:</para>

<itemizedlist>
  <listitem>If the content type returned is RDF then no further transformation is needed and the process
stops. For instance, when consuming an (X)HTML document with a GRDDL profile, the profile URI points to a
data provider that simply returns RDF instance data. </listitem>
  <listitem>If the content type is not RDF (i.e. application/rdf+xml or text/rdf+n3 ), for instance
'text/plain', the Sponger looks in the Cartridge Registry iterating over every record for which the
RM_ENABLED flag is true, with the look-up sequence ordered on the RM_ID column values. For each record,
the processor tries matching the content type or URL against the RM_PATTERN value and, if there is
match, the function specified in RM_HOOK column is called. If the function doesn't exist, or signals
an error, the SPARQL processor looks at next record.
    <itemizedlist>
      <listitem>If the hook returns zero, the next cartridge is tried. (A cartridge function can return
zero if it believes a subsequent cartridge in the chain is capable of extracting more RDF data.)</listitem>
      <listitem>If the result returned by the hook is negative, the Sponger is instructed that no
RDF was generated and the process stops.
      <itemizedlist>
          <listitem>If the hook result is positive, the Sponger is informed that structured data was
retrieved and the process stops. </listitem>
      </itemizedlist>
    </listitem>
  </itemizedlist>
  </listitem>
  <listitem>If none of the cartridges match the source data signature (content type or URL), the
 ODS-Briefcase WebDAV metadata extractor and RDF generator is called.</listitem>
</itemizedlist>
<para><emphasis>Meta</emphasis></para>
<para>Virtuoso also supports another cartridge type - a 'meta-cartridge'. Meta-cartridges act as
post-processors in the cartridge pipeline, augmenting entity descriptions in an RDF graph with
additional information gleaned from 'lookup' data sources and web services.</para>
</sect2>
<sect2 id="virtuosospongercartridgesextractor"><title>Virtuoso Sponger Cartridge RDF Extractor</title>
<para>
Used to extract RDF from a Web Data Source it consumes services from: Virtuoso PL, C/C++, Java
based RDF Extractors</para>
<para>The RDF mappers provide a way to extract metadata from non-RDF documents such as HTML pages,
images Office documents etc. and pass to SPARQL sponger (crawler which retrieve missing
source graphs). For brevity further in this article the "RDF mapper" we simply will call "mapper".
</para>
<para>The mappers consist of PL procedure (hook) and extractor, where extractor itself can be built
using PL, C or any external language supported by Virtuoso server.</para>
<para>Once the mapper is developed it must be plugged into the SPARQL engine by adding a record
in the table DB.DBA.SYS_RDF_MAPPERS.</para>
<para>If a SPARQL query instructs the SPARQL processor to retrieve target graph into local storage,
then the SPARQL sponger will be invoked. If the target graph IRI represents a deferencable URL
then content will be retrieved using content negotiation. The next step is the content type
to be detected:</para>
<itemizedlist>
<listitem>If RDF and no further transformation such as GRDDL is needed, then the process would stop.</listitem>
<listitem>If such as 'text/plain' and is not known to have metadata, then the SPARQL sponger will
look in the DB.DBA.SYS_RDF_MAPPERS table by order of RM_ID and for every matching URL or MIME
type pattern (depends on column RM_TYPE) will call the mapper hook.
  <itemizedlist>
    <listitem>If hook returns zero the next mapper will be tried;</listitem>
    <listitem>If result is negative the process would stop instructing the SPARQL nothing was retrieved;</listitem>
    <listitem>If result is positive the process would stop instructing the SPARQL that metadata was retrieved.</listitem>
  </itemizedlist>
</listitem>
</itemizedlist>
<sect3 id="virtuosospongercartridgesextractorpl"><title>Virtuoso Sponger Cartridge RDF Extractor PL Requirements</title>
<para><emphasis>PL hook requirements:</emphasis></para>
<para>Every PL function used to plug a mapper into SPARQL engine must have following parameters in
the same order:</para>
<itemizedlist>
<listitem>in graph_iri varchar: the graph IRI which is currently retrieved</listitem>
<listitem>in new_origin_uri varchar: the URL of the document retrieved</listitem>
<listitem>in destination varchar: the destination graph IRI</listitem>
<listitem>inout content any: the content of the document retrieved by SPARQL sponger </listitem>
<listitem>inout async_queue any: an asynchronous queue, can be used to push something to execute
on background if needed.</listitem>
<listitem>inout ping_service any: the value of [SPARQL] - PingService INI parameter, could be used
to configure a service notification such as pingthesemanticweb.com</listitem>
<listitem>inout api_key any: a plain text id single key value or serialized vector of key structure,
basically the value of RM_KEY column of the DB.DBA.SYS_RDF_MAPPERS table.</listitem>
</itemizedlist>
<para>Note: the names of the parameters are not important, but their order and presence are!</para>
<para><emphasis>Example Implementation:</emphasis></para>
<para>In the example script bellow we implement a basic mapper, which maps a text/plain mime type to an
imaginary ontology, which extends the class Document from FOAF with properties 'txt:UniqueWords'
and 'txt:Chars', where the prefix 'txt:' we specify as 'urn:txt:v0.0:'.</para>
<programlisting><![CDATA[
use DB;

create procedure DB.DBA.RDF_LOAD_TXT_META
 (
  in graph_iri varchar,
  in new_origin_uri varchar,
  in dest varchar,
  inout ret_body any,
  inout aq any,
  inout ps any,
  inout ser_key any
  )
{
  declare words, chars int;
  declare vtb, arr, subj, ses, str any;
  declare ses any;
  -- if any error we just say nothing can be done
  declare exit handler for sqlstate '*'
    {
      return 0;
    };
  subj := coalesce (dest, new_origin_uri);
  vtb := vt_batch ();
  chars := length (ret_body);

  -- using the text index procedures we get a list of words
  vt_batch_feed (vtb, ret_body, 1);
  arr := vt_batch_strings_array (vtb);

  -- the list has 'word' and positions array, so we must divide by 2
  words := length (arr) / 2;
  ses := string_output ();

  -- we compose a N3 literal
  http (sprintf ('<%s> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://xmlns.com/foaf/0.1/Document> .\n', subj), ses);
  http (sprintf ('<%s> <urn:txt:v0.0:UniqueWords> "%d" .\n', subj, words), ses);
  http (sprintf ('<%s> <urn:txt:v0.0:Chars> "%d" .\n', subj, chars), ses);
  str := string_output_string (ses);

  -- we push the N3 text into the local store
  DB.DBA.TTLP (str, new_origin_uri, subj);
  return 1;
};

delete from DB.DBA.SYS_RDF_MAPPERS where RM_HOOK = 'DB.DBA.RDF_LOAD_TXT_META';

insert soft DB.DBA.SYS_RDF_MAPPERS (RM_PATTERN, RM_TYPE, RM_HOOK, RM_KEY, RM_DESCRIPTION)
values ('(text/plain)', 'MIME', 'DB.DBA.RDF_LOAD_TXT_META', null, 'Text Files (demo)');

-- here we set order to some large number so don't break existing mappers
update DB.DBA.SYS_RDF_MAPPERS set RM_ID = 2000 where RM_HOOK = 'DB.DBA.RDF_LOAD_TXT_META';
]]></programlisting>
<para>To test the mapper we just use /sparql endpoint with option 'Retrieve remote RDF data
for all missing source graphs' to execute:</para>
<programlisting><![CDATA[
select * from <URL-of-a-txt-file> where { ?s ?p ?o }
]]></programlisting>
<para>It is important that the SPARQL_UPDATE role to be granted to "SPARQL" account in order
to allow local repository update via sponge feature.</para>
<para><emphasis>Authentication in Sponger</emphasis></para>
<para>To enable usage of user defined authentication, there are added more parameters to the
/proxy/rdf and /sparql endpoints. So to use it, the RDF browser and iSPARQL should send following
url parameters:</para>
<itemizedlist>
<listitem>for /proxy/rdf endpoint:
<programlisting><![CDATA[
'login=<account name>'
]]></programlisting>
</listitem>
<listitem>for /sparql endpoint:
<programlisting><![CDATA[
get-login=<account name>
]]></programlisting>
</listitem>
</itemizedlist>
</sect3>
<sect3 id="virtuosospongercartridgesextractorusecases"><title>RDF Cartridges Use Cases</title>
<para>This section contains examples of Web resources which can be transformed by RDF Cartridges.
It also states where additional setup for given cartrides is needed i.e. keys account names etc.
</para>
<para><emphasis>Service based:</emphasis></para>
<itemizedlist>
<listitem>amazon
<programlisting><![CDATA[
needs: api key
example: http://www.amazon.com/gp/product/0553383043
]]></programlisting>
</listitem>
<listitem>ebay
<programlisting><![CDATA[
needs: account, api-key
example: http://cgi.ebay.com/RARE-DAY-IN-FAIRY-LAND-ELEPHANT-FOLIO-20-FULL-COLOR_W0QQitemZ140209597189QQihZ004QQcategoryZ29223QQssPageNameZWDVWQQrdZ1QQcmdZViewItem
]]></programlisting>
</listitem>
<listitem>flickr
needs: api-key
example: http://farm1.static.flickr.com/212/496684670_7122c831ed.jpg
<programlisting><![CDATA[
]]></programlisting>
</listitem>
<listitem>mbz
<programlisting><![CDATA[
example: http://musicbrainz.org/release/37e955d4-a53c-45aa-a812-1b23b88dbc13.html
]]></programlisting>
</listitem>
<listitem>mql (freebase)
<programlisting><![CDATA[
example: http://www.freebase.com/view/en/beta_ursae_majoris
]]></programlisting>
</listitem>
<listitem>facebook
<programlisting><![CDATA[
needs: api-key, secret, persistent-session-id
example: http://www.facebook.com/profile.php?id=841100003
]]></programlisting>
</listitem>
<listitem>yahoo-stock
<programlisting><![CDATA[
example: http://finance.yahoo.com/q?s=AAPL
]]></programlisting>
</listitem>
<listitem>yahoo-traffic
<programlisting><![CDATA[
example: http://local.yahooapis.com/MapsService/V1/trafficData?appid=YahooDemo&street=701+First+Street&city=Sunnyvale&state=CA
]]></programlisting>
</listitem>
<listitem>Bugzilla
<programlisting><![CDATA[
example: https://bugzilla.mozilla.org/show_bug.cgi?id=251714
]]></programlisting>
</listitem>
<listitem>SVG</listitem>
<listitem>OO document
<programlisting><![CDATA[
needs: unzip plugin
]]></programlisting>
</listitem>
<listitem>Wikipedia
<programlisting><![CDATA[
needs: php plugin & dbpedia extractor
example: http://wikipedia.org/wiki/London
]]></programlisting>
</listitem>
<listitem>Opencalais</listitem>
<listitem>iCalendar</listitem>
</itemizedlist>
<para><emphasis>GRDDL</emphasis></para>
<itemizedlist>
<listitem>Google Base (google)
<programlisting><![CDATA[
example: http://www.google.com/base/feeds/snippets/17891817243016304554
]]></programlisting>
</listitem>
<listitem>eRDF</listitem>
<listitem>RDFa</listitem>
<listitem>hCard</listitem>
<listitem>hCalendar</listitem>
<listitem>hReview</listitem>
<listitem>relLicense</listitem>
<listitem>XBRL</listitem>
<listitem>HR-XML</listitem>
<listitem>DC</listitem>
<listitem>geoURL</listitem>
<listitem>Ning</listitem>
<listitem>XFN</listitem>
<listitem>xFolk</listitem>
</itemizedlist>
<para><emphasis>URN handlers</emphasis></para>
<itemizedlist>
<listitem>LSID
<programlisting><![CDATA[
example: urn:lsid:ubio.org:namebank:12292
]]></programlisting>
</listitem>
<listitem>DOI
<programlisting><![CDATA[
needs: hslookup plugin, relevant html, pdf, xml etc. mappers enabled
example: doi:10.1038/35057062
]]></programlisting>
</listitem>
<listitem>OAI
<programlisting><![CDATA[
example: oai:dcmi.ischool.washington.edu:article/8
]]></programlisting>
</listitem>
</itemizedlist>
</sect3>
</sect2>
<sect2 id="virtuosospongerrdfmappers"><title>Extending SPARQL IRI Dereferencing with RDF Mappers</title>
<para>The Virtuoso SPARQL engine (called for brevity just SPARQL bellow) supports IRI Dereferencing,
however it understands only RDF data, that is it can retrieve only files containing RDF/XML, turtle
or N3 serialized RDF data, if format is unknown it will try mapping with built-in WebDAV metadata
extractor. In order to extend this feature with dereferencing web or file resources which naturally
don't have RDF data (like PDF, JPEG files for example) is provided a special mechanism in SPARQL
engine. This mechanism is called RDF mappers for translation of non-RDF data files to RDF.</para>
<para>In order to instruct the SPARQL to call a RDF mapper it needs to be registered and it will
be called for a given URL or MIME type pattern. In other words, when unknown for SPARQL format is
received during URL dereferencing process, it will look into a special registry (a table) to match
either the MIME type or IRI using a regular expression, if match is found the mapper function will
be called.</para>
<sect3 id="virtuosospongerrdfmappersregistry"><title>Regsitry</title>
<para>The table DB.DBA.SYS_RDF_MAPPERS is used as registry for registering RDF mappers.</para>
<programlisting><![CDATA[
create table DB.DBA.SYS_RDF_MAPPERS (
    RM_ID integer identity,         -- mapper ID, designate order of execution
    RM_PATTERN varchar,             -- a REGEX pattern to match URL or MIME type
    RM_TYPE varchar default 'MIME', -- what property of the current resource to match: MIME or URL are supported at present
    RM_HOOK varchar,                -- fully qualified PL function name e.q. DB.DBA.MY_MAPPER_FUNCTION
    RM_KEY  long varchar,           -- API specific key to use
    RM_DESCRIPTION long varchar,    -- Mapper description, free text
    RM_ENABLED integer default 1,   -- a flag 0 or 1 integer to include or exclude the given mapper from processing chain
    primary key (RM_TYPE, RM_PATTERN))
;
]]></programlisting>
<para>The current way to register/update/unregister a mapper is just a DML statement e.g.
NSERT/UPDATE/DELETE.</para>
</sect3>
<sect3 id="virtuosospongerrdfmappersexec"><title>Execution order and processing</title>
<para>When SPARQL retrieves a resource with unknown content it will look in the mappers registry
and will loop over every record having RM_ENABLED flag true. The sequence of look-up is based on
ordering by RM_ID column. For every record it will either try matching the MIME type or URL against
RM_PATTERN value and if there is match the function specified in RM_HOOK column will be called.
If the function doesn't exists or signal an error the SPARQL will look at next record.</para>
<para>When it stops looking? It will stop if value returned by mapper function is positive or
negative number, if the return is negative processing stops with meaning no RDF was supplied,
if return is positive the meaning is that RDF data was extracted, if zero integer is returned
then SPARQL will look for next mapper. The mapper function also can return zero if it is expected
next mapper in the chain to get more RDF data.</para>
<para>If none of the mappers matches the signature (MIME type nor URL) the built-in WebDAV
metadata extractor will be called.</para>
</sect3>
<sect3 id="virtuosospongerrdfmappersextfunc"><title>Extension function</title>
<para>The mapper function is a PL stored procedure with following signature:</para>
<programlisting><![CDATA[
THE_MAPPER_FUNCTION_NAME (
        in graph_iri varchar,
        in origin_uri varchar,
        in destination_uri varchar,
        inout content varchar,
        inout async_notification_queue any,
        inout ping_service any,
        inout keys any
        )
{
   -- do processing here
   -- return -1, 0 or 1 (as explained above in Execution order and processing section)
}
;
]]></programlisting>
<para><emphasis>Parameters</emphasis></para>
<itemizedlist>
<listitem>graph_iri - the target graph IRI</listitem>
<listitem>origin_uri - the current URI of processing</listitem>
<listitem>destination_uri - get:destination value</listitem>
<listitem>content - the resource content</listitem>
<listitem>async_notification_queue - if INI parameter PingService is specified in SPARQL
section in the INI file, this is a pre-allocated asynchronous queue to be used to call
ping service</listitem>
<listitem>ping_service - the URL of the ping service configured in SPARQL section in the
INI in PingService parameter</listitem>
<listitem>keys - a string value contained in the RM_KEY column for given mapper, can be
single string or serialized array, generally can be used as mapper specific data.</listitem>
</itemizedlist>
<para><emphasis>Return value</emphasis></para>
<itemizedlist>
<listitem>0 - no data was retrieved or some next matching mapper must extract more data</listitem>
<listitem>1 - data is retrieved, stop looking for other mappers</listitem>
<listitem>-1 - no data is retrieved, stop looking for more data</listitem>
</itemizedlist>
</sect3>
<sect3 id="virtuosospongerrdfmapperspackage"><title>RDF Mappers package content</title>
<para>The Virtuoso supply as a rdf_mappers_dav VAD package a cartridge for extracting RDF data
from certain popular Web resources and file types. It can be installed (if not already) using
VAD_INSTALL function, see the VAD chapter in documentation on how to do that.</para>
<para><emphasis>HTTP-in-RDF</emphasis></para>
<para>Maps the HTTP request response to HTTP Vocabulary in RDF, see http://www.w3.org/2006/http#.</para>
<para>This mapper is disabled by default. If it's enabled , it must be first in order of execution.</para>
<para>Also it always will return 0, which means any other mapper should push more data.</para>
<para><emphasis>HTML</emphasis></para>
<para>This mapper is composite, it looking for metadata which can specified in a HTML pages as
follows:</para>
<itemizedlist>
<listitem>Embedded/linked RDF
  <itemizedlist>
    <listitem>scan for meta in RDF
<programlisting><![CDATA[
<link rel="meta" type="application/rdf+xml"
]]></programlisting></listitem>
    <listitem>RDF embedded in xHTML (as markup or inside XML comments)</listitem>
  </itemizedlist>
</listitem>
<listitem>Micro-formats
      <itemizedlist>
    <listitem>GRDDL - GRDDL Data Views: RDF expressed in XHTML and XML: http://www.w3.org/2003/g/data-view#</listitem>
    <listitem>eRDF - http://purl.org/NET/erdf/profile</listitem>
    <listitem>RDFa</listitem>
    <listitem>hCard - http://www.w3.org/2006/03/hcard</listitem>
    <listitem>hCalendar - http://dannyayers.com/microformats/hcalendar-profile</listitem>
    <listitem>hReview - http://dannyayers.com/micromodels/profiles/hreview</listitem>
    <listitem>relLicense - CC license: http://web.resource.org/cc/schema.rdf</listitem>
    <listitem>Dublin Core (DCMI) - http://purl.org/dc/elements/1.1/</listitem>
    <listitem>geoURL - http://www.w3.org/2003/01/geo/wgs84_pos#</listitem>
    <listitem>Google Base - OpenLink Virtuoso specific mapping</listitem>
    <listitem>Ning Metadata </listitem>
      </itemizedlist>
</listitem>
<listitem>Feeds extraction
      <itemizedlist>
    <listitem>RSS/RDF - SIOC &amp; AtomOWL</listitem>
    <listitem>RSS 1.0 - RSS/RDF, SIOC &amp; AtomOWL</listitem>
    <listitem>Atom 1.0 - RSS/RDF, SIOC &amp; AtomOWL</listitem>
      </itemizedlist>
</listitem>
<listitem>xHTML metadata transformation using FOAF (foaf:Document) and Dublin Core
properties (dc:title, dc:subject etc.)</listitem>
</itemizedlist>
<para>The HTML page mapper will look for RDF data in order as listed above, it will try to extract
metadata on each step and will return positive flag if any of the above step give a RDF data. In
case where page URL matches some of other RDF mappers listed in registry it will return 0 so
next mapper to extract more data. In order to function properly, this mapper must be executed
before any other specific mappers.</para>
<para><emphasis>Flickr URLs</emphasis></para>
<para>This mapper extracts metadata of the Flickr images, using Flickr REST API. To function
properly it must have configured key. The Flickr mapper extracts metadata using: CC license,
Dublin Core, Dublin Core Metadata Terms, GeoURL, FOAF, EXIF: http://www.w3.org/2003/12/exif/ns/ ontology.
</para>
<para><emphasis>Amazon URLs</emphasis></para>
<para>This mapper extracts metadata for Amazon articles, using Amazon REST API. It needs a Amazon
API key in order to be functional.</para>
<para><emphasis>eBay URLs</emphasis></para>
<para>Implements eBay REST API for extracting metadata of eBay articles, it needs a key and user
name to be configured in order to work.</para>
<para><emphasis>Open Office (OO) documents</emphasis></para>
<para>The OO documents contains metadata which can be extracted using UNZIP, so this extractor
needs Virtuoso unzip plugin to be configured on the server.</para>
<para><emphasis>Yahoo traffic data URLs</emphasis></para>
<para>Implements transformation of the result of Yahoo traffic data to RDF.
</para>
<para><emphasis>iCal files</emphasis></para>
<para>Transform iCal files to RDF as per http://www.w3.org/2002/12/cal/ical# .</para>
<para><emphasis>Binary content, PDF, PowerPoint</emphasis></para>
<para>The unknown binary content, PDF and MS PowerPoint files can be transformed to RDF using
Aperture framework (http://aperture.sourceforge.net/). This mapper needs Virtuoso with Java hosting
support, Aperture framework and MetaExtractor.class installed on the host system in order to work.</para>
<para>The Aperture framework &amp; MetaExtractor.class must be installed on the system before to
install the RDF mappers package. If the package is already installed, then to activate this mapper
you can just re-install the VAD.</para>
<para><emphasis>Setting-up Virtuoso with Java hosting to run Aperture framework</emphasis></para>
<itemizedlist>
<listitem>Install Virtuoso with Java hosting</listitem>
<listitem>Download the Aperture framework from http://aperture.sourceforge.net</listitem>
<listitem>unpack in the Virtuoso working directory e.q. where database file is, make a symbolic link 'lib' to it</listitem>
<listitem>configure in the INI Parametres section:
<programlisting><![CDATA[
JavaClasspath = lib/sesame-2.0-alpha-3.jar:lib/openrdf-util-crazy-debug.jar:lib/htmlparser-1.6.jar:lib/activation-1.0.2-upd2.jar:lib/bcmail-jdk14-132.jar:lib/poi-scratchpad-3.0-alpha2-20060616.jar:lib/openrdf-model-2.0-alpha-3.jar:lib/jacob-1.10-pre4.jar:lib/bcprov-jdk14-132.jar:lib/demork-2.0.jar:lib/commons-codec.jar:lib/fontbox-0.1.0-dev.jar:lib/pdfbox-0.7.3.jar:lib/applewrapper-0.1.jar:lib/junit-3.8.1.jar:lib/winlaf-0.5.1.jar:lib/aperture-test-2006.1-alpha-3.jar:lib/openrdf-util-fixed-locking.jar:lib/commons-logging-1.1.jar:lib/mail-1.4.jar:lib/aperture-2006.1-alpha-3.jar:lib/poi-3.0-alpha2-20060616.jar:lib/ical4j-cvs20061019.jar:lib/openrdf-util-2.0-alpha-3.jar:lib/rio-2.0-alpha-3.jar:lib/poi-contrib-3.0-alpha2-20060616.jar:lib/aperture-examples-2006.1-alpha-3.jar:.
]]></programlisting>
</listitem>
<listitem>Make sure MetaExtractor.class is in the Virtuoso working directory</listitem>
<listitem>Start the Virtuoso server with java hosting support</listitem>
<listitem>connect with ISQL tool and check if installation is complete:
<programlisting><![CDATA[
SQL> DB.DBA.import_jar (NULL, 'MetaExtractor', 1);

Done. -- 466 msec.
SQL> select "MetaExtractor"().getMetaFromFile ('some_pdf_in_server_working_dir.pdf', 5);
... some RDF must be returned ...
]]></programlisting>
</listitem>
</itemizedlist>
<para>Important: the above is verified to work with aperture-2006.1-alpha-3 on Linux system.
For different version of Aperture of operation system this may need some adjustments e.g. to
re-build MetaExtractor.class &amp; changes to CLASSPATH etc.</para>
<para><emphasis>Examples &amp; tutorials</emphasis></para>
<para>How to write own RDF mapper? Look at Virtuoso tutorial on this subject
http://demo.openlinksw.com/tutorial/rdf/rd_s_1/rd_s_1.vsp .
</para>
</sect3>
<sect3 id="virtuosospongerproxy"><title>Sponger Proxy service</title>
<para>Sponger functionality is also exposed via Virtuoso's "/proxy/rdf/" endpoint, as an in-built
REST style Web service available in any Virtuoso standard installation. This web service takes
a target URL and either returns the content "as is" or tries to transform (by sponging) to RDF.
Thus, the proxy service can be used as a 'pipe' for RDF browsers to browse non-RDF sources.
</para>
<para>For more information see <link linkend="rdfproxyservice">RDF Sponger Proxy service</link></para>
</sect3>
<sect3 id="virtuosospongercache"><title>Sponger Cache Clearing</title>
<para>To clear cache on all values of HS_LOCAL_IRI of the SYS_HTTP_SPONGE table use:
<programlisting><![CDATA[
sparql clear graph <A-Named-Graph>;
]]></programlisting>
</para>
</sect3>

</sect2>
  <sect2 id="virtuosospongerprguide">
    <title>Sponger Cartridge Programmer's Guide</title>
    <para>The Sponger forms part of the extensible RDF framework built into Virtuoso Universal Server. A
key component of the Sponger's pluggable architecture is its support for Sponger Cartridges, which
themselves are comprised of an Entity Extractor and an Ontology Mapper. Virtuoso bundles numerous
pre-written cartridges for RDF data extraction from a wide range of data sources. However, developers
are free to develop their own custom cartridges. This programmer's guide describes how.</para>
    <para>The guide is a companion to the <ulink url="http://virtuoso.openlinksw.com/Whitepapers/pdf/sponger_whitepaper_10102007.pdf">Virtuoso Sponger</ulink> whitepaper. The latter describes the Sponger in depth, its architecture, configuration, use and integration with other Virtuoso facilities such as the Open Data Services (ODS) application framework. This guide focuses solely on custom cartridge development.</para>
    <sect3 id="virtuosospongeroverview">
      <para>The "Sponger" is an example of a new class of tools for converting non-RDF data into RDF.
Such tools are known as RDFizers. Introduced in Virtuoso Universal Server 5.0, the Sponger is packaged
in an easily extensible framework, with tight integration to the Virtuoso RDF Quad Store.</para>
    <para>The Sponger provides built-in RDF middleware for transforming non-RDF data into RDF "on the fly".
Its goal is to use non-RDF Web data sources as input, e.g. (X)HTML Web Pages, (X)HTML Web pages hosting
microformats, and even Web services such as those from Google, Del.icio.us, Flickr etc., and create RDF
as output. The implication of this facility is that you can use non-RDF data sources as Semantic Web data
sources.</para>
    <para><emphasis>How is it used?</emphasis></para>
    <para>The Sponger can be invoked via the following mechanisms:</para>
    <orderedlist>
      <listitem>Virtuoso SPARQL query processor</listitem>
      <listitem>OpenLink RDF client applications via the Virtuoso RDF Proxy Service</listitem>
      <listitem>From Virtuoso PL, by calling the cartridge hook function directly</listitem>
      <listitem>ODS-Briefcase (Virtuoso WebDAV) - a component of the OpenLink Data Spaces distributed collaborative application platform</listitem>
    </orderedlist>
    <para>File metadata extraction by ODS-Briefcase details you can find at the <ulink url="http://virtuoso.openlinksw.com/Whitepapers/pdf/sponger_whitepaper_10102007.pdf">Virtuoso Sponger whitepaper</ulink>.</para>
    <para><emphasis>SPARQL Query Processor IRI Dereferencing</emphasis></para>
    <para>The Sponger is transparently integrated into the Virtuoso SPARQL query processor, where it supports
IRI dereferencing.</para>
    <para>Given the distributed nature of RDF data, it is quite possible when executing a SPARQL query that
some of the referenced data resides outside the local quad store. To cope with this scenario, the Virtuoso
SPARQL query processor can be instructed to retrieve the external data and cache it in local quad storage.
This feature is exposed through a set of Virtuoso SPARQL extensions known as "IRI dereferencing".
Essentially these enable downloading and local storage of selected triples either from one or more
named graphs or based on a proximity search from a starting URI for entities matching the select
criteria and also related by the specified predicates, up to a given depth. Because the SPARQL
processor understands only RDF data (serialized as RDF/XML, Turtle, N3), it utilizes the Sponger
RDF mapper functionality when dereferencing web or file resources which don't naturally contain RDF data.</para>
    <para><emphasis>RDF Proxy Service</emphasis></para>
    <para>The Sponger's functionality is also exposed via an in-built REST style Web service. This web
service takes a target URL and either returns the content "as is" or tries to transform (by sponging)
to RDF. Thus, the proxy service can be used as a 'pipe' for RDF browsers to browse non-RDF sources.</para>
    <para>When the rdf_mappers package is installed, Virtuoso reserves the path '/about/[rdf|html]/' for
RDF proxy service. For example, if a Virtuoso installation on host example.com listens for HTTP
requests on port 8080 then client applications should use a 'service endpoint' string equal to
'http://example.com:8080/about/[rdf|html]/'. If the rdf_mappers package is not installed, then
the service uses the path '/proxy/rdf/'.</para>
    <para>Note: The old RDF proxy service pattern '/proxy/' is now deprecated.</para>
    <para><emphasis>Example:</emphasis></para>
    <para>The following URLs return information about musician John Cale, gleaned from the MusicBrainz
music metadatabase, rendered as RDF or HTML respectively. (The sponged data is available in the HTML
rendering through the foaf:primaryTopic property.)</para>
    <itemizedlist mark="bullet">
      <listitem>http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/artist/72c090b6-a68e-4cb9-b330-85278681a714.html</listitem>
      <listitem>http://demo.openlinksw.com/about/html/http://musicbrainz.org/artist/72c090b6-a68e-4cb9-b330-85278681a714.html</listitem>
    </itemizedlist>
    <sect4 id="virtuosospongeroverviewxmlset">
      <title>Configuration of CURIEs used by the sponger</title>
      <para>For configuring CURIEs used by the Sponger which is exposed via sponger
clients such as "description.vsp" - the VSP based information resource description utility,
you can use the <link linkend="fn_xml_set_ns_decl"><function>xml_set_ns_decl</function></link> function.</para>
      <para>Here is sample example to add curie pattern:</para>
<programlisting><![CDATA[
-- Example link: http://linkeddata.uriburner.com/about/rdf/http://twitter.com/guykawasaki/status/1144945513#this
XML_SET_NS_DECL ('uriburner',
                 'http://linkeddata.uriburner.com/about/rdf/http://',
                 2);
]]></programlisting>
    </sect4>
    <sect4 id="virtuosospongeroverviewcartarch">
      <title>Cartridge Architecture</title>
      <para>The Sponger is comprised of cartridges which are themselves comprised of an entity extractor
and an ontology mapper. Entities extracted from non-RDF resources are used as the basis for generating
structured data by mapping them to a suitable ontology. A cartridge is invoked through its cartridge hook,
a Virtuoso/PL procedure entry point and binding to the cartridge's entity extractor and ontology mapper.</para>
      <para><emphasis>Entity Extractor</emphasis></para>
      <para>When an RDF aware client requests data from a network accessible resource via the Sponger the
following events occur:</para>
      <itemizedlist mark="bullet">
        <listitem>A request is made for data in RDF form (explicitly via HTTP Accept Headers), and if
RDF is returned nothing further happens. </listitem>
        <listitem>If RDF isn't returned, the Sponger passes the data through a <emphasis>Entity Extraction Pipeline</emphasis>
(using Entity Extractors). </listitem>
        <listitem>The extracted data is transformed into RDF via a <emphasis>Mapping Pipeline</emphasis>. RDF instance data is generated by way of ontology matching and mapping. </listitem>
        <listitem>RDF instance data (aka. RDF Structured Linked Data) are returned to the client.</listitem>
      </itemizedlist>
      <para><emphasis>Extraction Pipeline</emphasis></para>
      <para>Depending on the file or format type detected at ingest, the Sponger applies the appropriate
entity extractor. Detection occurs at the time of content negotiation instigated by the retrieval user
agent. The normal extraction pipeline processing is as follows:</para>
      <itemizedlist mark="bullet">
        <listitem>The Sponger tries to get RDF data (including N3 or Turtle) directly from the dereferenced
URL. If it finds some, it returns it, otherwise, it continues.</listitem>
        <listitem>If the URL refers to a HTML file, the Sponger tries to find "link" elements referring to
RDF documents. If it finds one or more of them, it adds their triples into a temporary RDF graph and
continues its processing.</listitem>
        <listitem>The Sponger then scans for microformats or GRDDL. If either is found, RDF triples are
generated and added to a temporary RDF graph before continuing.</listitem>
        <listitem>If the Sponger finds eRDF or RDFa data in the HTML file, it extracts it from the HTML
file and inserts it into the RDF graph before continuing.</listitem>
        <listitem>If the Sponger finds it is talking with a web service such as Google Base, it maps
the API of the web service with an ontology, creates triples from that mapping and includes the triples
into the temporary RDF graph.</listitem>
        <listitem>The next fallback is scanning of the HTML header for different Web 2.0 types or RSS
1.1, RSS 2.0, Atom, etc. </listitem>
        <listitem>Failing those tests, the scan then uses standard Web 1.0 rules to search in the
header tags for metadata (typically Dublin Core) and transform them to RDF and again add them to the
temporary graph. Other HTTP response header data may also be transformed to RDF.</listitem>
        <listitem>If nothing has been retrieved at this point, the ODS-Briefcase metadata
extractor is tried.</listitem>
        <listitem>Finally, if nothing is found, the Sponger will return an empty graph.</listitem>
      </itemizedlist>
      <para><emphasis>Ontology Mapper</emphasis></para>
      <para>Sponger ontology mappers peform the the task of generating RDF instance data from
extracted entities (non-RDF) using ontologies associated with a given data source type. They are
typically XSLT (using GRDDL or an in-built Virtuoso mapping scheme) or Virtuoso/PL based. Virtuoso
comes preconfigured with a large range of ontology mappers contained in one or more Sponger
cartridges.</para>
      <para><emphasis>Cartridge Registry</emphasis></para>
      <para>To be recognized by the SPARQL engine, a Sponger cartridge must be registered in
the Cartridge Registry by adding a record to the table DB.DBA.SYS_RDF_MAPPERS, either manually
via DML, or more easily through Conductor, Virtuoso's browser-based administration console,
which provides a UI for adding your own cartridges. (Sponger configuration using Conductor is
described in detail later.) The SYS_RDF_MAPPERS table definition is as follows:</para>
<programlisting><![CDATA[
create table "DB"."DBA"."SYS_RDF_MAPPERS"
(
"RM_ID" INTEGER IDENTITY,  -- cartridge ID. Determines the order of the cartridge's invocation in the Sponger processing chain
"RM_PATTERN" VARCHAR,  -- a REGEX pattern to match the resource URL or MIME type
"RM_TYPE" VARCHAR,  -- which property of the current resource to match: "MIME" or "URL"
"RM_HOOK" VARCHAR,  -- fully qualified Virtuoso/PL function name
"RM_KEY" LONG VARCHAR,  -- API specific key to use
"RM_DESCRIPTION" LONG VARCHAR,  -- cartridge description (free text)
"RM_ENABLED" INTEGER,  -- a 0 or 1 integer flag to exclude or include the cartridge from the Sponger processing chain
"RM_OPTIONS" ANY,  -- cartridge specific options
"RM_PID" INTEGER IDENTITY,
PRIMARY KEY ("RM_PATTERN", "RM_TYPE")
);
]]></programlisting>
    </sect4>
    <sect4 id="virtuosospongeroverviewcartinvo">
      <title>Cartridge Invocation</title>
      <para>The Virtuoso SPARQL processor supports IRI dereferencing via the Sponger. If a SPARQL query
references non-default graph URIs, the Sponger goes out (via HTTP) to sponge the data source URIs and
inserts the extracted RDF data into the local RDF quad store. The Sponger invokes the appropriate
cartridge for the data source type to produce RDF instance data. If none of the registered cartridges
are capable of handling the received content type, the Sponger will attempt to obtain RDF instance
data via the in-built WebDAV metadata extractor.</para>
      <para>Sponger cartridges are invoked as follows:</para>
      <para>When the SPARQL processor dereferences a URI, it plays the role of an HTTP user agent
(client) that makes a content type specific request to an HTTP server via the HTTP request's Accept
headers. The following then occurs:</para>
      <itemizedlist mark="bullet">
        <listitem>If the content type returned is RDF then no further transformation is needed and
the process stops. For instance, when consuming an (X)HTML document with a GRDDL profile, the profile
URI points to a data provider that simply returns RDF instance data.</listitem>
        <listitem>If the content type is not RDF (i.e. application/rdf+xml or text/rdf+n3 ), for
instance 'text/plain', the Sponger looks in the Cartridge Registry iterating over every record for
which the RM_ENABLED flag is true, with the look-up sequence ordered on the RM_ID column values.
For each record, the processor tries matching the content type or URL against the RM_PATTERN value
and, if there is match, the function specified in RM_HOOK column is called. If the function doesn't
exist, or signals an error, the SPARQL processor looks at next record.
          <itemizedlist mark="bullet">
            <listitem>If the hook returns zero, the next cartridge is tried. (A cartridge function
can return zero if it believes a subsequent cartridge in the chain is capable of extracting more
RDF data.)</listitem>
            <listitem>If the result returned by the hook is negative, the Sponger is instructed
that no RDF was generated and the process stops. </listitem>
            <listitem>If the hook result is positive, the Sponger is informed that structured
data was retrieved and the process stops.</listitem>
          </itemizedlist>
        </listitem>
        <listitem>If none of the cartridges match the source data signature (content type or URL),
the ODS-Briefcase WebDAV metadata extractor and RDF generator is called.</listitem>
      </itemizedlist>
      <para><emphasis>Meta-Cartridges</emphasis></para>
      <para>The above describes the RDF generation process for 'primary' Sponger cartridges. Virtuoso
also supports another cartridge type - a 'meta-cartridge'. Meta-cartridges act as post-processors in
the cartridge pipeline, augmenting entity descriptions in an RDF graph with additional information
gleaned from 'lookup' data sources and web services. Meta-cartridges are described in more detail in
a later section.</para>
      <figure id="spong1" float="1">
        <title>Meta-Cartridges</title>
        <graphic fileref="ui/spong1.png"/>
      </figure>
    </sect4>
    </sect3>
    <sect3 id="virtuosospongercatrbundled">
      <title>Cartridges Bundled with Virtuoso</title>
      <sect4 id="virtuosospongercatrbundledrdfvad">
        <title>RDF Mappers VAD</title>
        <para>Virtuoso supplies a number of prewritten cartridges for extracting RDF data from a
variety of popular Web resources and file types. The cartridges are bundled as part of the rdf_mappers
VAD (Virtuoso Application Distribution). Appendix B of the Virtuoso Sponger whitepaper briefly
outlines the cartridges contained in the VAD.</para>
        <para>To see which cartridges are available, look at the 'RDF Cartridges' screen in
Conductor. This can be reached through the 'RDF' > 'RDF Cartridges' tabbed menu items.</para>
        <figure id="spong2" float="1">
          <title>RDF Cartridges</title>
          <graphic fileref="ui/spong2.png"/>
        </figure>
        <para>To check which version of the rdf_mappers VAD is installed, or to upgrade it,
refer to Conductor's 'VAD Packages' screen, reachable through the 'System Admin' > 'Packages'
menu items.</para>
        <para>The latest VADs for the closed source releases of Virtuoso can be
<ulink url="http://download.openlinksw.com/download/">downloaded</ulink> from the downloads area on the OpenLink website. Select either the 'DBMS (WebDAV) Hosted' or
'File System Hosted' product format from the 'Distributed Collaborative Applications' section,
depending on whether you want the Virtuoso application to use WebDAV or native filesystem storage.
VADs for Virtuoso Open Source edition (VOS) are available for
<ulink url="http://virtuoso.openlinksw.com/dataspace/dav/wiki/Main/VOSDownload">download</ulink> from
the VOS Wiki.</para>
      </sect4>
      <sect4 id="virtuosospongercatrbundledexample">
        <title>Example Source Code</title>
        <para>For developers wanting example cartridge code, the most authoritative reference is
the rdf_mappers VAD source code itself. This is included as part of the VOS distribution. After
downloading and unpacking the sources, the script used to create the cartridges, and the associated
stylesheets can be found in:</para>
        <itemizedlist mark="bullet">
          <listitem>&lt;vos root>/binsrc/rdf_mappers/rdf_mappers.sql</listitem>
          <listitem>&lt;vos root>/binsrc/rdf_mappers/xslt/*.xsl</listitem>
        </itemizedlist>
        <para>Alternatively, you can look at the actual cartridge implementations installed in your
Virtuoso instance by inspecting the cartridge hook function used by a particular cartridge. This is
easily identified from the 'Cartridge name' field of Conductor's 'RDF Cartridges' screen, after
selecting the cartridge of interest. The hook function code can be viewed from the 'Schema Objects'
screen under the 'Database' menu, by locating the function in the 'DB' > 'Procedures' folder.
Stylesheets used by the cartridges are installed in the WebDAV folder DAV/VAD/rdf_mappers/xslt.
This can be explored using Conductor's WebDAV interface. The actual rdf_mappers.sql file installed
with your system can also be found in the DAV/VAD/rdf_mappers folder.</para>
      </sect4>
    </sect3>
    <sect3 id="virtuosospongercatrbundledcusgtomcart">
      <title>Custom Cartridge</title>
      <para>Virtuoso comes well supplied with a variety of Sponger cartridges and GRDDL filters.
When then is it necessary to write your own cartridge?</para>
      <para>In the main, writing a new cartridge should only be necessary to generate RDF from
a REST-style Web service not supported by an existing cartridge, or to customize the output from
an existing cartridge to your own requirements. Apart from these circumstances, the existing
Sponger infrastructure should meet most of your needs. This is particularly the case for
document resources.</para>
     <sect4 id="virtuosospongerdocres">
       <title>Document Resources</title>
       <para>We use the term document resource to identify content which is not being returned
from a Web service. Normally it can broadly be conceived as some form of document, be it a text
based entity or some form of file, for instance an image file.</para>
       <para>In these cases, the document either contains RDF, which can be extracted directly,
or it holds metadata in a supported format which can be transformed to RDF using an existing
filter.</para>
       <para>The following cases should all be covered by the existing Sponger cartridges:</para>
         <itemizedlist mark="bullet">
           <listitem>embedded or linked RDF</listitem>
           <listitem>RDFa, eRDF and other popular microformats extractable directly or via GRDDL</listitem>
           <listitem>popular syndication formats (RSS 2.0 , Atom, OPML , OCS , XBEL)</listitem>
         </itemizedlist>
     </sect4>
     <sect4 id="virtuosospongergrddl">
       <title>GRDDL</title>
       <para>GRDDL (Gleaning Resource Descriptions from Dialects of Languages) is mechanism for deriving
RDF data from XML documents and in particular XHTML pages. Document authors may associate transformation
algorithms, typically expressed in XSLT, with their documents to transform embedded metadata into RDF.</para>
       <para>The rdf_mappers VAD installs a number of GRDDL filters for transforming popular microformats
(such as RDFa, eRDF or hCalendar) into RDF. The available filters can be viewed, or configured, in
Conductor's 'GRDDL Filters for XHTML' screen. Navigate to the 'RDF Cartridges' screen using the
'RDF' > 'RDF Cartridges' menu items, then select the 'GRDDL Mappings' tab to display the 'GRDDL Filters
for XHTML' screen. GRDDL filters are held in the WebDAV folder /DAV/VAD/rdf_cartridges/xslt/ alongside
other XSLT templates. The Conductor interface allows you to add new GRDDL filters should you so wish.</para>
       <para>For an introduction to GRDDL, try the <ulink url="http://www.w3.org/TR/grddl-primer/">GRDDL Primer</ulink>. To underline GRDDL's utility, the primer
includes an example of transforming Excel spreadsheet data, saved as XML, into RDF.</para>
       <para>A comprehensive <ulink url="http://esw.w3.org/topic/CustomRdfDialects">list of stylesheets</ulink>
for transforming HTML and non-HTML XML dialects is maintained
on the ESW Wiki. The list covers a range of microformats, syndication formats and feedlists.</para>
     </sect4>
     <sect4 id="virtuosospongerwebservices">
       <para>To see which Web Services are already catered for, view the list of cartridges in Conductor's 'RDF Cartridges' screen.</para>
     </sect4>
    </sect3>
    <sect3 id="virtuosospongercreatecustcartr">
      <title>Creating Custom Cartridges</title>
      <para>The Sponger is fully extensible by virtue of its pluggable cartridge architecture. New data formats can
be sponged by creating new cartridges. While OpenLink is active in adding cartridges for new data sources,
you are free to develop your own custom cartridges. Entity extractors can be built using Virtuoso PL,
C/C++, Java or any other external language supported by Virtuoso's Server Extension API. Of course,
Virtuoso's own entity extractors are written in Virtuoso PL.</para>
      <sect4 id="virtuosospongercreatecustcartran">
        <title>The Anatomy of a Cartridge</title>
        <para><emphasis>Cartridge Hook Function</emphasis></para>
        <para>Every Virtuoso PL hook function used to plug a custom Sponger cartridge into the Virtuoso
SPARQL engine must have a parameter list with the following parameters (the names of the parameters are
not important, but their order and presence are):</para>
        <itemizedlist mark="bullet">
          <listitem><emphasis>in graph_iri varchar</emphasis>: the IRI of the graph being retrieved/crawled</listitem>
          <listitem><emphasis>in new_origin_uri varchar</emphasis>: the URL of the document being retrieved</listitem>
          <listitem><emphasis>in dest varchar</emphasis>: the destination/target graph IRI</listitem>
          <listitem><emphasis>inout content any</emphasis>: the content of the retrieved document</listitem>
          <listitem><emphasis>inout async_queue any</emphasis>: if the PingService initialization parameter
has been configured in the [SPARQL] section of the virtuoso.ini file, this is a pre-allocated asynchronous
queue to be used to call the ping service</listitem>
          <listitem><emphasis>inout ping_service any</emphasis>: the URL of a ping service, as assigned
to the PingService parameter in the [SPARQL] section of the virtuoso.ini configuration file.
PingTheSemanticWeb is an example of a such a service. See Appendix A for more details.</listitem>
          <listitem><emphasis>inout api_key any</emphasis>: a string value specific to a given cartridge,
contained in the RC_KEY column of the DB.DBA.SYS_RDF_CARTRIDGES table. The value can be a single
string or a serialized array of strings providing cartridge specific data.</listitem>
          <listitem><emphasis>inout opts any</emphasis>: cartridge specific options held in a Virtuoso/PL
vector which acts as an array of key-value pairs.</listitem>
        </itemizedlist>
        <para><emphasis>Return Value</emphasis></para>
        <para>If the hook procedure returns zero the next cartridge will be tried. If the result is negative
the sponging process stops, instructing the SPARQL engine that nothing was retrieved. If the result is
positive the process stops, this time instructing the SPARQL engine
that RDF data was successfully retrieved.</para>
        <para>If your cartridge should need to test whether other cartridges are configured to handle a
particular data source, the following extract taken from the RDF_LOAD_CALAIS hook procedure illustrates
how you might do this:</para>
<programlisting><![CDATA[
if (xd is not null)
{
  -- Sponging successful. Load sponged data in Virtuoso quad store
  DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
  flag := 1;
}

declare ord any;
ord := (select RM_ID from DB.DBA.SYS_RDF_MAPPERS where
	  RM_HOOK = 'DB.DBA.RDF_LOAD_CALAIS');
for select RM_PATTERN from DB.DBA.SYS_RDF_MAPPERS where
  RM_ID > ord and RM_TYPE = 'URL' and RM_ENABLED = 1 order by RM_ID do
{
  if (regexp_match (RM_PATTERN, new_origin_uri) is not null)
    -- try next candidate cartridge
    flag := 0;
}
return flag;
]]></programlisting>
        <para><emphasis>Specifying the Target Graph</emphasis></para>
        <para>Two cartridge hook function parameters contain graph IRIs, graph_iri and dest. graph_iri
identifies an input graph being crawled. dest holds the IRI specified in any input:grab-destination
pragma defined to control the SPARQL processor's IRI dereferencing. The pragma overrides the default
behaviour and forces all retrieved triples to be stored in a single graph, irrespective of their graph
of origin.</para>
        <para>So, under some circumstances depending on how the Sponger has been invoked and whether
it is being used to crawl an existing RDF graph, or derive RDF data from a non-RDF data source,
dest may be null.</para>
        <para>Consequently, when loading sponged RDF data into the quad store, cartridges typically
specify the graph to receive the data using the coalesce function which returns the first non-null
parameter. e.g.</para>
<programlisting><![CDATA[
DB.DBA.RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
]]></programlisting>
        <para>Here xd is an RDF/XML string holding the sponged RDF.</para>
        <para><emphasis>Specifying &amp; Retrieving Cartridge Specific Options</emphasis></para>
        <para>The hook function prototype allows cartridge specific data to be passed to a cartridge
through the RM_OPTIONS parameter, a Virtuoso/PL vector which acts as a heterogeneous array.</para>
        <para>In the following example, two options are passed, 'add-html-meta' and 'get-feeds'
with both values set to 'no'.</para>
<programlisting><![CDATA[
insert soft DB.DBA.SYS_RDF_MAPPERS (
  RM_PATTERN, RM_TYPE, RM_HOOK, RM_KEY, RM_DESCRIPTION, RM_OPTIONS
)
values (
  '(text/html)|(text/xml)|(application/xml)|(application/rdf.xml)',
  'MIME', 'DB.DBA.RDF_LOAD_HTML_RESPONSE', null, 'xHTML',
  vector ('add-html-meta', 'no', 'get-feeds', 'no')
);
]]></programlisting>
        <para>The RM_OPTIONS vector can be handled as an array of key-value pairs using the
get_keyword function. get_keyword performs a case sensitive search for the given keyword at
every even index of the given array. It returns the element following the keyword, i.e.
the keyword value.</para>
        <para>Using get_keyword, any options passed to the cartridge can be retrieved
using an approach similar to that below:</para>
<programlisting><![CDATA[
create procedure DB.DBA.RDF_LOAD_HTML_RESPONSE (
  in graph_iri varchar, in new_origin_uri varchar, in dest varchar,
  inout ret_body any, inout aq any, inout ps any, inout _key any,
  inout opts any )
{
  declare get_feeds, add_html_meta;
  ...
  get_feeds := add_html_meta := 0;
  if (isarray (opts) and 0 = mod (length(opts), 2))
  {
    if (get_keyword ('get-feeds', opts) = 'yes')
      get_feeds := 1;
    if (get_keyword ('add-html-meta', opts) = 'yes')
      add_html_meta := 1;
  }
  ...
]]></programlisting>
         <para><emphasis>API Keys</emphasis></para>
         <para>Certain web services require applications to provide an API
key to use the service. Flickr is one such service. Developers must register
to obtain a key. See for instance http://developer.yahoo.com/flickr/. In order
to cater for services which require an application key, the Cartridge Registry
SYS_RDF_MAPPERS table includes an RM_KEY column to store any key required for a
particular service. This value is passed to the service's cartridge through the
_key parameter of the cartridge hook function.</para>
         <para>Alternatively a cartridge can store a key value in the virtuoso.ini
configuration file and retrieve it in the hook function.</para>
         <para>The next example shows an extract from the Flickr cartridge hook function
DB.DBA.RDF_LOAD_FLICKR_IMG and the use of an API key. Also, commented out, is a call to
cfg_item_value() which illustrates how the API key could instead be stored and retrieved
from the SPARQL section of the virtuoso.ini file.
         </para>
<programlisting><![CDATA[
create procedure DB.DBA.RDF_LOAD_FLICKR_IMG (
in graph_iri varchar, in new_origin_uri varchar, in dest varchar,
inout _ret_body any, inout aq any, inout ps any, inout _key any,
inout opts any )
{
declare xd, xt, url, tmp, api_key, img_id, hdr, exif any;
declare exit handler for sqlstate '*'
{
 return 0;
};
tmp := sprintf_inverse (new_origin_uri,
  'http://farm%s.static.flickr.com/%s/%s_%s.%s', 0);
img_id := tmp[2];
api_key := _key;
--cfg_item_value (virtuoso_ini_path (), 'SPARQL', 'FlickrAPIkey');
if (tmp is null or length (tmp) <> 5 or not isstring (api_key))
  return 0;
url :=  sprintf('http://api.flickr.com/services/rest/?method=flickr.photos.getInfo&photo_id=%s&api_key=%s',img_id, api_key);
tmp := http_get (url, hdr);
]]></programlisting>
        <para><emphasis>XSLT - The Fulchrum</emphasis></para>
        <para>XSLT is the fulchrum of all OpenLink supplied cartridges. It provides the most convenient
means of converting structured data extracted from web content by a cartridge's Entity Extractor into RDF.</para>
        <para><emphasis>Virtuoso's XML Infrastructure &amp; Tools</emphasis></para>
        <para>Virtuoso's XML support and XSLT support are covered in detail in the on-line documentation.
Virtuoso includes a highly capable XML parser and supports XPath, XQuery, XSLT and XML Schema validation.</para>
        <para>Virtuoso supports extraction of XML documents from SQL datasets. A SQL long varchar, long xml or
xmltype column in a database table can contain XML data as text or in a binary serialized format.
 A string representing a well-formed XML entity can be converted into an entity object representing
the root node.</para>
        <para>While Sponger cartridges will not normally concern themselves with handling XML extracted
from SQL data, the ability to convert a string into an in-memory XML document is used extensively.
The function xtree_doc(string) converts a string into such a document and returns a reference to the
document's root. This document together with an appropriate stylesheet forms the input for
the transformation of the extracted entities to RDF using XSLT. The input string to xtree_doc
generally contains structured content derived from a web service.</para>
        <para><emphasis>Virtuoso XSLT Support</emphasis></para>
        <para>Virtuoso implements XSLT 1.0 transformations as SQL callable functions. The xslt() Virtuoso/PL function
applies a given stylesheet to a given source XML document and returns the transformed document. Virtuoso
provides a way to extend the abilities of the XSLT processor by creating user defined XPath functions.
The functions xpf_extension() and xpf_extension_remove() allow addition and removal of XPath extension
functions.</para>
        <para><emphasis>General Cartridge Pipeline</emphasis></para>
        <para>The broad pipeline outlined here reflects the steps common to most cartridges:</para>
          <itemizedlist mark="bullet">
            <listitem>Redirect from the requested URL to a Web service which returns XML</listitem>
            <listitem>Stream the content into an in-memory XML document</listitem>
            <listitem>Convert it to the required RDF/XML, expressed in the chosen ontology, using XSLT</listitem>
            <listitem>Encode the RDF/XML as UTF-8</listitem>
            <listitem>Load the RDF/XML into the quad store</listitem>
          </itemizedlist>
        <para>The <ulink url="http://musicbrainz.org/">MusicBrainz</ulink> cartridge typifies this approach. MusicBrainz is a community music
metadatabase which captures information about artists, their recorded works, and the relationships
between them. Artists always have a unique ID, so the URL
http://musicbrainz.org/artist/4d5447d7-c61c-4120-ba1b-d7f471d385b9.html takes you directly to entries
for John Lennon.</para>
        <para>If you were to look at this page in your browser, you would see that the information about
the artist contains no RDF data. However, the cartridge is configured to intercept requests to URLs of
the form http://musicbrainz.org/([^/]*)/([^.]*) and redirect to the cartridge to sponge all the
available information on the given artist, release, track or label.</para>
        <para>The cartridge extracts entities by redirecting to the MusicBrainz XML Web Service using
as the basis for the initial query the item ID, e.g. an artist or label ID, extracted from the original
URL. Stripped to its essentials, the core of the cartridge is:</para>
<programlisting><![CDATA[
webservice_uri := sprintf ('http://musicbrainz.org/ws/1/%s/%s?type=xml&inc=%U',
					kind, id, inc);
content := RDF_HTTP_URL_GET (webservice_uri, '', hdr, 'GET', 'Accept: */*');
xt := xtree_doc (content);
...
xd := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_rdf_mappers_path_') || 'xslt/mbz2rdf.xsl', xt);
...
xd := serialize_to_UTF8_xml (xd);
DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
]]></programlisting>
        <para>In the above outline, RDF_HTTP_URL_GET sends a query to the MusicBrainz web service,
using query parameters appropriate for the original request, and retrieves the response using
HTTP GET.</para>
        <para>The returned XML is parsed into an in-memory parse tree by xtree_doc. Virtuoso/PL
function RDF_MAPPER_XSLT is a simple wrapper around the function xslt which sets the current user
to dba before returning an XML document transformed by an XSLT stylesheet, in this case mbz2rdf.xsl.
Function serialize_to_UTF8_xml changes the character set of the in-memory XML document to UTF8.
Finally, RM_RDF_LOAD_RDFXML is a wrapper around RDF_LOAD_RDFXML which parses the content of an
RDF/XML string into a sequence of RDF triples and loads them into the quad store. XSLT stylesheets
are usually held in the DAV/VAD/rdf_mappers/xslt folder of Virtuoso's WebDAV store.
registry_get('rdf_mappers_path') returns the RDF Mappers VAD path, 'DAV/VAD/rdf_mappers', from the
Virtuoso registry.</para>
        <para><emphasis>Error Handling with Exit Handlers</emphasis></para>
        <para>Virtuoso condition handlers determine the behaviour of a Virtuoso/PL procedure when a
condition occurs. You can declare one or more condition handlers in a Virtuoso/PL procedure for
general SQL conditions or specific SQLSTATE values. If a statement in your procedure raises an
SQLEXCEPTION condition and you declared a handler for the specific SQLSTATE or SQLEXCEPTION
condition the server passes control to that handler. If a statement in your Virtuoso/PL procedure
raises an SQLEXCEPTION condition, and you have not declared a handler for the specific SQLSTATE
or the SQLEXCEPTION condition, the server passes the exception to the calling procedure (if any).
If the procedure call is at the top-level, then the exception is signaled to the calling client.</para>
        <para>A number of different condition handler types can be declared (see the <ulink url="http://docs.openlinksw.com/virtuoso/handlingplcondit.html">Virtuoso reference documentation</ulink>
for more details.) Of these, exit handlers are probably all you will need. An example is shown below
which handles any SQLSTATE. Commented out is a debug statement which outputs the message describing
the SQLSTATE.</para>
<programlisting><![CDATA[
create procedure DB.DBA.RDF_LOAD_SOCIALGRAPH (in graph_iri varchar, ...)
{
  declare qr, path, hdr any;
  ...
  declare exit handler for sqlstate '*'
  {
    -- dbg_printf ('%s', __SQL_MESSAGE);
    return 0;
  };
  ...
  -- data extraction and mapping successful
  return 1;
}
]]></programlisting>
        <para>Exit handlers are used extensively in the Virtuoso supplied cartridges. They are useful
for ensuring graceful failure when trying to convert content which may not conform to your expectations.
The RDF_LOAD_FEED_SIOC procedure (which is used internally by several cartridges) shown below uses this
approach:</para>
<programlisting><![CDATA[
-- /* convert the feed in rss 1.0 format to sioc */
create procedure DB.DBA.RDF_LOAD_FEED_SIOC (in content any, in iri varchar, in graph_iri varchar, in is_disc int := '')
{
  declare xt, xd any;
  declare exit handler for sqlstate '*'
    {
      goto no_sioc;
    };
  xt := xtree_doc (content);
  xd := DB.DBA.RDF_MAPPER_XSLT (
      registry_get ('_rdf_mappers_path_') || 'xslt/feed2sioc.xsl', xt,
      vector ('base', graph_iri, 'isDiscussion', is_disc));
  xd := serialize_to_UTF8_xml (xd);
  DB.DBA.RM_RDF_LOAD_RDFXML (xd, iri, graph_iri);
  return 1;
no_sioc:
  return 0;
}
]]></programlisting>
        <para><emphasis>Loading RDF into the Quad Store</emphasis></para>
        <para><emphasis>RDF_LOAD_RDFXML &amp; TTLP</emphasis></para>
        <para>The two main Virtuoso/PL functions used by the cartridges for loading RDF data into the
Virtuoso quad store are DB.DBA.TTLP and DB.DBA.RDF_LOAD_RDFXML. Multithreaded versions of these functions,
DB.DBA.TTLP_MT and DB.DBA.RDF_LOAD_RDFXML_MT, are also available.</para>
        <para>RDF_LOAD_RDFXML parses the content of an RDF/XML string as a sequence of RDF triples and
loads then into the quad store. TTLP parses TTL (Turtle or N3) and places its triples into quad
storage. Ordinarily, cartridges use RDF_LOAD_RDFXML. However there may be occasions where you want
to insert statements written as TTL, rather than RDF/XML, in which case you should use TTLP.</para>
        <para><emphasis>Attribution</emphasis></para>
        <para>Many of the OpenLink supplied cartridges actually use RM_RDF_LOAD_RDFXML to load data
into the quad store. This is a thin wrapper around RDF_LOAD_RDFXML which includes in the generated
graph an indication of the external ontologies being used. The attribution takes the form:</para>
<programlisting><![CDATA[
<ontologyURI> a opl:DataSource .
<spongedResourceURI> rdfs:isDefinedBy <ontologyURI> .
<ontologyURI> opl:hasNamespacePrefix "<ontologyPrefix>" .
]]></programlisting>
        <para>where prefix opl: denotes the ontology http://www.openlinksw.com/schema/attribution#.</para>
        <para><emphasis>Deleting Existing Graphs</emphasis></para>
        <para>Before loading sponged RDF data into a graph, you may want to delete any existing graph
with the same URI. To do so, select the 'RDF' > 'List of Graphs' menu commands in Conductor, then use
the 'Delete' command for the appropriate graph. Alternatively, you can use one of the following SQL
commands:</para>
<programlisting><![CDATA[
sparql clear graph ;
or
delete from DB.DBA.RDF_QUAD where G = DB.DBA.RDF_MAKE_IID_OF_QNAME (graph_iri);
]]></programlisting>
        <para><emphasis>Proxy Service Data Expiration</emphasis></para>
        <para>When the Proxy Service is invoked by a user agent, the Sponger records the expiry date
of the imported data in the table DB.DBA.SYS_HTTP_SPONGE. The data invalidation rules conform to those
of traditional HTTP clients (Web browsers). The data expiration time is determined based on subsequent
data fetches of the same resource. The first data retrieval records the 'expires' header. On subsequent
fetches, the current time is compared to the expiration time stored in the local cache. If HTTP 'expires'
header data isn't returned by the source data server, the Sponger will derive its own expiration time by
evaluating the 'date' header and 'last-modified' HTTP headers.</para>
      </sect4>
      <sect4 id="virtuosospongercreatecustcartrontolg">
        <title>Ontology Mapping</title>
        <para>After extracting entities from a web resource and converting them to an in-memory XML
document, the entities must be transformed to the target ontology using XSLT and an appropriate stylesheet.
A typical call sequence would be:</para>
<programlisting><![CDATA[
xt := xtree_doc (content);
...
xd := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_rdf_mappers_path_') || 'xslt/mbz2rdf.xsl', xt);
]]></programlisting>
        <para>Because of the wide variation in the data mapped by cartridges, it is not possible to present
a typical XSL stylesheet outline. The Examples section presented later includes detailed extracts from the
MusicBrainz? cartridge's stylesheet which provide a good example of how to map to an ontology. Rather than
attempting to be an XSLT tutorial, the material which follows offers some general guidelines.</para>
        <para><emphasis>Passing Parameters to the XSLT Processor</emphasis></para>
        <para>Virtuoso's XSLT processor will accept default values for global parameters from the optional
third argument of the xslt() function. This argument, if specified, must be a vector of parameter names
and values of the form vector(name1, value1,... nameN, valueN), where name1 ... nameN must be of type
varchar, and value1 ... valueN may be of any Virtuoso datatype, but may not be null.</para>
        <para>This extract from the Crunchbase cartridge shows how parameters may be passed to the XSLT
processor. The function RDF_MAPPER_XSLT (in xslt varchar, inout xt any, in params any := null) passes
the parameters vector directly to xslt().</para>
<programlisting><![CDATA[
xt := DB.DBA.RDF_MAPPER_XSLT (
registry_get ('_rdf_mappers_path_') || 'xslt/crunchbase2rdf.xsl', xt,
vector ('baseUri', coalesce (dest, graph_iri), 'base', base, 'suffix', suffix)
);
]]></programlisting>
        <para>The corresponding stylesheet crunchbase2rdf.xsl retrieves the parameters baseUri, base and suffix as follows:</para>
<programlisting><![CDATA[
...
<xsl:output method="xml" indent="yes" />
  <xsl:variable name="ns">http://www.crunchbase.com/</xsl:variable>
  <xsl:param name="baseUri" />
  <xsl:param name="base"/>
  <xsl:param name="suffix"/>
  <xsl:template name="space-name">
...
]]></programlisting>
        <para><emphasis>An RDF Description Template</emphasis></para>
        <para><emphasis>Defining A Generic Resource Description Wrapper</emphasis></para>
        <para>Many of the OpenLink cartridges create a resource description formed to a common "wrapper"
template which describes the relationship between the (usually) non-RDF source resource being sponged
and the RDF description generated by the Sponger. The wrapper is appropriate for resources which can
broadly be conceived as documents. It provides a generic minimal description of the source document,
but also links to the much more detailed description provided by the Sponger. So, instead of just
emitting a resource description, the Sponger factors the container into the generated graph constituting
the RDF description.</para>
        <para>The template is depicted below:</para>
        <figure id="spong3" float="1">
          <title>Template</title>
          <graphic fileref="ui/spong3.png"/>
        </figure>
        <para>To generate an RDF description corresponding to the wrapper template, a stylesheet containing
the following block of instructions is used. This extract is taken from the eBay cartridge's stylesheet,
ebay2rdf.xsl. Many of the OpenLink cartridges follow a similar pattern.</para>
<programlisting><![CDATA[
    <xsl:param name="baseUri"/>
    ...
    <xsl:variable name="resourceURL">
	<xsl:value-of select="$baseUri"/>
    </xsl:variable>
    ...
    <xsl:template match="/">
	<rdf:RDF>
	    <rdf:Description rdf:about="{$resourceURL}">
		<rdf:type rdf:resource="Document"/>
		<rdf:type rdf:resource="Document"/>
		<rdf:type rdf:resource="Container"/>
		<sioc:container_of rdf:resource="{vi:proxyIRI ($resourceURL)}"/>
		<foaf:primaryTopic rdf:resource="{vi:proxyIRI ($resourceURL)}"/>
		<dcterms:subject rdf:resource="{vi:proxyIRI ($resourceURL)}"/>
	    </rdf:Description>
	    <rdf:Description rdf:about="{vi:proxyIRI ($resourceURL)}">
		<rdf:type rdf:resource="Item"/>
		<sioc:has_container rdf:resource="{$resourceURL}"/>
		<xsl:apply-templates/>
	    </rdf:Description>
	</rdf:RDF>
    </xsl:template>
    ...
]]></programlisting>
        <para><emphasis>Using SIOC as a Generic Container Model</emphasis></para>
        <para>The generic resource description wrapper just described uses SIOC to establish the
container/contained relationship between the source resource and the generated graph. Although the most
important classes for the generic wrapper are obviously Container and Item, SIOC provides a generic data
model of containers, items, item types, and associations between items which can be combined with other
 vocabularies such as FOAF and Dublin Core.</para>
        <para>SIOC defines a number of other classes, such as User, UserGroup, Role, Site, Forum and
Post. A separate SIOC types module (T-SIOC) extends the SIOC Core ontology by defining subclasses and
subproperties of SIOC terms. Subclasses include: AddressBook, BookmarkFolder, Briefcase, EventCalendar,
ImageGallery, Wiki, Weblog, BlogPost, Wiki plus many others.</para>
        <para>OpenLink Data Spaces (ODS) uses SIOC extensively as a data space "glue" ontology to
describe the base data and containment hierarchy of all the items managed by ODS applications
(Data Spaces). For example, ODS-Weblog is an application of type sioc:Forum. Each ODS-Weblog
application instance contains blogs of type sioct:Weblog. Each blog is a sioc:container_of posts
of type sioc:Post.</para>
        <para>Generally, when deciding how to describe resources handled by your own custom cartridge,
SIOC provides a useful framework for the description which complements the SIOC-based container model
adopted throughout the ODS framework.</para>
        <para><emphasis>Naming Conventions for Sponger Generated Descriptions</emphasis></para>
        <para>As can be seen from the stylesheet extract just shown, the URI of the resource
description generated by the Sponger to describe the sponged resource is given by the
function {vi:proxyIRI ($resourceURL)} where resourceURL is the URL of the original resource
being sponged. proxyIRI is an XPath extension function defined in rdf_mappers.sql as</para>
<programlisting><![CDATA[
xpf_extension ('http://www.openlinksw.com/virtuoso/xslt/:proxyIRI', 'DB.DBA.RDF_SPONGE_PROXY_IRI');
]]></programlisting>
        <para>which maps to the Virtuoso/PL procedure DB.DBA.RDF_SPONGE_PROXY_IRI. This procedure in
turn generates a resource description URI which typically takes the form:
http://&lt;hostName:port>/about/rdf/&lt;resourceURL>#this</para>
      </sect4>
      <sect4 id="virtuosospongercreatecustcartrrgst">
        <title>Registering &amp; Configuring Cartridges</title>
        <para>Once you have developed a cartridge, you must register it in the Cartridge Registry
to have the SPARQL processor recognise and use it. You should have compiled your cartridge hook
function first by issuing a "create procedure DB.DBA.RDF_LOAD_xxx ..." command through one of
Virtuoso's SQL interfaces. You can create the required Cartridge Registry entry either by adding
a row to the SYS_REF_MAPPERS table directly using SQL, or by using the Conductor UI.</para>
        <para><emphasis>Using SQL</emphasis></para>
        <para>If you choose register your cartridge using SQL, possibly as part of a Virtuoso/PL
script, the required SQL will typically mirror one of the following INSERT commands.</para>
        <para>Below, a cartridge for OpenCalais is being installed which will be tried when
the MIME type of the data being sponged is one of text/plain, text/xml or text/html.
(The definition of the SYS_RDF_MAPPERS table was introduced earlier in section
'Cartridge Registry'.)</para>
<programlisting><![CDATA[
insert soft DB.DBA.SYS_RDF_MAPPERS (
  RM_PATTERN, RM_TYPE, RM_HOOK, RM_KEY, RM_DESCRIPTION, RM_ENABLED)
values (
  '(text/plain)|(text/xml)|(text/html)', 'MIME', 'DB.DBA.RDF_LOAD_CALAIS',
  null, 'Opencalais', 1);
]]></programlisting>
        <para>As an alternative to matching on the content's MIME type,
candidate cartridges to be tried in the conversion pipeline can be identified by matching the
data source URL against a URL pattern stored in the cartridge's entry in the Cartridge Registry.</para>
<programlisting><![CDATA[
insert soft DB.DBA.SYS_RDF_MAPPERS (
  RM_PATTERN, RM_TYPE, RM_HOOK, RM_KEY, RM_DESCRIPTION, RM_OPTIONS)
values (
  '(http://api.crunchbase.com/v/1/.*)|(http://www.crunchbase.com/.*)', 'URL',
  'DB.DBA.RDF_LOAD_CRUNCHBASE', null, 'CrunchBase', null);
]]></programlisting>
        <para>The value of RM_ID to set depends on where in the cartridge invocation order you want
to position a particular cartridge. RM_ID should be set lower than 10028 to ensure the cartridge
is tried before the ODS-Briefcase (WebDAV) metadata extractor, which is always the last mapper to
be tried if no preceding cartridge has been successful.</para>
<programlisting><![CDATA[
update DB.DBA.SYS_RDF_MAPPERS set RM_ID = 1000 where RM_HOOK = 'DB.DBA.RDF_LOAD_BIN_DOCUMENT';
]]></programlisting>
        <para><emphasis>Using Conductor</emphasis></para>
        <para>Cartridges can be added manually using the 'Add' panel of the 'RDF Cartridges' screen.</para>
        <figure id="spong4" float="1">
          <title>RDF Cartridges</title>
          <graphic fileref="ui/spong4.png"/>
        </figure>
        <figure id="spong5" float="1">
          <title>RDF Cartridges</title>
          <graphic fileref="ui/spong5.png"/>
        </figure>
        <para><emphasis>Installing Stylesheets</emphasis></para>
        <para>Although you could place your cartridge stylesheet in any folder configured to be accessible
by Virtuoso, the simplest option is to upload them to the DAV/VAD/rdf_mappers/xslt folder using the
WebDAV browser accessible from the Conductor UI.</para>
        <figure id="spong6" float="1">
          <title>WebDAV browser</title>
          <graphic fileref="ui/spong6.png"/>
        </figure>
        <para>Should you wish to locate your stylesheets elsewhere, ensure
that the DirsAllowed setting in the virtuoso.ini file is configured appropriately.</para>
      </sect4>
      <sect4 id="virtuosospongercreatecustcartrexmp">
        <title>Example - MusicBrainz: A Music Metadatabase</title>
        <para>To illustrate some of the material presented so far, we'll delve
deeper into the <ulink url="http://musicbrainz.org/">MusicBrainz</ulink> cartridge mentioned earlier.</para>
        <para><emphasis>MusicBrainz XML Web Service</emphasis></para>
        <para>The cartridge extracts data through the <ulink url="http://musicbrainz.org/doc/XMLWebService">MusicBrainz XML Web Service</ulink> using, as the basis
for the initial query, an item type and MBID (MusicBrainz ID) extracted from the original URI submitted
to the RDF proxy. A range of item types are supported including artist, release and track.</para>
        <para>Using the album "Imagine" by John Lennon as an example, a standard HTML description of
the album (which has an MBID of f237e6a0-4b0e-4722-8172-66f4930198bc) can be retrieved direct from
MusicBrainz using the URL:</para>
<programlisting><![CDATA[
http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html
]]></programlisting>
        <para>Alternatively, information can be extracted in XML form through the web service.
A description of the tracks on the album can be obtained with the query:</para>
<programlisting><![CDATA[
http://musicbrainz.org/ws/1/release/f237e6a0-4b0e-4722-8172-66f4930198bc?type=xml&inc=tracks
]]></programlisting>
        <para>The XML returned by the web service is shown below (only the first two tracks
are shown for brevity):</para>
<programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
  <metadata xmlns="http://musicbrainz.org/ns/mmd-1.0#"
   xmlns:ext="http://musicbrainz.org/ns/ext-1.0#">
    <release id="f237e6a0-4b0e-4722-8172-66f4930198bc" type="Album Official" >
      <title>Imagine</title>
        <text-representation language="ENG" script="Latn"/>
        <asin>B0000457L2</asin>
        <track-list>
          <track id="b88bdafd-e675-4c6a-9681-5ea85ab99446">
            <title>Imagine</title>
            <duration>182933</duration>
          </track>
          <track id="b38ce90d-3c47-4ccd-bea2-4718c4d34b0d">
            <title>Crippled Inside</title>
            <duration>227906</duration>
          </track>
	  . . .
        </track-list>
      </release>
  </metadata>
]]></programlisting>
        <para>Although, as shown above, MusicBrainz defines its own <ulink url="http://musicbrainz.org/doc/MusicBrainzXMLMetaData">XML Metadata Format</ulink> to represent
music metadata, the MusicBrainz sponger converts the raw data to a subset of the <ulink url="http://musicontology.com/">Music Ontology</ulink>,
an RDF vocabulary which aims to provide a set of core classes and properties for describing music
on the Semantic Web. Part of the subset used is depicted in the following RDF graph (representing
in this case a John Cale album).</para>
        <figure id="spong7" float="1">
          <title>RDF graph</title>
          <graphic fileref="ui/spong7.png"/>
        </figure>
        <para>With the prefix mo: denoting the Music Ontology at http://purl.org/ontology/mo/, it can be
seen that artists are represented by instances of class mo:Artist, their albums, records etc. by instances
of class mo:Release and tracks on these releases by class mo:Track. The property foaf:made links an
artist and his/her releases. Property mo:track links a release with the tracks it contains</para>
        <para><emphasis>RDF Output</emphasis></para>
        <para>An RDF description of the album can be obtained by sponging the same URL, i.e. by submitting it to the Sponger's proxy interface using the URL:</para>
<programlisting><![CDATA[
http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html
]]></programlisting>
        <para>The extract below shows part of the (reorganized) RDF output returned by the Sponger
for "Imagine". Only the album's title track is included.</para>
<programlisting><![CDATA[
<?xml version="1.0" encoding="utf-8" ?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
 xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">

<rdf:Description
 rdf:about="http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html">
  <rdf:type rdf:resource="http://xmlns.com/foaf/0.1/Document"/>
</rdf:Description>

<rdf:Description
 rdf:about="http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html">
  <foaf:primaryTopic xmlns:foaf="http://xmlns.com/foaf/0.1/"
   rdf:resource="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this"/>
</rdf:Description>

<rdf:Description rdf:about="http://purl.org/ontology/mo/">
  <rdf:type rdf:resource="http://www.openlinksw.com/schema/attribution#DataSource"/>
</rdf:Description>
...
<rdf:Description
 rdf:about="http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html">
  <rdfs:isDefinedBy rdf:resource="http://purl.org/ontology/mo/"/>

</rdf:Description>
...
<!-- Record description -->
<rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this">
  <rdf:type rdf:resource="http://purl.org/ontology/mo/Record"/>
</rdf:Description>

<rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this">
  <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Imagine</dc:title>
</rdf:Description>

<rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this">
  <mo:release_status xmlns:mo="http://purl.org/ontology/mo/" rdf:resource="http://purl.org/ontology/mo/official"/>
</rdf:Description>

<rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this">
  <mo:release_type xmlns:mo="http://purl.org/ontology/mo/"
   rdf:resource="http://purl.org/ontology/mo/album"/>
</rdf:Description>
<!-- Title track description -->
<rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this">
  <mo:track xmlns:mo="http://purl.org/ontology/mo/"
   rdf:resource="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/track/b88bdafd-e675-4c6a-9681-5ea85ab99446.html#this"/>
</rdf:Description>
<rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/track/b88bdafd-e675-4c6a-9681-5ea85ab99446.html#this">
  <rdf:type rdf:resource="http://purl.org/ontology/mo/Track"/>
</rdf:Description>

<rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/track/b88bdafd-e675-4c6a-9681-5ea85ab99446.html#this">
  <dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Imagine</dc:title>
</rdf:Description>

<rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/track/b88bdafd-e675-4c6a-9681-5ea85ab99446.html#this">
  <mo:track_number xmlns:mo="http://purl.org/ontology/mo/">1</mo:track_number>
</rdf:Description>

<rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/track/b88bdafd-e675-4c6a-9681-5ea85ab99446.html#this">
  <mo:duration xmlns:mo="http://purl.org/ontology/mo/" rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">182933</mo:duration>
</rdf:Description>
</rdf:RDF>
]]></programlisting>
        <para><emphasis>Cartridge Hook Function</emphasis></para>
        <para>The cartridge's hook function is listed below. It is important to note that MusicBrainz
 supports a variety of query types, each of which returns a different set of information, depending
on the item type being queried. Full details can be found on the MusicBrainz? site. The sponger
cartridge is capable of handling all the query types supported by MusicBrainz? and is intended to
be used in a drill-down scenario, as would be the case when using an RDF browser such as the
<ulink url="http://ode.openlinksw.com/">OpenLink Data Explorer (ODE)</ulink>. This example focuses primarily on the types release and track.</para>
<programlisting><![CDATA[
create procedure DB.DBA.RDF_LOAD_MBZ (
  in graph_iri varchar, in new_origin_uri varchar, in dest varchar,
  inout _ret_body any, inout aq any, inout ps any, inout _key any,
  inout opts any)
{
  declare kind, id varchar;
  declare tmp, incs any;
  declare uri, cnt, hdr, inc, xd, xt varchar;
  tmp := regexp_parse ('http://musicbrainz.org/([^/]*)/([^\.]+)', new_origin_uri, 0);
  declare exit handler for sqlstate '*'
  {
    -- dbg_printf ('%s', __SQL_MESSAGE);
    return 0;
  };
  if (length (tmp) < 6)
    return 0;

  kind := subseq (new_origin_uri, tmp[2], tmp[3]);
  id :=   subseq (new_origin_uri, tmp[4], tmp[5]);
  incs := vector ();
  if (kind = 'artist')
    {
      inc := 'aliases artist-rels label-rels release-rels track-rels url-rels';
      incs :=
      	vector (
	'sa-Album', 'sa-Single', 'sa-EP', 'sa-Compilation', 'sa-Soundtrack',
	'sa-Spokenword', 'sa-Interview', 'sa-Audiobook', 'sa-Live', 'sa-Remix', 'sa-Other'
	, 'va-Album', 'va-Single', 'va-EP', 'va-Compilation', 'va-Soundtrack',

	'va-Spokenword', 'va-Interview', 'va-Audiobook', 'va-Live', 'va-Remix', 'va-Other'
	);
    }
  else if (kind = 'release')
    inc := 'artist counts release-events discs tracks artist-rels label-rels release-rels track-rels url-rels track-level-rels labels';
  else if (kind = 'track')
    inc := 'artist releases puids artist-rels label-rels release-rels track-rels url-rels';
  else if (kind = 'label')
    inc := 'aliases artist-rels label-rels release-rels track-rels url-rels';
  else
    return 0;
  if (dest is null)
    delete from DB.DBA.RDF_QUAD where G = DB.DBA.RDF_MAKE_IID_OF_QNAME (graph_iri);
  DB.DBA.RDF_LOAD_MBZ_1 (graph_iri, new_origin_uri, dest, kind, id, inc);
  DB.DBA.TTLP (sprintf ('<%S> <http://xmlns.com/foaf/0.1/primaryTopic> <%S> .\n<%S> a <http://xmlns.com/foaf/0.1/Document> .',
  	new_origin_uri, DB.DBA.RDF_SPONGE_PROXY_IRI (new_origin_uri), new_origin_uri),
  	'', graph_iri);
  foreach (any inc1 in incs) do
    {
      DB.DBA.RDF_LOAD_MBZ_1 (graph_iri, new_origin_uri, dest, kind, id, inc1);
    }
  return 1;
};
]]></programlisting>
        <para>The hook function uses a subordinate procedure RDF_LOAD_MBZ_1:</para>
<programlisting><![CDATA[
create procedure DB.DBA.RDF_LOAD_MBZ_1 (in graph_iri varchar, in new_origin_uri varchar,
   in dest varchar, in kind varchar, in id varchar, in inc varchar)
{
  declare uri, cnt, xt, xd, hdr any;
  uri := sprintf ('http://musicbrainz.org/ws/1/%s/%s?type=xml&inc=%U', kind, id, inc);
  cnt := RDF_HTTP_URL_GET (uri, '', hdr, 'GET', 'Accept: */*');
  xt := xtree_doc (cnt);
  xd := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_rdf_mappers_path_') || 'xslt/mbz2rdf.xsl', xt,
        vector ('baseUri', new_origin_uri));
  xd := serialize_to_UTF8_xml (xd);
  DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
};
]]></programlisting>
        <para><emphasis>XSLT Stylesheet</emphasis></para>
        <para>The key sections of the MusicBrainz XSLT template relevant to this example are
listed below. Only the sections relating to an artist, his releases, or the tracks on those
releases, are shown.</para>
<programlisting><![CDATA[
<!DOCTYPE xsl:stylesheet [
<!ENTITY xsd "http://www.w3.org/2001/XMLSchema#">
<!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#">
<!ENTITY mo "http://purl.org/ontology/mo/">
<!ENTITY foaf "http://xmlns.com/foaf/0.1/">
<!ENTITY mmd "http://musicbrainz.org/ns/mmd-1.0#">
<!ENTITY dc "http://purl.org/dc/elements/1.1/">
]>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:vi="http://www.openlinksw.com/virtuoso/xslt/"
    xmlns:rdf=""
    xmlns:rdfs=""
    xmlns:foaf=""
    xmlns:mo=""
    xmlns:mmd=""
    xmlns:dc=""
    >

    <xsl:output method="xml" indent="yes" />
    <xsl:variable name="base" select="'http://musicbrainz.org/'"/>
    <xsl:variable name="uc">ABCDEFGHIJKLMNOPQRSTUVWXYZ</xsl:variable>
    <xsl:variable name="lc">abcdefghijklmnopqrstuvwxyz</xsl:variable>
    <xsl:template match="/mmd:metadata">
	<rdf:RDF>
	    <xsl:apply-templates />
	</rdf:RDF>
    </xsl:template>

    ...

    <xsl:template match="mmd:artist[@type='Person']">
	<mo:MusicArtist rdf:about="{vi:proxyIRI (concat($base,'artist/',@id,'.html'))}">
	    <foaf:name><xsl:value-of select="mmd:name"/></foaf:name>
	    <xsl:for-each select="mmd:release-list/mmd:release|mmd:relation-list[@target-type='Release']/mmd:relation/mmd:release">
		<foaf:made rdf:resource="{vi:proxyIRI (concat($base,'release/',@id,'.html'))}"/>
	    </xsl:for-each>
	</mo:MusicArtist>
	<xsl:apply-templates />
    </xsl:template>

    <xsl:template match="mmd:release">
	<mo:Record rdf:about="{vi:proxyIRI (concat($base,'release/',@id,'.html'))}">
	    <dc:title><xsl:value-of select="mmd:title"/></dc:title>
	    <mo:release_type rdf:resource="{translate (substring-before (@type, ' '),
                                                          $uc, $lc)}"/>
	    <mo:release_status rdf:resource="{translate (substring-after (@type, ' '), $uc,
                                                  $lc)}"/>
	    <xsl:for-each select="mmd:track-list/mmd:track">
		<mo:track rdf:resource="{vi:proxyIRI (concat($base,'track/',@id,'.html'))}"/>

	    </xsl:for-each>
	</mo:Record>
	<xsl:apply-templates select="mmd:track-list/mmd:track"/>
    </xsl:template>

    <xsl:template match="mmd:track">
	<mo:Track rdf:about="{vi:proxyIRI (concat($base,'track/',@id,'.html'))}">
	    <dc:title><xsl:value-of select="mmd:title"/></dc:title>
	    <mo:track_number><xsl:value-of select="position()"/></mo:track_number>
	    <mo:duration rdf:datatype="integer">
             <xsl:value-of select="mmd:duration"/>
           </mo:duration>
	    <xsl:if test="artist[@id]">
		<foaf:maker rdf:resource="{vi:proxyIRI (concat ($base, 'artist/',
                                          artist/@id, '.html'))}"/>
	    </xsl:if>
	    <mo:musicbrainz rdf:resource="{vi:proxyIRI (concat ($base, 'track/', @id, '.html'))}"/>
	</mo:Track>
    </xsl:template>

    ...

    <xsl:template match="text()"/>
</xsl:stylesheet>
]]></programlisting>
      </sect4>
      <sect4 id="virtuosospongercreatecustcartrxslt">
      <title>Meta-Cartridges</title>
        <para>So far the discussion has centred on 'primary' cartridges. However,
Virtuoso supports an alternative type of cartridge, a 'meta-cartridge'. The way a
meta-cartridge operates is essentially the same as a primary cartridge, that is it
has a cartridge hook function with the same signature and its inserts data into the
quad store through entity extraction and ontology mapping as before. Where meta-cartridges
differ from primary cartridges is in their intent and their position in the cartridge
invocation pipeline.</para>
        <para>The purpose of meta-cartridges is to enrich graphs produced by other (primary)
cartridges. They serve as general post-processors to add additional information about selected
entities in an RDF graph. For instance, a particular meta-cartridge might be designed to search
for entities of type 'umbel:Country' in a given graph, and then add additional statements about
each country it finds, where the information contained in these statements is retrieved from the
web service targetted by the meta-cartridge. One such example might be a 'World Bank' meta-cartridge
which adds information relating to a country's GDP, its exports of goods and services as a percentage
of GDP etc; retrieved using the <ulink url="http://developer.worldbank.org/docs/">World Bank web service API</ulink>.
In order to benefit from the World Bank meta-cartridge, any primary cartridge which might generate instance data relating to countries should
ensure that each country instance it handles is also described as being of rdf:type 'umbel:Country'.
Here, the <ulink url="http://wiki.umbel.org/index.php/Welcome">UMBEL</ulink> (Upper Mapping and Binding Exchange Layer) ontology is used as a data-source-agnostic
classification system. It provides a core set of 20,000+ subject concepts which act as "a fixed set of
reference points in a global knowledge space". The use of UMBEL in this way serves to decouple
meta-cartridges from primary cartridges and data source specific ontologies.</para>
        <para>Virtuoso includes two default meta-cartridges which use
UMBEL and <ulink url="http://www.opencalais.com/">OpenCalais</ulink> to augment source graphs.</para>
        <para><emphasis>Registration</emphasis></para>
        <para>Meta-cartridges must be registered in the RDF_META_CARTRIDGES table, which fulfills a role
similar to the SYS_RDF_MAPPERS table used by primary cartridges. The structure of the table, and the
meaning and use of its columns, are similar to SYS_RDF_MAPPERS. The meta-cartridge hook function
signature is identical to that for primary cartridges.</para>
        <para>The RDF_META_CARTRIDGES table definition is as follows:</para>
<programlisting><![CDATA[
create table DB.DBA.RDF_META_CARTRIDGES (
MC_ID INTEGER IDENTITY,		-- meta-cartridge ID. Determines the order of the
                           	   meta-cartridge's invocation in the Sponger
                                 processing chain
MC_SEQ INTEGER IDENTITY,
MC_HOOK VARCHAR,			-- fully qualified Virtuoso/PL function name
MC_TYPE VARCHAR,
MC_PATTERN VARCHAR, 		-- a REGEX pattern to match resource URL or
					   MIME type
MC_KEY VARCHAR,			-- API specific key to use
MC_OPTIONS ANY,			-- meta-cartridge specific options
MC_DESC LONG VARCHAR, 		-- meta-cartridge description (free text)
MC_ENABLED INTEGER		-- a 0 or 1 integer flag to exclude or include
					   meta-cartridge from Sponger processing chain
);
]]></programlisting>
        <para>(At the time of writing there is no Conductor UI for registering meta-cartridges, they must be
registered using SQL. A Conductor interface for this task will be added in due course.)</para>
        <para><emphasis>Invocation</emphasis></para>
        <para>Meta-cartridges are invoked through the post-processing hook procedure RDF_LOAD_POST_PROCESS
which is called, for every document retrieved, after RDF_LOAD_RDFXML loads sponged data into the quad
store.</para>
        <para>Cartridges in the meta-cartridge registry (RDF_META_CARTRIDGES) are configured to match a given
MIME type or URI pattern. Matching meta-cartridges are invoked in order of their MC_SEQ value. Ordinarily
a meta-cartridge should return 0, in which case the next meta-cartridge in the post-processing chain will
be invoked. If it returns 1 or -1, the post-processing stops and no further meta-cartridges are invoked.</para>
        <para>The order of processing by the Sponger cartridge pipeline is thus:</para>
        <orderedlist>
          <listitem>Try to get RDF in the form of TTL or RDF/XML. If RDF is retrieved if go to step 3</listitem>
          <listitem>Try generating RDF through the Sponger primary cartridges as before</listitem>
          <listitem>Post-process the RDF using meta-cartridges in order of their MC_SEQ value. If a meta-cartridge returns 1 or -1, stop the post-processing chain.</listitem>
        </orderedlist>
        <para>Notice that meta-cartridges may be invoked even if primary cartridges are not.</para>
      </sect4>
      <sect4 id="virtuosospongercreatecustcartrexfm">
        <title>Example - A Campaign Finance Meta-Cartridge for Freebase</title>
        <para><emphasis>Note</emphasis></para>
        <para>The example which follows builds on a Freebase Sponger cartridge developed prior to the announcement of Freebase's
support for generating Linked Data through the endpoint http://rdf.freebase.com/ . The OpenLink cartridge
has since evolved to reflect these changes. A snapshot of the Freebase cartridge and stylesheet compatible
with this example can be found in Appendix C.</para>
        <para><ulink url="http://www.freebase.com/">Freebase</ulink> is an open community database of the world's information which serves facts
and statistics rather than articles. Its designers see this difference in emphasis from article-oriented
databases as beneficial for developers wanting to use Freebase facts in other websites and applications.</para>
        <para>Virtuoso includes a Freebase cartridge in the rdf_mappers VAD. The aim of the example cartridge presented here is to provide a lightweight
meta-cartridge that is used to conditionally add triples to graphs generated by the Freebase cartridge,
if Freebase is describing a U.S. senator.</para>
        <para><emphasis>New York Times Campaign Finance (NYTCF) API</emphasis></para>
        <para>The <ulink url="http://developer.nytimes.com/docs/campaign_finance_api?authChecked=1">New York Times Campaign Finance (NYTCF) API</ulink> allows you to retrieve contribution and
expenditure data based on United States Federal Election Commission filings. You can retrieve totals
for a particular presidential candidate, see aggregates by ZIP code or state, or get details on a
particular donor.</para>
        <para>The API supports a number of query types. To keep this example from being overly long,
the meta-cartridge supports just one of these - a query for the candidate details. An example query
and the resulting output follow:</para>
        <para><emphasis>Query:</emphasis></para>
<programlisting><![CDATA[
http://api.nytimes.com/svc/elections/us/v2/president/2008/finances/candidates/obama,barack.xml?api-key=xxxx
]]></programlisting>
        <para>Result:</para>
<programlisting><![CDATA[
<result_set>
 <status>OK</status>
 <copyright>
  Copyright (c) 2008 The New York Times Company.  All Rights Reserved.
 </copyright>
 <results>
  <candidate>
    <candidate_name>Obama, Barack</candidate_name>
    <committee_id>C00431445</committee_id>
    <party>D</party>
    <total_receipts>468841844</total_receipts>
    <total_disbursements>391437723.5</total_disbursements>
    <cash_on_hand>77404120</cash_on_hand>
    <net_individual_contributions>426902994</net_individual_contributions>
    <net_party_contributions>150</net_party_contributions>
    <net_pac_contributions>450</net_pac_contributions>
    <net_candidate_contributions>0</net_candidate_contributions>
    <federal_funds>0</federal_funds>
    <total_contributions_less_than_200>222694981.5</total_contributions_less_than_200>
    <total_contributions_2300>76623262</total_contributions_2300>
    <net_primary_contributions>46444638.81</net_primary_contributions>
    <net_general_contributions>30959481.19</net_general_contributions>
    <total_refunds>2058240.92</total_refunds>
    <date_coverage_from>2007-01-01</date_coverage_from>
    <date_coverage_to>2008-08-31</date_coverage_to>
  </candidate>
 </results>
</result_set>
]]></programlisting>
        <para><emphasis>Sponging Freebase</emphasis></para>
        <para><emphasis>Using OpenLink Data Explorer</emphasis></para>
        <para>The following instructions assume you have the <ulink url="http://ode.openlinksw.com/">OpenLink Data Explorer (ODE)</ulink> browser extension installed in your browser.</para>
        <para>An HTML description of Barack Obama can be obtained directly from Freebase by pasting the
 following URL into your browser: http://www.freebase.com/view/en/barack_obama</para>
        <para>To view RDF data sponged from this page, select 'Linked Data Sources' from the browser's
'View' menu. An OpenLink Data Explorer interface will load in a new tab.</para>
        <para>Clicking on the 'Barack Obama' link under the 'Person' category displayed by ODE sponges
RDF data using the Freebase cartridge. Click the 'down arrow' adjacent to the 'Barack Obama' link to
explore the retrieved data.</para>
        <para>Assuming your Virtuoso instance is running on port 8890 on localhost, the list of data caches displayed
by ODE should include: http://localhost:8890/about/rdf/http://www.freebase.com/view/en/barack_obama#this</para>
        <para>The information displayed in the rest of the page relates to the entity instance identified by this URI. The prefix http://localhost:8890/about/rdf prepended to the
original URI indicates that the Sponger Proxy Service has been invoked. The Sponger creates an associated
entity instance (identified by the above URI with the #this suffix) which holds sponged information
about the original entity.</para>
        <para><emphasis>Using the Command Line</emphasis></para>
        <para>As an alternative to ODE, you can sponge from the command line with the command:</para>
<programlisting><![CDATA[
curl -H "Accept: text/xml" "http://localhost:8890/about/rdf/http://www.freebase.com/view/en/barack_obama"
]]></programlisting>
        <para>To view the results, you can use Conductor's browser-based SPARQL interface (e.g.
http://localhost:8890/sparql) to query the resulting graph generated by the Sponger,
http://www.freebase.com/view/en/barack_obama.</para>
        <para><emphasis>Installing the Meta-Cartridge</emphasis></para>
        <para>To register the meta-cartridge, a procedure similar to the following can be used:</para>
<programlisting><![CDATA[
create procedure INSTALL_RDF_LOAD_NYTCF ()
{
  -- delete any previous NYTCF cartridge installed as a primary cartridge
  delete from SYS_RDF_MAPPERS where RM_HOOK = 'DB.DBA.RDF_LOAD_NYTCF';
  -- register in the meta-cartridge post-processing chain
  insert soft DB.DBA.RDF_META_CARTRIDGES (MC_PATTERN, MC_TYPE, MC_HOOK,
    MC_KEY, MC_DESC, MC_OPTIONS)
    values (
    'http://www.freebase.com/view/.*',
    'URL', 'DB.DBA.RDF_LOAD_NYTCF', '2c1d95a62e5fxxxxx', 'Freebase NYTCF',
    vector ());
};
]]></programlisting>
        <para>Looking at the list of cartridges in Conductor's 'RDF Cartridges' screen, you will
see that the Freebase cartridge is configured by default to sponge URIs which match the pattern
"http://www.freebase.com/view/.*" The meta-cartridge is configured to match on the same URI pattern.</para>
        <para>To use the Campaign Finance API, you must register and request an API key. The script
above shows an invalid key. Replace it with your own key before executing the procedure.</para>
        <para><emphasis>NYTCF Meta-Cartridge Functions</emphasis></para>
        <para>The meta-cartridge function definitions are listed below. They can be executed by
pasting them into Conductor's iSQL interface.</para>
<programlisting><![CDATA[
--no_c_escapes-
create procedure DB.DBA.RDF_NYTCF_LOOKUP(
  in candidate_id any,  -- id of candidate
  in graph_iri varchar, -- graph into which the campaign finance triples should be loaded
  in api_key varchar	-- NYT finance API key
)
{
  declare version, campaign_type, year any;
  declare nyt_url, hdr, tmp any;
  declare xt, xd any;

  -- Common parameters - The NYT API only supports the following values at present:
  version := 'v2';
  campaign_type := 'president';
  year := '2008';

  -- Candidate details
  nyt_url := sprintf(
    'http://api.nytimes.com/svc/elections/us/%s/%s/%s/finances/candidates/%s.xml?api-key=%s',
     version, campaign_type, year, candidate_id, api_key);
  tmp := http_get (nyt_url, hdr);
  if (hdr[0] not like 'HTTP/1._ 200 %')
    signal ('22023', trim(hdr[0], '\r\n'), 'RDF_LOAD_NYTCF_LOOKUP');
  xd := xtree_doc (tmp);

  -- baseUri specifies what the generated RDF description is about
  -- <rdf:Description rdf:about="{baseUri}">
  -- Example baseUri's:
  -- http://localhost:8890/about/rdf/http://www.freebase.com/view/en/barack_obama#this
  -- http://localhost:8890/about/rdf/http://www.freebase.com/view/en/hillary_rodham_clinton#this
  xt := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_rdf_mappers_path_') || 'xslt/nytcf2rdf.xsl', xd,
      	vector ('baseUri', graph_iri));
  xd := serialize_to_UTF8_xml (xt);
  DB.DBA.RDF_LOAD_RDFXML (xd, '', graph_iri);
};

create procedure DB.DBA.RDF_MQL_RESOURCE_IS_SENATOR (
  in fb_graph_uri varchar	-- URI of graph containing Freebase resource
)
{
  -- Check if the resource described by Freebase is a U.S. senator.
  -- Only then does it make sense to query for campaign finance data from the NYT data space.
  -- To test for senators, we start by looking for two statements in the Freebase cartridge
  -- output, similar to:
  -- <rdf:Description
  -- rdf:about="http://.../about/rdf/http://www.freebase.com/view/en/hillary_rodham_clinton#this">
  --   <rdf:type rdf:resource="http://xmlns.com/foaf/0.1/Person"/>
  --   <rdfs:seeAlso rdf:resource="http://en.wikipedia.org/wiki/Hillary_Rodham_Clinton"/>
  --   ...
  -- where the graph generated by the Sponger will be
  -- <http://www.freebase.com/view/en/hillary_rodham_clinton>
  --
  -- To test whether a resource is a senator:
  -- 1) Check whether the Freebase resource is of rdf:type foaf:Person
  -- 2) Extract the person_name from the Wikipedia URI referenced by rdfs:seeAlso
  -- 3) Use the extracted person_name to build a URI to DBpedia's description of the person.
  -- 4) Query the DBpedia description to see if the person is of rdf:type yago:Senator110578471
  declare xp, xt, tmp any;
  declare sparql_ep varchar; 		-- SPARQL endpoint
  declare qry varchar;			-- SPARQL query
  declare qry_uri varchar;		-- query URI
  declare qry_res varchar;		-- query result
  declare default_host varchar;	-- host executing this procedure
  declare dbp_resource_name varchar;	-- Equivalent resource name in DBpedia
  declare fb_resource_uri varchar; 	-- Freebase resource URI
  declare exit handler for sqlstate '*' {
    dbg_printf ('%s', __SQL_MESSAGE);
    return 0;
  };

  default_host := cfg_item_value (virtuoso_ini_path(), 'URIQA', 'DefaultHost');
  if (default_host is null)
  {
    default_host := sys_stat ('st_host_name');
    if (server_http_port () <> '80')
      default_host := default_host ||':'|| server_http_port ();
  }

  fb_resource_uri := sprintf('http://%s/about/rdf/%s#this', default_host, fb_graph_uri);

  -- 1) Check whether the Freebase resource is of rdf:type foaf:Person
  sparql_ep := 'http://' || default_host || '/sparql';
  {
    declare stat, msg varchar;
    declare mdata, rset any;

    qry := sprintf (
    		'sparql ask from <%s> where { <%s> rdf:type <http://xmlns.com/foaf/0.1/Person> }',
		 fb_graph_uri, fb_resource_uri);
    exec (qry, stat, msg, vector(), 1, mdata, rset);
    if (length(rset) = 0 or rset[0][0] <> 1)
      return 0;
  }

  -- 2) Extract the person_name from the Wikipedia URI referenced by rdfs:seeAlso
  {
    declare stat, msg varchar;
    declare mdata, rset any;

    qry := 'sparql prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> \n';
    qry := qry || sprintf ('select ?o from <%s> where { <%s> rdfs:seeAlso ?o }',
    			   fb_graph_uri, fb_resource_uri);
    exec (qry, stat, msg, vector(), 1, mdata, rset);
    if (length (rset) = 0)
      return 0;
    tmp := cast (rset[0][0] as varchar);
    tmp := sprintf_inverse (tmp, 'http://en.wikipedia.org/wiki/%s', 0);
  }

  if (length (tmp) <> 1)
    return 0;
  dbp_resource_name := tmp[0];

  -- 3) Use the extracted person_name to build a URI to DBpedia's description of the person.
  -- 4) Query the DBpedia description to see if the person is of rdf:type yago:Senator110578471
  qry := 'prefix yago: <http://dbpedia.org/class/yago/> \n';
  qry := qry || 'prefix dbp: <http://dbpedia.org/resource/> \n';
  qry := qry || sprintf ('ask from <http://dbpedia.org> where {dbp:%s a yago:Senator110578471}',
 			    dbp_resource_name);
  qry_res := http_client (url=>sprintf('%s?query=%U', 'http://dbpedia.org/sparql', qry),
 			    timeout=>30);
  xt := xtree_doc (qry_res);
  xp := cast (xpath_eval('/sparql/boolean/text()', xt) as varchar);
  if (xp = 'false')
    return 0;
  return 1;
};

create procedure DB.DBA.RDF_LOAD_NYTCF (
  in graph_iri varchar, in new_origin_uri varchar, in dest varchar,
  inout _ret_body any, inout aq any, inout ps any, inout api_key any, inout opts any )
{
  declare candidate_id, candidate_name any;
  declare indx, tmp any;
  declare exit handler for sqlstate '*'
  {
    --dbg_printf('%s', __SQL_MESSAGE);
    return 0;
  };

  if (not DB.DBA.RDF_MQL_RESOURCE_IS_SENATOR (new_origin_uri))
    return 0;

  -- NYT API supports a candidate_id in one of two forms:
  -- candidate_id ::= {candidate_ID} | {last_name [,first_name]}
  -- first_name is optional. If included, there should be no space after the comma.
  --
  -- Because this meta cartridge supplies additional triples for the Freebase
  -- cartridges, only the second form of candidate_id is supported.
  -- i.e. We extract the candidate name, rather than a numeric
  -- candidate_ID (FEC committee ID) from the Freebase URL.
  --
  -- It's assumed that the source URI includes the candidate's first name.
  -- If it is omitted, the NYT API will return information about *all* candidates
  -- with that last name - something we don't want.

  indx := strstr(graph_iri, 'www.freebase.com/view/en/');
  if (indx is not null)
  {
    -- extract candidate_id from Freebase URI
    tmp := sprintf_inverse(subseq(graph_iri, indx), 'www.freebase.com/view/en/%s', 0);
    if (length(tmp) <> 1)
      return 0;
    candidate_name := tmp[0];
  }
  else
  {
    return 0;
  }


  -- split candidate_name into its component parts
  --   candidate_name is assumed to be firstname_[middlename_]*lastname
  --   e.g. hillary_rodham_clinton (Freebase), Hillary_clinton (Wikipedia)
  {
    declare i, _end, len int;
    declare names, tmp_name varchar;

    names := vector ();
    tmp_name := candidate_name;
    len := length (tmp_name);
    while (1)
    {
      _end := strchr(tmp_name, '_');
      if (_end is not null)
      {
        names := vector_concat (names, vector(subseq(tmp_name, 0, _end)));
        tmp_name := subseq(tmp_name, _end + 1);
      }
      else
      {
        names := vector_concat(names, vector(tmp_name));
        goto done;
      }
    }
done:
    if (length(names) < 2)
      return 0;
    -- candidate_id ::= lastname,firstname
    candidate_id := sprintf('%s,%s', names[length(names)-1], names[0]);
  }

  DB.DBA.RDF_NYTCF_LOOKUP(candidate_id, coalesce (dest, graph_iri), api_key);
  return 0;
}
]]></programlisting>
        <para><emphasis>NYTCF Meta-Cartridge Stylesheet</emphasis></para>
        <para>The XSLT stylesheet, nyctf2rdf.xsl, used by the meta-cartridge to transform the base
Campaign Finance web service output to RDF is shown below. RDF_NYCTF_LOOKUP() assumes the stylesheet
is located alongside the other stylesheets provided by the rdf_mappers VAD in the Virtuoso WebDAV
folder DAV/VAD/rdf_mappers/xslt. You should create nyctf2rdf.xsl here from the following listing.
The WebDAV Browser interface in Conductor provides the easiest means to upload the stylesheet.</para>
<programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xsl:stylesheet [
<!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<!ENTITY nyt "http://www.nytimes.com/">
]>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:vi="http://www.openlinksw.com/virtuoso/xslt/"
    xmlns:rdf=""
    xmlns:nyt=""
    >
    <xsl:output method="xml" indent="yes" />
    <xsl:template match="/result_set/status">
      <xsl:if test="text() = 'OK'">
        <xsl:apply-templates mode="ok" select="/result_set/results/candidate"/>
      </xsl:if>
    </xsl:template>

    <xsl:template match="candidate" mode="ok">
      <rdf:Description rdf:about="{vi:proxyIRI($baseUri)}">
	  <nyt:candidate_name><xsl:value-of select="candidate_name"/></nyt:candidate_name>
	  <nyt:committee_id><xsl:value-of select="committee_id"/></nyt:committee_id>
	  <nyt:party><xsl:value-of select="party"/></nyt:party>
	  <nyt:total_receipts><xsl:value-of select="total_receipts"/></nyt:total_receipts>
	  <nyt:total_disbursements>
	    <xsl:value-of select="total_disbursements"/>
	  </nyt:total_disbursements>
	  <nyt:cash_on_hand><xsl:value-of select="cash_on_hand"/></nyt:cash_on_hand>
	  <nyt:net_individual_contributions>
	    <xsl:value-of select="net_individual_contributions"/>
         </nyt:net_individual_contributions>
	  <nyt:net_party_contributions>
	    <xsl:value-of select="net_party_contributions"/>
	  </nyt:net_party_contributions>
	  <nyt:net_pac_contributions>
	    <xsl:value-of select="net_pac_contributions"/>
	  </nyt:net_pac_contributions>
	  <nyt:net_candidate_contributions>
	    <xsl:value-of select="net_candidate_contributions"/>
	  </nyt:net_candidate_contributions>
	  <nyt:federal_funds><xsl:value-of select="federal_funds"/></nyt:federal_funds>
	  <nyt:total_contributions_less_than_200>
	    <xsl:value-of select="total_contributions_less_than_200"/>
	  </nyt:total_contributions_less_than_200>
	  <nyt:total_contributions_2300>
	    <xsl:value-of select="total_contributions_2300"/>
	  </nyt:total_contributions_2300>
	  <nyt:net_primary_contributions>
	    <xsl:value-of select="net_primary_contributions"/>
	  </nyt:net_primary_contributions>
	  <nyt:net_general_contributions>
	    <xsl:value-of select="net_general_contributions"/>
	  </nyt:net_general_contributions>
	  <nyt:total_refunds><xsl:value-of select="total_refunds"/></nyt:total_refunds>
	  <nyt:date_coverage_from rdf:datatype="date">
	    <xsl:value-of select="date_coverage_from"/>
	  </nyt:date_coverage_from>
	  <nyt:date_coverage_to rdf:datatype="date">
           <xsl:value-of select="date_coverage_to"/>
          </nyt:date_coverage_to>
      </rdf:Description>
    </xsl:template>
    <xsl:template match="text()|@*"/>
</xsl:stylesheet>
]]></programlisting>
        <para>The stylesheet uses the prefix nyt: (http://www.nytimes.com) for the predicates of
the augmenting triples. This has been used purely for illustration - you may prefer to define your
own ontology for RDF data derived from New York Times APIs.</para>
        <para><emphasis>Testing the Meta-Cartridge</emphasis></para>
        <para>After creating the required Virtuoso/PL functions and installing the stylesheet, you
should be able to test the meta-cartridge by sponging a Freebase page as described earlier using
ODE or the command line. For instance:</para>
        <itemizedlist mark="bullet">
          <listitem>http://www.freebase.com/view/en/barack_obama , or </listitem>
          <listitem>http://www.freebase.com/view/en/hillary_rodham_clinton</listitem>
        </itemizedlist>
        <para>You should see campaign finance data added to the graph created by the Sponger in the form of triples with predicates starting http://www.nytimes.com/xxx, e.g. http://www.nytimes.com/net_primary_contribution.</para>
        <para><emphasis>How The Meta-Cartridge Works</emphasis></para>
        <para>The comments in the meta-cartridge code detail how the cartridge works. In brief:</para>
        <para>Given the URI of the graph being created by the Freebase cartridge,
RDF_MQL_RESOURCE_IS_SENATOR checks if the resource described by Freebase is a U.S. senator.
Only then does it make sense to query for campaign finance data from the NYTCF data space.</para>
        <para>To test for senators, the procedure starts by looking for two statements in the Freebase cartridge output similar to:</para>
<programlisting><![CDATA[
<rdf:Description rdf:about="http://localhost:8890/about/rdf/http://www.freebase.com/view/en/barack_obama#this">
  <rdf:type rdf:resource="http://xmlns.com/foaf/0.1/Person"/>
  <rdfs:seeAlso rdf:resource="http://en.wikipedia.org/wiki/Barack_Obama"/>
   ...
]]></programlisting>
        <para>where the graph generated by the Sponger will be</para>
<programlisting><![CDATA[
<http://www.freebase.com/view/en/barack_obama>
]]></programlisting>
        <para>To test whether a resource is a senator, RDF_MQL_RESOURCE_IS_SENATOR</para>
    <itemizedlist mark="bullet">
      <listitem>Checks whether the Freebase resource is of rdf:type foaf:Person</listitem>
      <listitem>Extracts the person's name from the Wikipedia URI referenced by rdfs:seeAlso</listitem>
      <listitem>Uses the extracted name to build a URI to DBpedia's description of the person. </listitem>
      <listitem>Queries the DBpedia description to see if the person is of rdf:type yago:Senator110578471 (
<ulink url="http://www.mpi-inf.mpg.de/~suchanek/downloads/yago/">YAGO</ulink> is a semantic knowledge base which provides a core set of concepts which in turn are used by DBpedia.)</listitem>
    </itemizedlist>
        <para>Only if this is the case is the RDF_NYTCF_LOOKUP routine called to query for and return campaign finance data for the candidate. The form of the query and the resulting XML output from the Campaign Finance service were presented earlier.</para>
      </sect4>
    </sect3>
    <sect3 id="virtuosospongerelatedfunc">
    <title>Virtuoso functions usage examples</title>
    <sect4 id="virtuosospongerelatedfuncstring">
      <title>String Functions</title>
        <para><emphasis><link linkend="fn_sprintf_inverse">sprintf_inverse</link></emphasis></para>
<programlisting><![CDATA[
tmp := sprintf_inverse (new_origin_uri, 'http://farm%s.static.flickr.com/%s/%s_%s.%s', 0);
img_id := tmp[2];
]]></programlisting>
        <para><emphasis><link linkend="fn_split_and_decode">split_and_decode</link></emphasis></para>
<programlisting><![CDATA[
request_hdr := headers[0];
response_hdr := headers[1];
host := http_request_header (request, 'Host');
tmp := split_and_decode (request_hdr[0], 0, '\0\0 ');

http_method := tmp[0];
url := tmp[1];
protocol_version := substring (tmp[2], 6, 8);
tmp := rtrim (response_hdr[0], '\r\n');
tmp := split_and_decode (response_hdr[0], 0, '\0\0 ');
]]></programlisting>
      </sect4>
      <sect4 id="virtuosospongerelatedfuncrurl">
      <title>Retrieving URLs</title>
        <para><emphasis><link linkend="fn_http_get">http_get</link></emphasis></para>
<programlisting><![CDATA[
url := sprintf('http://api.flickr.com/services/rest/?i"??
	method=flickr.photos.getInfo&photo_id=%s&api_key=%s', img_id, api_key);
tmp := http_get (url, hdr);
if (hdr[0] not like 'HTTP/1._ 200 %')
  signal ('22023', trim(hdr[0], '\r\n'), 'RDFXX');
xd := xtree_doc (tmp);
]]></programlisting>
        <para><emphasis>DB.DBA.RDF_HTTP_URL_GET</emphasis></para>
        <para>A wrapper around http_get. Retrieves a URL using the specified HTTP method
(defaults to GET). The function can handle proxies, redirects (up to fifteen) and HTTPS.</para>
<programlisting><![CDATA[
uri := sprintf ('http://musicbrainz.org/ws/1/%s/%s?type=xml&inc=%U',
	kind, id, inc);
cnt := RDF_HTTP_URL_GET (uri, '', hdr, 'GET', 'Accept: */*');
xt := xtree_doc (cnt);
xd := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_rdf_mappers_path_') || 'xslt/mbz2rdf.xsl', xt, vector ('baseUri', new_origin_uri));
]]></programlisting>
        <para><emphasis><link linkend="fn_http_request_header">http_request_header</link></emphasis></para>
<programlisting><![CDATA[
content := RDF_HTTP_URL_GET (rdf_url, new_origin_uri, hdr, 'GET',
		'Accept: application/rdf+xml, text/rdf+n3, */*');
ret_content_type := http_request_header (hdr, 'Content-Type', null, null);
]]></programlisting>
      </sect4>
      <sect4 id="virtuosospongerelatedfunchnxml">
      <title>Handling Non-XML Response Content</title>
        <para><emphasis>json_parse</emphasis>: Parses JSON content into a tree.</para>
<programlisting><![CDATA[
url := sprintf ('http://www.freebase.com/api/service/mqlread?queries=%U', qr);
  content := http_get (url, hdr);
  tree := json_parse (content);
  tree := get_keyword ('ROOT', tree);
  tree := get_keyword ('result', tree);
]]></programlisting>
      </sect4>
      <sect4 id="virtuosospongerelatedfuncwrarb">
      <title>Writing Arbitrarily Long Text</title>
        <para><emphasis><link linkend="fn_http">http</link></emphasis></para>
<programlisting><![CDATA[
-- Writing N3 to a string output stream using function http(), parsing the N3 into a graph, then loading the graph into the quad store.
ses := string_output ();
http ('@prefix opl: <http://www.openlinksw.com/schema/attribution#> .\n', ses);
http ('@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n', ses);
...
DB.DBA.TTLP (ses, base, graph);
DB.DBA.RDF_LOAD_RDFXML (strg, base, graph);
]]></programlisting>
        <para><emphasis><link linkend="fn_string_output">string_output</link></emphasis></para>
<programlisting><![CDATA[
ses := string_output ();
cnt := http_get (sprintf ('http://download.finance.yahoo.com/d/quotes.csv?s=%U&f=nsbavophg&e=.csv',
    symbol));
arr := rdfm_yq_parse_csv (cnt);
http ('<quote stock="NASDAQ">', ses);
foreach (any q in arr) do
  {
    http_value (q[0], 'company', ses);
    http_value (q[1], 'symbol', ses);
    ...
  }
  http ('</quote>', ses);
  content := string_output_string (ses);
  xt := xtree_doc (content);
]]></programlisting>
        <para><emphasis><link linkend="fn_string_output_string">string_output_string</link></emphasis></para>
      </sect4>
      <sect4 id="virtuosospongerelatedfuncxmlxslt">
      <title>XML &amp; XSLT</title>
        <para><emphasis><link linkend="fn_xtree_doc">xtree_doc</link></emphasis></para>
<programlisting><![CDATA[
content := RDF_HTTP_URL_GET (uri, '', hdr, 'GET', 'Accept: */*');
xt := xtree_doc (content);
]]></programlisting>
       <para><emphasis><link linkend="fn_xpath_eval">xpath_eval</link></emphasis></para>
<programlisting><![CDATA[
profile := cast (xpath_eval ('/html/head/@profile', xt) as varchar);
]]></programlisting>
        <para><emphasis><link linkend="fn_xslt">DB.DBA.RDF_MAPPER_XSLT</link></emphasis></para>
<programlisting><![CDATA[
tmp := http_get (url);
xd := xtree_doc (tmp);
xt := DB.DBA.RDF_MAPPER_XSLT (
	registry_get ('_rdf_mappers_path_') || 'xslt/atom2rdf.xsl',
	xd, vector ('baseUri', coalesce (dest, graph_iri)));
]]></programlisting>
      </sect4>
      <sect4 id="virtuosospongerelatedfunccharserconv">
      <title>Character Set Conversion</title>
        <para><emphasis><link linkend="fn_serialize_to_UTF8_xml">serialize_to_UTF8_xml</link></emphasis></para>
<programlisting><![CDATA[
xt := DB.DBA.RDF_MAPPER_XSLT (
	registry_get ('_rdf_mappers_path_') || 'xslt/crunchbase2rdf.xsl',
	xt, vector ('baseUri', coalesce (dest, graph_iri), 'base', base,
	'suffix', suffix));
xd := serialize_to_UTF8_xml (xt);
DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
]]></programlisting>
      </sect4>
      <sect4 id="virtuosospongerelatedfuncloaddata">
      <title>Loading Data Into the Quad Store</title>
        <para><emphasis><link linkend="fn_rdf_load_rdfxml">DB.DBA.RDF_LOAD_RDFXML</link></emphasis></para>
<programlisting><![CDATA[
content := RDF_HTTP_URL_GET (uri, '', hdr, 'GET', 'Accept: */*');
xt := xtree_doc (content);
xd := DB.DBA.RDF_MAPPER_XSLT (
	registry_get ('_rdf_mappers_path_') || 'xslt/mbz2rdf.xsl',
	xt, vector ('baseUri', new_origin_uri));
xd := serialize_to_UTF8_xml (xd);
DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
]]></programlisting>
        <para><emphasis><link linkend="fn_ttlp">DB.DBA.TTLP</link></emphasis></para>
<programlisting><![CDATA[
sess := string_output ();
...
http (sprintf ('<http://dbpedia.org/resource/%s>
	<http://xbrlontology.com/ontology/finance/stock_market#hasCompetitor>
	<http://dbpedia.org/resource/%s> .\n',
	symbol, x), sess);
http (sprintf ('<http://dbpedia.org/resource/%s>
	<http://www.w3.org/2000/01/rdf-schema#isDefinedBy>
	<http://finance.yahoo.com/q?s=%s> .\n',
	 x, x), sess);
content := string_output_string (sess);
DB.DBA.TTLP (content, new_origin_uri, coalesce (dest, graph_iri));
]]></programlisting>
      </sect4>
      <sect4 id="virtuosospongerelatedfuncdebugpoutput">
        <title>Debug Output</title>
        <para><emphasis><link linkend="fn_dbg_obj_print">dbg_obj_print</link></emphasis></para>
<programlisting><![CDATA[
dbg_obj_print ('try all grddl mappings here');
]]></programlisting>
      </sect4>
    </sect3>
    <sect3 id="virtuosospongeref">
      <title>References</title>
      <itemizedlist mark="bullet">
        <listitem>RDF Primer: http://www.w3.org/TR/2004/REC-rdf-primer-20040210/</listitem>
        <listitem>RDF/XML Syntax Specification: http://www.w3.org/TR/rdf-syntax-grammar/</listitem>
        <listitem>GRDDL Primer: http://www.w3.org/TR/grddl-primer/</listitem>
      </itemizedlist>
      <sect4 id="virtuosospongerefping">
        <title>PingTheSemanticWeb RDF Notification Service</title>
        <para><ulink url="http://www.pingthesemanticweb.com/">PingtheSemanticWeb</ulink> (PTSW) is a repository for RDF documents. The PTSW web service
archives the location of recently created or updated RDF documents on the Web. It is intended
for use by crawlers or other types of software agents which need to know when and where the
latest updated RDF documents can be found. They can request a list of recently updated documents
as a starting location to crawl the Semantic Web.</para>
        <para>You may find this service useful for publicizing your own RDF content. Content authors can
notify PTSW that an RDF document has been created or updated by pinging the service with the URL of
the document. The Sponger supports this facility through the async_queue and ping_service parameters
of the cartridge hook function, where the ping_service parameter contains the ping service URL as
configured in the SPARQL section of the virtuoso.ini file:</para>
<programlisting><![CDATA[
[SPARQL]
...
PingService = http://rpc.pingthesemanticweb.com/
...
]]></programlisting>
        <para>The configured ping service can be called using an asynchronous request and
the RDF_SW_PING procedure as illustrated below. </para>
<programlisting><![CDATA[
create procedure DB.DBA.RDF_LOAD_HTML_RESPONSE (
  in graph_iri varchar, in new_origin_uri varchar, in dest varchar,
  inout ret_body any, inout async_queue any, inout ping_service any,
  inout _key any, inout opts any )
{
  ...
  if ( ... and async_queue is not null)
    aq_request (async_queue, 'DB.DBA.RDF_SW_PING',
                vector (ping_service, new_origin_uri));
]]></programlisting>
        <para>For more details refer to section <link linkend="ASYNCEXECMULTITHREAD">Asynchronous Execution and Multithreading in Virtuoso/PL</link></para>
      </sect4>
      <sect4 id="virtuosospongeremname">
        <title>Main Namespaces used by OpenLink Cartridges</title>
        <para>A list of the main namespaces / ontologies used by OpenLink-provided Sponger cartridges
is given below. Some of these ontologies may prove useful when creating your own cartridges.</para>
        <itemizedlist mark="bullet">
          <listitem>- http://www.openlinksw.com/virtuoso/xslt/</listitem>
          <listitem>- http://www.openlinksw.com/schemas/XHTML# </listitem>
          <listitem>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# </listitem>
          <listitem>rdfs: http://www.w3.org/2000/01/rdf-schema# </listitem>
          <listitem>dc: http://purl.org/dc/elements/1.1/</listitem>
          <listitem>dcterms: http://purl.org/dc/terms/</listitem>
          <listitem>foaf: http://xmlns.com/foaf/0.1/</listitem>
          <listitem>sioc: http://rdfs.org/sioc/ns# </listitem>
          <listitem>sioct: http://rdfs.org/sioc/types# </listitem>
          <listitem>skos: http://www.w3.org/2004/02/skos/core# </listitem>
          <listitem>bibo: http://purl.org/ontology/bibo/</listitem>
        </itemizedlist>
      </sect4>
      <sect4 id="virtuosospongerfreeb">
        <title>Freebase Cartridge &amp; Stylesheet</title>
        <para>Snapshots of the Freebase cartridge and stylesheet compatible with the meta-cartridge
example presented earlier in this document can be found below.</para>
        <para><emphasis>DB.DBA.RDF_LOAD_MQL:</emphasis></para>
<programlisting><![CDATA[
--no_c_escapes-
create procedure DB.DBA.RDF_LOAD_MQL (in graph_iri varchar, in new_origin_uri varchar,  in dest varchar,
    inout _ret_body any, inout aq any, inout ps any, inout _key any, inout opts any)
{
  declare qr, path, hdr any;
  declare tree, xt, xd, types any;
  declare k, cnt, url, sa varchar;

  hdr := null;
  sa := '';
  declare exit handler for sqlstate '*'
    {
      --dbg_printf ('%s', __SQL_MESSAGE);
      return 0;
    };

  path := split_and_decode (new_origin_uri, 0, '%\0/');
  if (length (path) < 1)
    return 0;
  k := path [length(path) - 1];
  if (path [length(path) - 2] = 'guid')
    k := sprintf ('"id":"/guid/%s"', k);
  else
  {
    if (k like '#%')
        k := sprintf ('"id":"%s"', k);
    else
      {
	sa := DB.DBA.RDF_MQL_GET_WIKI_URI (k);
    k := sprintf ('"key":"%s"', k);
  }
  }
  qr := sprintf ('{"ROOT":{"query":[{%s, "type":[]}]}}', k);
  url := sprintf ('http://www.freebase.com/api/service/mqlread?queries=%U', qr);
  cnt := http_get (url, hdr);
  tree := json_parse (cnt);
  xt := get_keyword ('ROOT', tree);
  if (not isarray (xt))
    return 0;
  xt := get_keyword ('result', xt);
  types := vector ();
  foreach (any tp in xt) do
    {
      declare tmp any;
      tmp := get_keyword ('type', tp);
      types := vector_concat (types, tmp);
    }
  --types := get_keyword ('type', xt);
  delete from DB.DBA.RDF_QUAD where g =  iri_to_id(new_origin_uri);
  foreach (any tp in types) do
    {
      qr := sprintf ('{"ROOT":{"query":{%s, "type":"%s", "*":[]}}}', k, tp);
      url := sprintf ('http://www.freebase.com/api/service/mqlread?queries=%U', qr);
      cnt := http_get (url, hdr);
      --dbg_printf ('%s', cnt);
      tree := json_parse (cnt);
      xt := get_keyword ('ROOT', tree);
      xt := DB.DBA.MQL_TREE_TO_XML (tree);
      --dbg_obj_print (xt);
      xt := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_rdf_mappers_path_') || 'xslt/mql2rdf.xsl', xt,
      	vector ('baseUri', coalesce (dest, graph_iri), 'wpUri', sa));
      sa := '';
      xd := serialize_to_UTF8_xml (xt);
--      dbg_printf ('%s', xd);
      DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
    }
  return 1;
}
]]></programlisting>
        <para><emphasis>mql2rdf.xsl:</emphasis></para>
<programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!--
 -
 -  $Id$
 -
 -  This file is part of the OpenLink Software Virtuoso Open-Source (VOS)
 -  project.
 -
 -  Copyright (C) 1998-2008 OpenLink Software
 -
 -  This project is free software; you can redistribute it and/or modify it
 -  under the terms of the GNU General Public License as published by the
 -  Free Software Foundation; only version 2 of the License, dated June 1991.
 -
 -  This program is distributed in the hope that it will be useful, but
 -  WITHOUT ANY WARRANTY; without even the implied warranty of
 -  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 -  General Public License for more details.
 -
 -  You should have received a copy of the GNU General Public License along
 -  with this program; if not, write to the Free Software Foundation, Inc.,
 -  51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-->
<!DOCTYPE xsl:stylesheet [
<!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<!ENTITY bibo "http://purl.org/ontology/bibo/">
<!ENTITY xsd  "http://www.w3.org/2001/XMLSchema#">
<!ENTITY foaf "http://xmlns.com/foaf/0.1/">
<!ENTITY sioc "http://rdfs.org/sioc/ns#">
]>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:vi="http://www.openlinksw.com/virtuoso/xslt/"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:sioc=""
    xmlns:bibo=""
    xmlns:foaf=""
    xmlns:skos="http://www.w3.org/2004/02/skos/core#"
    xmlns:dcterms= "http://purl.org/dc/terms/"
    xmlns:mql="http://www.freebase.com/">

    <xsl:output method="xml" indent="yes" />

    <xsl:param name="baseUri" />
    <xsl:param name="wpUri" />

    <xsl:variable name="ns">http://www.freebase.com/</xsl:variable>

    <xsl:template match="/">
	<rdf:RDF>
	    <xsl:if test="/results/ROOT/result/*">
		<rdf:Description rdf:about="{$baseUri}">
		    <rdf:type rdf:resource="Document"/>
		    <rdf:type rdf:resource="Document"/>
		    <rdf:type rdf:resource="Container"/>
		    <sioc:container_of rdf:resource="{vi:proxyIRI($baseUri)}"/>
		    <foaf:primaryTopic rdf:resource="{vi:proxyIRI($baseUri)}"/>
		    <dcterms:subject rdf:resource="{vi:proxyIRI($baseUri)}"/>
		</rdf:Description>
		<rdf:Description rdf:about="{vi:proxyIRI($baseUri)}">
		    <rdf:type rdf:resource="Item"/>
		    <sioc:has_container rdf:resource="{$baseUri}"/>
		    <xsl:apply-templates select="/results/ROOT/result/*"/>
		    <xsl:if test="$wpUri != ''">
			<rdfs:seeAlso rdf:resource="{$wpUri}"/>
		    </xsl:if>
		</rdf:Description>
	    </xsl:if>
	</rdf:RDF>
    </xsl:template>

    <xsl:template match="*[starts-with(.,'http://') or starts-with(.,'urn:')]">
	<xsl:element namespace="{$ns}" name="{name()}">
	    <xsl:attribute name="rdf:resource">
		<xsl:value-of select="vi:proxyIRI (.)"/>
	    </xsl:attribute>
	</xsl:element>
    </xsl:template>

    <xsl:template match="*[starts-with(.,'/')]">
	<xsl:if test="local-name () = 'type' and . like '%/person'">
	    <rdf:type rdf:resource="Person"/>
	</xsl:if>
	<xsl:if test="local-name () = 'type'">
	    <sioc:topic>
		<skos:Concept rdf:about="{vi:proxyIRI (concat ($ns, 'view', .))}"/>
	    </sioc:topic>
	</xsl:if>

	<xsl:element namespace="{$ns}" name="{name()}">
	    <xsl:attribute name="rdf:resource">
		<xsl:value-of select="vi:proxyIRI(concat ($ns, 'view', .))"/>
	    </xsl:attribute>
	</xsl:element>
    </xsl:template>

    <xsl:template match="*[* and ../../*]">
	<xsl:element namespace="{$ns}" name="{name()}">
	    <xsl:attribute name="rdf:parseType">Resource</xsl:attribute>
	    <xsl:apply-templates select="@*|node()"/>
	</xsl:element>
    </xsl:template>

    <xsl:template match="*">
	<xsl:if test="* or . != ''">
		<xsl:choose>
		    <xsl:when test="name()='image'">
			<foaf:depiction rdf:resource="{vi:mql-image-by-name (.)}"/>
		    </xsl:when>
		    <xsl:otherwise>
			<xsl:element namespace="{$ns}" name="{name()}">
			    <xsl:if test="name() like 'date_%'">
				<xsl:attribute name="rdf:datatype">dateTime</xsl:attribute>
			    </xsl:if>
			    <xsl:apply-templates select="@*|node()"/>
			</xsl:element>
		    </xsl:otherwise>
		</xsl:choose>
	</xsl:if>
    </xsl:template>
</xsl:stylesheet>
]]></programlisting>
      </sect4>
    </sect3>
  </sect2>
</sect1>



<sect1 id="rdfiridereferencing"><title>Dereferencable IRIs and RDF Linked Data</title>
<para>There are many cases when RDF data should be retrieved from remote sources only when really needed.
E.g., a scheduling application may read personal calendars from personal sites of its users.
Calendar data expire quickly, so there's no reason to frequently re-load them in hope that they are queried before expired.
</para>
<para>Virtuoso extends SPARQL so it is possible to download RDF resource from a given IRI, parse them and store the resulting triples in a graph, all three operations will be performed during the SPARQL query execution.
The IRI of graph to store triples is usually equal to the IRI where the resource is download from, so the feature is named &quot;IRI dereferencing&quot;
There are two different use cases for this feature.
In simple case, a SPARQL query contains <emphasis>from</emphasis> clauses that enumerate graphs to process, but there are no triples in <emphasis>DB.DBA.RDF_QUAD</emphasis> that correspond to some of these graphs.
The query execution starts with dereferencing of these graphs and the rest runs as usual.
In more sophisticated case, the query is executed many times in a loop.
Every execution produces a partial result.
SPARQL processor checks for IRIs in the result such that resources with that IRIs may contain relevant data but not yet loaded into the <emphasis>DB.DBA.RDF_QUAD</emphasis>.
After some iteration, the partial result is identical to the result of the previous iteration, because there's no more data to retrieve.
As the last step, SPARQL processor builds the final result set.
</para>
<sect2 id="rdfinputgrab"><title>IRI Dereferencing For FROM Clauses, &quot;define get:...&quot; Pragmas</title>
<para>Virtuoso extends SPARQL syntax of <emphasis>from</emphasis> and <emphasis>from named</emphasis> clauses.
It allows additional list of options at end of clause: <emphasis>option ( param1 value1, param2 value2, ... )</emphasis>
where parameter names are QNames that start with <emphasis>get:</emphasis> prefix and values are &quot;precode&quot; expressions, i.e. expressions that does not contain variables other than external parameters.
Names of allowed parameters are listed below.
</para>
<itemizedlist>
  <listitem><emphasis>get:soft</emphasis> is the retrieval mode, supported values are &quot;soft&quot; and &quot;replacing&quot;.
If the value is &quot;soft&quot; then the SPARQL processor will not even try to retrieve triples if the destination graph is non-empty.
Other <emphasis>get:...</emphasis> parameters are useless without this one.</listitem>
  <listitem><emphasis>get:uri</emphasis> is the IRI to retrieve if it is not equal to the IRI of the <emphasis>from</emphasis> clause.
These can be used if data should be retrieved from a mirror, not from original resource location or in any other case when the destination graph IRI differs from the location of the resource.</listitem>
<programlisting><![CDATA[
SQL>sparql
define get:uri "http://myopenlink.net/dataspace/person/kidehen"
select ?id
from named <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/sioc.ttl>
where { graph ?g { ?id a ?o } }
limit 10;

id
VARCHAR
_______________________________________________________________________________

http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1231
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1231
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1243
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1243
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1261
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1261
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1261
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com#this
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D

10 Rows. -- 10 msec.

]]></programlisting>
  <listitem><emphasis>get:method</emphasis> is the HTTP method that should be used to retrieve the resource, supported methods are &quot;GET&quot; for plain HTTP and &quot;MGET&quot; for URIQA web service endpoint.
By default, &quot;MGET&quot; is used for IRIs that end with &quot;/&quot; and &quot;GET&quot; for everything else.</listitem>
  <listitem><emphasis>get:refresh</emphasis> is the maximum allowed age of the cached resource, no matter what is specified by the server where the resource resides.
The value is an positive integer (number of seconds). Virtuoso reads HTTP headers and uses &quot;Date&quot;, &quot;ETag&quot;, &quot;Expires&quot;, &quot;Last-Modified&quot;, &quot;Cache-Control&quot; and &quot;Pragma: no-cache&quot; fields to calculate when the resource should be reloaded, this value can become smaller due to <emphasis>get:refresh</emphasis> but can not be incremented.</listitem>
<programlisting><![CDATA[
sparql
define get:refresh "3600"
select ?id
from named <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/sioc.ttl>
where { graph ?g { ?id a ?o } }
limit 10;

id
VARCHAR
_______________________________________________________________________________

http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1231
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1231
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1243
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1243
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1261
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1261
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1261
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com#this
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D

10 Rows. -- 10 msec.

]]></programlisting>
  <listitem><emphasis>get:proxy</emphasis> address of the proxy server, as &quot;host:port&quot; string, if direct download is impossible; the default is to not use proxy.</listitem>
<programlisting><![CDATA[
sparql
define get:proxy "www.openlinksw.com:80"
define get:method "GET"
define get:soft "soft"
select ?id
from named <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/sioc.ttl>
where { graph ?g { ?id a ?o } }
limit 10;

id
VARCHAR
_______________________________________________________________________________

http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1231
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1231
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1243
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1243
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1261
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1261
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1261
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com#this
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D
http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D

10 Rows. -- 10 msec.
SQL> limit 10;
]]></programlisting>

<!--
  <listitem><emphasis>get:login</emphasis></listitem>
  <listitem><emphasis>get:password</emphasis></listitem>
  <listitem><emphasis>get:query</emphasis></listitem> -->
<para>If a value of some <emphasis>get:...</emphasis> parameter repeats for every <emphasis>from</emphasis> clause then it can be written as a global
pragma like <emphasis>define get:soft "soft"</emphasis>.
The following two queries will work identically:
</para>
<programlisting><![CDATA[
sparql
select ?id
from named <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/sioc.ttl>
  option (get:soft "soft", get:method "GET")
from named <http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog/sioc.ttl>
  option (get:soft "soft", get:method "GET")
where { graph ?g { ?id a ?o } }
limit 10;

id
VARCHAR
_______________________________________________________________________________

http://www.openlinksw.com/dataspace/person/oerling#this
http://www.openlinksw.com/mt-tb
http://www.openlinksw.com/RPC2
http://www.openlinksw.com/dataspace/oerling#this
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog/958
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog/958
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog/949
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog/949

10 Rows. -- 862 msec.
]]></programlisting>
<programlisting><![CDATA[
sparql
define get:method "GET"
define get:soft "soft"
select ?id
from named <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/sioc.ttl>
from named <http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog/sioc.ttl>
where { graph ?g { ?id a ?o } }
limit 10;

id
VARCHAR
_______________________________________________________________________________

http://www.openlinksw.com/dataspace/person/oerling#this
http://www.openlinksw.com/mt-tb
http://www.openlinksw.com/RPC2
http://www.openlinksw.com/dataspace/oerling#this
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog/958
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog/958
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog/949
http://www.openlinksw.com/dataspace/oerling/weblog/Orri%20Erling%27s%20Blog/949

10 Rows. -- 10 msec.
]]></programlisting>
<para>
It can make text shorter and it is especially useful when the query text comes from client but the parameter should have a fixed value due to security reasons:
the values set by <emphasis>define get:...</emphasis> can not be redefined inside the query and the application may prevent the text with desired pragmas before the execution.
</para>
<para>
Note that the user should have <emphasis>SPARQL_UPDATE</emphasis> role in order to execute such a query.
By default SPARQL web service endpoint is owned by <emphasis>SPARQL</emphasis> user that have <emphasis>SPARQL_SELECT</emphasis> but not
<emphasis>SPARQL_UPDATE</emphasis>.
It is possible in principle to grant <emphasis>SPARQL_UPDATE</emphasis> to <emphasis>SPARQL</emphasis> but this breaches the whole security of the RDF storage.
</para>
<listitem><emphasis>FROM CLAUSE with options</emphasis>: options in OPTION() list should be delimited with commas.
grab options are not allowed as they are global for the query. Only specific 'get:xxx' options are useful here.</listitem>
<programlisting><![CDATA[
SQL>sparql
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
SELECT DISTINCT ?friend
FROM NAMED  <http://myopenlink.net/dataspace/person/kidehen>
OPTION (get:soft "soft", get:method "GET")
WHERE
  {
      <http://myopenlink.net/dataspace/person/kidehen#this> foaf:knows
?friend .
  };
friend
VARCHAR
_______________________________________________________________________________

http://www.dajobe.org/foaf.rdf#i
http://www.w3.org/People/Berners-Lee/card#i
http://www.w3.org/People/Connolly/#me
http://my.opera.com/chaals/xml/foaf#me
http://www.w3.org/People/Berners-Lee/card#amy
http://www.w3.org/People/EM/contact#me
http://myopenlink.net/dataspace/person/ghard#this
http://myopenlink.net/dataspace/person/omfaluyi#this
http://myopenlink.net/dataspace/person/alanr#this
http://myopenlink.net/dataspace/person/bblfish#this
http://myopenlink.net/dataspace/person/danja#this
http://myopenlink.net/dataspace/person/tthibodeau#this
...
36 Rows. -- 1693 msec.
]]></programlisting>
</itemizedlist>
</sect2>
<sect2 id="rdfinputgrab"><title>IRI Dereferencing For Variables, &quot;define input:grab-...&quot; Pragmas</title>
<para>
Consider a set of personal data such that one resource can list many persons and point to resources where that persons are described in more details.
E.g. resource about <emphasis>user1</emphasis> describes the user and also contain statements that <emphasis>user2</emphasis> and <emphasis>user3</emphasis> are persons and more data can be found in <emphasis>user2.ttl</emphasis> and <emphasis>user3.ttl</emphasis>,
<emphasis>user3.ttl</emphasis> can contain statements that <emphasis>user4</emphasis> is also person and more data can be found in <emphasis>user4.ttl</emphasis> and so on.
The query should find as many users as it is possible and return their names and e-mails.
</para>
<para>
If all data about all users were loaded into the database, the query could be quite simple:
</para>
<programlisting><![CDATA[
SQL>sparql
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select ?id ?firstname ?nick
where
  {
    graph ?g
      {
        ?id rdf:type foaf:Person.
        ?id foaf:firstName ?firstname.
        ?id foaf:knows ?fn .
        ?fn foaf:nick ?nick.
      }
   }
limit 10;

id                                                      firstname  nick
VARCHAR                                                 VARCHAR    VARCHAR
_______________________________________________________________________________

http://myopenlink.net/dataspace/person/pmitchell#this   LaRenda    sdmonroe
http://myopenlink.net/dataspace/person/pmitchell#this   LaRenda    kidehen{at}openlinksw.com
http://myopenlink.net/dataspace/person/pmitchell#this   LaRenda    alexmidd
http://myopenlink.net/dataspace/person/abm#this         Alan       kidehen{at}openlinksw.com
http://myopenlink.net/dataspace/person/igods#this       Cameron    kidehen{at}openlinksw.com
http://myopenlink.net/dataspace/person/goern#this       Christoph  captsolo
http://myopenlink.net/dataspace/person/dangrig#this     Dan        rickbruner
http://myopenlink.net/dataspace/person/dangrig#this     Dan        sdmonroe
http://myopenlink.net/dataspace/person/dangrig#this     Dan        lszczepa
http://myopenlink.net/dataspace/person/dangrig#this     Dan        kidehen

10 Rows. -- 80 msec.
]]></programlisting>
<para>
It is possible to enable IRI dereferencing in such a way that all appropriate resources are loaded during the query execution even if names of some of them are not known a priori.
</para>
<programlisting><![CDATA[
SQL>sparql
  define input:grab-var "?more"
  define input:grab-depth 10
  define input:grab-limit 100
  define input:grab-base "http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1300"
  prefix foaf: <http://xmlns.com/foaf/0.1/>
  prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
  prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
select ?id ?firstname ?nick
where {
    graph ?g {
               ?id rdf:type foaf:Person.
               ?id foaf:firstName ?firstname.
               ?id foaf:knows ?fn .
               ?fn foaf:nick ?nick.
               optional { ?id rdfs:SeeAlso ?more }
            }
}
limit 10;

id                                                         firstname  nick
VARCHAR                                                    VARCHAR    VARCHAR
_______________________________________________________________________________

http://myopenlink.net/dataspace/person/ghard#this          Yrj+?n+?   kidehen
http://inamidst.com/sbp/foaf#Sean                          Sean       d8uv
http://myopenlink.net/dataspace/person/dangrig#this        Dan        rickbruner
http://myopenlink.net/dataspace/person/dangrig#this        Dan        sdmonroe
http://myopenlink.net/dataspace/person/dangrig#this        Dan        lszczepa
http://myopenlink.net/dataspace/person/dangrig#this        Dan        kidehen
http://captsolo.net/semweb/foaf-captsolo.rdf#Uldis_Bojars  Uldis      mortenf
http://captsolo.net/semweb/foaf-captsolo.rdf#Uldis_Bojars  Uldis      danja
http://captsolo.net/semweb/foaf-captsolo.rdf#Uldis_Bojars  Uldis      zool
http://myopenlink.net/dataspace/person/rickbruner#this     Rick       dangrig

10 Rows. -- 530 msec.

]]></programlisting>
<para>
The IRI dereferencing is controlled by the following pragmas:
</para>
<itemizedlist>
  <listitem><emphasis>input:grab-var</emphasis> specifies a name of variable whose values should be used as IRIs of resources that should be downloaded.
It is not an error if the variable is sometimes unbound or gets values that can not be converted to IRIs (e.g., integers) -- bad values are silently ignored.
It is also not an error if the IRI can not be retrieved, this makes IRI retrieval somewhat similar to &quot;best effort union&quot; in SQL.
This pragma can be used more than once to specify many variable names.
It is not an error if values of different variables result in same IRI or a variable gets same value many times -- no one IRI is retrieved more than once.</listitem>
  <listitem><emphasis>input:grab-iri</emphasis> specifies an IRI that should be retrieved before executing the rest of the query, if it is not in the <emphasis>DB.DBA.RDF_QUAD</emphasis> already.
This pragma can be used more than once to specify many IRIs.
The typical use of this pragma is querying a set of related resources when only one &quot;root&quot; resource IRI is known but even that resource is not loaded.</listitem>
<programlisting><![CDATA[
SQL>sparql
  define input:storage ""
  define input:grab-iri <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/sioc.ttl>
  define input:grab-var "id"
  define input:grab-depth 10
  define input:grab-limit 100
  define input:grab-base "http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1300"
select ?id
where { graph ?g { ?id a ?o } }
limit 10;

id
VARCHAR
_______________________________________________________________________________

http://www.openlinksw.com/virtrdf-data-formats#default-iid
http://www.openlinksw.com/virtrdf-data-formats#default-iid-nullable
http://www.openlinksw.com/virtrdf-data-formats#default-iid-nonblank
http://www.openlinksw.com/virtrdf-data-formats#default-iid-nonblank-nullable
http://www.openlinksw.com/virtrdf-data-formats#default
http://www.openlinksw.com/virtrdf-data-formats#default-nullable
http://www.openlinksw.com/virtrdf-data-formats#sql-varchar
http://www.openlinksw.com/virtrdf-data-formats#sql-varchar-nullable
http://www.openlinksw.com/virtrdf-data-formats#sql-longvarchar
http://www.openlinksw.com/virtrdf-data-formats#sql-longvarchar-nullable

10 Rows. -- 530 msec.

]]></programlisting>
  <listitem><emphasis>input:grab-all</emphasis> is the simplest possible way to enable the feature but the resulting performance can be very bad.
It turns all variables and IRI constants in all graph, subject and object fields of all triple patterns of the query into values for
<emphasis>input:grab-var</emphasis> and <emphasis>input:grab-iri</emphasis>,
so the SPARQL processor will dereference everything what might be related to the text of the query.</listitem>
<programlisting><![CDATA[
SQL>sparql
  define input:grab-all "yes"
  define input:grab-depth 10
  define input:grab-limit 100
  define input:grab-base "http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1300"
  prefix foaf: <http://xmlns.com/foaf/0.1/>
  prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
select ?id ?firstname ?nick
where
  {
    graph ?g
     {
       ?id rdf:type foaf:Person.
       ?id foaf:firstName ?firstname.
       ?id foaf:knows ?fn .
       ?fn foaf:nick ?nick.
     }
  }
limit 10;

id                                                      firstname   nick
VARCHAR                                                 VARCHAR     VARCHAR
____________________________________________________________________

http://myopenlink.net/dataspace/person/pmitchell#this   LaRenda     sdmonroe
http://myopenlink.net/dataspace/person/pmitchell#this   LaRenda     kidehen{at}openlinksw.com
http://myopenlink.net/dataspace/person/pmitchell#this   LaRenda     alexmidd
http://myopenlink.net/dataspace/person/abm#this         Alan        kidehen{at}openlinksw.com
http://myopenlink.net/dataspace/person/igods#this       Cameron     kidehen{at}openlinksw.com
http://myopenlink.net/dataspace/person/goern#this       Christoph   captsolo
http://myopenlink.net/dataspace/person/dangrig#this     Dan         rickbruner
http://myopenlink.net/dataspace/person/dangrig#this     Dan         sdmonroe
http://myopenlink.net/dataspace/person/dangrig#this     Dan         lszczepa
http://myopenlink.net/dataspace/person/dangrig#this     Dan         kidehen

10 Rows. -- 660 msec.

]]></programlisting>
  <listitem><emphasis>input:grab-seealso</emphasis> (and synonym <emphasis>input:grab-follow-predicate</emphasis>) specifies an IRI of an predicate similar to foaf:seeAlso.
Predicates of that sort suggest location of resources that contain more data about predicate subject.
The IRI dereferencing routine may use these predicates to find additional IRIs for loading resources.
This is especially useful when the text of the query comes from remote client and may lack triple patterns like
<emphasis><![CDATA[optional { ?id <SeeAlso> ?more }]]></emphasis> from the previous example.
The use of <emphasis>input:grab-seealso</emphasis> makes the SPARQL query nondeterministic, because the order and the number of retrieved documents will
depend on execution plan and they may change from run to run.
This pragma can be used more than once to specify many IRIs, but this feature is costly.
Every additional predicate may result in significant number of lookups in the RDF storage, affecting total execution time.</listitem>
<programlisting><![CDATA[
SQL>sparql
  define input:grab-iri <http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/sioc.ttl>
  define input:grab-var "id"
  define input:grab-depth 10
  define input:grab-limit 100
  define input:grab-base "http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1300"
  define input:grab-seealso <foaf:maker>
    prefix foaf: <http://xmlns.com/foaf/0.1/>
select ?id
where
  {
    graph ?g
      {
        ?id a foaf:Person .
      }
  }
limit 10;

id
VARCHAR
_______________________________________________________________________________

mailto:somebody@example.domain
http://localhost:8895/dataspace/person/dav#this
http://localhost:8895/dataspace/person/dba#this
mailto:2@F.D
http://localhost:8895/dataspace/person/test1#this
http://www.openlinksw.com/blog/~kidehen/gems/rss.xml#Kingsley%20Uyi%20Idehen
http://art.weblogsinc.com/rss.xml#
http://digitalmusic.weblogsinc.com/rss.xml#
http://partners.userland.com/nytrss/books.xml#
http://partners.userland.com/nytrss/arts.xml#

10 Rows. -- 105 msec.

]]></programlisting>
  <listitem><emphasis>input:grab-limit</emphasis> should be an integer that is a maximum allowed number of resource retrievals.
The default value is pretty big (few millions of documents) so it is strongly recommended to set smaller value.
Set it even if you're absolutely sure that the set of resources is small, because program errors are always possible.
All resource downloads are counted, both successful and failed, both forced by <emphasis>input:grab-iri</emphasis> and forced by <emphasis>input:grab-var</emphasis>.
Nevertheless, all constant IRIs specified by <emphasis>input:grab-iri</emphasis> (or <emphasis>input:grab-all</emphasis>) are downloaded before the first check of the <emphasis>input:grab-limit</emphasis> counter,
so this limit will never prevent from downloading &quot;root&quot; resources.
</listitem>
  <listitem><emphasis>input:grab-depth</emphasis> should be an integer that is a maximum allowed number of query iterations.
Every iteration may find new IRIs to retrieve, because resources loaded on previous iteration may add these IRIs to <emphasis>DB.DBA.RDF_QUAD</emphasis> and make result set longer.
The default value is 1, so the SPARQL processor will retrieve only resources explicitly named in &quot;root&quot; resources or in quad that are in the database before the query execution.
</listitem>
  <listitem><emphasis>input:grab-base</emphasis> specifies a base IRI used to convert relative IRIs into absolute. The default is an empty string.</listitem>
<programlisting><![CDATA[
SQL>sparql
  define input:grab-depth 10
  define input:grab-limit 100
  define input:grab-var "more"
  define input:grab-base "http://www.openlinksw.com/dataspace/kidehen@openlinksw.com/weblog/kidehen@openlinksw.com%27s%20BLOG%20%5B127%5D/1300"
  prefix foaf: <http://xmlns.com/foaf/0.1/>
select ?id
where
  {
    graph ?g
     {
       ?id a foaf:Person .
       optional { ?id foaf:maker ?more }
     }
  }
limit 10;

id
VARCHAR
_______________________________________________________________________________

mailto:somebody@example.domain
http://localhost:8895/dataspace/person/dav#this
http://localhost:8895/dataspace/person/dba#this
mailto:2@F.D
http://localhost:8895/dataspace/person/test1#this
http://www.openlinksw.com/blog/~kidehen/gems/rss.xml#Kingsley%20Uyi%20Idehen
http://art.weblogsinc.com/rss.xml#
http://digitalmusic.weblogsinc.com/rss.xml#
http://partners.userland.com/nytrss/books.xml#
http://partners.userland.com/nytrss/arts.xml#

10 Rows. -- 115 msec.

]]></programlisting>
  <listitem><emphasis>input:grab-resolver</emphasis> is a name of procedure that resolve IRIs and determines the HTTP method of retrieval.
The default is name of <emphasis>DB.DBA.RDF_GRAB_RESOLVER_DEFAULT()</emphasis> procedure that is described below.
If other procedure is specified, the signature should match to the default one.</listitem>
  <listitem><emphasis>input:grab-destination</emphasis> is to override the default behaviour of the IRI dereferencing and store all retrieved triples in a single graph.
This is convenient when there's no logical difference where any given triple comes from, and changes in remote resources will only add triples but not make cached triples obsolete.
A SPARQL query is usually faster when all graph IRIs are fixed and there are no graph group patterns with an unbound graph variable, so storing everything in one single graph is worth considering.
</listitem>
  <listitem><emphasis>input:grab-loader</emphasis> is a name of procedure that retrieve the resource via HTTP, parse it and store it.
The default is name of <emphasis>DB.DBA.RDF_SPONGE_UP()</emphasis> procedure; this procedure also used by IRI dereferencing for FROM clauses.
You will probably never need to write your own procedure of this sort but some Virtuoso plugins will provide ready-to-use functions that will retrieve non-RDF resources and extract their metadata as triples or
will implement protocols other than HTTP.
</listitem>
</itemizedlist>
<para>Default resolver procedure is <emphasis>DB.DBA.RDF_GRAB_RESOLVER_DEFAULT()</emphasis>. Note that the function produce two absolute URIs,
<emphasis>abs_uri</emphasis> and <emphasis>dest_uri</emphasis>. Default procedure returns two equal strings, but other may return different values,
e.g., return primary and permanent location of the resource as <emphasis>dest_uri</emphasis> and the fastest known mirror location as
<emphasis>abs_uri</emphasis> thus saving HTTP retrieval time. It can even signal an error to block the downloading of some unwanted resource.</para>
<programlisting><![CDATA[
DB.DBA.RDF_GRAB_RESOLVER_DEFAULT (
  in base varchar,         -- base IRI as specified by input:grab-base pragma
  in rel_uri varchar,      -- IRI of the resource as it is specified by input:grab-iri or a value of a variable
  out abs_uri varchar,     -- the absolute IRI that should be downloaded
  out dest_uri varchar,    -- the graph IRI where triples should be stored after download
  out get_method varchar ) -- the HTTP method to use, should be "GET" or "MGET".
]]></programlisting>
</sect2>
<sect2 id="rdfiridereferencingexamples"><title>Examples of other Web Resolvers</title>
<para>Example of <emphasis>LSIDs</emphasis>: A scientific name from UBio</para>
<programlisting><![CDATA[
SQL>sparql
define get:soft "soft"
select *
from <urn:lsid:ubio.org:namebank:11815>
where { ?s ?p ?o }
limit 5;

s                                 p                                           o
VARCHAR                           VARCHAR                                     VARCHAR
_______________________________________________________________________________

urn:lsid:ubio.org:namebank:11815  http://purl.org/dc/elements/1.1/title       Pternistis leucoscepus
urn:lsid:ubio.org:namebank:11815  http://purl.org/dc/elements/1.1/subject     Pternistis leucoscepus (Gray, GR) 1867
urn:lsid:ubio.org:namebank:11815  http://purl.org/dc/elements/1.1/identifier  urn:lsid:ubio.org:namebank:11815
urn:lsid:ubio.org:namebank:11815  http://purl.org/dc/elements/1.1/creator     http://www.ubio.org
urn:lsid:ubio.org:namebank:11815  http://purl.org/dc/elements/1.1/type        Scientific Name

5 Rows. -- 741 msec.
]]></programlisting>
<para>Example of <emphasis>LSIDs</emphasis>: A segment of the human genome from GDB</para>
<programlisting><![CDATA[
SQL>sparql
define get:soft "soft"
select *
from <urn:lsid:gdb.org:GenomicSegment:GDB132938>
where { ?s ?p ?o }
limit 5;

s                                          p                                                     o
VARCHAR                                    VARCHAR                                               VARCHAR
_______________________________________________________________________________

urn:lsid:gdb.org:GenomicSegment:GDB132938  urn:lsid:gdb.org:DBObject-predicates:accessionID      GDB:132938
urn:lsid:gdb.org:GenomicSegment:GDB132938  http://www.ibm.com/LSID/2004/RDF/#lsidLink            urn:lsid:gdb.org:DBObject:GDB132938
urn:lsid:gdb.org:GenomicSegment:GDB132938  urn:lsid:gdb.org:DBObject-predicates:objectClass      DBObject
urn:lsid:gdb.org:GenomicSegment:GDB132938  urn:lsid:gdb.org:DBObject-predicates:displayName      D20S95
urn:lsid:gdb.org:GenomicSegment:GDB132938  urn:lsid:gdb.org:GenomicSegment-predicates:variantsQ  nodeID://1000027961

5 Rows. -- 822 msec.
]]></programlisting>
<para>Example of <emphasis>OAI</emphasis>: an institutional / departmental repository.</para>
<programlisting><![CDATA[
SQL>sparql
define get:soft "soft"
select *
from <oai:etheses.bham.ac.uk:23>
where { ?s ?p ?o }
limit 5;

s                           p                                           o
VARCHAR                     VARCHAR                                     VARCHAR
_____________________________________________________________________________

oai:etheses.bham.ac.uk:23   http://purl.org/dc/elements/1.1/title       A study of the role of ATM mutations in the pathogenesis of B-cell chronic lymphocytic leukaemia
oai:etheses.bham.ac.uk:23   http://purl.org/dc/elements/1.1/date        2007-07
oai:etheses.bham.ac.uk:23   http://purl.org/dc/elements/1.1/subject     RC0254 Neoplasms. Tumors. Oncology (including Cancer)
oai:etheses.bham.ac.uk:23   http://purl.org/dc/elements/1.1/identifier  Austen, Belinda (2007) A study of the role of ATM mutations in the pathogenesis of B-cell chronic lymphocytic leukaemia. Ph.D. thesis, University of Birmingham.
oai:etheses.bham.ac.uk:23   http://purl.org/dc/elements/1.1/identifier  http://etheses.bham.ac.uk/23/1/Austen07PhD.pdf

5 Rows. -- 461 msec.
]]></programlisting>
<para>Example of <emphasis>DOI</emphasis></para>
<para>In order to execute correctly queries with doi resolver you need to have:</para>
<itemizedlist>
<listitem>the handle.dll file accessible from your system. For ex. you can put it in the Virtuoso bin folder where the rest of the server components are.</listitem>
<listitem>in your Virtuoso database ini file in section Plugins added the hslookup.dll file, which location should be in the plugins folder under your Virtuoso server installation. For ex:
<programlisting><![CDATA[
[Plugins]
LoadPath = ./plugin
...
Load6    = plain,hslookup
]]></programlisting>
</listitem>
</itemizedlist>
<programlisting><![CDATA[
SQL>sparql
define get:soft "soft"
select *
from <doi:10.1045/march99-bunker>
where { ?s ?p ?o } ;

s                                                      p                                                 o
VARCHAR                                                VARCHAR                                           VARCHAR
_______________________________________________________________________________

http://www.dlib.org/dlib/march99/bunker/03bunker.html  http://www.w3.org/1999/02/22-rdf-syntax-ns#type   http://www.openlinksw.com/schemas/XHTML#
http://www.dlib.org/dlib/march99/bunker/03bunker.html  http://www.openlinksw.com/schemas/XHTML#title     Collaboration as a Key to Digital Library Development: High Performance Image Management at the University of Washington

2 Rows. -- 12388 msec.
]]></programlisting>
<para>Other examples</para>
<programlisting><![CDATA[
SQL>sparql
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX doap: <http://usefulinc.com/ns/doap#>
SELECT DISTINCT ?name ?mbox ?projectName
WHERE {
 <http://dig.csail.mit.edu/2005/ajar/ajaw/data#Tabulator>
doap:developer ?dev .
 ?dev foaf:name ?name .
 OPTIONAL { ?dev foaf:mbox ?mbox }
 OPTIONAL { ?dev doap:project ?proj .
            ?proj foaf:name ?projectName }
};

name          mbox              projectName
VARCHAR       VARCHAR           VARCHAR
_______________________________________________________________________________

Adam Lerer    NULL              NULL
Dan Connolly  NULL              NULL
David Li      NULL              NULL
David Sheets  NULL              NULL
James Hollenbach  NULL          NULL
Joe Presbrey  NULL              NULL
Kenny Lu      NULL              NULL
Lydia Chilton NULL              NULL
Ruth Dhanaraj NULL              NULL
Sonia Nijhawan    NULL          NULL
Tim Berners-Lee   NULL          NULL
Timothy Berners-Lee   NULL      NULL
Yuhsin Joyce Chen         NULL NULL

13 Rows. -- 491 msec.
]]></programlisting>
<programlisting><![CDATA[
SQL>sparql
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
SELECT DISTINCT ?friendsname ?friendshomepage ?foafsname ?foafshomepage
WHERE
 {
  <http://myopenlink.net/dataspace/person/kidehen#this> foaf:knows ?friend .
  ?friend foaf:mbox_sha1sum ?mbox .
  ?friendsURI foaf:mbox_sha1sum ?mbox .
  ?friendsURI foaf:name ?friendsname .
  ?friendsURI foaf:homepage ?friendshomepage .
  OPTIONAL { ?friendsURI foaf:knows ?foaf .
              ?foaf foaf:name ?foafsname .
              ?foaf foaf:homepage ?foafshomepage .
           }
 };

friendsname   friendshomepage  foafsname   foafshomepage
VARCHAR       VARCHAR          VARCHAR VARCHAR
_______________________________________________________________________________

Tim Berners-Lee   http://www.w3.org/People/Berners-Lee/                 Dan Connolly    http://www.w3.org/People/Connolly/
Tim Berners-Lee   http://www.w3.org/People/Berners-Lee/                 Eric Miller     http://purl.org/net/eric/
Dave Beckett      http://www.dajobe.org/                                NULL            NULL
Richard Cyganiak  http://richard.cyganiak.de/                           Dan Connolly    http://www.w3.org/People/Connolly/

...
73 Rows. -- 1452 msec.
SQL>

]]></programlisting>
</sect2>
</sect1>
<sect1 id="rdfviews"><title>RDF Views -- Mapping Relational Data to RDF</title>
<para>
RDF Views map relational data into RDF and allow customizing RDF representation of locally stored RDF data.
To let SPARQL clients access relational data as well as physical RDF graphs in a single query, we introduce a declarative Meta Schema Language for mapping SQL Data to RDF Ontologies.
As a result, all types of clients can efficiently access all data stored on the server.
The mapping functionality dynamically generates RDF Data Sets for popular ontologies such as SIOC, SKOS, FOAF, and ATOM/OWL without disruption to the existing database infrastructure of Web 1.0 or Web 2.0 solutions.
RDF views are also suitable for declaring custom representation for RDF triples, e.g. property tables, where one row holds many single-valued properties.
</para>
<sect2 id="rdfviewsintro"><title>Introduction</title>
<para>
The Virtuoso RDF Views meta schema is a built-in feature of Virtuoso's SPARQL to SQL translator.
It recognizes triple patterns that refer to graphs for which an alternate representation is declared and translates these into SQL accordingly.
The main purpose of this is evaluating SPARQL queries against existing relational databases.
There exists previous work from many parties for rendering relational data as RDF and opening it to SPARQL access.
We can mention D2RQ, SPASQL, Squirrel RDF, DBLP and others.
The Virtuoso effort differs from these mainly in the following:
</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem>Integration with a triple store.
Virtuoso can process a query for which some triple patterns will go to local or remote relational data and some to local physical RDF triples.
</listitem><listitem>SPARQL query can be used in any place where SQL can.
Database connectivity protocols are neutral to the syntax of queries they transmit, thus any SQL client, e.g. JDBC, ODBC or XMLA application, can send SPARQL queries and fetch result sets.
Moreover, a SQL query may contain SPARQL subqueries and SPARQL expressions may use SQL built-in functions and stored procedures.
</listitem><listitem>Integration with SQL.
Since SPARQL and SQL share the same run time and query optimizer, the query compilation decisions are always made with the best knowledge of the data and its location.
This is especially important when mixing triples and relational data or when dealing with relational data distributed across many outside databases.
</listitem><listitem>No limits on SPARQL.
It remains possible to make queries with unspecified graph or predicate against mapped relational data, even though these may sometimes be inefficient.
</listitem><listitem>Coverage of the whole relational model.
Multi-part keys etc. are supported in all places.
</listitem>
</itemizedlist>
</sect2>
<sect2 id="rdfviewrationale"><title>Rationale</title>
<para>
Since most of the data that is of likely use for the emerging semantic web is stored in relational databases, the argument for exposing this to SPARQL access is clear.
We note that historically, SQL access to relational data has essentially never been given to the public outside of the organization.
If programmatic access to corporate IS has been available to partners or the public, it has been through dynamic web pages or more recently web services.
There are reasons of performance, security, maintainability and so forth for this.
</para><para>
The culture of the emerging semantic web is however taking a different turn.
Since RDF and OWL offer a mergeable and queryable model for heterogeneous data, it is more meaningful and maintainable to expose selected data for outside query than it would be with SQL.
Advances in hardware make this also less of a performance issue than it would have been in the client-server database era.
</para><para>
In the context of Virtuoso, since Virtuoso is originally a virtual/federated database, incorporating SPARQL to relational mapping is an evident extension of the product's mission as a multi-protocol, multi-platform connector between information systems.
</para>
</sect2>
<sect2 id="rdfviewquadmapatternsvalueandiriclasses"><title>Quad Map Patterns, Value and IRI Classes</title>
<para>
In the simplest sense, any relational schema can be rendered into RDF by converting all primary keys and foreign keys into IRI's, assigning a predicate IRI to each column, and an rdf:type predicate for each row linking it to a RDF class IRI corresponding to the table.
Then a triple with the primary key IRI as subject, the column IRI as predicate and the column's value as object is considered to exist for each column that is neither part of a primary or foreign key.
</para><para>
Strictly equating a subject value to a row and each column to a predicate is often good but is too restrictive for the general case.
</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem>Multiple triples with the same subject and predicate can exist.
</listitem><listitem>A single subject can get single-valued properties from multiple tables or in some cases stored procedures.
</listitem><listitem>An IRI value of a subject or other field of a triple can be composed from more than one SQL value, these values may reside in different columns, maybe in different joined tables.
</listitem><listitem>Some table rows should be excluded from mapping.
</listitem></itemizedlist>
<para>
Thus in the most common case the RDF meta schema should consist of independent transformations; the domain of each transformation is a result-set of some SQL <emphasis>SELECT</emphasis> statement and range is a set of triples.
The <emphasis>SELECT</emphasis> that produce the domain is quite simple: it does not use aggregate functions, joins and sorting, only inner joins and <emphasis>WHERE</emphasis> conditions.
There is no need to support outer joins in the RDF meta schema because NULLs are usually bad inputs for functions that produce IRIs.
In the rare cases when NULLs are OK for functions, outer joins can be encapsulated in SQL views.
The range of mapping can be described by a SPARQL triple pattern: a pattern field is a variable if it depends on table columns, otherwise it is a constant.
Values of variables in the pattern may have additional restrictions on datatypes, when datatypes of columns are known.
</para><para>
This common case of an RDF meta schema is implemented in Virtuoso, with one adjustment.
Virtuoso stores quads, not triples, using the graph field (G) to indicate that a triple belongs to some particular application or resource.
A SPARQL query may use quads from different graphs without large difference between G and the other three fields of a quad.
E.g., variable <emphasis>?g</emphasis> in expression <emphasis>GRAPH ?g {...}</emphasis> can be unbound.
SPARQL has special syntax for &quot;graph group patterns&quot; that is convenient for sets of triple patterns with a common graph, but it also has shorthands for common subject and predicate, so the difference is no more than in syntax.
There is only one feature that is specific for graphs but not for other fields: the SPARQL compiler can create restrictions on graphs according to <emphasis>FROM</emphasis> and <emphasis>FROM NAMED</emphasis> clauses.
</para><para>
Virtuoso RDF Views should offer the same flexibility with the graphs as SPARQL addressing physical triples.
A transformation cannot always be identified by the graph used for ranges because graph may be composed from SQL data. The key element of the meta schema is a &quot;<emphasis>quad map pattern</emphasis>&quot;.
A simple quad map pattern fully defines one particular transformation from one set of relational columns into triples that match one SPARQL graph pattern.
The main part of quad map pattern is four declarations of &quot;<emphasis>quad map values</emphasis>&quot;, each declaration specifies how to calculate the value of the corresponding triple field from the SQL data.
The pattern also lists boolean SQL expressions that should be used to filter out unwanted rows of source data (and to join multiple tables if source columns belong to different tables).
There are also quad map patterns that group together similar quad patterns but do not specify any real transformation or even prevent unwanted transformations from being used, they are described in &quot;Grouping Map Patterns&quot; below.
</para><para>
Quad map values refer to schema elements of two further types: &quot;IRI classes&quot; and &quot;literal classes&quot;.
</para>
<sect3 id="rdfviewiriclasses"><title>IRI Classes</title>
<para>
An IRI class declares that a column or set of columns gets converted into a IRI in a certain way.
The conversion of this sort can be declared revertible (bijection) so an IRI can be parsed into original SQL values; this is useful when some equality of an IRI constant and a calculated IRI can be replaced with an equality of a parse result of a constant and an SQL column that is index criteria or simply faster.
In addition, the SPARQL optimizer will eliminate redundant conversions if one IRI class is explicitly declared as a subclass of another.
The most flexible declaration for conversion consists of specifying functions that assemble and disassemble from IRI into its constituent parts.
This is overkill for typical conversions so it is possible to specify only one sprintf-style format string such that <emphasis>sprintf()</emphasis> SQL function will print an IRI using this format and <emphasis>sprintf_inverse()</emphasis> will be able to parse it back.
</para><para>The use of <emphasis>sprintf_inverse()</emphasis> assumes that the format does not contain fragments like <emphasis>'%s%s'</emphasis> that make it impossible to separate parts of IRI from each other.
</para><para>
In the following, we shall map the Virtuoso users and user roles system tables into the SIOC ontology.
</para>
<programlisting><![CDATA[
create iri class oplsioc:user_iri "http://myhost/sys/user?id=%d"
  (in uid integer not null) .
create iri class oplsioc:group_iri "http://myhost/sys/group?id=%d"
  (in gid integer not null) .
create iri class oplsioc:membership_iri
  "http://myhost/sys/membership?super=%d&sub=%d"
  (in super integer not null, in sub integer not null) .
create iri class oplsioc:dav_iri "http://myhost%s"
  (in path varchar) .
]]></programlisting>
<para>
These IRI classes are used for mapping data from the <emphasis>DB.DBA.SYS_USERS</emphasis> and <emphasis>DB.DBA.SYS_ROLE_GRANTS</emphasis> system tables that are defined in Virtuoso as follows:
</para>
<programlisting><![CDATA[
create table DB.DBA.SYS_USERS (
  U_ID                integer not null unique,
  U_NAME              char (128) not null primary key,
  U_IS_ROLE           integer default 0,
  U_FULL_NAME         char (128),
  U_E_MAIL            char (128) default &quot;,
  U_ACCOUNT_DISABLED  integer default 1,
  U_DAV_ENABLE        integer default 0,
  U_SQL_ENABLE        integer default 1,
  U_HOME              varchar (128),
. . .
 );
]]></programlisting>
<para>
Single record in <emphasis>DB.DBA.SYS_USERS</emphasis> corresponds to a plain user or a group (role).
Users and roles are collectively named &quot;grantees&quot;. Thus a role may be granted to another role or to a user account.
A role grant may be direct (explicit) or assigned by recursion.
</para>
<programlisting><![CDATA[
create table SYS_ROLE_GRANTS (
  GI_SUPER   integer,
  GI_SUB     integer,
  GI_DIRECT  integer default 1,
. . .
  primary key (GI_SUPER, GI_SUB, GI_DIRECT));
]]></programlisting>
<para>One IRI class usually corresponds to one ontology class, because similar things are usually called similarly.
One may wish to use identifiers of ontology classes as identifiers of related IRI classes, to not remember double number of names, e.g. <emphasis>create IRI class mybank:XpressXfer</emphasis> for subjects that will have <emphasis>rdf:type</emphasis> property <emphasis>mybank:XpressXfer</emphasis> made by mapping. That is technically possible but proven to become inconvenient and misleading as application evolves. While RDF types tend to persist, IRI classes may change over time or same subject may get more than one name via more than one IRI class, say, for exports to different systems. It is found to be more convenient to compose names of IRI classes by adding some common prefixes or suffixes to RDF classes (or to table names), say, write <emphasis>create IRI class mybank:XpressXfer_iri</emphasis>.</para>
</sect3>
<sect3 id="rdfviewliteralclasses"><title>Literal Classes</title>
<para>
A &quot;literal class&quot; declares that a column or set of columns gets converted into a literal instead of an IRI.
More precisely, the result of conversion can be <emphasis>IRI_ID</emphasis> so it represents an IRI, but in current version of Virtuoso this is supported only for some internal built-in literal classes, not for classes declared by the user.
So for user-defined literal class the result of the conversion is an RDF literal even if it is a string representation of a valid IRI.
</para><para>
In any case, a literal class can be used only in quad map values of O fields, because Virtuoso does not support literal values as subjects.
</para><para>
A special case of literal class is the identity class that converts a value from <emphasis>varchar</emphasis> column into an untyped literal and value from column of any other SQL datatype into a typed literal with type from XMLSchema set, i.e. <emphasis>xsd:integer</emphasis>, <emphasis>xsd:dateTime</emphasis> and so on.
Columns of types <emphasis>ANY</emphasis> and <emphasis>IRI_ID</emphasis> are not supported.
</para><para>
The SPARQL optimizer knows that RDF literal types are pairwise disjoint so literal classes that produce literals of different types are known to be pairwise disjoint.
The optimizer will replace a join on two disjoint literal classes with an empty statement, to simplify the resulting query.
</para>
</sect3>
<sect3 id="rdfviewsimplequadmappatterns"><title>Simple Quad Map Patterns</title>
<para>
The following declaration of quad map pattern is self-explanatory. The line for <emphasis>object</emphasis> uses identity literal class so there's no need to specify its name.
</para>
<programlisting><![CDATA[
graph      <http://myhost/sys>
subject    oplsioc:user_iri (DB.DBA.SYS_USERS.U_ID)
predicate  foaf:email
object     DB.DBA.SYS_USERS.U_E_MAIL
]]></programlisting>
<para>
The description language also supports SPARQL-style notation that contains less keywords and eliminates duplicate graphs, subjects and predicates.
The following add two patterns with constant graph IRI <emphasis>&lt;http://myhost/sys&gt;</emphasis> and subjects are made from column <emphasis>DB.DBA.SYS_USERS.U_ID</emphasis> by <emphasis>oplsioc:user_iri</emphasis>.
</para>
<programlisting><![CDATA[
graph <http://myhost/sys>
  {
    oplsioc:user_iri (DB.DBA.SYS_USERS.U_ID)
      a sioc:user ;
      oplsioc:name DB.DBA.SYS_USERS.U_FULL_NAME .
  }
]]></programlisting>
</sect3>
<sect3 id="rdfviewassigningnamestoquadmappatterns"><title>Assigning Names To Quad Map Patterns</title>
<para>
In real applications, quad map patterns should be named, for schema manipulation and keeping debug info readable.
Thus it is much better to rewrite the previous example as
</para>
<programlisting><![CDATA[
create virtrdf:SysUsers as graph <http://myhost/sys>
  {
    oplsioc:user_iri (DB.DBA.SYS_USERS.U_ID)
      a sioc:user
          as virtrdf:SysUserType-User;
      oplsioc:name DB.DBA.SYS_USERS.U_FULL_NAME
          as virtrdf:SysUsersFullName .
  }
]]></programlisting>
<para>
Using these names, one may later write, say, <emphasis>drop quad map virtrdf:SysUserType-User</emphasis>.
</para><para>
One name, <emphasis>virtrdf:DefaultQuadMap</emphasis> is reserved.
It is an internal quad map pattern used to access &quot;native-form&quot; quads from <emphasis>DB.DBA.RDF_QUAD</emphasis>:
</para>
<programlisting><![CDATA[
create virtrdf:DefaultQuadMap as
graph rdfdf:default-iid-nonblank (DB.DBA.RDF_QUAD.G)
subject rdfdf:default-iid (DB.DBA.RDF_QUAD.S)
predicate rdfdf:default-iid-nonblank (DB.DBA.RDF_QUAD.P)
object rdfdf:default (DB.DBA.RDF_QUAD.O)
]]></programlisting>
<para>
IRI classes from <emphasis>rdfdf:...</emphasis> namespace are also reserved.
</para>
</sect3>
<sect3 id="rdfviewgroupingmappatterns"><title>Grouping Map Patterns</title>
<para>
The previous example actually contains three map patterns, not two.
The name <emphasis>virtrdf:SysUsers</emphasis> refers to a &quot;<emphasis>group map pattern</emphasis>&quot; that does not define any real transformation of relational data into RDF but helps organize quad map patterns into a tree.
Group may contain both quad map patterns and other groups.
A group can be manipulated as a whole, e.g. <emphasis>drop quad map virtrdf:SysUsers</emphasis> will remove all three map patterns.
</para>
</sect3>
</sect2>
<sect2 id="rdfviewnorthwindexample1"><title>Simple Mapping Example -- Northwind RDF View</title>
<para>Here is example of the basic Northwind RDF Views deployment. The sequence of operations is very common for adding SPARQL access to existing application.</para>
<para>There exist few important questions to answer. Who should have access to data behind RDF View? Should someone have access to other sorts of RDF data but not to the new View? What are applications that should be interoperable with the new RDF data source? Are there any applications that produce similar data but that data sould be kept apart from data made by view? How to ensure that deployment the view will not cause problems for other applications?</para>
<para>First of all, we decide whether the default web service endpoint should have access to the data in question. If it should then we have to grant SELECT priviledges to the account "SPARQL" that is used for the default endpoint; if it should not but some custom edpoint should then grant to the owner account of that account. Granting access is less trivial that it is usual. On one hand, those who can make SQL SELECT statements on application's tables can also make SPARQL queries on RDF View over that tables, because it makes SQL inside. On the other hand, those who do not intend to query that data at all may get unexpected &quot;permission denied&quot; errors on queries that worked fine before adding an RDF View. If SPARQL compiler can not prove that the query can not access data from the view then it will generate SQL code that will access tables behind the view. In some cases permission problems should be resolved by creating RDF View in a separate <link linkend="rdfviewconfiguringrdfstorages">RDF storage</link>. In this example, data are public:</para>
<programlisting><![CDATA[
use DB;

GRANT SELECT ON "Demo"."demo"."Products" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Suppliers" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Shippers" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Categories" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Customers" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Employees" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Orders" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Order_Details" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Countries" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Provinces" TO "SPARQL";
]]></programlisting>

<para>Interoperability is the next question. The example is not
interoperable with anything so in can provide data of any form, a real
application will probably use some ontology from external
source. Sometimes data should be converted from internal application's
representation to something different (such as metric to imperial or
ATT country code to two-character country id); sometimes composed IRIs
should follow special rules; <link
linkend="rdfviewiriusingfunction">function-based IRI classes</link>
may help in that cases. As this is the first example, only plain
format-string-based IRI classes are used.</para>

<para>We should also ensure that data generated by the new view will
not be accidentally mixed with other data of the database. For that
purpose the example will use a unique graph name that includes both
application name and host name. In addition, the script will drop
declarations that might remain  from a previous run of the same script. The
script is executed many times during the development so erasing
previous version is worth writing. It will report an error if there's
nothing to erase but it's better than unpredictable errors due to
writing new declarations over existing ones.</para>


<note><para>Making graph name unique for every host is not needed if
the application is supposed to be &quot;local&quot; and nobody will
access more than one installation of the application. If this is
the case, use some fixed graph IRI, not necessarily starting with
hostname at all; this is much more convenient for querying because you
don't have to calculate the graph name in each query. With fixed graph
in use, it is still possible to clone the RDF View to map to a unique
graph as soon as the application become &quot;public&quot; and requires
merging data from many installations.</para></note>

<programlisting><![CDATA[
SPARQL drop quad map graph iri("http://^{URIQADefaultHost}^/Northwind")
;
SPARQL drop quad map virtrdf:NorthwindDemo
;
]]></programlisting>
<note><para>The <emphasis>^{URIQADefaultHost}^</emphasis> macro is replaced with the value of <emphasis>DefaultHost</emphasis> parameter of <link linkend="ini_URIQA">[URIQA]</link> section of configuration file. The IRI is written as <emphasis>iri("http://^{URIQADefaultHost}^/Northwind")</emphasis>, not as <emphasis>&lt;http://^{URIQADefaultHost}^/Northwind&gt;</emphasis> because macro of this sort works only inside SPARQL string values.</para></note>

<para>Now it's safe to create IRI classes needed for the view. If
these classes are used only in the view we define then it is safe to
create all of them in a single statement. If some of them are used
across multiple declarations then errors may occur. it is impossible
to redefine an IRI class that is in use; the compiler will try to
avoid reporting errors by checking whether the new declaration is
identical to the existing one and by trying garbage collection in hope
that the IRI class is used only in garbage, but errors may occur
anyway. Thus it is better to declare &quot;shared&quot; IRI classes by
individual statements and group together only &quot;private&quot; IRI
classes of a view. If a &quot;class redefinition&quot; error occurs in
the middle of a group then &quot;undefined class&quot; errors may
occur after because the processing of the group was interrupted before
rest of group was not executed. When in trouble, try <link
linkend="fn_rdf_audit_metadata"><function>DB.DBA.RDF_AUDIT_METADATA</function></link>
procedure.</para>


<programlisting><![CDATA[
SPARQL
create iri class northwind:Category "http://^{URIQADefaultHost}^/Northwind/Category/%d#this" (in category_id integer not null) .
create iri class northwind:Shipper "http://^{URIQADefaultHost}^/Northwind/Shipper/%d#this" (in shipper_id integer not null) .
create iri class northwind:Supplier "http://^{URIQADefaultHost}^/Northwind/Supplier/%d#this" (in supplier_id integer not null) .
create iri class northwind:Product   "http://^{URIQADefaultHost}^/Northwind/Product/%d#this" (in product_id integer not null) .
create iri class northwind:Customer "http://^{URIQADefaultHost}^/Northwind/Customer/%U#this" (in customer_id varchar not null) .
create iri class northwind:Employee "http://^{URIQADefaultHost}^/Northwind/Employee/%U%U%d#this" (in employee_firstname varchar not null, in employee_lastname varchar not null, in employee_id integer not null) .
create iri class northwind:Order "http://^{URIQADefaultHost}^/Northwind/Order/%d#this" (in order_id integer not null) .
create iri class northwind:CustomerContact "http://^{URIQADefaultHost}^/Northwind/CustomerContact/%U#this" (in customer_id varchar not null) .
create iri class northwind:OrderLine "http://^{URIQADefaultHost}^/Northwind/OrderLine/%d/%d#this" (in order_id integer not null, in product_id integer not null) .
create iri class northwind:Province "http://^{URIQADefaultHost}^/Northwind/Province/%U/%U#this" (in country_name varchar not null, in province_name varchar not null) .
create iri class northwind:Country "http://^{URIQADefaultHost}^/Northwind/Country/%U#this" (in country_name varchar not null) .
create iri class northwind:Flag "http://^{URIQADefaultHost}^%U#this" (in flag_path varchar not null) .
create iri class northwind:dbpedia_iri "http://dbpedia.org/resource/%U" (in uname varchar not null) .
create iri class northwind:EmployeePhoto "http://^{URIQADefaultHost}^/DAV/VAD/demo/sql/EMP%d#this" (in emp_id varchar not null) .
create iri class northwind:CategoryPhoto "http://^{URIQADefaultHost}^/DAV/VAD/demo/sql/CAT%d#this" (in category_id varchar not null) .
;
]]></programlisting>
<para>One IRI class per subject type; format strings begin with same host but different directory names so this will let the compiler to guess the type of subject by the text of IRI. Most of declarations are <link linkend="rdfviewbijandreturns">bijections</link> and may get  <emphasis>option (bijection)</emphasis> hint but these format strings are so simple that the compiler may understant it by itself.
(<emphasis>northwind:Employee</emphasis> is not a bijection because <link linkend="fn_sprintf_inverse"><function>sprintf_inverse</function></link> will be unable to split the tail of IRI string and find the boundary between first and last name.)</para>
<para>The final operation is extending the default quad storage with new tree of quad map patterns.</para>
<programlisting><![CDATA[
SPARQL
prefix northwind: <http://demo.openlinksw.com/schemas/northwind#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>

alter quad storage virtrdf:DefaultQuadStorage
from Demo.demo.Products as products
from Demo.demo.Suppliers as suppliers
from Demo.demo.Shippers as shippers
from Demo.demo.Categories as categories
from Demo.demo.Customers as customers
from Demo.demo.Employees as employees
from Demo.demo.Orders as orders
from Demo.demo.Order_Details as order_lines
from Demo.demo.Countries as countries
from Demo.demo.Provinces as provinces
where (^{suppliers.}^.Country = ^{countries.}^.Name)
where (^{customers.}^.Country = ^{countries.}^.Name)
where (^{employees.}^.Country = ^{countries.}^.Name)
where (^{orders.}^.ShipCountry = ^{countries.}^.Name)
{
        create virtrdf:NorthwindDemo as graph iri ("http://^{URIQADefaultHost}^/Northwind") option (exclusive)
        {
                northwind:CustomerContact (customers.CustomerID)
                        a foaf:Person
                                as virtrdf:CustomerContact-foaf_Person .

                northwind:CustomerContact (customers.CustomerID)
                        a northwind:CustomerContact
                                as virtrdf:CustomerContact-CustomerContact;
                        foaf:name customers.ContactName
                                as virtrdf:CustomerContact-contact_name ;
                        foaf:phone customers.Phone
                                as virtrdf:CustomerContact-foaf_phone ;
                        northwind:is_contact_at northwind:Customer (customers.CustomerID)
                                as virtrdf:CustomerContact-is_contact_at ;
                        northwind:country northwind:Country (customers.Country)
                                as virtrdf:CustomerContact-country ;
                        rdfs:isDefinedBy northwind:customercontact_iri (customers.CustomerID) ;
                        rdfs:isDefinedBy northwind:CustomerContact (customers.CustomerID) .

                northwind:Country (customers.Country)
                        northwind:is_country_of
                northwind:CustomerContact (customers.CustomerID) as virtrdf:CustomerContact-is_country_of .

                northwind:Product (products.ProductID)
                        a northwind:Product
                                as virtrdf:Product-ProductID ;
                        northwind:has_category northwind:Category (products.CategoryID)
                                as virtrdf:Product-product_has_category ;
                        northwind:has_supplier northwind:Supplier (products.SupplierID)
                                as virtrdf:Product-product_has_supplier ;
                        northwind:productName products.ProductName
                                as virtrdf:Product-name_of_product ;
                        northwind:quantityPerUnit products.QuantityPerUnit
                                as virtrdf:Product-quantity_per_unit ;
                        northwind:unitPrice products.UnitPrice
                                as virtrdf:Product-unit_price ;
                        northwind:unitsInStock products.UnitsInStock
                                as virtrdf:Product-units_in_stock ;
                        northwind:unitsOnOrder products.UnitsOnOrder
                                as virtrdf:Product-units_on_order ;
                        northwind:reorderLevel products.ReorderLevel
                                as virtrdf:Product-reorder_level ;
                        northwind:discontinued products.Discontinued
                                as virtrdf:Product-discontinued ;
                        rdfs:isDefinedBy northwind:product_iri (products.ProductID) ;
                        rdfs:isDefinedBy northwind:Product (products.ProductID) .

                northwind:Category (products.CategoryID)
                        northwind:category_of northwind:Product (products.ProductID) as virtrdf:Product-category_of .

                northwind:Supplier (products.SupplierID)
                        northwind:supplier_of northwind:Product (products.ProductID) as virtrdf:Product-supplier_of .

                northwind:Supplier (suppliers.SupplierID)
                        a northwind:Supplier
                                as virtrdf:Supplier-SupplierID ;
                        northwind:companyName suppliers.CompanyName
                                as virtrdf:Supplier-company_name ;
                        northwind:contactName suppliers.ContactName
                                as virtrdf:Supplier-contact_name ;
                        northwind:contactTitle suppliers.ContactTitle
                                as virtrdf:Supplier-contact_title ;
                        northwind:address suppliers.Address
                                as virtrdf:Supplier-address ;
                        northwind:city suppliers.City
                                as virtrdf:Supplier-city ;
                        northwind:dbpedia_city northwind:dbpedia_iri(suppliers.City)
                                as virtrdf:Supplier-dbpediacity ;
                        northwind:region suppliers.Region
                                as virtrdf:Supplier-region ;
                        northwind:postalCode suppliers.PostalCode
                                as virtrdf:Supplier-postal_code ;
                        northwind:country northwind:Country(suppliers.Country)
                                as virtrdf:Supplier-country ;
                        northwind:phone suppliers.Phone
                                as virtrdf:Supplier-phone ;
                        northwind:fax suppliers.Fax
                                as virtrdf:Supplier-fax ;
                        northwind:homePage suppliers.HomePage
                                as virtrdf:Supplier-home_page ;
                        rdfs:isDefinedBy northwind:supplier_iri (suppliers.SupplierID) ;
                        rdfs:isDefinedBy northwind:Supplier (suppliers.SupplierID) .

                northwind:Country (suppliers.Country)
                        northwind:is_country_of
                northwind:Supplier (suppliers.SupplierID) as virtrdf:Supplier-is_country_of .

                northwind:Category (categories.CategoryID)
                        a northwind:Category
                                as virtrdf:Category-CategoryID ;
                        northwind:categoryName categories.CategoryName
                                as virtrdf:Category-home_page ;
                        northwind:description categories.Description
                                as virtrdf:Category-description ;
                        foaf:img northwind:CategoryPhoto(categories.CategoryID)
                                as virtrdf:Category-categories.CategoryPhoto ;
                        rdfs:isDefinedBy northwind:category_iri (categories.CategoryID) ;
                        rdfs:isDefinedBy northwind:Category (categories.CategoryID) .

                northwind:CategoryPhoto(categories.CategoryID)
                        a northwind:CategoryPhoto
                                as virtrdf:Category-categories.CategoryPhotoID ;
                        rdfs:isDefinedBy northwind:categoryphoto_iri (categories.CategoryID) ;
                        rdfs:isDefinedBy northwind:CategoryPhoto(categories.CategoryID) .

                northwind:Shipper (shippers.ShipperID)
                        a northwind:Shipper
                                as virtrdf:Shipper-ShipperID ;
                        northwind:companyName shippers.CompanyName
                                as virtrdf:Shipper-company_name ;
                        northwind:phone shippers.Phone
                                as virtrdf:Shipper-phone ;
                        rdfs:isDefinedBy northwind:shipper_iri (shippers.ShipperID) ;
                        rdfs:isDefinedBy northwind:Shipper (shippers.ShipperID) .

                northwind:Customer (customers.CustomerID)
                        a  northwind:Customer
                                as virtrdf:Customer-CustomerID2 ;
                        a  foaf:Organization
                                as virtrdf:Customer-CustomerID ;
                        foaf:name customers.CompanyName
                                as virtrdf:Customer-foaf_name ;
                        northwind:companyName customers.CompanyName
                                as virtrdf:Customer-company_name ;
                        northwind:has_contact northwind:CustomerContact (customers.CustomerID)
                                as virtrdf:Customer-contact ;
                        northwind:country northwind:Country (customers.Country)
                                as virtrdf:Customer-country ;
                        northwind:contactName customers.ContactName
                                as virtrdf:Customer-contact_name ;
                        northwind:contactTitle customers.ContactTitle
                                as virtrdf:Customer-contact_title ;
                        northwind:address customers.Address
                                as virtrdf:Customer-address ;
                        northwind:city customers.City
                                as virtrdf:Customer-city ;
                        northwind:dbpedia_city northwind:dbpedia_iri(customers.City)
                                as virtrdf:Customer-dbpediacity ;
                        northwind:region customers.Region
                                as virtrdf:Customer-region ;
                        northwind:PostalCode customers.PostalCode
                                as virtrdf:Customer-postal_code ;
                        foaf:phone customers.Phone
                                as virtrdf:Customer-foaf_phone ;
                        northwind:phone customers.Phone
                                as virtrdf:Customer-phone ;
                        northwind:fax customers.Fax
                                as virtrdf:Customer-fax ;
                        rdfs:isDefinedBy northwind:customer_iri (customers.CustomerID) ;
                        rdfs:isDefinedBy northwind:Customer (customers.CustomerID) .

                northwind:Country (customers.Country)
                        northwind:is_country_of
                northwind:Customer (customers.CustomerID) as virtrdf:Customer-is_country_of .

                northwind:Employee (employees.FirstName, employees.LastName, employees.EmployeeID)
                        a northwind:Employee
                                as virtrdf:Employee-EmployeeID2 ;
                        a foaf:Person
                                as virtrdf:Employee-EmployeeID ;
                        foaf:surname employees.LastName
                                as virtrdf:Employee-foaf_last_name ;
                        northwind:lastName employees.LastName
                                as virtrdf:Employee-last_name ;
                        foaf:firstName employees.FirstName
                                as virtrdf:Employee-foaf_first_name ;
                        northwind:firstName employees.FirstName
                                as virtrdf:Employee-first_name ;
                        foaf:title employees.Title
                                as virtrdf:Employee-title ;
                        northwind:titleOfCourtesy employees.TitleOfCourtesy
                                as virtrdf:Employee-title_of_courtesy ;
                        foaf:birthday employees.BirthDate
                                as virtrdf:Employee-foaf_birth_date ;
                        northwind:birthday employees.BirthDate
                                as virtrdf:Employee-birth_date ;
                        northwind:hireDate employees.HireDate
                                as virtrdf:Employee-hire_date ;
                        northwind:address employees.Address
                                as virtrdf:Employee-address ;
                        northwind:city employees.City
                                as virtrdf:Employee-city ;
                        northwind:dbpedia_city northwind:dbpedia_iri(employees.City)
                                as virtrdf:Employee-dbpediacity ;
                        northwind:region employees.Region
                                as virtrdf:Employee-region ;
                        northwind:postalCode employees.PostalCode
                                as virtrdf:Employee-postal_code ;
                        northwind:country northwind:Country(employees.Country)
                                as virtrdf:Employee-country ;
                        foaf:phone employees.HomePhone
                                as virtrdf:Employee-home_phone ;
                        northwind:extension employees.Extension
                                as virtrdf:Employee-extension ;
                        northwind:notes employees.Notes
                                as virtrdf:Employee-notes ;
                        northwind:reportsTo northwind:Employee(employees.FirstName, employees.LastName, employees.ReportsTo) where (^{employees.}^.ReportsTo = ^{employees.}^.EmployeeID)
                                as virtrdf:Employee-reports_to ;
                        foaf:img northwind:EmployeePhoto(employees.EmployeeID)
                                as virtrdf:Employee-employees.EmployeePhoto ;
                        rdfs:isDefinedBy northwind:employee_iri (employees.EmployeeID) ;
                        rdfs:isDefinedBy northwind:Employee (employees.FirstName, employees.LastName, employees.EmployeeID) .

                northwind:EmployeePhoto(employees.EmployeeID)
                        a northwind:EmployeePhoto
                                as virtrdf:Employee-employees.EmployeePhotoId ;
                        rdfs:isDefinedBy northwind:employeephoto_iri (employees.EmployeeID) ;
                        rdfs:isDefinedBy northwind:EmployeePhoto (employees.EmployeeID) .

                northwind:Employee (employees.FirstName, employees.LastName, orders.EmployeeID)
                        northwind:is_salesrep_of
                northwind:Order (orders.OrderID) where (^{orders.}^.EmployeeID = ^{employees.}^.EmployeeID) as virtrdf:Order-is_salesrep_of .

                northwind:Country (employees.Country)
                        northwind:is_country_of
                northwind:Employee (employees.FirstName, employees.LastName, employees.EmployeeID) as virtrdf:Employee-is_country_of .

                northwind:Order (orders.OrderID)
                        a northwind:Order
                                as virtrdf:Order-Order ;
                        northwind:has_customer northwind:Customer (orders.CustomerID)
                                as virtrdf:Order-order_has_customer ;
                        northwind:has_salesrep northwind:Employee (employees.FirstName, employees.LastName, orders.EmployeeID) where (^{orders.}^.EmployeeID = ^{employees.}^.EmployeeID)
                                as virtrdf:Customer-has_salesrep ;
                        northwind:has_employee northwind:Employee (employees.FirstName, employees.LastName, orders.EmployeeID) where (^{orders.}^.EmployeeID = ^{employees.}^.EmployeeID)
                                as virtrdf:Order-order_has_employee ;
                        northwind:orderDate orders.OrderDate
                                as virtrdf:Order-order_date ;
                        northwind:requiredDate orders.RequiredDate
                                as virtrdf:Order-required_date ;
                        northwind:shippedDate orders.ShippedDate
                                as virtrdf:Order-shipped_date ;
                        northwind:order_ship_via northwind:Shipper (orders.ShipVia)
                                as virtrdf:Order-order_ship_via ;
                        northwind:freight orders.Freight
                                as virtrdf:Order-freight ;
                        northwind:shipName orders.ShipName
                                as virtrdf:Order-ship_name ;
                        northwind:shipAddress orders.ShipAddress
                                as virtrdf:Order-ship_address ;
                        northwind:shipCity orders.ShipCity
                                as virtrdf:Order-ship_city ;
                        northwind:dbpedia_shipCity northwind:dbpedia_iri(orders.ShipCity)
                                as virtrdf:Order-dbpediaship_city ;
                        northwind:shipRegion orders.ShipRegion
                                as virtrdf:Order-ship_region ;
                        northwind:shipPostal_code orders.ShipPostalCode
                                as virtrdf:Order-ship_postal_code ;
                        northwind:shipCountry northwind:Country(orders.ShipCountry)
                                as virtrdf:ship_country ;
                        rdfs:isDefinedBy northwind:order_iri (orders.OrderID) ;
                        rdfs:isDefinedBy northwind:Order (orders.OrderID) .

                northwind:Country (orders.ShipCountry)
                        northwind:is_ship_country_of
                northwind:Order (orders.OrderID) as virtrdf:Order-is_country_of .

                northwind:Customer (orders.CustomerID)
                        northwind:has_order northwind:Order (orders.OrderID) as virtrdf:Order-has_order .

                northwind:Shipper (orders.ShipVia)
                        northwind:ship_order northwind:Order (orders.OrderID) as virtrdf:Order-ship_order .

                northwind:OrderLine (order_lines.OrderID, order_lines.ProductID)
                        a northwind:OrderLine
                                as virtrdf:OrderLine-OrderLines ;
                        northwind:has_order_id northwind:Order (order_lines.OrderID)
                                as virtrdf:order_lines_has_order_id ;
                        northwind:has_product_id northwind:Product (order_lines.ProductID)
                                as virtrdf:order_lines_has_product_id ;
                        northwind:unitPrice order_lines.UnitPrice
                                as virtrdf:OrderLine-unit_price ;
                        northwind:quantity order_lines.Quantity
                                as virtrdf:OrderLine-quantity ;
                        northwind:discount order_lines.Discount
                                as virtrdf:OrderLine-discount ;
                        rdfs:isDefinedBy northwind:orderline_iri (order_lines.OrderID, order_lines.ProductID) ;
                        rdfs:isDefinedBy northwind:OrderLine (order_lines.OrderID, order_lines.ProductID) .

                northwind:Order (orders.OrderID)
                        northwind:is_order_of
                northwind:OrderLine (order_lines.OrderID, order_lines.ProductID) where (^{orders.}^.OrderID = ^{order_lines.}^.OrderID) as virtrdf:Order-is_order_of .

                northwind:Product (products.ProductID)
                        northwind:is_product_of
                northwind:OrderLine (order_lines.OrderID, order_lines.ProductID) where (^{products.}^.ProductID = ^{order_lines.}^.ProductID) as virtrdf:Product-is_product_of .

                northwind:Country (countries.Name)
                        a northwind:Country
                                as virtrdf:Country-Type2 ;
                        a wgs:SpatialThing
                                as virtrdf:Country-Type ;
                        owl:sameAs northwind:dbpedia_iri (countries.Name) ;
                        northwind:name countries.Name
                                as virtrdf:Country-Name ;
                        northwind:code countries.Code
                                as virtrdf:Country-Code ;
                        northwind:smallFlagDAVResourceName countries.SmallFlagDAVResourceName
                                as virtrdf:Country-SmallFlagDAVResourceName ;
                        northwind:largeFlagDAVResourceName countries.LargeFlagDAVResourceName
                                as virtrdf:Country-LargeFlagDAVResourceName ;
                        northwind:smallFlagDAVResourceURI northwind:Flag(countries.SmallFlagDAVResourceURI)
                                as virtrdf:Country-SmallFlagDAVResourceURI ;
                        northwind:largeFlagDAVResourceURI northwind:Flag(countries.LargeFlagDAVResourceURI)
                                as virtrdf:Country-LargeFlagDAVResourceURI ;
                        wgs:lat countries.Lat
                                as virtrdf:Country-Lat ;
                        wgs:long countries.Lng
                                as virtrdf:Country-Lng ;
                        rdfs:isDefinedBy northwind:country_iri (countries.Name) ;
                        rdfs:isDefinedBy northwind:Country (countries.Name) .

                northwind:Country (countries.Name)
                        northwind:has_province
                northwind:Province (provinces.CountryCode, provinces.Province) where (^{provinces.}^.CountryCode = ^{countries.}^.Code) as virtrdf:Country-has_province .

                northwind:Province (provinces.CountryCode, provinces.Province)
                        a northwind:Province
                                as virtrdf:Province-Provinces ;
                        northwind:has_country_code provinces.CountryCode
                                as virtrdf:has_country_code ;
                        northwind:provinceName provinces.Province
                                as virtrdf:Province-ProvinceName ;
                        rdfs:isDefinedBy northwind:province_iri (provinces.CountryCode, provinces.Province) ;
                        rdfs:isDefinedBy northwind:Province (provinces.CountryCode, provinces.Province) .

                northwind:Province (provinces.CountryCode, provinces.Province)
                        northwind:is_province_of
                northwind:Country (countries.Name) where  (^{countries.}^.Code = ^{provinces.}^.CountryCode) as virtrdf:Province-country_of .
        }.
}.
;
]]></programlisting>
<para>The created RDF View is sufficient for querying relational data via SPARQL but not for accessing data by dereferencing IRIs of subjects. Making IRIs dereferenceable requires configuring HTTP server; that is explained in <link linkend="rdfsparqlexnpointnorthwindexample">second part of the example</link>.</para>
</sect2>
<sect2 id="rdfviewconfiguringrdfstorages"><title>Configuring RDF Storages</title>
<para>
&quot;<emphasis>Quad Storage</emphasis>&quot; is a named set of quad map patterns.
The declaration <emphasis>define input:storage storage-name</emphasis> states that a SPARQL query will be executed using only quad patterns of the given quad storage.
Declarations of IRI classes, literal classes and quad patterns are shared between all quad storages of an RDF meta schema but every quad storage contains only a subset of all available quad patterns.
Two quad storages are always defined:
</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem>A <emphasis>virtrdf:default</emphasis> one usually consists of everything (all user-relational mappings plus <emphasis>virtrdf:DefaultQuadMap</emphasis> for &quot;native-form&quot; quads from <emphasis>DB.DBA.RDF_QUAD</emphasis>)
</listitem><listitem>A <emphasis>virtrdf:empty</emphasis> storage refers solely to <emphasis>DB.DBA.RDF_QUAD</emphasis> and can not be altered.
</listitem></itemizedlist>
<para>
Three statements for manipulating storages are
</para>
<itemizedlist mark="number" spacing="compact">
<listitem><emphasis>create quad storage storage-name { quad-map-decls } .</emphasis>
</listitem><listitem><emphasis>alter quad storage storage-name { quad-map-decls-or-drops } .</emphasis>
</listitem><listitem><emphasis>drop quad storage storage-name . </emphasis>
</listitem></itemizedlist>
<para>
A map pattern can be created only as a part of <emphasis>create quad storage</emphasis> or <emphasis>alter quad storage</emphasis> statement, so initially it is used by exactly one storage.
It can be imported to some other storage using directive <emphasis>create map-id using storage source-storage</emphasis>. E.g., declarations of many storages create <emphasis>virtrdf:DefaultQuadMap</emphasis> using storage <emphasis>virtrdf:DefaultQuadStorage</emphasis>.
</para><para>
Only a &quot;top-level&quot; quad map pattern (standalone or a whole group with descendants) can be imported, member of a group can not.
The import directive also can not be a part of some group declaration.
</para><para>
The directive <emphasis>drop quad map map-name</emphasis> removes a map from one storage when it appears inside <emphasis>alter quad storage</emphasis> statement.
Otherwise it removes the map from all storages.
There exists garbage collection for quad map patterns, so any unused map is immediately deleted.
A group is deleted with all its descendants.
</para>
</sect2>
<sect2 id="rdfviewtranslationofpatterns"><title>Translation Of SPARQL Triple Patterns To Quad Map Patterns</title>
<para>
When a SPARQL query is compiled into SQL using a quad storage, every triple pattern should become a subquery that retrieves data from relational tables.
This subquery is an <emphasis>UNION ALL</emphasis> of joins generated from appropriate quad map patterns.
The complete SQL query is composed from these basic subqueries.
Thus the first operation of the SQL generation for a triple pattern is searching for quad map patterns that may in principle produce triples that match the triple pattern.
</para><para>
The more restrictions contained in the triple pattern the fewer quad map patterns will be used.
A triple pattern <emphasis>graph ?g { ?s ?p ?o }</emphasis> is common enough to invoke all data transformations of the storage.
A triple pattern <emphasis>graph &lt;g&gt; { ?s &lt;p&gt; &lt;o&gt; }</emphasis> will usually intersect with the range of only one quad map.
Sometimes it is possible to prove that the storage can not contain any data that matches the given triple pattern, hence zero number of members of <emphasis>UNION ALL</emphasis> will result in constantly empty result-set.
</para>
<para>The search for quad maps for a given pair of triple pattern and quad map storage is quite simple.
The storage is treated as a tree of map patterns where quad map patterns are leafs, grouping patterns are inner nodes and the whole storage is also treated as a grouping pattern that specify no fields and contains all top-level map patterns of the storage.
</para>
<para>
The tree is traversed from the root, left to right, non-leaf vertex are checked before their children.
The check of a vertex consists of up to four field checks, for G, S, P and O.
Every field check compares the field definition in the vertex and the corresponding field in the triple pattern, G and G, S and S and so on.
Note that a non-leaf vertex defines less than four of its fields, e.g., the root vertex does not define any of its fields and top-level <emphasis>graph map { ... }</emphasis> defines only graph.
Checks are performed only for defined fields and return one of three values: &quot;failed&quot;, &quot;passed&quot;, &quot;full match&quot;, according to the following rules:
</para>
<table><title>Matching Triple Field and Vertex Field</title>
<tgroup cols="3">
<thead><row>
<entry>Field of vertex</entry><entry>Field in triple pattern</entry><entry>Result</entry>
</row></thead>
<tbody>
<row><entry>constant</entry><entry>same constant</entry><entry>full match</entry></row>
<row><entry>constant</entry><entry>different constant</entry><entry>failed</entry></row>
<row><entry>constant</entry><entry>variable of same type</entry><entry>passed</entry></row>
<row><entry>constant</entry><entry>variable of different type</entry><entry>failed</entry></row>
<row><entry>quad map value</entry><entry>constant of same type</entry><entry>full match</entry></row>
<row><entry>quad map value</entry><entry>constant of different type</entry><entry>failed</entry></row>
<row><entry>quad map value of type X</entry><entry>variable, X or subtype of X</entry><entry>full match</entry></row>
<row><entry>quad map value of type X</entry><entry>variable, supertype of X</entry><entry>passed</entry></row>
<row><entry>quad map value of type X</entry><entry>variable, type does not intersect with X</entry><entry>failed</entry></row>
</tbody>
</tgroup>
</table>
<para>
If any of the checks fails, the vertex and all its children are excluded from the rest of processing.
Otherwise, if all four fields are defined for the quad map pattern, the map is added to the list of matching map patterns.
The difference between &quot;passed&quot; and &quot;full match&quot; is significant only if the map is declared with <emphasis>option (exclusive)</emphasis>
If all performed checks return &quot;full match&quot; and <emphasis>option (exclusive)</emphasis> is set then the traverse of the tree is stopped as soon as all children of the vertex are traversed.
The most typical use of this option is when the application developer is sure that all triples of a graph belong to his application and they come from his own quad map patterns, not from <emphasis>DB.DBA.RDF_QUAD</emphasis>.
This is to prevent the SPARQL compiler from generating redundant subqueries accessing <emphasis>DB.DBA.RDF_QUAD</emphasis>.
The declaration may look like
</para>
<programlisting><![CDATA[
create quad storage <mystorage>
  {
    graph <mygraph> option (exclusive) { . . . }
    create virtrdf:DefaultQuadMap
      using storage virtrdf:DefaultQuadStorage .
  }
]]></programlisting>
<para>
Exclusive patterns make the order of declarations important, because an exclusive declaration may &quot;throw a shadow&quot; on declarations after it.
Consider a database that have a special table RDF_TYPE that caches all RDF types of all subjects in all graphs.
Consider two declarations: all triples from graph <emphasis>&lt;http://myhost/sys&gt;</emphasis> and all triples with <emphasis>rdf:type</emphasis> predicate, both exclusive:
</para>
<programlisting><![CDATA[
graph <http://myhost/sys> option (exclusive)
  {
    . . . # mapping of DB.DBA.SYS_USERS as in previous examples.
  }
graph rdfdf:default-iid-nonblank (DB.DBA.RDF_TYPE.G)
subject rdfdf:default-iid (DB.DBA.RDF_TYPE.S)
predicate rdf:type
object rdfdf:default (DB.DBA.RDF_TYPE.O)
option (exclusive)
]]></programlisting>
<para>
The order of these declarations dictates that triple pattern
</para>
<programlisting><![CDATA[
graph <http://myhost/sys> {?s rdf:type ?o}
]]></programlisting>
<para>
is compiled using only quad map patterns of the graph declaration, ignoring second declaration (and of course ignoring default mapping rule, if any).
An explicit <emphasis>option (order N)</emphasis> at the end of quad map pattern will tweak the priority.
By default, order will grow from 1000 for the first declaration in the statement to 1999 for the last, explicit configuration is especially useful to make order persistent to <emphasis>alter storage</emphasis> statements.
</para>
<para>
The <emphasis>option (exclusive)</emphasis> trick is ugly, low-level and prone to cause compilation errors after altering storage declarations.
When misused, it is as bad as &quot;red cut&quot; in PROLOG, but one must use this trick to build scalable storages.
</para>
<para>The <emphasis>option (exclusive)</emphasis> helps the SPARQL compiler to prepare better SQL queries, but sometimes it is &quot;too exclusive&quot;. For instance, if a grouping quad map pattern specify only quad map value for graph and no other fields then making it exclusive prohibits the use of all declarations of the storage after that one. Sometimes it is better to notify compiler that quads made by the given quad map pattern are supposed to be different from all quads made by declarations listed after the given one.</para>

<para>Consider an application that exports users&apos; personal data
as graphs whose IRIs looks like
<emphasis>http://www.example.com/DAV/home/</emphasis>username<emphasis>/RDF/personal/</emphasis>;
the application makes a query and a triple pattern is proven to be
restrictive enough to filter out all quads that are not similar to
quads generated by the given quad map pattern (say, the graph is
constant
<emphasis>http://www.example.com/DAV/home/JohnSmith/RDF/personal/</emphasis>). The
application do not hope to find any quads that match the pattern but
made by other applications, because graphs named like in the pattern
are supposed to be solely for this single purpose; if, say,
DB.DBA.RDF_QUAD occasionally contains some quads with graph equal to
<emphasis>http://www.example.com/DAV/home/JohnSmith/RDF/personal/</emphasis>
then they can be ignored.</para>

<para>Under this circumstances, the quad map pattern may have <emphasis>option (soft exclusive)</emphasis>. That grants a permission to the compiler to ignore rest of storage as soon as it is proven that the triple pattern can not access quads that does not match the pattern. So if that is proven then the pattern is exclusive and it makes the query faster; when unsure, the complier work like there is no option at all.</para>


<note><para>The <emphasis>option (exclusive)</emphasis> can be used as
a security measure, <emphasis>option (soft exclusive)</emphasis> can
not. Say, if an financial application exports its data as a single
graph <emphasis>http://www.example.com/front-office/cash/</emphasis>
using <emphasis>exclusive</emphasis> then the query that explicitly
refers to that graph will never access any quads written by the
attacker into DB.DBA.RDF_QUAD using same graph IRI. The use of
<emphasis>soft exclusive</emphasis> gives no such protection. From the
compiler's perspective, the <emphasis>option (soft
exclusive)</emphasis> is a hint that may be ignored, not an
unambiguous order.</para></note>

<para>
There is one exception from the rules described above.
This exception is for <emphasis>virtrdf:DefaultQuadStorage</emphasis> only.
If a graph variable of a quad map pattern is not bound and no source graph specified by <emphasis>FROM</emphasis> clauses then quad maps for specific constant graphs are ignored.
In other words, if a default quad storage contains quad maps for specific graphs then the query in that storage should explicitly specify the graph in order to use a map for graph.
This rule will not work if the default quad map is removed from the <emphasis>virtrdf:DefaultQuadStorage</emphasis>.
This rule relates to the default storage itself, not to the containing patterns; copying some or all patterns into other storage will not reproduce there this special effect.
</para>
</sect2>
<sect2 id="rdfviewdescribingsourcerelationaltables"><title>Describing Source Relational Tables</title>
<para>Quad map patterns of an application usually share a common set of source tables and quad map values of one pattern usually share either a single table or very small number of joined tables.
Join and filtering conditions are also usually repeated in different patterns.
It is not necessary to type table descriptions multiple times, they are declare once in the beginning of storage declaration statement and shared between all quad map declarations inside the statement.
Names of aliases can be used instead of table names in quad map values.
</para>
<programlisting><![CDATA[
from DB.DBA.SYS_USERS as user where (^{user.}^.U_IS_ROLE = 0)
from DB.DBA.SYS_USERS as group where (^{group.}^.U_IS_ROLE = 1)
from DB.DBA.SYS_USERS as account
from user as active_user
  where (^{active_user.}^.U_ACCOUNT_DISABLED = 0)
from DB.DBA.SYS_ROLE_GRANTS as grant
  where (^{grant.}^.GI_SUPER = ^{account.}^.U_ID)
  where (^{grant.}^.GI_SUB = ^{group.}^.U_ID)
  where (^{grant.}^.GI_SUPER = ^{user.}^.U_ID)
]]></programlisting>
<para>
This declares five distinct aliases for two distinct tables, and six filtering conditions.
Every condition is an SQL expression with placeholders where a reference to the table should be printed.
The SPARQL compiler will not try to parse texts of these expressions (except dummy search for placeholders), so any logical expressions are acceptable.
When a quad map pattern declaration refers to some aliases, the <emphasis>WHERE</emphasis> clause of the generated SQL code will contain a conjunction of all distinct texts of &quot;relevant&quot; conditions.
A condition is relevant if every alias inside the condition is used in some quad map value of the map pattern, either directly or via clause like <emphasis>from user as active_user</emphasis>.
(<emphasis>user</emphasis> is a &quot;<emphasis>base alias</emphasis>&quot; for <emphasis>active_user</emphasis>).
</para><para>
Consider a group of four declarations.
</para>
<programlisting><![CDATA[
graph <http://myhost/sys>
  {
    oplsioc:user_iri (active_user.U_ID)
        a oplsioc:active-user .
    oplsioc:membership_iri (grant.GI_SUPER, grant.GI_SUB).
        oplsioc:is_direct
            grant.GI_DIRECT ;
        oplsioc:member-e-mail
            active_user.U_E_MAIL
               where (^{active_user.}^.U_E_MAIL like 'mailto:%').
    ldap:account-ref (account.U_NAME)
        ldap:belongs-to
            ldap:account-ref (group.U_NAME) option (using grant).
  }
]]></programlisting>
<para>
The first declaration will extend <emphasis>&lt;http://myhost/sys&gt;</emphasis> graph with one imaginary triples <emphasis>{ user a oplsioc:active-user }</emphasis> for every account record that is not a role and not disabled.
The second declaration deals with membership records.
A membership is a pair of a grantee (&quot;super&quot;) and a granted role (&quot;sub&quot;) stored as a row in <emphasis>DB.DBA.SYS_ROLE_GRANTS</emphasis>).
</para><para>
The second declaration states that every membership has <emphasis>oplsioc:is_direct</emphasis> property with value from <emphasis>GI_DIRECT</emphasis> column of that table (roles may be granted to other roles and users, so permissions are &quot;direct&quot; or &quot;recursive&quot;).
</para><para>
The third declaration declares <emphasis>oplsioc:member-e-mail</emphasis> property of memberships.
The value is a literal string from <emphasis>DB.DBA.SYS_USERS.U_E_MAIL</emphasis>, if the grantee is active (not disabled) and is not a role and its e-mail address starts with <emphasis>'mailto:'</emphasis>.
The join between <emphasis>DB.DBA.SYS_ROLE_GRANTS</emphasis> and <emphasis>DB.DBA.SYS_USERS</emphasis> is made by equality <emphasis>(GI_SUPER = U_ID)</emphasis> because the alias <emphasis>active_user</emphasis> in the declaration &quot;inherits&quot; all conditions specified for <emphasis>user</emphasis>.
In addition, the SPARQL compiler will add one more condition to check if the <emphasis>U_E_MAIL</emphasis> is not null because the NULL value is not a valid object and it knows that <emphasis>U_E_MAIL</emphasis> is not declared as <emphasis>NOT NULL</emphasis>.
</para><para>
The last declaration contains an <emphasis>option</emphasis> clause.
As usual, this indicates that the basic functionality is good for many tasks but not for all.
In this declaration, the <emphasis>ldap:belongs-to</emphasis> property establishes a relation between grantee (subject) and a granted role (object).
Both subject and object IRIs are based on account name, <emphasis>DB.DBA.SYS_USERS.U_NAME</emphasis>, so the quad map pattern contains two references to different aliases of <emphasis>DB.DBA.SYS_USERS</emphasis> but no alias for <emphasis>DB.DBA.SYS_ROLE_GRANTS</emphasis>.
Hence the declaration could produce a triple for every row of the Cartesian product of the <emphasis>DB.DBA.SYS_USERS</emphasis>.
To fix the problem, <emphasis>option (using alias-name)</emphasis> tells the compiler to process the alias-name as if it's used in some quad map value of the pattern.
</para><para>
It is an error to use an alias only in <emphasis>where</emphasis> clause of the quad map pattern but neither in values or in <emphasis>option (using alias-name)</emphasis>.
To detect more typos, an alias used in quad map values can not appear in <emphasis>option (using alias-name)</emphasis> clause.
</para>
</sect2>
<sect2 id="rdfviewiriusingfunction"><title>Function-Based IRI Classes</title>
<para>Most of IRI classes can be declared by a sprintf format string, but sophisticated cases may require calculations, not only printing the string. <emphasis>create IRI class using function</emphasis> allows the application transform relational values to IRIs by any custom routines.</para>
<para>
Let us extend the previous example about users and groups by a new class for grantees. Both users and groups are grantees and we have defined two IRI classes for them. Classes <emphasis>oplsioc:user_iri</emphasis> and <emphasis>oplsioc:group_iri</emphasis> work fine for quad maps of <emphasis>U_ID</emphasis> if and only if the value of <emphasis>U_IS_ROLE</emphasis> is accordingly restricted to FALSE or TRUE, otherwise one may occasionally generate, say, user IRI for a group.
To create and parse IRIs that correspond to any U_IDs, two functions should be created:
</para>
<programlisting><![CDATA[
create function DB.DBA.GRANTEE_URI (in id integer)
returns varchar
{
  declare isrole integer;
  isrole := coalesce ((select top 1 U_IS_ROLE
      from DB.DBA.SYS_USERS where U_ID = id ) );
  if (isrole is null)
    return NULL;
  else if (isrole)
    return sprintf ('http://%s/sys/group?id=%d', id);
  else
    return sprintf ('http://%s/sys/user?id=%d', id);
};
]]></programlisting>
<programlisting><![CDATA[
create function DB.DBA.GRANTEE_URI_INVERSE (in id_iri varchar)
returns integer
{
  declare parts any;
  parts := sprintf_inverse (id_iri,
      'http://myhost/sys/user?id=%d', 1 );
  if (parts is not null)
    {
      if (exists (select top 1 1 from DB.DBA.SYS_USERS
          where U_ID = parts[0] and not U_IS_ROLE ) )
        return parts[0];
    }
  parts := sprintf_inverse (id_iri,
      'http://myhost/sys/group?id=%d', 1 );
  if (parts is not null)
    {
      if (exists (select top 1 1 from DB.DBA.SYS_USERS
          where U_ID = parts[0] and U_IS_ROLE ) )
        return parts[0];
    }
  return NULL;
};
]]></programlisting>
<para>These functions may be more useful if the SPARQL web service endpoint is allowed to use them:</para>
<programlisting><![CDATA[
grant execute on DB.DBA.GRANTEE_URI to "SPARQL";
grant execute on DB.DBA.GRANTEE_URI_INVERSE to "SPARQL";
]]></programlisting>
<para>
The next declaration creates an IRI class based on these two functions:
</para>
<programlisting><![CDATA[
create iri class oplsioc:grantee_iri using
  function DB.DBA.GRANTEE_URI (in id integer)
    returns varchar,
  function DB.DBA.GRANTEE_URI_INVERSE (in id_iri varchar)
    returns integer .
]]></programlisting>
<para>
In common case, IRI class declaration contains an N-array function that composes IRIs and N inverse functions that gets an IRI as an argument and extracts the Nth SQL value.
IRI composing function should silently return NULL on incorrect arguments instead of error signal.
Inverse functions should return NULL if the argument has an incorrect type or value.
</para>
<para>
It is possible to specify only composing function without any of inverse functions. However <emphasis>option (bijection)</emphasis> can not be used in that case, obviously.
</para>
</sect2>
<sect2 id="rdfconnvarsiniriclasses"><title>Connection Variabes in IRI Classes</title>
<para>Writing function-based IRI class is overkill when the IRI can in principle be made by a <link linkend="fn_sprintf_iri"><function>sprintf_iri</function></link> but the format should contain some context-specific data, such as host name used for the <link linked="rdfdynamiclocal">dynamic renaming of local IRIs</link>.
Format strings offer a special syntax for that cases.
<emphasis>%{varname}U</emphasis> acts as <emphasis>%U</emphasis> but the function <link linkend="fn_sprintf"><function>sprintf</function></link> will take the value from client connection variable <emphasis>varname</emphasis>, not from list of arguments.
Similarly, <link linkend="fn_sprintf_inverse"><function>sprintf_inverse</function></link> will not return fragment that match to <emphasis>%{varname}U</emphasis> in the vector of other fragments; instead it will get the value from connection environment and ensure that it matches the fragment of input; mismatch between printed and actual value of variable will means that the whole string do not match the format.</para>
<para>SPARQL optimizer knows about this formatting feature and sometimes it makes more deductions from occurence of <emphasis>%{varname}U</emphasis> than from occurence of plain <emphasis>%U</emphasis>, so this notation may be used in <emphasis>option ( returns ...)</emphasis> when appropriate.
Of course, the optimizer has no access to the actual value of conection variabe because it may vary from run to run or may change between the compilation and the run, but the value is supposed to be persistent during any single query run so <emphasis>%{myvariable}U</emphasis> in one place is equal to <emphasis>%{myvariable}U</emphasis> in other.</para>
<para>Connection variables are set by <link linkend="fn_connection_set"><function>connection_set</function></link> and some of them have default values that are used if not overridden by application:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem><emphasis>URIQADefaultHost</emphasis> is for default host as it is specified in Virtuoso configuration file.
Note, however, that it will be escaped when printed so if it contains colon and port number then the colon is escaped.
In addition, there are special variables that match dynamic renaming of local IRIs more accurately.</listitem>
<listitem><emphasis>WSHost</emphasis> is for host and port as it is used by current client connection for dynamic renaming.
The colon before port will be escaped.</listitem>
<listitem><emphasis>WSHostName</emphasis> is for host name only, without port, as it is used by current client connection for dynamic renaming.</listitem>
<listitem><emphasis>WSHostPort</emphasis> is for port part of host IRI. That is string, not integer. The only real use of the variable is in formats like <emphasis>http://%{WSHostName}U:%{WSHostPort}U/...</emphasis>.</listitem>
</itemizedlist>

<para>It is inconvenient to write different format strings for
different cases.  Two most common policies are different host names
for default HTTP port of a publicly available service and different
non-default ports for one or more host names of an intranet
instalation; these two approaches are almost never used in a mix. So
declaration of IRI classes may use shorthand
<emphasis>^{DynamicLocalFormat}^</emphasis> in format strings that is
expanded either to <emphasis>http://%{WSHost}U</emphasis> or to
<emphasis>http://%{WSHostName}U:%{WSHostPort}U/...</emphasis>,
depending on absence or presence of port number in the value of
<emphasis>DefaultHost</emphasis> parameter of
<emphasis>URIQA</emphasis> section of configuration file.</para>

<note><para><emphasis>^{DynamicLocalFormat}^</emphasis> is for IRI class declarations only and is not expanded in any other place, so it is useful sometimes to create an IRI class with empty argument list in order to get &quot;almost constant&quot; IRIs calculated without writing special procedures.</para></note>
</sect2>
<sect2 id="rdfviewbijandreturns"><title>Lookup Optimization -- BIJECTION and RETURNS Options</title>
<para>
There is one subtle problem with IRI class declarations.
To get benefit from a relational index, SPARQL optimizer should compose equality between table column and some known SQL value, not between return value of IRI class and a known composed IRI.
In addition, redundant calculations of IRIs takes time.
To enable this optimization, an IRI class declaration should end with <emphasis>option (bijection)</emphasis> clause. For some simple format strings the compiler may recognize the bijection automatically but an explicit declaration is always a good idea.
</para>
<note><title>Note:</title>
<para>
See also: <ulink url="http://en.wikipedia.org/wiki/One-to-one_correspondence">Wikipedia - Bijection</ulink>.
In mathematics, a bijection, or a bijective function is a function f from a set X to a set Y such that,
for every y in Y, there is exactly one x in X such that f(x) = y.
</para>
<para>
Alternatively, f is bijective if it is a one-to-one correspondence between those sets; i.e.,
both one-to-one (injective) and onto (surjective).
</para>
</note>
<para>
The SPARQL compiler may produce big amounts of SQL code when the query contains equality of two calculated IRIs and these IRIs may come from many different IRI classes.
It is possible to provide hints that will let the compiler check if two IRI classes form disjoint sets of possible IRI values. The more disjoint sets are found the less possible combinations remain so the resulting SQL query will contain fewer unions of joins.
The SPARQL compiler can prove some properties of sprintf format strings. E.g., it can prove that set of all strings printed by &quot;http://example.com/item%d&quot; and the set of strings printed by &quot;http://example.com/item%d/&quot; are disjoint.
It can prove some more complicated statements about unions and intersections of sets of strings.
The IRI or literal class declaration may contain <emphasis>option (returns ...)</emphasis> clause that will specify one or more sprintf patterns that cover the set of generated values.
Consider a better version of IRI class declaration listed above:
</para>
<programlisting><![CDATA[
create iri class oplsioc:grantee_iri using
  function DB.DBA.GRANTEE_URI (in id integer)
    returns varchar,
  function DB.DBA.GRANTEE_URI_INVERSE (in id_iri varchar)
    returns integer
  option ( bijection,
    returns "http://myhost/sys/group?id=%d"
    union   "http://myhost/sys/user?id=%d" ) .
]]></programlisting>
<para>
It is very important to keep IRI classes easily distinguishable by the text of IRI string and easy to parse.
</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem>Format <emphasis>%U</emphasis> is better than <emphasis>%s</emphasis>, especially in the middle of IRI, because the <emphasis>%U</emphasis> fragment can not contain characters like &quot;/&quot; or &quot;=&quot;; one may prove that <emphasis>/%U/</emphasis> and <emphasis>/abra%d/cadabra/</emphasis> are disjoint but <emphasis>/%s/</emphasis> and <emphasis>/abra%d/cadabra/</emphasis> are not disjoint.
</listitem><listitem>It is better when the variable part like <emphasis>%U</emphasis> or <emphasis>%d</emphasis> is placed between characters that may not occur in the <emphasis>%U</emphasis> or <emphasis>%d</emphasis> output, i.e. <emphasis>%U</emphasis> is placed between &quot;/&quot;, &quot;&amp;&quot; or &quot;=&quot; and <emphasis>%d</emphasis> is placed between non-digits; <emphasis>order_line_%d</emphasis> is better than <emphasis>order-line-%d</emphasis> because minus may be part of <emphasis>%d</emphasis> output.
</listitem><listitem>End-of-line is treated as a special character, so placing <emphasis>%U</emphasis> or <emphasis>%d</emphasis> between &quot;/&quot; and end of line is as good as placing it between two &quot;/&quot;.
</listitem></itemizedlist>
<para>
In some cases <emphasis>option (returns ...)</emphasis> can be used for IRI classes that are declared using sprintf format, but actual data have more specific format.
Consider a literal class declaration that is used to output strings and the application knows that all these strings are ISBN numbers:
</para>
<programlisting><![CDATA[
create literal class example:isbn_ref "%s" (in isbn varchar not null)
  option ( bijection, returns "%u-%u-%u-%u" union "%u-%u-%u-X" )
]]></programlisting>
<para>
Sometimes interoperability restrictions will force you to violate these rules but please try to follow them as often as possible.
</para>
</sect2>
<sect2 id="rdfviewsubclasses"><title>Join Optimization -- Declaring IRI Subclasses</title>
<para>
Additional problem appears when the equality is between two IRIs of two different IRI classes.
Even if both of them are bijections, the compiler does not know if these IRI classes behave identically on the intersection of their domains.
To let the optimizer know this fact, one IRI class can be explicitly declared as a subclass of another:
</para>
<programlisting><![CDATA[
make oplsioc:user_iri subclass of oplsioc:grantee_iri .
make oplsioc:group_iri subclass of oplsioc:grantee_iri .
]]></programlisting>
<para>
The SPARQL compiler can not check the validity of a subclass declaration.
The developer should carefully test functions to ensure that transformations are really subclasses, as well as to ensure that functions of an IRI class declarations are really inverse to each other.
</para><para>
When declaring that a table's primary key is converted into a IRI according to one IRI class, one usually declares that all foreign keys referring to this class also get converted into an IRI as per this same class, or subclass of same class.
</para><para>
Subclasses can be declared for literal classes as well as for IRI classes, but this case is rare. The reason is that most of literals are made by identity literal classes that are disjoint to each other even if values may be equal in SQL sense, such as <emphasis>"2"</emphasis> of type <emphasis>xsd:integer</emphasis> and <emphasis>"2.0"</emphasis> of type <emphasis>xsd:double</emphasis>.
</para>
</sect2>
<sect2 id="rdfmetadatarecovery"><title>RDF Metadata Maintenance and Recovery</title>
   <para>
This section refers to checking and backing up RDF view and storage declarations only.  The checks and backup/restore do not affect physical quads, relational schema or tables or data therein.  For general backup and restore, see server administration.
     To detect and fix automatically most popular sorts of RDF metadata corruption use <link linkend="fn_rdf_audit_metadata"><function>DB.DBA.RDF_AUDIT_METADATA</function></link>.
It is also possible to backup RDF data by
    <link linkend="fn_rdf_backup_metadata"><function>DB.DBA.RDF_BACKUP_METADATA</function></link>
and restore the saved state later by using
    <link linkend="fn_rdf_restore_metadata"><function>DB.DBA.RDF_RESTORE_METADATA</function></link>.
It is convenient to make a backup before any modification of quad storages, quad map patterns or IRI classes, especially during debugging new RDF Views.
   </para>
<note><para>In SQL, adding a new view can not break anything. This is because SQL lacks the ability of querying &quot;everything&quot; so data sources are always specified. This is not true for SPARQL, so please treat <emphasis>any</emphasis> metadata manipulation as potentially destructive operation. If an RDF storage is supposed to be used by more than one application then these applications should be tested together, not one after other, and they should be installed/upgraded on live database in the very same order as they were installed/upgraded on istrumental machine during testing. Always remember that these applications share RDF tables so they may interfere.</para></note>
</sect2>
<sect2 id="splitrdfview"><title>Split RDF View</title>
<para>RDF View can be created by two or more "sparql alter storage" statements. In each statement
can be created one quad map that contains mappings for half or a third of all tables. Quad maps
created should have distinct names but may mention same graph. The important fact is that if the
RDF View in question is exclusive for a graph then only the last quad map should be exclusive but
all previous should not have this option. This is because if a map is exclusive on a graph the rest
of maps on that graph will be silently ignored.</para>
<para>The example below shows a sample part of the Virtuoso eCRM Views code,
where the RDF view is split in two parts: with quad map virtrdf:ecrmDemo1 and with
quad map virtrdf:ecrmDemo2:</para>
<programlisting><![CDATA[
SPARQL
prefix ecrm: <http://demo.openlinksw.com/schemas/ecrm#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix cal: <http://www.w3.org/2002/12/cal/ical#>
prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
prefix product: <http://www.swop-project.eu/ontologies/pmo/product.owl#>
prefix owl: <http://www.w3.org/2002/07/owl#>
drop quad map virtrdf:ecrmDemo1 .
;

SPARQL
prefix ecrm: <http://demo.openlinksw.com/schemas/ecrm#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix cal: <http://www.w3.org/2002/12/cal/ical#>
prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
prefix product: <http://www.swop-project.eu/ontologies/pmo/product.owl#>
prefix owl: <http://www.w3.org/2002/07/owl#>
drop quad map virtrdf:ecrmDemo2 .
;

...

SPARQL
prefix ecrm: <http://demo.openlinksw.com/schemas/ecrm#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix cal: <http://www.w3.org/2002/12/cal/ical#>
prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
prefix product: <http://www.swop-project.eu/ontologies/pmo/product.owl#>
prefix owl: <http://www.w3.org/2002/07/owl#>
alter quad storage virtrdf:DefaultQuadStorage
from eCRM.DBA.SFA_SALES_QUOTA_VIEW2 as sales_quotas
from eCRM.DBA.SFA_COMPANIES_VIEW2 as companies
from eCRM.DBA.SFA_COMPANIES as companies_table text literal companies_table.DESCRIPTION of (companies.DESCRIPTION)
from eCRM.DBA.SFA_CONTACTS_VIEW2 as contacts
from eCRM.DBA.SFA_CONTACTS as contacts_table text literal contacts_table.NAME_FIRST of (contacts.NAME_FIRST)
from eCRM.DBA.SFA_EMPLOYMENTS_VIEW2 as employments
from eCRM.DBA.SFA_LEADS_VIEW2 as leads
from eCRM.DBA.SFA_LEADS as leads_table text literal leads_table.SUBJECT of (leads.SUBJECT)
from eCRM.DBA.SFA_OPPORTUNITIES_VIEW2 as opportunities
from eCRM.DBA.SFA_OPPORTUNITIES as opportunities_table text literal opportunities_table.OPPORTUNITY_NAME of (opportunities.OPPORTUNITY_NAME)
from eCRM.DBA.SFA_ACTIVITIES as activities
from eCRM.DBA.SFA_MAIL_MESSAGES as messages
from eCRM.DBA.SFA_DOCUMENTS_VIEW2 as documents
from eCRM.DBA.SFA_INFLUENCERS_VIEW2 as influencers
from eCRM.DBA.SFA_TEAMS_VIEW2 as teams
from eCRM.DBA.SFA_NOTES_VIEW2 as notes
from eCRM.DBA.SFA_NOTES as notes_table text literal notes_table.DESCRIPTION of (notes.DESCRIPTION)
from eCRM.DBA.SFA_COMPETITORS_VIEW2 as competitors
from eCRM.DBA.SFA_ISSUES_VIEW2 as issues
from eCRM.DBA.SFA_CUSTOM_FIELD_DEFS_VIEW2 as custom_field_defs
from eCRM.DBA.SFA_CUSTOM_FIELDS_VIEW2 as custom_fields
from eCRM.DBA.SFA_CASES_VIEW2 as cases
from eCRM.DBA.SFA_CASES as cases_table text literal cases_table.SUMMARY of (cases.SUMMARY)
from eCRM.DBA.SFA_ORDERS_VIEW2 as orders
from eCRM.DBA.SFA_ORDERS as orders_table text literal orders_table.EMAIL of (orders.EMAIL)
from eCRM.DBA.SFA_ORDER_ITEMS_VIEW2 as order_items
from eCRM.DBA.PM_CATEGORIES_VIEW2 as categories
from eCRM.DBA.PM_PRODUCT_ATTRIBUTE_DEFS_VIEW2 as product_attribute_defs
from eCRM.DBA.PM_PRODUCTS_VIEW2 as products
from eCRM.DBA.PM_PRODUCTS as products_table text literal products_table.DESCRIPTION of (products.DESCRIPTION)
from eCRM.DBA.PM_PRODUCT_ATTRIBUTES_VIEW2 as product_attributes
from eCRM.DBA.PM_CATALOGS_VIEW2 as catalogs
from eCRM.DBA.PM_CATALOG_PRODUCTS_VIEW2 as catalog_products
from eCRM.DBA.XSYS_MODULES as modules
from eCRM.DBA.XSYS_REGISTRY as registries
from eCRM.DBA.XSYS_ORGANIZATIONS_DATA as organizations_data
from eCRM.DBA.XSYS_MESSAGES as xsysmessages
from eCRM.DBA.XSYS_COUNTRIES_VIEW2 as countries
from eCRM.DBA.XSYS_PROVINCES_VIEW2 as provinces
from eCRM.DBA.XSYS_TIMEZONES as timezones
from eCRM.DBA.XSYS_MIME_TYPES as mimetypes
from eCRM.DBA.XSYS_MIME_EXTENSIONS as mimeexts
from eCRM.DBA.XSYS_CNAMES as cnames
from eCRM.DBA.XSYS_QUOTAS as quotas
from eCRM.DBA.XSYS_ROLES as roles
from eCRM.DBA.XSYS_ACCOUNTS as accounts
from eCRM.DBA.XSYS_USERDATA as userdatas
from eCRM.DBA.XSYS_GROUPDATA as groupdatas
from eCRM.DBA.XSYS_MEMBERS as members
from eCRM.DBA.XSYS_SESSIONS_DATA as sessionsdatas
from eCRM.DBA.XSYS_SESSION_DATA as sessiondatas
from eCRM.DBA.XSYS_LIST_MEMBERS_DEFS as list_members_defs
from eCRM.DBA.XSYS_CLASSES as classes
from eCRM.DBA.XSYS_ORG_CLASSES as org_classes
from eCRM.DBA.XSYS_CLASS_METHODS as class_methods
from eCRM.DBA.XSYS_CLASS_VIEWS as class_views
from eCRM.DBA.XSYS_ROLE_PRIVILEGES as role_priveleges
from eCRM.DBA.XSYS_USER_PRIVILEGES as user_priveleges
from eCRM.DBA.XSYS_HISTORY as history
from eCRM.DBA.XSYS_USERS as xsys_users
from eCRM.DBA.AP_PROCESSES_VIEW2 as ap_processes
from eCRM.DBA.AP_RULES_VIEW2 as ap_rules
from eCRM.DBA.AP_QUEUE as ap_queues
where (^{companies.}^.COUNTRY_NAME = ^{countries.}^.COUNTRY_NAME)
where (^{contacts.}^.COUNTRY_NAME = ^{countries.}^.COUNTRY_NAME)
where (^{leads.}^.COUNTRY_NAME = ^{countries.}^.COUNTRY_NAME)
where (^{products.}^.COUNTRY_NAME = ^{countries.}^.COUNTRY_NAME)
where (^{orders.}^.SHIP_COUNTRY_NAME = ^{countries.}^.COUNTRY_NAME)
where (^{leads_table.}^.FREETEXT_ID = ^{leads.}^.FREETEXT_ID)
where (^{contacts_table.}^.FREETEXT_ID = ^{contacts.}^.FREETEXT_ID)
where (^{companies_table.}^.FREETEXT_ID = ^{companies.}^.FREETEXT_ID)
where (^{opportunities_table.}^.FREETEXT_ID = ^{opportunities.}^.FREETEXT_ID)
where (^{cases_table.}^.FREETEXT_ID = ^{cases.}^.FREETEXT_ID)
where (^{notes_table.}^.FREETEXT_ID = ^{notes.}^.FREETEXT_ID)
where (^{orders_table.}^.FREETEXT_ID = ^{orders.}^.FREETEXT_ID)
where (^{products_table.}^.FREETEXT_ID = ^{products.}^.FREETEXT_ID)
{
        create virtrdf:ecrmDemo1 as graph iri ("http://^{URIQADefaultHost}^/ecrm") option (order 1501)
        {
            ecrm:Country (countries.COUNTRY_NAME)
                a ecrm:Country
                    as virtrdf:Country-Countrys2 ;
                a geo:SpatialThing
                    as virtrdf:Country-Countrys ;
                owl:sameAs ecrm:dbpedia_iri (countries.COUNTRY_NAME) ;
                ecrm:countryID countries.COUNTRY_ID
                        as virtrdf:Country-COUNTRY_ID ;
                ecrm:countryID3 countries.COUNTRY_ID3
                        as virtrdf:Country-COUNTRY_ID3 ;
                ecrm:isoCode countries.ISO_CODE
                        as virtrdf:Country-ISO_CODE ;
                ecrm:countryName countries.COUNTRY_NAME
                        as virtrdf:Country-COUNTRY_NAME .

            ecrm:Country (countries.COUNTRY_NAME)
                        ecrm:has_province
            ecrm:Province (provinces.COUNTRY_ID, provinces.PROVINCE_NAME) where
                        (^{provinces.}^.COUNTRY_ID = ^{countries.}^.COUNTRY_ID) as virtrdf:ecrmCountry-has_province .

...
  } .
} .
;
SPARQL
prefix ecrm: <http://demo.openlinksw.com/schemas/ecrm#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
prefix cal: <http://www.w3.org/2002/12/cal/ical#>
prefix product: <http://www.swop-project.eu/ontologies/pmo/product.owl#>
prefix owl: <http://www.w3.org/2002/07/owl#>
alter quad storage virtrdf:DefaultQuadStorage
from eCRM.DBA.SFA_SALES_QUOTA_VIEW2 as sales_quotas
from eCRM.DBA.SFA_COMPANIES_VIEW2 as companies
from eCRM.DBA.SFA_COMPANIES as companies_table text literal companies_table.DESCRIPTION of (companies.DESCRIPTION)
from eCRM.DBA.SFA_CONTACTS_VIEW2 as contacts
from eCRM.DBA.SFA_CONTACTS as contacts_table text literal contacts_table.NAME_FIRST of (contacts.NAME_FIRST)
from eCRM.DBA.SFA_EMPLOYMENTS_VIEW2 as employments
from eCRM.DBA.SFA_LEADS_VIEW2 as leads
from eCRM.DBA.SFA_LEADS as leads_table text literal leads_table.SUBJECT of (leads.SUBJECT)
from eCRM.DBA.SFA_OPPORTUNITIES_VIEW2 as opportunities
from eCRM.DBA.SFA_OPPORTUNITIES as opportunities_table text literal opportunities_table.OPPORTUNITY_NAME of (opportunities.OPPORTUNITY_NAME)
from eCRM.DBA.SFA_ACTIVITIES as activities
from eCRM.DBA.SFA_MAIL_MESSAGES as messages
from eCRM.DBA.SFA_DOCUMENTS_VIEW2 as documents
from eCRM.DBA.SFA_INFLUENCERS_VIEW2 as influencers
from eCRM.DBA.SFA_TEAMS_VIEW2 as teams
from eCRM.DBA.SFA_NOTES_VIEW2 as notes
from eCRM.DBA.SFA_NOTES as notes_table text literal notes_table.DESCRIPTION of (notes.DESCRIPTION)
from eCRM.DBA.SFA_COMPETITORS_VIEW2 as competitors
from eCRM.DBA.SFA_ISSUES_VIEW2 as issues
from eCRM.DBA.SFA_CUSTOM_FIELD_DEFS_VIEW2 as custom_field_defs
from eCRM.DBA.SFA_CUSTOM_FIELDS_VIEW2 as custom_fields
from eCRM.DBA.SFA_CASES_VIEW2 as cases
from eCRM.DBA.SFA_CASES as cases_table text literal cases_table.SUMMARY of (cases.SUMMARY)
from eCRM.DBA.SFA_ORDERS_VIEW2 as orders
from eCRM.DBA.SFA_ORDERS as orders_table text literal orders_table.EMAIL of (orders.EMAIL)
from eCRM.DBA.SFA_ORDER_ITEMS_VIEW2 as order_items
from eCRM.DBA.PM_CATEGORIES_VIEW2 as categories
from eCRM.DBA.PM_PRODUCT_ATTRIBUTE_DEFS_VIEW2 as product_attribute_defs
from eCRM.DBA.PM_PRODUCTS_VIEW2 as products
from eCRM.DBA.PM_PRODUCTS as products_table text literal products_table.DESCRIPTION of (products.DESCRIPTION)
from eCRM.DBA.PM_PRODUCT_ATTRIBUTES_VIEW2 as product_attributes
from eCRM.DBA.PM_CATALOGS_VIEW2 as catalogs
from eCRM.DBA.PM_CATALOG_PRODUCTS_VIEW2 as catalog_products
from eCRM.DBA.XSYS_MODULES as modules
from eCRM.DBA.XSYS_REGISTRY as registries
from eCRM.DBA.XSYS_ORGANIZATIONS_DATA as organizations_data
from eCRM.DBA.XSYS_MESSAGES as xsysmessages
from eCRM.DBA.XSYS_COUNTRIES_VIEW2 as countries
from eCRM.DBA.XSYS_PROVINCES_VIEW2 as provinces
from eCRM.DBA.XSYS_TIMEZONES as timezones
from eCRM.DBA.XSYS_MIME_TYPES as mimetypes
from eCRM.DBA.XSYS_MIME_EXTENSIONS as mimeexts
from eCRM.DBA.XSYS_CNAMES as cnames
from eCRM.DBA.XSYS_QUOTAS as quotas
from eCRM.DBA.XSYS_ROLES as roles
from eCRM.DBA.XSYS_ACCOUNTS as accounts
from eCRM.DBA.XSYS_USERDATA as userdatas
from eCRM.DBA.XSYS_GROUPDATA as groupdatas
from eCRM.DBA.XSYS_MEMBERS as members
from eCRM.DBA.XSYS_SESSIONS_DATA as sessionsdatas
from eCRM.DBA.XSYS_SESSION_DATA as sessiondatas
from eCRM.DBA.XSYS_LIST_MEMBERS_DEFS as list_members_defs
from eCRM.DBA.XSYS_CLASSES as classes
from eCRM.DBA.XSYS_ORG_CLASSES as org_classes
from eCRM.DBA.XSYS_CLASS_METHODS as class_methods
from eCRM.DBA.XSYS_CLASS_VIEWS as class_views
from eCRM.DBA.XSYS_ROLE_PRIVILEGES as role_priveleges
from eCRM.DBA.XSYS_USER_PRIVILEGES as user_priveleges
from eCRM.DBA.XSYS_HISTORY as history
from eCRM.DBA.XSYS_USERS as xsys_users
from eCRM.DBA.AP_PROCESSES_VIEW2 as ap_processes
from eCRM.DBA.AP_RULES_VIEW2 as ap_rules
from eCRM.DBA.AP_QUEUE as ap_queues
where (^{companies.}^.COUNTRY_NAME = ^{countries.}^.COUNTRY_NAME)
where (^{contacts.}^.COUNTRY_NAME = ^{countries.}^.COUNTRY_NAME)
where (^{leads.}^.COUNTRY_NAME = ^{countries.}^.COUNTRY_NAME)
where (^{products.}^.COUNTRY_NAME = ^{countries.}^.COUNTRY_NAME)
where (^{orders.}^.SHIP_COUNTRY_NAME = ^{countries.}^.COUNTRY_NAME)
where (^{leads_table.}^.FREETEXT_ID = ^{leads.}^.FREETEXT_ID)
where (^{contacts_table.}^.FREETEXT_ID = ^{contacts.}^.FREETEXT_ID)
where (^{companies_table.}^.FREETEXT_ID = ^{companies.}^.FREETEXT_ID)
where (^{opportunities_table.}^.FREETEXT_ID = ^{opportunities.}^.FREETEXT_ID)
where (^{cases_table.}^.FREETEXT_ID = ^{cases.}^.FREETEXT_ID)
where (^{notes_table.}^.FREETEXT_ID = ^{notes.}^.FREETEXT_ID)
where (^{orders_table.}^.FREETEXT_ID = ^{orders.}^.FREETEXT_ID)
where (^{products_table.}^.FREETEXT_ID = ^{products.}^.FREETEXT_ID)
{
        create virtrdf:ecrmDemo2 as graph iri ("http://^{URIQADefaultHost}^/ecrm") option (exclusive, order 1502)
        {
            ecrm:Order (orders.ORG_ID, orders.ORDER_ID)
                a ecrm:Order
                    as virtrdf:Order-Orders ;
                ecrm:has_ecrm_organization ecrm:OrganizationsData(orders.ORG_ID, organizations_data.DNS_ZONE) where (^{orders.}^.ORG_ID = ^{organizations_data.}^.ORG_ID)
                        as virtrdf:Order-ORG_ID ;
                ecrm:owner ecrm:XSys_User(orders.ORG_ID, xsys_users.ACCOUNT_NAME, orders.OWNER_ID)
                        where (^{orders.}^.OWNER_ID = ^{xsys_users.}^.ACCOUNT_ID and ^{orders.}^.ORG_ID = ^{xsys_users.}^.ORG_ID)
                        as virtrdf:Order-OWNER_ID ;
                ecrm:FREETEXT_ID orders.FREETEXT_ID
                        as virtrdf:Order-FREETEXT_ID ;
                ecrm:has_company ecrm:Company(orders.COMPANY_NAME, orders.COMPANY_ID, orders.ORG_ID)
                        as virtrdf:Order-COMPANY_ID ;
                ecrm:companyName orders.COMPANY_NAME
                        as virtrdf:Order-COMPANY_NAME ;
                ecrm:has_contact ecrm:Contact(contacts.NAME_FIRST, contacts.NAME_MIDDLE, contacts.NAME_LAST, orders.CONTACT_ID, orders.ORG_ID)
                        where (^{orders.}^.CONTACT_ID = ^{contacts.}^.CONTACT_ID and ^{orders.}^.ORG_ID = ^{contacts.}^.ORG_ID)
                        as virtrdf:Order-CONTACT_ID ;
                ecrm:contactName orders.CONTACT_NAME
                        as virtrdf:Order-CONTACT_NAME ;
                ecrm:orderNo orders.ORDER_NO
                        as virtrdf:Order-ORDER_NO ;
                ecrm:shipFirstName orders.SHIP_FNAME
                        as virtrdf:Order-SHIP_FNAME ;
                ecrm:shipSecondName orders.SHIP_SNAME
                        as virtrdf:Order-SHIP_SNAME ;
                ecrm:phoneNumber orders.PHONE_NUMBER
                        as virtrdf:Order-PHONE_NUMBER ;
                ecrm:phoneExtension orders.PHONE_EXTENSION
                        as virtrdf:Order-PHONE_EXTENSION ;
                ecrm:email orders.EMAIL
                        as virtrdf:Order-EMAIL ;
                ecrm:shipCountry ecrm:Country(orders.SHIP_COUNTRY_NAME)
                        as virtrdf:Order-SHIP_COUNTRY_NAME ;
                ecrm:shipCountryCode ecrm:Country (countries.COUNTRY_NAME) where  (^{countries.}^.COUNTRY_NAME = ^{orders.}^.SHIP_COUNTRY_NAME)
                        as virtrdf:Order-SHIP_COUNTRY_CODE ;
                ecrm:shipProvince orders.SHIP_PROVINCE
                        as virtrdf:Order-SHIP_PROVINCE ;
                ecrm:shipCity orders.SHIP_CITY
                        as virtrdf:Order-SHIP_CITY ;
                ecrm:dbpedia_shipCity ecrm:dbpedia_iri (orders.SHIP_CITY)
                        as virtrdf:Order-SHIP_dbpedia_CITY ;
                ecrm:shipPostalCode orders.SHIP_POSTAL_CODE
                        as virtrdf:Order-SHIP_POSTAL_CODE ;
                ecrm:shipAddress1 orders.SHIP_ADDRESS1
                        as virtrdf:Order-SHIP_ADDRESS1 ;
                ecrm:shipAddress2 orders.SHIP_ADDRESS2
                        as virtrdf:Order-SHIP_ADDRESS2 ;
                ecrm:salesRep orders.SALESREP
                        as virtrdf:Order-SALESREP ;
                ecrm:orderDate orders.ORDER_DATE
                        as virtrdf:Order-ORDER_DATE ;
                ecrm:orderValue orders.ORDER_VALUE
                        as virtrdf:Order-ORDER_VALUE ;
                ecrm:refund orders.REFUND
                        as virtrdf:Order-REFUND ;
                ecrm:year orders.YEAR
                        as virtrdf:Order-YEAR ;
                ecrm:month orders.MONTH
                        as virtrdf:Order-MONTH ;
                ecrm:quarter orders.QUARTER
                        as virtrdf:Order-QUARTER ;
                ecrm:financialYear orders.FINANCIAL_YEAR
                        as virtrdf:Order-FINANCIAL_YEAR ;
                ecrm:CONTACT_REL_ID orders.CONTACT_REL_ID
                        as virtrdf:Order-CONTACT_REL_ID ;
                ecrm:COMPANY_REL_ID orders.COMPANY_REL_ID
                        as virtrdf:Order-COMPANY_REL_ID .

...
        } .
} .
;

]]></programlisting>
</sect2>
<sect2 id="rdfviewsrcur"><title>RDF views and recursive FK relationships</title>
  <para>Here is sample example of a script to include an additional table alias for a table:</para>
<programlisting><![CDATA[
alter quad storage virtrdf:DefaultQuadStorage
  :
  from isports_rdf.prs10_isports_rdf.VRef_Call      as Ref_Call_tbl
  from isports_rdf.prs10_isports_rdf.VRef_Call      as Ref_Call_tbl_1
  :
{
  :
  refcall:ref-call_iri (Ref_Call_tbl.Call_Num) a refcall:Ref-Call as
virtrdf:ref-call_pk ;
  :
  refcall:has_parent  refcall:ref-call_iri (Ref_Call_tbl_1.Call_Num)
where  ( ^{Ref_Call_tbl.}^.Parent    = ^{Ref_Call_tbl_1.}^.Call_Num )   as
virtrdf:Ref-Call_has_parent .
]]></programlisting>
  <para>This demonstrates the way to self-join the table VRef_Call with itself. Like in SQL,
are needed two different aliases for one table if you want to join it with itself.
  </para>
</sect2>
  <sect2 id="rdfviewsenterpr"><title>Enterprise Data Access &amp; Integration</title>
    <sect3 id="rdfviewsenterprtn">
      <title>Virtuoso's Northwind based Demo Database (Tutorials variant) to RDF </title>
<programlisting><![CDATA[
use DB;

DB.DBA.exec_no_error('UPDATE WS.WS.SYS_DAV_RES set RES_TYPE=\'image/jpeg\' where RES_FULL_PATH like \'/DAV/VAD/demo/sql/CAT%\'')
;

DB.DBA.exec_no_error('UPDATE WS.WS.SYS_DAV_RES set RES_TYPE=\'image/jpeg\' where RES_FULL_PATH like \'/DAV/VAD/demo/sql/EMP%\'')
;

GRANT SELECT ON "Demo"."demo"."Products" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Suppliers" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Shippers" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Categories" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Customers" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Employees" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Orders" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Order_Details" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Countries" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Provinces" TO "SPARQL";

SPARQL
prefix tut_northwind: <http://demo.openlinksw.com/schemas/tutorial/northwind#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
drop quad map graph iri("http://^{URIQADefaultHost}^/tutorial/Northwind") .
;

SPARQL
prefix tut_northwind: <http://demo.openlinksw.com/schemas/tutorial/northwind#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
drop quad map virtrdf:TutorialNorthwindDemo .
;

create function DB.DBA.TUT_NORTHWIND_ID_TO_IRI(in _prefix varchar,in _id varchar)
{
  declare iri, uriqa_host any;
  uriqa_host := cfg_item_value(virtuoso_ini_path(), 'URIQA','DefaultHost');
  iri := 'http://' || uriqa_host || '/tutorial/Northwind/' || _prefix || '/' || _id || '#this';
  return sprintf ('http://%s/DAV/VAD/tutorial/rdfview/rd_v_1/RDFData/All/iid%%20(%d).rdf', uriqa_host, iri_id_num (iri_to_id (iri)));
}
;

create function DB.DBA.TUT_NORTHWIND_IRI_TO_ID(in _iri varchar)
{
    declare parts any;
    parts := sprintf_inverse (_iri, 'http://%s/DAV/VAD/tutorial/rdfview/rd_v_1/RDFData/All/iid (%d).rdf', 1 );
    if (parts is not null)
    {
        declare uriqa_host, iri any;
        uriqa_host := cfg_item_value(virtuoso_ini_path(), 'URIQA','DefaultHost');
        if (parts[0] = uriqa_host)
        {
            iri := id_to_iri(iri_id_from_num(parts[1]));
            parts := sprintf_inverse (iri, 'http://%s/tutorial/Northwind/%s/%s#this', 1 );
            if (parts[0] = uriqa_host)
            {
                return parts[2];
            }
        }
    }
    return NULL;
}
;

create function DB.DBA.TUT_CATEGORY_IRI (in _id integer) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('Category', cast(_id as varchar));
}
;

create function DB.DBA.TUT_CATEGORY_IRI_INVERSE (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};

create function DB.DBA.TUT_SHIPPER_IRI (in _id integer) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('Shipper', cast(_id as varchar));
}
;

create function DB.DBA.TUT_SHIPPER_IRI_INVERSE (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};

create function DB.DBA.TUT_SUPPLIER_IRI (in _id integer) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('Supplier', cast(_id as varchar));
}
;

create function DB.DBA.TUT_SUPPLIER_IRI_INVERSE (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};

create function DB.DBA.TUT_PRODUCT_IRI (in _id integer) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('Product', cast(_id as varchar));
}
;

create function DB.DBA.TUT_PRODUCT_IRI_INVERSE (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};

create function DB.DBA.TUT_CUSTOMER_IRI (in _id varchar) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('Customer', _id);
}
;

create function DB.DBA.TUT_CUSTOMER_IRI_INVERSE (in _iri varchar) returns varchar
{
    return DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri);
};

create function DB.DBA.TUT_EMPLOYEE_IRI (in _id integer) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('Employee', cast(_id as varchar));
}
;

create function DB.DBA.TUT_EMPLOYEE_IRI_INVERSE (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};

create function DB.DBA.TUT_ORDER_IRI (in _id integer) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('Order', cast(_id as varchar));
}
;

create function DB.DBA.TUT_ORDER_IRI_INVERSE (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};

create function DB.DBA.TUT_CUSTOMERCONTACT_IRI (in _id integer) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('CustomerContact', cast(_id as varchar));
}
;

create function DB.DBA.TUT_CUSTOMERCONTACT_IRI_INVERSE (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};

create function DB.DBA.TUT_ORDERLINE_IRI (in _id1 integer, in _id2 integer) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('OrderLine', sprintf('%d/%d', _id1, _id2));
}
;

create function DB.DBA.TUT_ORDERLINE_IRI_INV_1 (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};

create function DB.DBA.TUT_ORDERLINE_IRI_INV_2 (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};


create function DB.DBA.TUT_PROVINCE_IRI (in _id1 varchar, in _id2 varchar) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('Province', sprintf('%s/%s', _id1, _id2));
}
;

create function DB.DBA.TUT_PROVINCE_IRI_INV_1 (in _iri varchar) returns varchar
{
    return DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri);
};

create function DB.DBA.TUT_PROVINCE_IRI_INV_2 (in _iri varchar) returns varchar
{
    return DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri);
};

create function DB.DBA.TUT_COUNTRY_IRI (in _id varchar) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('Country', _id);
}
;

create function DB.DBA.TUT_COUNTRY_IRI_INVERSE (in _iri varchar) returns varchar
{
    return DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri);
};

create function DB.DBA.TUT_FLAG_IRI (in _id varchar) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('Flag', _id);
}
;

create function DB.DBA.TUT_FLAG_IRI_INVERSE (in _iri varchar) returns varchar
{
    return DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri);
};

create function DB.DBA.TUT_EMPLOYEEPHOTO_IRI (in _id integer) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('EmployeePhoto', cast(_id as varchar));
}
;

create function DB.DBA.TUT_EMPLOYEEPHOTO_IRI_INVERSE (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};

create function DB.DBA.TUT_CATEGORYPHOTO_IRI (in _id integer) returns varchar
{
    return TUT_NORTHWIND_ID_TO_IRI('CategoryPhoto', cast(_id as varchar));
}
;

create function DB.DBA.TUT_CATEGORYPHOTO_IRI_INVERSE (in _iri varchar) returns integer
{
    return atoi(DB.DBA.TUT_NORTHWIND_IRI_TO_ID(_iri));
};

grant execute on DB.DBA.TUT_CATEGORY_IRI to "SPARQL";
grant execute on DB.DBA.TUT_CATEGORY_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_SHIPPER_IRI to "SPARQL";
grant execute on DB.DBA.TUT_SHIPPER_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_SUPPLIER_IRI to "SPARQL";
grant execute on DB.DBA.TUT_SUPPLIER_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_PRODUCT_IRI to "SPARQL";
grant execute on DB.DBA.TUT_PRODUCT_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_CUSTOMER_IRI to "SPARQL";
grant execute on DB.DBA.TUT_CUSTOMER_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_EMPLOYEE_IRI to "SPARQL";
grant execute on DB.DBA.TUT_EMPLOYEE_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_ORDER_IRI to "SPARQL";
grant execute on DB.DBA.TUT_ORDER_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_CUSTOMERCONTACT_IRI to "SPARQL";
grant execute on DB.DBA.TUT_CUSTOMERCONTACT_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_ORDERLINE_IRI to "SPARQL";
grant execute on DB.DBA.TUT_ORDERLINE_IRI_INV_1 to "SPARQL";
grant execute on DB.DBA.TUT_ORDERLINE_IRI_INV_2 to "SPARQL";
grant execute on DB.DBA.TUT_PROVINCE_IRI to "SPARQL";
grant execute on DB.DBA.TUT_PROVINCE_IRI_INV_1 to "SPARQL";
grant execute on DB.DBA.TUT_PROVINCE_IRI_INV_2 to "SPARQL";
grant execute on DB.DBA.TUT_COUNTRY_IRI to "SPARQL";
grant execute on DB.DBA.TUT_COUNTRY_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_FLAG_IRI to "SPARQL";
grant execute on DB.DBA.TUT_FLAG_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_EMPLOYEEPHOTO_IRI to "SPARQL";
grant execute on DB.DBA.TUT_EMPLOYEEPHOTO_IRI_INVERSE to "SPARQL";
grant execute on DB.DBA.TUT_CATEGORYPHOTO_IRI to "SPARQL";
grant execute on DB.DBA.TUT_CATEGORYPHOTO_IRI_INVERSE to "SPARQL";

SPARQL
prefix tut_northwind: <http://demo.openlinksw.com/schemas/tutorial/northwind#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
create iri class tut_northwind:Category "http://^{URIQADefaultHost}^/tutorial/Northwind/Category/%d#this" (in category_id integer not null) .
create iri class tut_northwind:Shipper "http://^{URIQADefaultHost}^/tutorial/Northwind/Shipper/%d#this" (in shipper_id integer not null) .
create iri class tut_northwind:Supplier "http://^{URIQADefaultHost}^/tutorial/Northwind/Supplier/%d#this" (in supplier_id integer not null) .
create iri class tut_northwind:Product   "http://^{URIQADefaultHost}^/tutorial/Northwind/Product/%d#this" (in product_id integer not null) .
create iri class tut_northwind:Customer "http://^{URIQADefaultHost}^/tutorial/Northwind/Customer/%U#this" (in customer_id varchar not null) .
create iri class tut_northwind:Employee "http://^{URIQADefaultHost}^/tutorial/Northwind/Employee/%U%U%d#this" (in employee_firstname varchar not null, in employee_lastname varchar not null, in employee_id integer not null) .
create iri class tut_northwind:Order "http://^{URIQADefaultHost}^/tutorial/Northwind/Order/%d#this" (in order_id integer not null) .
create iri class tut_northwind:CustomerContact "http://^{URIQADefaultHost}^/tutorial/Northwind/CustomerContact/%U#this" (in customer_id varchar not null) .
create iri class tut_northwind:OrderLine "http://^{URIQADefaultHost}^/tutorial/Northwind/OrderLine/%d/%d#this" (in order_id integer not null, in product_id integer not null) .
create iri class tut_northwind:Province "http://^{URIQADefaultHost}^/tutorial/Northwind/Province/%U/%U#this" (in country_name varchar not null, in province_name varchar not null) .
create iri class tut_northwind:Country "http://^{URIQADefaultHost}^/tutorial/Northwind/Country/%U#this" (in country_name varchar not null) .
create iri class tut_northwind:Flag "http://^{URIQADefaultHost}^%U#this" (in flag_path varchar not null) .
create iri class tut_northwind:dbpedia_iri "http://dbpedia.org/resource/%U" (in uname varchar not null) .
create iri class tut_northwind:EmployeePhoto "http://^{URIQADefaultHost}^/DAV/VAD/demo/sql/EMP%d#this" (in emp_id varchar not null) .
create iri class tut_northwind:CategoryPhoto "http://^{URIQADefaultHost}^/DAV/VAD/demo/sql/CAT%d#this" (in category_id varchar not null) .
;

SPARQL
prefix tut_northwind: <http://demo.openlinksw.com/schemas/tutorial/northwind#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
create iri class tut_northwind:customercontact_iri using
    function DB.DBA.TUT_CUSTOMERCONTACT_IRI (in customer_id varchar) returns varchar,
    function DB.DBA.TUT_CUSTOMERCONTACT_IRI_INVERSE (in customer_iri varchar) returns varchar.
create iri class tut_northwind:category_iri using
    function DB.DBA.TUT_CATEGORY_IRI (in customer_id integer) returns varchar,
    function DB.DBA.TUT_CATEGORY_IRI_INVERSE (in customer_iri varchar) returns integer.
create iri class tut_northwind:shipper_iri using
    function DB.DBA.TUT_SHIPPER_IRI (in customer_id integer) returns varchar,
    function DB.DBA.TUT_SHIPPER_IRI_INVERSE (in customer_iri varchar) returns integer.
create iri class tut_northwind:supplier_iri using
    function DB.DBA.TUT_SUPPLIER_IRI (in customer_id varchar) returns varchar,
    function DB.DBA.TUT_SUPPLIER_IRI_INVERSE (in customer_iri varchar) returns varchar.
create iri class tut_northwind:product_iri using
    function DB.DBA.TUT_PRODUCT_IRI (in customer_id integer) returns varchar,
    function DB.DBA.TUT_PRODUCT_IRI_INVERSE (in customer_iri varchar) returns integer.
create iri class tut_northwind:customer_iri using
    function DB.DBA.TUT_CUSTOMER_IRI (in customer_id varchar) returns varchar,
    function DB.DBA.TUT_CUSTOMER_IRI_INVERSE (in customer_iri varchar) returns varchar.
create iri class tut_northwind:employee_iri using
    function DB.DBA.TUT_EMPLOYEE_IRI (in customer_id integer) returns varchar,
    function DB.DBA.TUT_EMPLOYEE_IRI_INVERSE (in customer_iri varchar) returns integer.
create iri class tut_northwind:order_iri using
    function DB.DBA.TUT_ORDER_IRI (in customer_id integer) returns varchar,
    function DB.DBA.TUT_ORDER_IRI_INVERSE (in customer_iri varchar) returns integer.
create iri class tut_northwind:orderline_iri using
    function DB.DBA.TUT_ORDERLINE_IRI (in customer_id integer, in customer_id2 integer) returns varchar,
    function DB.DBA.TUT_ORDERLINE_IRI_INV_1 (in customer_iri varchar) returns integer,
    function DB.DBA.TUT_ORDERLINE_IRI_INV_2 (in customer_iri varchar) returns integer.
create iri class tut_northwind:province_iri using
    function DB.DBA.TUT_PROVINCE_IRI (in customer_id varchar, in customer_id2 varchar) returns varchar,
    function DB.DBA.TUT_PROVINCE_IRI_INV_1 (in customer_iri varchar) returns varchar,
    function DB.DBA.TUT_PROVINCE_IRI_INV_2 (in customer_iri varchar) returns varchar.
create iri class tut_northwind:country_iri using
    function DB.DBA.TUT_COUNTRY_IRI (in customer_id varchar) returns varchar,
    function DB.DBA.TUT_COUNTRY_IRI_INVERSE (in customer_iri varchar) returns varchar.
create iri class tut_northwind:employeephoto_iri using
    function DB.DBA.TUT_EMPLOYEEPHOTO_IRI (in customer_id integer) returns varchar,
    function DB.DBA.TUT_EMPLOYEEPHOTO_IRI_INVERSE (in customer_iri varchar) returns integer.
create iri class tut_northwind:categoryphoto_iri using
    function DB.DBA.TUT_CATEGORYPHOTO_IRI (in customer_id integer) returns varchar,
    function DB.DBA.TUT_CATEGORYPHOTO_IRI_INVERSE (in customer_iri varchar) returns integer.
create iri class tut_northwind:flag_iri using
    function DB.DBA.TUT_FLAG_IRI (in customer_id varchar) returns varchar,
    function DB.DBA.TUT_FLAG_IRI_INVERSE (in customer_iri varchar) returns varchar.
;

SPARQL
prefix tut_northwind: <http://demo.openlinksw.com/schemas/tutorial/northwind#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
alter quad storage virtrdf:DefaultQuadStorage
from Demo.demo.Products as products
from Demo.demo.Suppliers as suppliers
from Demo.demo.Shippers as shippers
from Demo.demo.Categories as categories
from Demo.demo.Customers as customers
from Demo.demo.Employees as employees
from Demo.demo.Orders as orders
from Demo.demo.Order_Details as order_lines
from Demo.demo.Countries as countries
from Demo.demo.Provinces as provinces
where (^{suppliers.}^.Country = ^{countries.}^.Name)
where (^{customers.}^.Country = ^{countries.}^.Name)
where (^{employees.}^.Country = ^{countries.}^.Name)
where (^{orders.}^.ShipCountry = ^{countries.}^.Name)
{
        create virtrdf:TutorialNorthwindDemo as graph iri ("http://^{URIQADefaultHost}^/tutorial/Northwind") option (exclusive)
        {
                tut_northwind:CustomerContact (customers.CustomerID)
                        a foaf:Person
                                as virtrdf:tutCustomerContact-foaf_Person .

                tut_northwind:CustomerContact (customers.CustomerID)
                        a tut_northwind:CustomerContact
                                as virtrdf:tutCustomerContact-CustomerContact;
                        foaf:name customers.ContactName
                                as virtrdf:tutCustomerContact-contact_name ;
                        foaf:phone customers.Phone
                                as virtrdf:tutCustomerContact-foaf_phone ;
                        tut_northwind:is_contact_at tut_northwind:Customer (customers.CustomerID)
                                as virtrdf:tutCustomerContact-is_contact_at ;
                        tut_northwind:country tut_northwind:Country (customers.Country)
                                as virtrdf:tutCustomerContact-country ;
                        rdfs:isDefinedBy tut_northwind:customercontact_iri (customers.CustomerID) ;
                        rdfs:isDefinedBy tut_northwind:CustomerContact (customers.CustomerID) .

                tut_northwind:Country (customers.Country)
                        tut_northwind:is_country_of
                tut_northwind:CustomerContact (customers.CustomerID) as virtrdf:tutCustomerContact-is_country_of .

                tut_northwind:Product (products.ProductID)
                        a tut_northwind:Product
                                as virtrdf:tutProduct-ProductID ;
                        tut_northwind:has_category tut_northwind:Category (products.CategoryID)
                                as virtrdf:tutProduct-product_has_category ;
                        tut_northwind:has_supplier tut_northwind:Supplier (products.SupplierID)
                                as virtrdf:tutProduct-product_has_supplier ;
                        tut_northwind:productName products.ProductName
                                as virtrdf:tutProduct-name_of_product ;
                        tut_northwind:quantityPerUnit products.QuantityPerUnit
                                as virtrdf:tutProduct-quantity_per_unit ;
                        tut_northwind:unitPrice products.UnitPrice
                                as virtrdf:tutProduct-unit_price ;
                        tut_northwind:unitsInStock products.UnitsInStock
                                as virtrdf:tutProduct-units_in_stock ;
                        tut_northwind:unitsOnOrder products.UnitsOnOrder
                                as virtrdf:tutProduct-units_on_order ;
                        tut_northwind:reorderLevel products.ReorderLevel
                                as virtrdf:tutProduct-reorder_level ;
                        tut_northwind:discontinued products.Discontinued
                                as virtrdf:tutProduct-discontinued ;
                        rdfs:isDefinedBy tut_northwind:product_iri (products.ProductID) ;
                        rdfs:isDefinedBy tut_northwind:Product (products.ProductID).

                tut_northwind:Category (products.CategoryID)
                        tut_northwind:category_of tut_northwind:Product (products.ProductID) as virtrdf:tutProduct-category_of .

                tut_northwind:Supplier (products.SupplierID)
                        tut_northwind:supplier_of tut_northwind:Product (products.ProductID) as virtrdf:tutProduct-supplier_of .

                tut_northwind:Supplier (suppliers.SupplierID)
                        a tut_northwind:Supplier
                                as virtrdf:tutSupplier-SupplierID ;
                        tut_northwind:companyName suppliers.CompanyName
                                as virtrdf:tutSupplier-company_name ;
                        tut_northwind:contactName suppliers.ContactName
                                as virtrdf:tutSupplier-contact_name ;
                        tut_northwind:contactTitle suppliers.ContactTitle
                                as virtrdf:tutSupplier-contact_title ;
                        tut_northwind:address suppliers.Address
                                as virtrdf:tutSupplier-address ;
                        tut_northwind:city suppliers.City
                                as virtrdf:tutSupplier-city ;
                        tut_northwind:dbpedia_city tut_northwind:dbpedia_iri(suppliers.City)
                                as virtrdf:tutSupplier-dbpedia_city ;
                        tut_northwind:region suppliers.Region
                                as virtrdf:tutSupplier-region ;
                        tut_northwind:postalCode suppliers.PostalCode
                                as virtrdf:tutSupplier-postal_code ;
                        tut_northwind:country tut_northwind:Country(suppliers.Country)
                                as virtrdf:tutSupplier-country ;
                        tut_northwind:phone suppliers.Phone
                                as virtrdf:tutSupplier-phone ;
                        tut_northwind:fax suppliers.Fax
                                as virtrdf:tutSupplier-fax ;
                        tut_northwind:homePage suppliers.HomePage
                                as virtrdf:tutSupplier-home_page ;
                        rdfs:isDefinedBy tut_northwind:supplier_iri (suppliers.SupplierID) ;
                        rdfs:isDefinedBy tut_northwind:Supplier (suppliers.SupplierID).

                tut_northwind:Country (suppliers.Country)
                        tut_northwind:is_country_of
                tut_northwind:Supplier (suppliers.SupplierID) as virtrdf:tutSupplier-is_country_of .

                tut_northwind:Category (categories.CategoryID)
                        a tut_northwind:Category
                                as virtrdf:tutCategory-CategoryID ;
                        tut_northwind:categoryName categories.CategoryName
                                as virtrdf:tutCategory-home_page ;
                        tut_northwind:description categories.Description
                                as virtrdf:tutCategory-description ;
                        foaf:img tut_northwind:CategoryPhoto(categories.CategoryID)
                                as virtrdf:tutCategory-categories.CategoryPhoto ;
                        rdfs:isDefinedBy tut_northwind:category_iri (categories.CategoryID) ;
                        rdfs:isDefinedBy tut_northwind:Category (categories.CategoryID).

                tut_northwind:CategoryPhoto(categories.CategoryID)
                        a tut_northwind:CategoryPhoto
                                as virtrdf:tutCategory-categories.CategoryPhotoID ;
                        rdfs:isDefinedBy tut_northwind:categoryphoto_iri (categories.CategoryID) ;
                        rdfs:isDefinedBy tut_northwind:CategoryPhoto(categories.CategoryID).

                tut_northwind:Shipper (shippers.ShipperID)
                        a tut_northwind:Shipper
                                as virtrdf:tutShipper-ShipperID ;
                        tut_northwind:companyName shippers.CompanyName
                                as virtrdf:tutShipper-company_name ;
                        tut_northwind:phone shippers.Phone
                                as virtrdf:tutShipper-phone ;
                        rdfs:isDefinedBy tut_northwind:shipper_iri (shippers.ShipperID) ;
                        rdfs:isDefinedBy tut_northwind:Shipper (shippers.ShipperID).

                tut_northwind:Customer (customers.CustomerID)
                        a  tut_northwind:Customer
                                as virtrdf:tutCustomer-CustomerID2 ;
                        a  foaf:Organization
                                as virtrdf:tutCustomer-CustomerID ;
                        foaf:name customers.CompanyName
                                as virtrdf:tutCustomer-foaf_name ;
                        tut_northwind:companyName customers.CompanyName
                                as virtrdf:tutCustomer-company_name ;
                        tut_northwind:has_contact tut_northwind:CustomerContact (customers.CustomerID)
                                as virtrdf:tutCustomer-contact ;
                        tut_northwind:country tut_northwind:Country (customers.Country)
                                as virtrdf:tutCustomer-country ;
                        tut_northwind:contactName customers.ContactName
                                as virtrdf:tutCustomer-contact_name ;
                        tut_northwind:contactTitle customers.ContactTitle
                                as virtrdf:tutCustomer-contact_title ;
                        tut_northwind:address customers.Address
                                as virtrdf:tutCustomer-address ;
                        tut_northwind:city customers.City
                                as virtrdf:tutCustomer-city ;
                        tut_northwind:dbpedia_city tut_northwind:dbpedia_iri(customers.City)
                                as virtrdf:tutCustomer-dbpedia_city ;
                        tut_northwind:region customers.Region
                                as virtrdf:tutCustomer-region ;
                        tut_northwind:PostalCode customers.PostalCode
                                as virtrdf:tutCustomer-postal_code ;
                        foaf:phone customers.Phone
                                as virtrdf:tutCustomer-foaf_phone ;
                        tut_northwind:phone customers.Phone
                                as virtrdf:tutCustomer-phone ;
                        tut_northwind:fax customers.Fax
                                as virtrdf:tutCustomer-fax ;
                        rdfs:isDefinedBy tut_northwind:customer_iri (customers.CustomerID) ;
                        rdfs:isDefinedBy tut_northwind:Customer (customers.CustomerID).

                tut_northwind:Country (customers.Country)
                        tut_northwind:is_country_of
                tut_northwind:Customer (customers.CustomerID) as virtrdf:tutCustomer-is_country_of .

                tut_northwind:Employee (employees.FirstName, employees.LastName, employees.EmployeeID)
                        a tut_northwind:Employee
                                as virtrdf:tutEmployee-EmployeeID2 ;
                        a foaf:Person
                                as virtrdf:tutEmployee-EmployeeID ;
                        foaf:surname employees.LastName
                                as virtrdf:tutEmployee-foaf_last_name ;
                        tut_northwind:lastName employees.LastName
                                as virtrdf:tutEmployee-last_name ;
                        foaf:firstName employees.FirstName
                                as virtrdf:tutEmployee-foaf_first_name ;
                        tut_northwind:firstName employees.FirstName
                                as virtrdf:tutEmployee-first_name ;
                        foaf:title employees.Title
                                as virtrdf:tutEmployee-title ;
                        tut_northwind:titleOfCourtesy employees.TitleOfCourtesy
                                as virtrdf:tutEmployee-title_of_courtesy ;
                        foaf:birthday employees.BirthDate
                                as virtrdf:tutEmployee-foaf_birth_date ;
                        tut_northwind:birthday employees.BirthDate
                                as virtrdf:tutEmployee-birth_date ;
                        tut_northwind:hireDate employees.HireDate
                                as virtrdf:tutEmployee-hire_date ;
                        tut_northwind:address employees.Address
                                as virtrdf:tutEmployee-address ;
                        tut_northwind:city employees.City
                                as virtrdf:tutEmployee-city ;
                        tut_northwind:dbpedia_city tut_northwind:dbpedia_iri(employees.City)
                                as virtrdf:tutEmployee-dbpedia_city ;
                        tut_northwind:region employees.Region
                                as virtrdf:tutEmployee-region ;
                        tut_northwind:postalCode employees.PostalCode
                                as virtrdf:tutEmployee-postal_code ;
                        tut_northwind:country tut_northwind:Country (employees.Country)
                                as virtrdf:tutEmployee-country ;
                        foaf:phone employees.HomePhone
                                as virtrdf:tutEmployee-home_phone ;
                        tut_northwind:extension employees.Extension
                                as virtrdf:tutEmployee-extension ;
                        tut_northwind:notes employees.Notes
                                as virtrdf:tutEmployee-notes ;
                        tut_northwind:reportsTo tut_northwind:Employee(employees.FirstName, employees.LastName, employees.ReportsTo) where (^{employees.}^.ReportsTo = ^{employees.}^.EmployeeID)
                                as virtrdf:tutEmployee-reports_to ;
                        foaf:img tut_northwind:EmployeePhoto(employees.EmployeeID)
                                as virtrdf:tutEmployee-employees.EmployeePhoto ;
                        rdfs:isDefinedBy tut_northwind:employee_iri (employees.EmployeeID) ;
                        rdfs:isDefinedBy tut_northwind:Employee (employees.FirstName, employees.LastName, employees.EmployeeID).

                tut_northwind:EmployeePhoto(employees.EmployeeID)
                        a tut_northwind:EmployeePhoto
                                as virtrdf:tut_Employee-employees.EmployeePhotoId ;
                        rdfs:isDefinedBy tut_northwind:employeephoto_iri (employees.EmployeeID) ;
                        rdfs:isDefinedBy tut_northwind:EmployeePhoto (employees.EmployeeID).

                tut_northwind:Employee (employees.FirstName, employees.LastName, orders.EmployeeID)
                        tut_northwind:is_salesrep_of
                tut_northwind:Order (orders.OrderID) where (^{orders.}^.EmployeeID = ^{employees.}^.EmployeeID) as virtrdf:tutOrder-is_salesrep_of .

                tut_northwind:Country (employees.Country)
                        tut_northwind:is_country_of
                tut_northwind:Employee (employees.FirstName, employees.LastName, employees.EmployeeID) as virtrdf:tutEmployee-is_country_of .

                tut_northwind:Order (orders.OrderID)
                        a tut_northwind:Order
                                as virtrdf:tutOrder-Order ;
                        tut_northwind:has_customer tut_northwind:Customer (orders.CustomerID)
                                as virtrdf:tutOrder-order_has_customer ;
                        tut_northwind:has_salesrep tut_northwind:Employee (employees.FirstName, employees.LastName, orders.EmployeeID) where (^{orders.}^.EmployeeID = ^{employees.}^.EmployeeID)
                                as virtrdf:tutCustomer-has_salesrep ;
                        tut_northwind:has_employee tut_northwind:Employee (employees.FirstName, employees.LastName, orders.EmployeeID) where (^{orders.}^.EmployeeID = ^{employees.}^.EmployeeID)
                                as virtrdf:tutOrder-order_has_employee ;
                        tut_northwind:orderDate orders.OrderDate
                                as virtrdf:tutOrder-order_date ;
                        tut_northwind:requiredDate orders.RequiredDate
                                as virtrdf:tutOrder-required_date ;
                        tut_northwind:shippedDate orders.ShippedDate
                                as virtrdf:tutOrder-shipped_date ;
                        tut_northwind:order_ship_via tut_northwind:Shipper (orders.ShipVia)
                                as virtrdf:tutOrder-order_ship_via ;
                        tut_northwind:freight orders.Freight
                                as virtrdf:tutOrder-freight ;
                        tut_northwind:shipName orders.ShipName
                                as virtrdf:tutOrder-ship_name ;
                        tut_northwind:shipAddress orders.ShipAddress
                                as virtrdf:tutOrder-ship_address ;
                        tut_northwind:shipCity orders.ShipCity
                                as virtrdf:tutOrder-ship_city ;
                        tut_northwind:dbpedia_shipCity tut_northwind:dbpedia_iri(orders.ShipCity)
                                as virtrdf:tutOrder-ship_dbpedia_city ;
                        tut_northwind:shipRegion orders.ShipRegion
                                as virtrdf:tutOrder-ship_region ;
                        tut_northwind:shipPostal_code orders.ShipPostalCode
                                as virtrdf:tutOrder-ship_postal_code ;
                        tut_northwind:shipCountry tut_northwind:Country(orders.ShipCountry)
                                as virtrdf:tutship_country ;
                        rdfs:isDefinedBy tut_northwind:order_iri (orders.OrderID) ;
                        rdfs:isDefinedBy tut_northwind:Order (orders.OrderID).

                tut_northwind:Country (orders.ShipCountry)
                        tut_northwind:is_ship_country_of
                tut_northwind:Order (orders.OrderID) as virtrdf:tutOrder-is_country_of .

                tut_northwind:Customer (orders.CustomerID)
                        tut_northwind:has_order tut_northwind:Order (orders.OrderID) as virtrdf:tutOrder-has_order .

                tut_northwind:Shipper (orders.ShipVia)
                        tut_northwind:ship_order tut_northwind:Order (orders.OrderID) as virtrdf:tutOrder-ship_order .

                tut_northwind:OrderLine (order_lines.OrderID, order_lines.ProductID)
                        a tut_northwind:OrderLine
                                as virtrdf:tutOrderLine-OrderLines ;
                        tut_northwind:has_order_id tut_northwind:Order (order_lines.OrderID)
                                as virtrdf:tutorder_lines_has_order_id ;
                        tut_northwind:has_product_id tut_northwind:Product (order_lines.ProductID)
                                as virtrdf:tutorder_lines_has_product_id ;
                        tut_northwind:unitPrice order_lines.UnitPrice
                                as virtrdf:tutOrderLine-unit_price ;
                        tut_northwind:quantity order_lines.Quantity
                                as virtrdf:tutOrderLine-quantity ;
                        tut_northwind:discount order_lines.Discount
                                as virtrdf:tutOrderLine-discount ;
                        rdfs:isDefinedBy tut_northwind:orderline_iri (order_lines.OrderID, order_lines.ProductID) ;
                        rdfs:isDefinedBy tut_northwind:OrderLine (order_lines.OrderID, order_lines.ProductID).

                tut_northwind:Order (orders.OrderID)
                        tut_northwind:is_order_of
                tut_northwind:OrderLine (order_lines.OrderID, order_lines.ProductID) where (^{orders.}^.OrderID = ^{order_lines.}^.OrderID) as virtrdf:tutOrder-is_order_of .

                tut_northwind:Product (products.ProductID)
                        tut_northwind:is_product_of
                tut_northwind:OrderLine (order_lines.OrderID, order_lines.ProductID) where (^{products.}^.ProductID = ^{order_lines.}^.ProductID) as virtrdf:tutProduct-is_product_of .

                tut_northwind:Country (countries.Name)
                        a tut_northwind:Country
                                as virtrdf:tutCountry-Type2 ;
                        a wgs:SpatialThing
                                as virtrdf:tutCountry-Type ;
                        owl:sameAs tut_northwind:dbpedia_iri (countries.Name) ;
                        tut_northwind:name countries.Name
                                as virtrdf:tutCountry-Name ;
                        tut_northwind:code countries.Code
                                as virtrdf:tutCountry-Code ;
                        tut_northwind:smallFlagDAVResourceName countries.SmallFlagDAVResourceName
                                as virtrdf:tutCountry-SmallFlagDAVResourceName ;
                        tut_northwind:largeFlagDAVResourceName countries.LargeFlagDAVResourceName
                                as virtrdf:tutCountry-LargeFlagDAVResourceName ;
                        tut_northwind:smallFlagDAVResourceURI tut_northwind:Flag(countries.SmallFlagDAVResourceURI)
                                as virtrdf:tutCountry-SmallFlagDAVResourceURI ;
                        tut_northwind:largeFlagDAVResourceURI tut_northwind:Flag(countries.LargeFlagDAVResourceURI)
                                as virtrdf:tutCountry-LargeFlagDAVResourceURI ;
                        wgs:lat countries.Lat
                                as virtrdf:tutCountry-Lat ;
                        wgs:long countries.Lng
                                as virtrdf:tutCountry-Lng ;
                        rdfs:isDefinedBy tut_northwind:country_iri (countries.Name) ;
                        rdfs:isDefinedBy tut_northwind:Country (countries.Name).

                tut_northwind:Country (countries.Name)
                        tut_northwind:has_province
                tut_northwind:Province (provinces.CountryCode, provinces.Province) where (^{provinces.}^.CountryCode = ^{countries.}^.Code) as virtrdf:tutCountry-has_province .

                tut_northwind:Province (provinces.CountryCode, provinces.Province)
                        a tut_northwind:Province
                                as virtrdf:tutProvince-Provinces ;
                        tut_northwind:has_country_code provinces.CountryCode
                                as virtrdf:tuthas_country_code ;
                        tut_northwind:provinceName provinces.Province
                                as virtrdf:tutProvince-ProvinceName ;
                        rdfs:isDefinedBy tut_northwind:province_iri (provinces.CountryCode, provinces.Province) ;
                        rdfs:isDefinedBy tut_northwind:Province (provinces.CountryCode, provinces.Province).

                tut_northwind:Province (provinces.CountryCode, provinces.Province)
                        tut_northwind:is_province_of
                tut_northwind:Country (countries.Name) where  (^{countries.}^.Code = ^{provinces.}^.CountryCode) as virtrdf:tutProvince-country_of .
        } .
} .
;

delete from db.dba.url_rewrite_rule_list where urrl_list like 'tut_nw%';
delete from db.dba.url_rewrite_rule where urr_rule like 'tut_nw%';

create procedure DB.DBA.install_run ()
{
        declare file_text, uriqa varchar;
        uriqa := registry_get('URIQADefaultHost');
        file_text := (select blob_to_string (RES_CONTENT) from WS.WS.SYS_DAV_RES where RES_FULL_PATH='/DAV/VAD/tutorial/rdfview/rd_v_1/rd_v_1.isparql');
        file_text := replace(file_text, 'URIQA_MACRO', concat('http://', uriqa, '/tutorial/Northwind'));
        update WS.WS.SYS_DAV_RES set RES_CONTENT=file_text where RES_FULL_PATH='/DAV/VAD/tutorial/rdfview/rd_v_1/rd_v_1.isparql';
}
;

DB.DBA.install_run()
;

drop procedure DB.DBA.install_run
;

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tut_nw_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Fp+%%3Fo+}+FROM+%%3Chttp%%3A//^{URIQADefaultHost}^/tutorial/Northwind%%3E+WHERE+{+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tut_nw_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/rdfbrowser/index.html?uri=http%%3A//^{URIQADefaultHost}^%U%%23this',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tut_nw_rule3',
    1,
    '(/[^#]*)/\x24',
    vector('path'),
    1,
    '%s',
    vector('path'),
    null,
    null,
    0,
    null
    );

create procedure DB.DBA.REMOVE_TUT_DEMO_RDF_DET()
{
  declare colid int;
  colid := DAV_SEARCH_ID('/DAV/VAD/tutorial/rdfview/rd_v_1/', 'C');
  if (colid < 0)
    return;
  update WS.WS.SYS_DAV_COL set COL_DET=null where COL_ID = colid;
}
;

DB.DBA.REMOVE_TUT_DEMO_RDF_DET();

drop procedure DB.DBA.REMOVE_TUT_DEMO_RDF_DET;

create procedure DB.DBA.TUT_NORTHWIND_MAKE_RDF_DET()
{
    declare uriqa_str varchar;
    uriqa_str := cfg_item_value(virtuoso_ini_path(), 'URIQA','DefaultHost');
    uriqa_str := 'http://' || uriqa_str || '/tutorial/Northwind';
    DB.DBA."RDFData_MAKE_DET_COL" ('/DAV/VAD/tutorial/rdfview/rd_v_1/RDFData/', uriqa_str, NULL);
    VHOST_REMOVE (lpath=>'/tutorial/Northwind/data/rdf');
    DB.DBA.VHOST_DEFINE (lpath=>'/tutorial/Northwind/data/rdf', ppath=>'/DAV/VAD/tutorial/rdfview/rd_v_1/RDFData/All/', is_dav=>1, vsp_user=>'dba');
}
;

DB.DBA.TUT_NORTHWIND_MAKE_RDF_DET();

drop procedure DB.DBA.TUT_NORTHWIND_MAKE_RDF_DET;

-- procedure to convert path to DET resource name
create procedure DB.DBA.TUT_NORTHWIND_DET_REF (in par varchar, in fmt varchar, in val varchar)
{
  declare res, iri any;
  declare uriqa_str varchar;
  uriqa_str := cfg_item_value(virtuoso_ini_path(), 'URIQA','DefaultHost');
  uriqa_str := 'http://' || uriqa_str || '/tutorial/Northwind';
  iri := uriqa_str || val;
  res := sprintf ('iid (%d).rdf', iri_id_num (iri_to_id (iri)));
  return sprintf (fmt, res);
}
;

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('tut_nw_rdf', 1,
    '/tutorial/Northwind/(.*)', vector('path'), 1,
    '/tutorial/Northwind/data/rdf/%U', vector('path'),
    'DB.DBA.TUT_NORTHWIND_DET_REF',
    'application/rdf.xml',
    2,
    303);

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'tut_nw_rule_list1',
    1,
    vector (
                'tut_nw_rule1',
                'tut_nw_rule2',
                'tut_nw_rule3',
                'tut_nw_rdf'
          ));


VHOST_REMOVE (lpath=>'/tutorial/Northwind');
DB.DBA.VHOST_DEFINE (lpath=>'/tutorial/Northwind', ppath=>'/DAV/VAD/tutorial/rdfview/rd_v_1/', vsp_user=>'dba', is_dav=>1, def_page=>'sfront.vspx',
          is_brws=>0, opts=>vector ('url_rewrite', 'tut_nw_rule_list1'));

create procedure DB.DBA.LOAD_TUTNW_ONTOLOGY_FROM_DAV()
{
  declare content, urihost varchar;
  whenever not found goto endpoint;
  select cast (RES_CONTENT as varchar) into content from WS.WS.SYS_DAV_RES where RES_FULL_PATH = '/DAV/VAD/tutorial/rdfview/rd_v_1/rd_v_1.owl';
  if (content is null or content = '')
    goto endpoint;
  DB.DBA.RDF_LOAD_RDFXML (content, 'http://demo.openlinksw.com/schemas/tutorial/northwind#', 'http://demo.openlinksw.com/schemas/TutorialNorthwindOntology/1.0/');
  if (urihost = 'demo.openlinksw.com')
  {
    DB.DBA.VHOST_REMOVE (lpath=>'/schemas/tutorial/northwind#');
    DB.DBA.VHOST_DEFINE (lpath=>'/schemas/tutorial/northwind#', ppath=>'/DAV/VAD/tutorial/rdfview/rd_v_1/rd_v_1.owl', vsp_user=>'dba', is_dav=>1, is_brws=>0);
    DB.DBA.VHOST_REMOVE (lpath=>'/schemas/tutorial/northwind');
    DB.DBA.VHOST_DEFINE (lpath=>'/schemas/tutorial/northwind', ppath=>'/DAV/VAD/tutorial/rdfview/rd_v_1/rd_v_1.owl', vsp_user=>'dba', is_dav=>1, is_brws=>0);
  }
  endpoint:
  ;
}
;

DB.DBA.LOAD_TUTNW_ONTOLOGY_FROM_DAV()
;

drop procedure DB.DBA.LOAD_TUTNW_ONTOLOGY_FROM_DAV
;

create procedure DB.DBA.LOAD_TUTNW_ONTOLOGY_FROM_DAV2()
{
  declare urihost varchar;
  sparql base <http://demo.openlinksw.com/schemas/tutorial/northwind#> load bif:concat ("http://", bif:registry_get("URIQADefaultHost"), "/DAV/VAD/tutorial/rdfview/rd_v_1/rd_v_1.owl")
   into graph <http://demo.openlinksw.com/schemas/TutorialNorthwindOntology/1.0/>;
  urihost := cfg_item_value(virtuoso_ini_path(), 'URIQA','DefaultHost');
  if (urihost = 'demo.openlinksw.com')
  {
    DB.DBA.VHOST_REMOVE (lpath=>'/tutorial/northwind#');
    DB.DBA.VHOST_DEFINE (lpath=>'/tutorial/northwind#', ppath=>'/DAV/VAD/tutorial/rdfview/rd_v_1/rd_v_1.owl', vsp_user=>'dba', is_dav=>1, is_brws=>0);
  }
}
;

--DB.DBA.LOAD_TUTNW_ONTOLOGY_FROM_DAV2();

drop procedure DB.DBA.LOAD_TUTNW_ONTOLOGY_FROM_DAV2
;

DB.DBA.XML_SET_NS_DECL ('tut_northwind', 'http://demo.openlinksw.com/schemas/tutorial/northwind#', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsenterprsn">
      <title>SQL Server's Northwind Demo Database</title>
<programlisting><![CDATA[
use DB;

DB.DBA.exec_stmt ('UPDATE WS.WS.SYS_DAV_RES set RES_TYPE=\'image/jpeg\' where RES_FULL_PATH like \'/DAV/VAD/demo/sql/CAT%\'', 0)
;

DB.DBA.exec_stmt ('UPDATE WS.WS.SYS_DAV_RES set RES_TYPE=\'image/jpeg\' where RES_FULL_PATH like \'/DAV/VAD/demo/sql/EMP%\'', 0)
;

GRANT SELECT ON "Demo"."demo"."Products" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Suppliers" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Shippers" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Categories" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Customers" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Employees" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Orders" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Order_Details" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Countries" TO "SPARQL";
GRANT SELECT ON "Demo"."demo"."Provinces" TO "SPARQL";


SPARQL drop quad map graph iri("http://^{URIQADefaultHost}^/Northwind") .
;

SPARQL drop quad map virtrdf:NorthwindDemo .
;

SPARQL
prefix northwind: <http://demo.openlinksw.com/schemas/northwind#>
drop iri class northwind:Category .
drop iri class northwind:CategoryDoc .
drop iri class northwind:Shipper .
drop iri class northwind:ShipperDoc .
drop iri class northwind:Supplier .
drop iri class northwind:SupplierDoc .
drop iri class northwind:Product .
drop iri class northwind:ProductDoc .
drop iri class northwind:Customer .
drop iri class northwind:CustomerDoc .
drop iri class northwind:Employee .
drop iri class northwind:EmployeeDoc .
drop iri class northwind:Order .
drop iri class northwind:OrderDoc .
drop iri class northwind:CustomerContact .
drop iri class northwind:CustomerContactDoc .
drop iri class northwind:OrderLine .
drop iri class northwind:OrderLineDoc .
drop iri class northwind:Province .
drop iri class northwind:ProvinceDoc .
drop iri class northwind:Country .
drop iri class northwind:CountryDoc .
drop iri class northwind:Flag .
drop iri class northwind:FlagDoc .
drop iri class northwind:dbpedia_iri2 .
drop iri class northwind:EmployeePhoto .
drop iri class northwind:CategoryPhoto .

drop iri class northwind:category_iri .
drop iri class northwind:categorydoc_iri .
drop iri class northwind:shipper_iri .
drop iri class northwind:shipperdoc_iri .
drop iri class northwind:supplier_iri .
drop iri class northwind:supplierdoc_iri .
drop iri class northwind:product_iri .
drop iri class northwind:productdoc_iri .
drop iri class northwind:customer_iri .
drop iri class northwind:customerdoc_iri .
drop iri class northwind:employee_iri .
drop iri class northwind:employeedoc_iri .
drop iri class northwind:order_iri .
drop iri class northwind:orderdoc_iri .
drop iri class northwind:customercontact_iri .
drop iri class northwind:customercontactdoc_iri .
drop iri class northwind:orderline_iri .
drop iri class northwind:orderlinedoc_iri .
drop iri class northwind:province_iri .
drop iri class northwind:provincedoc_iri .
drop iri class northwind:country_iri .
drop iri class northwind:countrydoc_iri .
drop iri class northwind:employeephoto_iri .
drop iri class northwind:categoryphoto_iri .
drop iri class northwind:flag_iri .
drop iri class northwind:flagdoc_iri .
;

SPARQL
prefix northwind: <http://demo.openlinksw.com/schemas/northwind#>

create iri class northwind:Category "http://^{URIQADefaultHost}^/Northwind/Category/%d#this" (in category_id integer not null) .
create iri class northwind:CategoryDoc "http://^{URIQADefaultHost}^/Northwind/Category/%d" (in category_id integer not null) .
create iri class northwind:Shipper "http://^{URIQADefaultHost}^/Northwind/Shipper/%d#this" (in shipper_id integer not null) .
create iri class northwind:ShipperDoc "http://^{URIQADefaultHost}^/Northwind/Shipper/%d" (in shipper_id integer not null) .
create iri class northwind:Supplier "http://^{URIQADefaultHost}^/Northwind/Supplier/%d#this" (in supplier_id integer not null) .
create iri class northwind:SupplierDoc "http://^{URIQADefaultHost}^/Northwind/Supplier/%d" (in supplier_id integer not null) .
create iri class northwind:Product   "http://^{URIQADefaultHost}^/Northwind/Product/%d#this" (in product_id integer not null) .
create iri class northwind:ProductDoc   "http://^{URIQADefaultHost}^/Northwind/Product/%d" (in product_id integer not null) .
create iri class northwind:Customer "http://^{URIQADefaultHost}^/Northwind/Customer/%U#this" (in customer_id varchar not null) .
create iri class northwind:CustomerDoc "http://^{URIQADefaultHost}^/Northwind/Customer/%U" (in customer_id varchar not null) .
create iri class northwind:Employee "http://^{URIQADefaultHost}^/Northwind/Employee/%U_%U_%d#this" (in employee_firstname varchar not null, in employee_lastname varchar not null, in employee_id integer not null) .
create iri class northwind:EmployeeDoc "http://^{URIQADefaultHost}^/Northwind/Employee/%U_%U_%d" (in employee_firstname varchar not null, in employee_lastname varchar not null, in employee_id integer not null) .
create iri class northwind:Order "http://^{URIQADefaultHost}^/Northwind/Order/%d#this" (in order_id integer not null) .
create iri class northwind:OrderDoc "http://^{URIQADefaultHost}^/Northwind/Order/%d" (in order_id integer not null) .
create iri class northwind:CustomerContact "http://^{URIQADefaultHost}^/Northwind/CustomerContact/%U#this" (in customer_id varchar not null) .
create iri class northwind:CustomerContactDoc "http://^{URIQADefaultHost}^/Northwind/CustomerContact/%U" (in customer_id varchar not null) .
create iri class northwind:OrderLine "http://^{URIQADefaultHost}^/Northwind/OrderLine/%d/%d#this" (in order_id integer not null, in product_id integer not null) .
create iri class northwind:OrderLineDoc "http://^{URIQADefaultHost}^/Northwind/OrderLine/%d/%d" (in order_id integer not null, in product_id integer not null) .
create iri class northwind:Province "http://^{URIQADefaultHost}^/Northwind/Province/%U/%U#this" (in country_name varchar not null, in province_name varchar not null) .
create iri class northwind:ProvinceDoc "http://^{URIQADefaultHost}^/Northwind/Province/%U/%U" (in country_name varchar not null, in province_name varchar not null) .
create iri class northwind:Country "http://^{URIQADefaultHost}^/Northwind/Country/%U#this" (in country_name varchar not null) .
create iri class northwind:CountryDoc "http://^{URIQADefaultHost}^/Northwind/Country/%U" (in country_name varchar not null) .
create iri class northwind:Flag "http://^{URIQADefaultHost}^%U#this" (in flag_path varchar not null) .
create iri class northwind:FlagDoc "http://^{URIQADefaultHost}^%U" (in flag_path varchar not null) .
create iri class northwind:dbpedia_iri2 "http://dbpedia.org/resource/%U" (in uname varchar not null) .
create iri class northwind:EmployeePhoto "http://^{URIQADefaultHost}^/DAV/VAD/demo/sql/EMP%d#this" (in emp_id varchar not null) .
create iri class northwind:CategoryPhoto "http://^{URIQADefaultHost}^/DAV/VAD/demo/sql/CAT%d#this" (in category_id varchar not null) .
create iri class northwind:Phone "tel:%s" (in phone_number varchar) .
create iri class northwind:Fax "fax:%s" (in fax_number varchar) .
;

SPARQL
prefix northwind: <http://demo.openlinksw.com/schemas/northwind#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>

alter quad storage virtrdf:DefaultQuadStorage
from Demo.demo.Products as products
from Demo.demo.Suppliers as suppliers
from Demo.demo.Shippers as shippers
from Demo.demo.Categories as categories
from Demo.demo.Customers as customers
from Demo.demo.Employees as employees
from Demo.demo.Orders as orders
from Demo.demo.Order_Details as order_lines
from Demo.demo.Countries as countries
from Demo.demo.Provinces as provinces
where (^{suppliers.}^.Country = ^{countries.}^.Name)
where (^{customers.}^.Country = ^{countries.}^.Name)
where (^{employees.}^.Country = ^{countries.}^.Name)
where (^{orders.}^.ShipCountry = ^{countries.}^.Name)
{
        create virtrdf:NorthwindDemo as graph iri ("http://^{URIQADefaultHost}^/Northwind") option (exclusive)
        {
                northwind:CustomerContact (customers.CustomerID)
                        a foaf:Person
                                as virtrdf:CustomerContact-foaf_Person .

                northwind:CustomerContact (customers.CustomerID)
                        a northwind:CustomerContact
                                as virtrdf:CustomerContact-CustomerContact;
                        foaf:name customers.ContactName
                                as virtrdf:CustomerContact-contact_name ;
                        foaf:phone northwind:Phone (customers.Phone)
                                as virtrdf:CustomerContact-foaf_phone ;
                        northwind:is_contact_at northwind:Customer (customers.CustomerID)
                                as virtrdf:CustomerContact-is_contact_at ;
                        northwind:country northwind:Country (customers.Country)
                                as virtrdf:CustomerContact-country ;
                        rdfs:isDefinedBy northwind: .

                northwind:CustomerContactDoc (customers.CustomerID)
                        a northwind:CustomerContactDoc
                                as virtrdf:CustomerContactDoc-CustomerID ;
                        a foaf:Document
                                as virtrdf:CustomerContactDoc-foaf_DocCustomerID ;
                        foaf:primaryTopic northwind:CustomerContact (customers.CustomerID)
                                as virtrdf:CustomerContactDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:Country (customers.Country)
                        northwind:is_country_of
                northwind:CustomerContact (customers.CustomerID) as virtrdf:CustomerContact-is_country_of .

                northwind:Product (products.ProductID)
                        a northwind:Product
                                as virtrdf:Product-ProductID ;
                        northwind:has_category northwind:Category (products.CategoryID)
                                as virtrdf:Product-product_has_category ;
                        northwind:has_supplier northwind:Supplier (products.SupplierID)
                                as virtrdf:Product-product_has_supplier ;
                        northwind:productName products.ProductName
                                as virtrdf:Product-name_of_product ;
                        northwind:quantityPerUnit products.QuantityPerUnit
                                as virtrdf:Product-quantity_per_unit ;
                        northwind:unitPrice products.UnitPrice
                                as virtrdf:Product-unit_price ;
                        northwind:unitsInStock products.UnitsInStock
                                as virtrdf:Product-units_in_stock ;
                        northwind:unitsOnOrder products.UnitsOnOrder
                                as virtrdf:Product-units_on_order ;
                        northwind:reorderLevel products.ReorderLevel
                                as virtrdf:Product-reorder_level ;
                        northwind:discontinued products.Discontinued
                                as virtrdf:Product-discontinued ;
                        rdfs:isDefinedBy northwind: .

                northwind:ProductDoc (products.ProductID)
                        a northwind:ProductDoc
                                as virtrdf:ProductDoc-ProductID ;
                        a foaf:Document
                                as virtrdf:ProductDoc-foaf_DocProductID ;
                        foaf:primaryTopic northwind:Product (products.ProductID)
                                as virtrdf:ProductDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:Category (products.CategoryID)
                        northwind:category_of northwind:Product (products.ProductID) as virtrdf:Product-category_of .

                northwind:Supplier (products.SupplierID)
                        northwind:supplier_of northwind:Product (products.ProductID) as virtrdf:Product-supplier_of .

                northwind:Supplier (suppliers.SupplierID)
                        a northwind:Supplier
                                as virtrdf:Supplier-SupplierID ;
                        northwind:companyName suppliers.CompanyName
                                as virtrdf:Supplier-company_name ;
                        northwind:contactName suppliers.ContactName
                                as virtrdf:Supplier-contact_name ;
                        northwind:contactTitle suppliers.ContactTitle
                                as virtrdf:Supplier-contact_title ;
                        northwind:address suppliers.Address
                                as virtrdf:Supplier-address ;
                        northwind:city northwind:dbpedia_iri2(suppliers.City)
                                as virtrdf:Supplier-dbpediacity ;
                        northwind:region suppliers.Region
                                as virtrdf:Supplier-region ;
                        northwind:postalCode suppliers.PostalCode
                                as virtrdf:Supplier-postal_code ;
                        northwind:country northwind:Country(suppliers.Country)
                                as virtrdf:Supplier-country ;
                        northwind:phone northwind:Phone (suppliers.Phone)
                                as virtrdf:Supplier-phone ;
                        northwind:fax northwind:Fax (suppliers.Fax)
                                as virtrdf:Supplier-fax ;
                        northwind:homePage suppliers.HomePage
                                as virtrdf:Supplier-home_page ;
                        rdfs:isDefinedBy northwind: .

                northwind:SupplierDoc (suppliers.SupplierID)
                        a northwind:SupplierDoc
                                as virtrdf:SupplierDoc-SupplierID ;
                        a foaf:Document
                                as virtrdf:SupplierDoc-foaf_DocSupplierID ;
                        foaf:primaryTopic northwind:Supplier (suppliers.SupplierID)
                                as virtrdf:SupplierDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:Country (suppliers.Country)
                        northwind:is_country_of
                northwind:Supplier (suppliers.SupplierID) as virtrdf:Supplier-is_country_of .

                northwind:Category (categories.CategoryID)
                        a northwind:Category
                                as virtrdf:Category-CategoryID ;
                        northwind:categoryName categories.CategoryName
                                as virtrdf:Category-home_page ;
                        northwind:description categories.Description
                                as virtrdf:Category-description ;
                        foaf:img northwind:CategoryPhoto(categories.CategoryID)
                                as virtrdf:Category-categories.CategoryPhoto ;
                        rdfs:isDefinedBy northwind: .

                northwind:CategoryDoc (categories.CategoryID)
                        a northwind:CategoryDoc
                                as virtrdf:CategoryDoc-CategoryID ;
                        a foaf:Document
                                as virtrdf:CategoryDoc-foaf_DocCategoryID ;
                        foaf:primaryTopic northwind:Category (categories.CategoryID)
                                as virtrdf:CategoryDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:CategoryPhoto(categories.CategoryID)
                        a northwind:CategoryPhoto
                                as virtrdf:Category-categories.CategoryPhotoID ;
                        rdfs:isDefinedBy northwind: .

                northwind:Shipper (shippers.ShipperID)
                        a northwind:Shipper
                                as virtrdf:Shipper-ShipperID ;
                        northwind:companyName shippers.CompanyName
                                as virtrdf:Shipper-company_name ;
                        northwind:phone northwind:Phone (shippers.Phone)
                                as virtrdf:Shipper-phone ;
                        rdfs:isDefinedBy northwind: .

                northwind:ShipperDoc (shippers.ShipperID)
                        a northwind:ShipperDoc
                                as virtrdf:ShipperDoc-ShipperID ;
                        a foaf:Document
                                as virtrdf:ShipperDoc-foaf_DocShipperID ;
                        foaf:primaryTopic northwind:Shipper (shippers.ShipperID)
                                as virtrdf:ShipperDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:Customer (customers.CustomerID)
                        a  northwind:Customer
                                as virtrdf:Customer-CustomerID2 ;
                        a  foaf:Organization
                                as virtrdf:Customer-CustomerID ;
                        foaf:name customers.CompanyName
                                as virtrdf:Customer-foaf_name ;
                        northwind:companyName customers.CompanyName
                                as virtrdf:Customer-company_name ;
                        northwind:has_contact northwind:CustomerContact (customers.CustomerID)
                                as virtrdf:Customer-contact ;
                        northwind:country northwind:Country (customers.Country)
                                as virtrdf:Customer-country ;
                        northwind:contactName customers.ContactName
                                as virtrdf:Customer-contact_name ;
                        northwind:contactTitle customers.ContactTitle
                                as virtrdf:Customer-contact_title ;
                        northwind:address customers.Address
                                as virtrdf:Customer-address ;
                        northwind:city northwind:dbpedia_iri2(customers.City)
                                as virtrdf:Customer-dbpediacity ;
                        northwind:region customers.Region
                                as virtrdf:Customer-region ;
                        northwind:PostalCode customers.PostalCode
                                as virtrdf:Customer-postal_code ;
                        foaf:phone northwind:Phone (customers.Phone)
                                as virtrdf:Customer-foaf_phone ;
                        northwind:phone northwind:Phone (customers.Phone)
                                as virtrdf:Customer-phone ;
                        northwind:fax northwind:Fax (customers.Fax)
                                as virtrdf:Customer-fax ;
                        rdfs:isDefinedBy northwind: .

                northwind:CustomerDoc (customers.CustomerID)
                        a  northwind:CustomerDoc
                                as virtrdf:CustomerDoc-CustomerID2 ;
                        a  foaf:Document
                                as virtrdf:CustomerDoc-CustomerID3 ;
                        foaf:primaryTopic northwind:Customer (customers.CustomerID)
                                as virtrdf:CustomerDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:Country (customers.Country)
                        northwind:is_country_of
                northwind:Customer (customers.CustomerID) as virtrdf:Customer-is_country_of .

                northwind:Employee (employees.FirstName, employees.LastName, employees.EmployeeID)
                        a northwind:Employee
                                as virtrdf:Employee-EmployeeID2 ;
                        a foaf:Person
                                as virtrdf:Employee-EmployeeID ;
                        foaf:surname employees.LastName
                                as virtrdf:Employee-foaf_last_name ;
                        northwind:lastName employees.LastName
                                as virtrdf:Employee-last_name ;
                        foaf:firstName employees.FirstName
                                as virtrdf:Employee-foaf_first_name ;
                        northwind:firstName employees.FirstName
                                as virtrdf:Employee-first_name ;
                        foaf:title employees.Title
                                as virtrdf:Employee-title ;
                        northwind:titleOfCourtesy employees.TitleOfCourtesy
                                as virtrdf:Employee-title_of_courtesy ;
                        foaf:birthday employees.BirthDate
                                as virtrdf:Employee-foaf_birth_date ;
                        northwind:birthday employees.BirthDate
                                as virtrdf:Employee-birth_date ;
                        northwind:hireDate employees.HireDate
                                as virtrdf:Employee-hire_date ;
                        northwind:address employees.Address
                                as virtrdf:Employee-address ;
                        northwind:city northwind:dbpedia_iri2(employees.City)
                                as virtrdf:Employee-dbpediacity ;
                        northwind:region employees.Region
                                as virtrdf:Employee-region ;
                        northwind:postalCode employees.PostalCode
                                as virtrdf:Employee-postal_code ;
                        northwind:country northwind:Country(employees.Country)
                                as virtrdf:Employee-country ;
                        foaf:phone employees.HomePhone
                                as virtrdf:Employee-home_phone ;
                        northwind:extension employees.Extension
                                as virtrdf:Employee-extension ;
                        northwind:notes employees.Notes
                                as virtrdf:Employee-notes ;
                        northwind:reportsTo northwind:Employee(employees.FirstName, employees.LastName, employees.ReportsTo) where (^{employees.}^.ReportsTo = ^{employees.}^.EmployeeID)
                                as virtrdf:Employee-reports_to ;
                        foaf:img northwind:EmployeePhoto(employees.EmployeeID)
                                as virtrdf:Employee-employees.EmployeePhoto ;
                        rdfs:isDefinedBy northwind: .

                northwind:EmployeeDoc (employees.FirstName, employees.LastName, employees.EmployeeID)
                        a  northwind:EmployeeDoc
                                as virtrdf:EmployeeDoc-EmployeeID2 ;
                        a  foaf:Document
                                as virtrdf:EmployeeDoc-EmployeeID3 ;
                        foaf:primaryTopic northwind:Employee (employees.FirstName, employees.LastName, employees.EmployeeID)
                                as virtrdf:EmployeeDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:EmployeePhoto(employees.EmployeeID)
                        a northwind:EmployeePhoto
                                as virtrdf:Employee-employees.EmployeePhotoId ;
                        rdfs:isDefinedBy northwind: .

                northwind:Employee (employees.FirstName, employees.LastName, orders.EmployeeID)
                        northwind:is_salesrep_of
                northwind:Order (orders.OrderID) where (^{orders.}^.EmployeeID = ^{employees.}^.EmployeeID) as virtrdf:Order-is_salesrep_of .

                northwind:Country (employees.Country)
                        northwind:is_country_of
                northwind:Employee (employees.FirstName, employees.LastName, employees.EmployeeID) as virtrdf:Employee-is_country_of .

                northwind:Order (orders.OrderID)
                        a northwind:Order
                                as virtrdf:Order-Order ;
                        northwind:has_customer northwind:Customer (orders.CustomerID)
                                as virtrdf:Order-order_has_customer ;
                        northwind:has_salesrep northwind:Employee (employees.FirstName, employees.LastName, orders.EmployeeID) where (^{orders.}^.EmployeeID = ^{employees.}^.EmployeeID)
                                as virtrdf:Customer-has_salesrep ;
                        northwind:has_employee northwind:Employee (employees.FirstName, employees.LastName, orders.EmployeeID) where (^{orders.}^.EmployeeID = ^{employees.}^.EmployeeID)
                                as virtrdf:Order-order_has_employee ;
                        northwind:orderDate orders.OrderDate
                                as virtrdf:Order-order_date ;
                        northwind:requiredDate orders.RequiredDate
                                as virtrdf:Order-required_date ;
                        northwind:shippedDate orders.ShippedDate
                                as virtrdf:Order-shipped_date ;
                        northwind:order_ship_via northwind:Shipper (orders.ShipVia)
                                as virtrdf:Order-order_ship_via ;
                        northwind:freight orders.Freight
                                as virtrdf:Order-freight ;
                        northwind:shipName orders.ShipName
                                as virtrdf:Order-ship_name ;
                        northwind:shipAddress orders.ShipAddress
                                as virtrdf:Order-ship_address ;
                        northwind:shipCity northwind:dbpedia_iri2(orders.ShipCity)
                                as virtrdf:Order-dbpediaship_city ;
                        northwind:shipRegion orders.ShipRegion
                                as virtrdf:Order-ship_region ;
                        northwind:shipPostal_code orders.ShipPostalCode
                                as virtrdf:Order-ship_postal_code ;
                        northwind:shipCountry northwind:Country(orders.ShipCountry)
                                as virtrdf:ship_country ;
                        rdfs:isDefinedBy northwind: .

                northwind:OrderDoc (orders.OrderID)
                        a  northwind:OrderDoc
                                as virtrdf:OrderDoc-OrderID2 ;
                        a  foaf:Document
                                as virtrdf:OrderDoc-OrderID3 ;
                        foaf:primaryTopic northwind:Order (orders.OrderID)
                                as virtrdf:OrderDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:Country (orders.ShipCountry)
                        northwind:is_ship_country_of
                northwind:Order (orders.OrderID) as virtrdf:Order-is_country_of .

                northwind:Customer (orders.CustomerID)
                        northwind:has_order northwind:Order (orders.OrderID) as virtrdf:Order-has_order .

                northwind:Shipper (orders.ShipVia)
                        northwind:ship_order northwind:Order (orders.OrderID) as virtrdf:Order-ship_order .

                northwind:OrderLine (order_lines.OrderID, order_lines.ProductID)
                        a northwind:OrderLine
                                as virtrdf:OrderLine-OrderLines ;
                        northwind:has_order_id northwind:Order (order_lines.OrderID)
                                as virtrdf:order_lines_has_order_id ;
                        northwind:has_product_id northwind:Product (order_lines.ProductID)
                                as virtrdf:order_lines_has_product_id ;
                        northwind:unitPrice order_lines.UnitPrice
                                as virtrdf:OrderLine-unit_price ;
                        northwind:quantity order_lines.Quantity
                                as virtrdf:OrderLine-quantity ;
                        northwind:discount order_lines.Discount
                                as virtrdf:OrderLine-discount ;
                        rdfs:isDefinedBy northwind: .

                northwind:OrderLineDoc (order_lines.OrderID, order_lines.ProductID)
                        a  northwind:OrderLineDoc
                                as virtrdf:OrderLineDoc-OrderLineID2 ;
                        a  foaf:Document
                                as virtrdf:OrderLineDoc-OrderLineID3 ;
                        foaf:primaryTopic northwind:OrderLine (order_lines.OrderID, order_lines.ProductID)
                                as virtrdf:OrderLineDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:Order (orders.OrderID)
                        northwind:is_order_of
                northwind:OrderLine (order_lines.OrderID, order_lines.ProductID) where (^{orders.}^.OrderID = ^{order_lines.}^.OrderID) as virtrdf:Order-is_order_of .

                northwind:Product (products.ProductID)
                        northwind:is_product_of
                northwind:OrderLine (order_lines.OrderID, order_lines.ProductID) where (^{products.}^.ProductID = ^{order_lines.}^.ProductID) as virtrdf:Product-is_product_of .

                northwind:Country (countries.Name)
                        a northwind:Country
                                as virtrdf:Country-Type2 ;
                        a wgs:SpatialThing
                                as virtrdf:Country-Type ;
                        owl:sameAs northwind:dbpedia_iri2 (countries.Name) ;
                        northwind:name countries.Name
                                as virtrdf:Country-Name ;
                        northwind:code countries.Code
                                as virtrdf:Country-Code ;
                        northwind:smallFlagDAVResourceName countries.SmallFlagDAVResourceName
                                as virtrdf:Country-SmallFlagDAVResourceName ;
                        northwind:largeFlagDAVResourceName countries.LargeFlagDAVResourceName
                                as virtrdf:Country-LargeFlagDAVResourceName ;
                        northwind:smallFlagDAVResourceURI northwind:Flag(countries.SmallFlagDAVResourceURI)
                                as virtrdf:Country-SmallFlagDAVResourceURI ;
                        northwind:largeFlagDAVResourceURI northwind:Flag(countries.LargeFlagDAVResourceURI)
                                as virtrdf:Country-LargeFlagDAVResourceURI ;
                        wgs:lat countries.Lat
                                as virtrdf:Country-Lat ;
                        wgs:long countries.Lng
                                as virtrdf:Country-Lng ;
                        rdfs:isDefinedBy northwind: .

                northwind:CountryDoc (countries.Name)
                        a  northwind:CountryDoc
                                as virtrdf:CountryDoc-CountryID2 ;
                        a  foaf:Document
                                as virtrdf:CountryDoc-CountryID3 ;
                        foaf:primaryTopic northwind:Country (countries.Name)
                                as virtrdf:CountryDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:Country (countries.Name)
                        northwind:has_province
                northwind:Province (provinces.CountryCode, provinces.Province) where (^{provinces.}^.CountryCode = ^{countries.}^.Code) as virtrdf:Country-has_province .

                northwind:Province (provinces.CountryCode, provinces.Province)
                        a northwind:Province
                                as virtrdf:Province-Provinces ;
                        owl:sameAs northwind:dbpedia_iri2 (provinces.Province) ;
                        northwind:has_country_code provinces.CountryCode
                                as virtrdf:has_country_code ;
                        northwind:provinceName provinces.Province
                                as virtrdf:Province-ProvinceName ;
                        rdfs:isDefinedBy northwind: .

                northwind:ProvinceDoc (provinces.CountryCode, provinces.Province)
                        a  northwind:ProvinceDoc
                                as virtrdf:ProvinceDoc-ProvinceID2 ;
                        a  foaf:Document
                                as virtrdf:ProvinceDoc-ProvinceID3 ;
                        foaf:primaryTopic northwind:Province (provinces.CountryCode, provinces.Province)
                                as virtrdf:ProvinceDoc-foaf_primarytopic ;
                        rdfs:isDefinedBy northwind: .

                northwind:Province (provinces.CountryCode, provinces.Province)
                        northwind:is_province_of
                northwind:Country (countries.Name) where  (^{countries.}^.Code = ^{provinces.}^.CountryCode) as virtrdf:Province-country_of .
        }.
}.
;

delete from DB.DBA.URL_REWRITE_RULE_LIST where urrl_list like 'demo_nw%';
delete from DB.DBA.URL_REWRITE_RULE where urr_rule like 'demo_nw%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'demo_nw_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=DESCRIBE+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%3E+FROM+%%3Chttp%%3A//^{URIQADefaultHost}^/Northwind%%3E&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'demo_nw_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'demo_nw_rule_list1',
    1,
    vector (
                'demo_nw_rule1',
                'demo_nw_rule2'
          ));


VHOST_REMOVE (lpath=>'/Northwind');
DB.DBA.VHOST_DEFINE (lpath=>'/Northwind', ppath=>'/DAV/home/demo/', vsp_user=>'dba', is_dav=>1,
          is_brws=>0, opts=>vector ('url_rewrite', 'demo_nw_rule_list1'));

create procedure DB.DBA.LOAD_NW_ONTOLOGY_FROM_DAV()
{
  declare content1, urihost varchar;
  select cast (RES_CONTENT as varchar) into content1 from WS.WS.SYS_DAV_RES where RES_FULL_PATH = '/DAV/VAD/demo/sql/nw.owl';
  DB.DBA.RDF_LOAD_RDFXML (content1, 'http://demo.openlinksw.com/schemas/northwind#', 'http://demo.openlinksw.com/schemas/NorthwindOntology/1.0/');
  urihost := cfg_item_value(virtuoso_ini_path(), 'URIQA','DefaultHost');
  if (urihost = 'demo.openlinksw.com')
  {
    DB.DBA.VHOST_REMOVE (lpath=>'/schemas/northwind');
    DB.DBA.VHOST_DEFINE (lpath=>'/schemas/northwind', ppath=>'/DAV/VAD/demo/sql/nw.owl', vsp_user=>'dba', is_dav=>1, is_brws=>0);
    DB.DBA.VHOST_REMOVE (lpath=>'/schemas/northwind#');
    DB.DBA.VHOST_DEFINE (lpath=>'/schemas/northwind#', ppath=>'/DAV/VAD/demo/sql/nw.owl', vsp_user=>'dba', is_dav=>1, is_brws=>0);
  }
};

DB.DBA.LOAD_NW_ONTOLOGY_FROM_DAV();
drop procedure DB.DBA.LOAD_NW_ONTOLOGY_FROM_DAV;

DB.DBA.XML_SET_NS_DECL ('northwind', 'http://demo.openlinksw.com/schemas/northwind#', 2);
]]></programlisting>
    <para><emphasis>Basic Northwind Ontology</emphasis></para>
<programlisting><![CDATA[
<?xml version="1.0" encoding="utf-8"?>
<!--
 -
 -
 -  This file is part of the OpenLink Software Virtuoso Open-Source (VOS)
 -  project.
 -
 -  Copyright (C) 1998-2007 OpenLink Software
 -
 -  This project is free software; you can redistribute it and/or modify it
 -  under the terms of the GNU General Public License as published by the
 -  Free Software Foundation; only version 2 of the License, dated June 1991.
 -
 -  This program is distributed in the hope that it will be useful, but
 -  WITHOUT ANY WARRANTY; without even the implied warranty of
 -  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 -  General Public License for more details.
 -
 -  You should have received a copy of the GNU General Public License along
 -  with this program; if not, write to the Free Software Foundation, Inc.,
 -  51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 -
-->
<rdf:RDF xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:owl ="http://www.w3.org/2002/07/owl#"
         xmlns:virtrdf="http://www.openlinksw.com/schemas/virtrdf#"
         xml:base="http://demo.openlinksw.com/schemas/northwind#">
  <owl:Ontology rdf:about="http://demo.openlinksw.com/schemas/northwind#">
        <rdfs:label>Northwind</rdfs:label>
        <rdfs:comment>Northwind database classes and properties</rdfs:comment>
        <virtrdf:catName>Northwind</virtrdf:catName>
        <virtrdf:version>1.00</virtrdf:version>
  </owl:Ontology>

  <rdfs:Class rdf:ID="Product">
    <rdfs:label>Product</rdfs:label>
  </rdfs:Class>
  <rdf:Property rdf:ID="has_category">
    <rdfs:range rdf:resource="#Category"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Category</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="has_supplier">
    <rdfs:range rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Supplier</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ProductName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ProductName</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="QuantityPerUnit">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>QuantityPerUnit</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="UnitPrice">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#double"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:domain rdf:resource="#OrderLine"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>UnitPrice</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="UnitsInStock">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>UnitsInStock</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="UnitsOnOrder">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>UnitsOnOrder</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ReorderLevel">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ReorderLevel</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Discontinued">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Discontinued</rdfs:label>
  </rdf:Property>

  <rdfs:Class rdf:ID="Supplier">
    <rdfs:label>Supplier</rdfs:label>
  </rdfs:Class>
  <rdf:Property rdf:ID="CompanyName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Shipper"/>
    <rdfs:domain rdf:resource="#Customer"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>CompanyName</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ContactName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Customer"/>
    <rdfs:domain rdf:resource="#CustomerContact"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ContactName</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ContactTitle">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/title"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Customer"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ContactTitle</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Address">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Customer"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Address</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="City">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Customer"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>City</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Region">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Customer"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Region</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="PostalCode">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Customer"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>PostalCode</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="CountryName">
    <rdfs:range rdf:resource="#Country"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Customer"/>
    <rdfs:domain rdf:resource="#CustomerContact"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Country</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Phone">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/phone"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Shipper"/>
    <rdfs:domain rdf:resource="#Customer"/>
    <rdfs:domain rdf:resource="#CustomerContact"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Phone</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Fax">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:domain rdf:resource="#Customer"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Fax</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="HomePage">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Supplier"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>HomePage</rdfs:label>
  </rdf:Property>

  <rdfs:Class rdf:ID="Category">
    <rdfs:label>Category</rdfs:label>
  </rdfs:Class>
  <rdf:Property rdf:ID="CategoryName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Category"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>CategoryName</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Description">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Category"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Description</rdfs:label>
  </rdf:Property>

  <rdfs:Class rdf:ID="Shipper">
    <rdfs:label>Shipper</rdfs:label>
  </rdfs:Class>

  <rdfs:Class rdf:ID="CustomerContact">
    <rdfs:label>CustomerContact</rdfs:label>
    <rdfs:subClassOf rdf:resource="http://xmlns.com/foaf/0.1/Person"/>
  </rdfs:Class>

  <rdfs:Class rdf:ID="Customer">
    <rdfs:label>Customer</rdfs:label>
    <rdfs:subClassOf rdf:resource="http://xmlns.com/foaf/0.1/Organization"/>
  </rdfs:Class>

  <rdfs:Class rdf:ID="Employee">
    <rdfs:label>Employee</rdfs:label>
    <rdfs:subClassOf rdf:resource="http://xmlns.com/foaf/0.1/Person"/>
  </rdfs:Class>
  <rdf:Property rdf:ID="LastName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/surname"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>LastName</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="FirstName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/firstName"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>FirstName</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Title">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/title"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Title</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="TitleOfCourtesy">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>TitleOfCourtesy</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="BirthDate">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/birthday"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>BirthDate</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="HireDate">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>HireDate</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Extension">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Extension</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Notes">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Notes</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ReportsTo">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/>
    <rdfs:domain rdf:resource="#Employee"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ReportsTo</rdfs:label>
  </rdf:Property>

  <rdfs:Class rdf:ID="Order">
    <rdfs:label>Order</rdfs:label>
  </rdfs:Class>
  <rdf:Property rdf:ID="has_customer">
    <rdfs:range rdf:resource="#Customer"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Customer</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="has_employee">
    <rdfs:range rdf:resource="#Employee"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Employee</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="OrderDate">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>OrderDate</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="RequiredDate">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>RequiredDate</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ShippedDate">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ShippedDate</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="order_ship_via">
    <rdfs:range rdf:resource="#Shipper"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Shipper</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Freight">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#double"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Freight</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ShipName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ShipName</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ShipAddress">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ShipAddress</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ShipCity">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ShipCity</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ShipRegion">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ShipRegion</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ShipPostalCode">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ShipPostalCode</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ShipCountry">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Order"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ShipCountry</rdfs:label>
  </rdf:Property>

  <rdfs:Class rdf:ID="OrderLine">
    <rdfs:label>OrderLine</rdfs:label>
  </rdfs:Class>
  <rdf:Property rdf:ID="has_order_id">
    <rdfs:range rdf:resource="#Order"/>
    <rdfs:domain rdf:resource="#OrderLine"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Order</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="has_product_id">
    <rdfs:range rdf:resource="#Product"/>
    <rdfs:domain rdf:resource="#OrderLine"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Product</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Quantity">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/>
    <rdfs:domain rdf:resource="#OrderLine"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Quantity</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Discount">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#double"/>
    <rdfs:domain rdf:resource="#OrderLine"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Discount</rdfs:label>
  </rdf:Property>

  <rdfs:Class rdf:ID="Country">
    <rdfs:label>Country</rdfs:label>
    <rdfs:subClassOf rdf:resource="http://www.w3.org/2003/01/geo/wgs84_pos#SpatialThing"/>
  </rdfs:Class>
  <rdf:Property rdf:ID="Name">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Country"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Name</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Code">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Country"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Code</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="SmallFlagDAVResourceName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Country"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>SmallFlagDAVResourceName</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="LargeFlagDAVResourceName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Country"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>LargeFlagDAVResourceName</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="SmallFlagDAVResourceURI">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Country"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>SmallFlagDAVResourceURI</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="LargeFlagDAVResourceURI">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Country"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>LargeFlagDAVResourceURI</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Lat">
    <rdfs:range rdf:resource="ttp://www.w3.org/2003/01/geo/wgs84_pos#lat"/>
    <rdfs:domain rdf:resource="#Country"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Lat</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="Lng">
    <rdfs:range rdf:resource="ttp://www.w3.org/2003/01/geo/wgs84_pos#lng"/>
    <rdfs:domain rdf:resource="#Country"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Lng</rdfs:label>
  </rdf:Property>

  <rdfs:Class rdf:ID="Province">
    <rdfs:label>Province</rdfs:label>
  </rdfs:Class>
  <rdf:Property rdf:ID="has_country_code">
    <rdfs:range rdf:resource="#Country"/>
    <rdfs:domain rdf:resource="#Provinces"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>Country Code</rdfs:label>
  </rdf:Property>
  <rdf:Property rdf:ID="ProvinceName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Province"/>
    <rdfs:cardinality>1</rdfs:cardinality>
    <rdfs:label>ProvinceName</rdfs:label>
  </rdf:Property>

</rdf:RDF>
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsenterohr">
      <title>Oracle Demonstration 'HR' Database </title>
<para><emphasis>Live links to a sample instance</emphasis></para>
<itemizedlist mark="bullet">
<listitem><ulink url="http://demo.openlinksw.com/sparql?default-graph-uri=&amp;should-sponge=&amp;query=%20prefix%20hr%3A%20%3Chttp%3A%2F%2Fdemo.openlinksw.com%2Fschemas%2Foraclehr%2F%3E%20select%20*%20from%20%3Chttp%3A%2F%2Fdemo.openlinksw.com%2Foraclehr%3E%20WHERE%20%7B%3Fs%20a%20hr%3Aemployees%7D&amp;format=text%2Fhtml&amp;debug=on">list all employee URIs</ulink></listitem>
<listitem><ulink url="http://demo.openlinksw.com/about/html/http://demo.openlinksw.com/oraclehr/employees/105">description of employee 105</ulink></listitem>
</itemizedlist>
<para><emphasis>Script to set up your own instance</emphasis></para>
<programlisting><![CDATA[
-- Setup script for RDF views of Oracle 10 Human Resources Sample Database --

GRANT SELECT ON HR.orama.COUNTRIES TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.REGIONS TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.DEPARTMENTS TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.LOCATIONS TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.EMPLOYEES TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.JOBS TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.JOB_HISTORY TO "SPARQL", "SPARQL_UPDATE";

-------------------------------------------------------------------

-------- Create rdfs:Class definitions ----------------------------

ttlp (
'
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix hr: <http://localhost:8890/schemas/oraclehr/> .

hr:countries a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "COUNTRIES" ;
	rdfs:comment "Oracle HR COUNTRIES table" .

hr:country_id a rdf:Property ;
	rdfs:domain hr:countries ;
	rdfs:range xsd:string ;
	rdfs:label "COUNTRY ID" .

hr:country_name a rdf:Property ;
	rdfs:domain hr:countries ;
	rdfs:range xsd:string ;
	rdfs:label "COUNTRY NAME" .

hr:region_id a rdf:Property ;
	rdfs:domain hr:countries ;
	rdfs:range hr:regions ;
	rdfs:label "REGION ID" .

hr:regions a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "REGIONS" ;
	rdfs:comment "Oracle HR REGIONS table" .

hr:region_id a rdf:Property ;
	rdfs:domain hr:regions ;
	rdfs:range xsd:integer ;
        rdfs:label "REGION ID" .

hr:region_name a rdf:Property ;
	rdfs:domain hr:regions ;
	rdfs:range xsd:string ;
	rdfs:label "REGION NAME" .

hr:departments a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "DEPARTMENTS" ;
	rdfs:comment "Oracle HR DEPARTMENT table" .

hr:department_id a rdf:Property ;
	rdfs:domain hr:departments ;
	rdfs:range xsd:integer ;
	rdfs:label "DEPARTMENT ID" .

hr:department_name a rdf:Property ;
   	rdfs:domain hr:departments ;
	rdfs:range xsd:string ;
	rdfs:comment "DEPARTMENT NAME" .

hr:manager_id a rdf:Property ;
 	rdfs:domain hr:departments ;
	rdfs:range hr:employees ;
	rdfs:comment "MANAGER ID" .

hr:location_id a rdf:Property ;
	rdfs:domain hr:departments ;
	rdfs:range hr:locations ;
	rdfs:comment "LOCATION ID" .

hr:employees a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "employees" ;
	rdfs:comment "Oracle HR EMPLOYEES table" .

hr:employee_id a rdf:Property ;
	rdfs:domain hr:employees;
	rdfs:range xsd:integer ;
	rdfs:label "EMPLOYEE ID" .

hr:first_name a rdf:Property ;
	rdfs:domain hr:employees;
	rdfs:range xsd:string ;
	rdfs:label "FIRST NAME" .

hr:last_name a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:string ;
	rdfs:label "LAST NAME" .

hr:email a rdf:Property ;
	rdfs:domain hr:employees;
	rdfs:range xsd:string ;
	rdfs:label "EMAIL" .

hr:phone_number a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:string ;
	rdfs:label "PHONE NUMBER" .

hr:hire_date a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:date ;
	rdfs:label "HIRE DATE" .

hr:job_id a rdf:Property ;
	rdfs:domain hr:employees;
	rdfs:range hr:jobs ;
	rdfs:label "JOB ID" .

hr:salary a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:integer ;
	rdfs:label "SALARY" .

hr:commission_pct a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:integer ;
	rdfs:label "COMMISSION PCT" .

hr:manager_id a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:string ;
	rdfs:label "MANAGER ID" .

hr:department_id a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range hr:departments ;
	rdfs:label "DEPARTMENT ID" .

hr:jobs a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "JOBS" ;
	rdfs:comment "Oracle HR JOBS table" .

hr:job_id a rdf:Property ;

	rdfs:domain hr:jobs ;
	rdfs:range xsd:string ;
	rdfs:label "JOB ID" .

hr:job_title a rdf:Property ;
	rdfs:domain hr:jobs ;
	rdfs:range xsd:string ;
	rdfs:label "JOB TITLE" .

hr:min_salary a rdf:Property ;
	rdfs:domain hr:jobs ;
	rdfs:range xsd:number;
	rdfs:label "MIN SALARY" .

hr:max_salary a rdf:Property ;
	rdfs:domain hr:jobs ;
	rdfs:range xsd:number;
	rdfs:label "MAXSALARY" .

hr:job_history a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "JOB HISTORY" ;
	rdfs:comment "Oracle HR JOB HISTORY table" .

hr:employee_id a rdf:Property ;
	rdfs:domain hr:job_history ;
	rdfs:range hr:employees ;
	rdfs:label "EMPLOYEE ID" .

hr:start_date a rdf:Property ;
	rdfs:domain hr:job_history ;
	rdfs:range xsd:date ;
	rdfs:label "START DATE" .

hr:end_date a rdf:Property ;
	rdfs:domain hr:job_history ;
	rdfs:range xsd:date ;
	rdfs:label "END DATE" .

hr:job_id a rdf:Property ;
	rdfs:domain hr:job_history ;
	rdfs:range hr:jobs ;
	rdfs:label "JOB ID" .

hr:department_id a rdf:Property ;
	rdfs:domain hr:job_history ;
	rdfs:range hr:departments ;
	rdfs:label "DEPARTMENT ID" .

hr:locations a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "LOCATIONS" ;
	rdfs:comment "Oracle HR JOB LOCATIONS table" .

hr:location_id a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range xsd:number ;
	rdfs:label "LOCATION ID" .

hr:street_address a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range xsd:string ;
	rdfs:label "STREET ADDRESS" .

hr:postal_code a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range xsd:string ;
	rdfs:label "POSTAL CODE" .

hr:city a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range xsd:string ;
	rdfs:label "CITY" .

hr:state_province a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range xsd:string ;
	rdfs:label "STATE PROVINCE" .

hr:country_id a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range hr:countries ;
	rdfs:label "COUNTRY" .
', '', 'http://localhost:8890/schemas/oraclehr', 0);

---------------------------------------------------------------

----------- Create IRI Classes -------------

create function DB.DBA.JOB_HISTORY (in EMPLOYEE_ID integer, in
START_DATE date) returns varchar
{
  return sprintf_or_null
('http://localhost:8890/oraclehr/job_history/%d_%s#this',
  EMPLOYEE_ID, cast (START_DATE as varchar) );
}
;

create function DB.DBA.JOB_HISTORY_INV_1 (in id varchar) returns integer
{
  return sprintf_inverse (id,
'http://localhost:8890/oraclehr/job_history/%d_%s#this',
2)[0];
}
;

create function DB.DBA.JOB_HISTORY_INV_2 (in id varchar) returns date
{
  declare exit handler for sqlstate '*' { return NULL; };
  return cast (sprintf_inverse (id,
'http://localhost:8890/oraclehr/job_history/%d_%s#this',
2)[1] as date);
}
;


GRANT EXECUTE ON DB.DBA.JOB_HISTORY TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON DB.DBA.JOB_HISTORY_URI_INV_1 TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON DB.DBA.JOB_HISTORY_URI_INV_2 TO "SPARQL", "SPARQL_UPDATE";

sparql


	create iri class <http://localhost:8890/schemas/oraclehr/countries_iri>
	"http://^{URIQADefaultHost}^/oraclehr/countries/%s#this"
    	(in COUNTRY_ID varchar not null) .

	create iri class <http://localhost:8890/schemas/oraclehr/regions_iri>
	"http://^{URIQADefaultHost}^/oraclehr/regions/%d#this"
	    (in REGION_ID integer not null) .

	create iri class <http://localhost:8890/schemas/oraclehr/departments_iri>
	"http://^{URIQADefaultHost}^/oraclehr/departments/%d#this"
	    (in DEPARTMENT_ID integer not null) .

	create iri class <http://localhost:8890/schemas/oraclehr/employees_iri>
	"http://^{URIQADefaultHost}^/oraclehr/employees/%d#this"
		(in EMPLOYEE_ID integer not null) .

	create iri class <http://localhost:8890/schemas/oraclehr/jobs_iri>
	"http://^{URIQADefaultHost}^/oraclehr/jobs/%s#this"
	    (in JOB_ID varchar not null) .

	create iri class <http://localhost:8890/schemas/oraclehr/job_history_iri>
		using function DB.DBA.JOB_HISTORY (in EMPLOYEE_ID integer not null, in
		START_DATE date not null) returns varchar not null,
		function DB.DBA.JOB_HISTORY_INV_1 (in id varchar) returns integer,
		function DB.DBA.JOB_HISTORY_INV_2 (in id varchar) returns date
		option (bijection, returns
		"http://localhost:8890/oraclehr/job_history/%d_%s#this") .

	create iri class <http://localhost:8890/schemas/oraclehr/locations_iri>
	"http://^{URIQADefaultHost}^/oraclehr/locations/%d#this"
	    (in LOCATION_ID integer not null) .
;

--------------------------------------------------------------------

------------- Create Quad Store ------------------------------------

sparql

prefix hr: <http://localhost:8890/schemas/oraclehr/>

alter quad storage virtrdf:DefaultQuadStorage
  from HR.orama.COUNTRIES as countries_tbl
  from HR.orama.REGIONS as regions_tbl
  from HR.orama.DEPARTMENTS as departments_tbl
  from HR.orama.EMPLOYEES as employees_tbl
  from HR.orama.EMPLOYEES as employees_tbl_1		### alias required to represent recursive FK relationship (hr: has_manager ) below.
  from HR.orama.JOBS as jobs_tbl
  from HR.orama.JOB_HISTORY as job_history_tbl
  from HR.orama.LOCATIONS as locations_tbl
{
  create virtrdf:oraclehr as
      graph <http://localhost:8890/oraclehr>
  {
        hr:countries_iri(countries_tbl.COUNTRY_ID) a hr:countries  as virtrdf:countires_country_id ;
        hr:country_name countries_tbl.COUNTRY_NAME  as virtrdf:countries_country_name ;
        hr:region_id hr:regions_iri(regions_tbl.REGION_ID) where (^{countries_tbl.}^.REGION_ID = ^{regions_tbl.}^.REGION_ID)  as virtrdf:countries_region_id .

	hr:regions_iri(regions_tbl.REGION_ID) a hr:regions as virtrdf:regions_region_id ;
	hr:region_name regions_tbl.REGION_NAME  as virtrdf:regions_region_name .

	hr:departments_iri(departments_tbl.DEPARTMENT_ID) a hr:departments as virtrdf:departments_department_id ;
	hr:department_name departments_tbl.DEPARTMENT_NAME as virtrdf:departments_department_name ;
	hr:location_id hr:locations_iri(locations_tbl.LOCATION_ID) where (^{departments_tbl.}^.LOCATION_ID = ^{locations_tbl.}^.LOCATION_ID) as virtrdf:departments_location_id ;
	hr:manager_id hr:employees_iri(employees_tbl.EMPLOYEE_ID) where (^{departments_tbl.}^.MANAGER_ID = ^{employees_tbl.}^.EMPLOYEE_ID) as virtrdf:departments_manager_id .

	hr:employees_iri(employees_tbl.EMPLOYEE_ID) a hr:employees as virtrdf:employees_employee_id ;
	hr:department_id hr:departments_iri(departments_tbl.DEPARTMENT_ID) where (^{employees_tbl.}^.DEPARTMENT_ID = ^{departments_tbl.}^.DEPARTMENT_ID) as virtrdf:employees_department_id ;
	hr:job_id hr:jobs_iri(jobs_tbl.JOB_ID) where (^{employees_tbl.}^.JOB_ID = ^{jobs_tbl.}^.JOB_ID) as virtrdf:employees_job_id ;
	hr:manager_id employees_tbl.MANAGER_ID as virtrdf:employees_manager_id ;
	hr:commissin_pct employees_tbl.COMMISSION_PCT as virtrdf:employees_commission_pct ;
	hr:email employees_tbl.EMAIL as virtrdf:employees_email ;
	hr:first_name employees_tbl.FIRST_NAME as virtrdf:employees_first_name ;
	hr:hire_date employees_tbl.HIRE_DATE as virtrdf:employees_hire_date ;
	hr:last_name employees_tbl.LAST_NAME as virtrdf:employees_last_name ;
	hr:phone_number employees_tbl.PHONE_NUMBER as virtrdf:employees_phone_number ;
	hr:salary employees_tbl.SALARY as virtrdf:employees_salary ;
	hr:has_job_history hr:job_history_iri(job_history_tbl.EMPLOYEE_ID, job_history_tbl.START_DATE) where (^{employees_tbl.}^.EMPLOYEE_ID = ^{job_history_tbl.}^.EMPLOYEE_ID) as virtrdf:employees_has_job_history;
	hr:has_manager hr:employees_iri(employees_tbl_1.EMPLOYEE_ID) where (^{employees_tbl.}^.MANAGER_ID = ^{employees_tbl_1.}^.EMPLOYEE_ID) as virtrdf:employees_has_manager.

	hr:locations_iri(locations_tbl.LOCATION_ID) a hr:locations as virtrdf:locations_location_id ;
	hr:country_id hr:countries_iri(countries_tbl.COUNTRY_ID) where (^{locations_tbl.}^.COUNTRY_ID = ^{countries_tbl.}^.COUNTRY_ID) as virtrdf:locations_country_id ;
	hr:city locations_tbl.CITY as virtrdf:locations_city ;
	hr:postal_code locations_tbl.POSTAL_CODE as virtrdf:locations_postal_code ;
	hr:state_province locations_tbl.STATE_PROVINCE as virtrdf:locations_state_province ;
	hr:street_address locations_tbl.STREET_ADDRESS as virtrdf:locations_street_address .

	hr:jobs_iri(jobs_tbl.JOB_ID) a hr:jobs as virtrdf:jobs_job_id ;
	hr:job_title jobs_tbl.JOB_TITLE as virtrdf:jobs_job_title ;
	hr:max_salary jobs_tbl.MAX_SALARY as virtrdf:jobs_max_salary ;
	hr:min_salary jobs_tbl.MIN_SALARY as virtrdf:jobs_min_salary .

	hr:job_history_iri(job_history_tbl.EMPLOYEE_ID, job_history_tbl.START_DATE) a hr:job_history as virtrdf:job_history_pk ;
	hr:employee_id hr:employees_iri(employees_tbl.EMPLOYEE_ID) where (^{job_history_tbl.}^.EMPLOYEE_ID = ^{employees_tbl.}^.EMPLOYEE_ID) as virtrdf:job_history_employee_id ;
	hr:department_id hr:departments_iri(departments_tbl.DEPARTMENT_ID) where (^{job_history_tbl.}^.DEPARTMENT_ID = ^{departments_tbl.}^.DEPARTMENT_ID) as virtrdf:job_history_department_id ;
	hr:job_id hr:jobs_iri(jobs_tbl.JOB_ID) where (^{job_history_tbl.}^.JOB_ID = ^{jobs_tbl.}^.JOB_ID) as virtrdf:job_history_job_id ;
	hr:start_date job_history_tbl.START_DATE as virtrdf:job_history_start_date ;
	hr:end_date job_history_tbl.END_DATE as virtrdf:job_history_end_date .

  } .
} .
;

delete from db.dba.url_rewrite_rule_list where urrl_list like 'oraclehr_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'oraclehr_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oraclehr_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );


DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oraclehr_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=DESCRIBE+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+FROM+%%3Chttp%%3A//localhost%%3A8890/oraclehr%%3E&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'oraclehr_rule_list1',
    1,
    vector (
  	 	'oraclehr_rule1',
  	 	'oraclehr_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/oraclehr');

VHOST_DEFINE (
	lpath=>'/oraclehr',
	ppath=>'/DAV/oraclehr/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'oraclehr_rule_list1')
	);

delete from db.dba.url_rewrite_rule_list where urrl_list like 'oracle_schemas_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'oracle_schemas_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oracle_schemas_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oracle_schemas_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}%%0D%%0AFROM+%%3Chttp%%3A//localhost%%3A8890/schemas/oraclehr%%3E+%%0D%%0AWHERE+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path','path','*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'oracle_schemas_rule_list1',
    1,
    vector (
  	 	'oracle_schemas_rule1',
  	 	'oracle_schemas_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/schema/oraclehr');

VHOST_DEFINE (
	lpath=>'/schemas/oraclehr',
	ppath=>'/DAV/schemas/oraclehr/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'oracle_schemas_rule_list1')
	);

DB.DBA.XML_SET_NS_DECL ('hr', 'http://^{URIQADefaultHost}^/schemas/oraclehr/', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsenterprohd">
      <title>Oracle using the demonstration 'Human Resources' database</title>
<para><emphasis>Live links to a sample instance</emphasis></para>
<itemizedlist mark="bullet">
<listitem><ulink url="http://demo.openlinksw.com/sparql?default-graph-uri=&amp;should-sponge=&amp;query=%20prefix%20hr%3A%20%3Chttp%3A%2F%2Fdemo.openlinksw.com%2Fschemas%2Foraclehr%2F%3E%20select%20*%20from%20%3Chttp%3A%2F%2Fdemo.openlinksw.com%2Foraclehr%3E%20WHERE%20%7B%3Fs%20a%20hr%3Aemployees%7D&amp;format=text%2Fhtml&amp;debug=on">list all employee URIs</ulink></listitem>
<listitem><ulink url="http://demo.openlinksw.com/about/html/http://demo.openlinksw.com/oraclehr/employees/105">description of employee 105</ulink></listitem>
</itemizedlist>
<para><emphasis>Script to set up your own instance</emphasis></para>
<programlisting><![CDATA[
-- Setup script for RDF views of Oracle 10 Human Resources Sample Database --

GRANT SELECT ON HR.orama.COUNTRIES TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.REGIONS TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.DEPARTMENTS TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.LOCATIONS TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.EMPLOYEES TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.JOBS TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON HR.orama.JOB_HISTORY TO "SPARQL", "SPARQL_UPDATE";

-------------------------------------------------------------------

-------- Create rdfs:Class definitions ----------------------------

ttlp (
'
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix hr: <http://localhost:8890/schemas/oraclehr/> .

hr:countries a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "COUNTRIES" ;
	rdfs:comment "Oracle HR COUNTRIES table" .

hr:country_id a rdf:Property ;
	rdfs:domain hr:countries ;
	rdfs:range xsd:string ;
	rdfs:label "COUNTRY ID" .

hr:country_name a rdf:Property ;
	rdfs:domain hr:countries ;
	rdfs:range xsd:string ;
	rdfs:label "COUNTRY NAME" .

hr:region_id a rdf:Property ;
	rdfs:domain hr:countries ;
	rdfs:range hr:regions ;
	rdfs:label "REGION ID" .

hr:regions a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "REGIONS" ;
	rdfs:comment "Oracle HR REGIONS table" .

hr:region_id a rdf:Property ;
	rdfs:domain hr:regions ;
	rdfs:range xsd:integer ;
        rdfs:label "REGION ID" .

hr:region_name a rdf:Property ;
	rdfs:domain hr:regions ;
	rdfs:range xsd:string ;
	rdfs:label "REGION NAME" .

hr:departments a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "DEPARTMENTS" ;
	rdfs:comment "Oracle HR DEPARTMENT table" .

hr:department_id a rdf:Property ;
	rdfs:domain hr:departments ;
	rdfs:range xsd:integer ;
	rdfs:label "DEPARTMENT ID" .

hr:department_name a rdf:Property ;
   	rdfs:domain hr:departments ;
	rdfs:range xsd:string ;
	rdfs:comment "DEPARTMENT NAME" .

hr:manager_id a rdf:Property ;
 	rdfs:domain hr:departments ;
	rdfs:range hr:employees ;
	rdfs:comment "MANAGER ID" .

hr:location_id a rdf:Property ;
	rdfs:domain hr:departments ;
	rdfs:range hr:locations ;
	rdfs:comment "LOCATION ID" .

hr:employees a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "employees" ;
	rdfs:comment "Oracle HR EMPLOYEES table" .

hr:employee_id a rdf:Property ;
	rdfs:domain hr:employees;
	rdfs:range xsd:integer ;
	rdfs:label "EMPLOYEE ID" .

hr:first_name a rdf:Property ;
	rdfs:domain hr:employees;
	rdfs:range xsd:string ;
	rdfs:label "FIRST NAME" .

hr:last_name a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:string ;
	rdfs:label "LAST NAME" .

hr:email a rdf:Property ;
	rdfs:domain hr:employees;
	rdfs:range xsd:string ;
	rdfs:label "EMAIL" .

hr:phone_number a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:string ;
	rdfs:label "PHONE NUMBER" .

hr:hire_date a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:date ;
	rdfs:label "HIRE DATE" .

hr:job_id a rdf:Property ;
	rdfs:domain hr:employees;
	rdfs:range hr:jobs ;
	rdfs:label "JOB ID" .

hr:salary a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:integer ;
	rdfs:label "SALARY" .

hr:commission_pct a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:integer ;
	rdfs:label "COMMISSION PCT" .

hr:manager_id a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range xsd:string ;
	rdfs:label "MANAGER ID" .

hr:department_id a rdf:Property ;
	rdfs:domain hr:employees ;
	rdfs:range hr:departments ;
	rdfs:label "DEPARTMENT ID" .

hr:jobs a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "JOBS" ;
	rdfs:comment "Oracle HR JOBS table" .

hr:job_id a rdf:Property ;

	rdfs:domain hr:jobs ;
	rdfs:range xsd:string ;
	rdfs:label "JOB ID" .

hr:job_title a rdf:Property ;
	rdfs:domain hr:jobs ;
	rdfs:range xsd:string ;
	rdfs:label "JOB TITLE" .

hr:min_salary a rdf:Property ;
	rdfs:domain hr:jobs ;
	rdfs:range xsd:number;
	rdfs:label "MIN SALARY" .

hr:max_salary a rdf:Property ;
	rdfs:domain hr:jobs ;
	rdfs:range xsd:number;
	rdfs:label "MAXSALARY" .

hr:job_history a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "JOB HISTORY" ;
	rdfs:comment "Oracle HR JOB HISTORY table" .

hr:employee_id a rdf:Property ;
	rdfs:domain hr:job_history ;
	rdfs:range hr:employees ;
	rdfs:label "EMPLOYEE ID" .

hr:start_date a rdf:Property ;
	rdfs:domain hr:job_history ;
	rdfs:range xsd:date ;
	rdfs:label "START DATE" .

hr:end_date a rdf:Property ;
	rdfs:domain hr:job_history ;
	rdfs:range xsd:date ;
	rdfs:label "END DATE" .

hr:job_id a rdf:Property ;
	rdfs:domain hr:job_history ;
	rdfs:range hr:jobs ;
	rdfs:label "JOB ID" .

hr:department_id a rdf:Property ;
	rdfs:domain hr:job_history ;
	rdfs:range hr:departments ;
	rdfs:label "DEPARTMENT ID" .

hr:locations a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/oraclehr> ;
	rdfs:label "LOCATIONS" ;
	rdfs:comment "Oracle HR JOB LOCATIONS table" .

hr:location_id a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range xsd:number ;
	rdfs:label "LOCATION ID" .

hr:street_address a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range xsd:string ;
	rdfs:label "STREET ADDRESS" .

hr:postal_code a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range xsd:string ;
	rdfs:label "POSTAL CODE" .

hr:city a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range xsd:string ;
	rdfs:label "CITY" .

hr:state_province a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range xsd:string ;
	rdfs:label "STATE PROVINCE" .

hr:country_id a rdf:Property ;
	rdfs:domain hr:locations ;
	rdfs:range hr:countries ;
	rdfs:label "COUNTRY" .
', '', 'http://localhost:8890/schemas/oraclehr', 0);

---------------------------------------------------------------

----------- Create IRI Classes -------------

create function DB.DBA.JOB_HISTORY (in EMPLOYEE_ID integer, in
START_DATE date) returns varchar
{
  return sprintf_or_null
('http://localhost:8890/oraclehr/job_history/%d_%s#this',
  EMPLOYEE_ID, cast (START_DATE as varchar) );
}
;

create function DB.DBA.JOB_HISTORY_INV_1 (in id varchar) returns integer
{
  return sprintf_inverse (id,
'http://localhost:8890/oraclehr/job_history/%d_%s#this',
2)[0];
}
;

create function DB.DBA.JOB_HISTORY_INV_2 (in id varchar) returns date
{
  declare exit handler for sqlstate '*' { return NULL; };
  return cast (sprintf_inverse (id,
'http://localhost:8890/oraclehr/job_history/%d_%s#this',
2)[1] as date);
}
;


GRANT EXECUTE ON DB.DBA.JOB_HISTORY TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON DB.DBA.JOB_HISTORY_URI_INV_1 TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON DB.DBA.JOB_HISTORY_URI_INV_2 TO "SPARQL", "SPARQL_UPDATE";

sparql


	create iri class <http://localhost:8890/schemas/oraclehr/countries_iri>
	"http://^{URIQADefaultHost}^/oraclehr/countries/%s#this"
    	(in COUNTRY_ID varchar not null) .

	create iri class <http://localhost:8890/schemas/oraclehr/regions_iri>
	"http://^{URIQADefaultHost}^/oraclehr/regions/%d#this"
	    (in REGION_ID integer not null) .

	create iri class <http://localhost:8890/schemas/oraclehr/departments_iri>
	"http://^{URIQADefaultHost}^/oraclehr/departments/%d#this"
	    (in DEPARTMENT_ID integer not null) .

	create iri class <http://localhost:8890/schemas/oraclehr/employees_iri>
	"http://^{URIQADefaultHost}^/oraclehr/employees/%d#this"
		(in EMPLOYEE_ID integer not null) .

	create iri class <http://localhost:8890/schemas/oraclehr/jobs_iri>
	"http://^{URIQADefaultHost}^/oraclehr/jobs/%s#this"
	    (in JOB_ID varchar not null) .

	create iri class <http://localhost:8890/schemas/oraclehr/job_history_iri>
		using function DB.DBA.JOB_HISTORY (in EMPLOYEE_ID integer not null, in
		START_DATE date not null) returns varchar not null,
		function DB.DBA.JOB_HISTORY_INV_1 (in id varchar) returns integer,
		function DB.DBA.JOB_HISTORY_INV_2 (in id varchar) returns date
		option (bijection, returns
		"http://localhost:8890/oraclehr/job_history/%d_%s#this") .

	create iri class <http://localhost:8890/schemas/oraclehr/locations_iri>
	"http://^{URIQADefaultHost}^/oraclehr/locations/%d#this"
	    (in LOCATION_ID integer not null) .
;

--------------------------------------------------------------------

------------- Create Quad Store ------------------------------------

sparql

prefix hr: <http://localhost:8890/schemas/oraclehr/>

alter quad storage virtrdf:DefaultQuadStorage
  from HR.orama.COUNTRIES as countries_tbl
  from HR.orama.REGIONS as regions_tbl
  from HR.orama.DEPARTMENTS as departments_tbl
  from HR.orama.EMPLOYEES as employees_tbl
  from HR.orama.EMPLOYEES as employees_tbl_1		### alias required to represent recursive FK relationship (hr: has_manager ) below.
  from HR.orama.JOBS as jobs_tbl
  from HR.orama.JOB_HISTORY as job_history_tbl
  from HR.orama.LOCATIONS as locations_tbl
{
  create virtrdf:oraclehr as
      graph <http://localhost:8890/oraclehr>
  {
        hr:countries_iri(countries_tbl.COUNTRY_ID) a hr:countries  as virtrdf:countires_country_id ;
        hr:country_name countries_tbl.COUNTRY_NAME  as virtrdf:countries_country_name ;
        hr:region_id hr:regions_iri(regions_tbl.REGION_ID) where (^{countries_tbl.}^.REGION_ID = ^{regions_tbl.}^.REGION_ID)  as virtrdf:countries_region_id .

	hr:regions_iri(regions_tbl.REGION_ID) a hr:regions as virtrdf:regions_region_id ;
	hr:region_name regions_tbl.REGION_NAME  as virtrdf:regions_region_name .

	hr:departments_iri(departments_tbl.DEPARTMENT_ID) a hr:departments as virtrdf:departments_department_id ;
	hr:department_name departments_tbl.DEPARTMENT_NAME as virtrdf:departments_department_name ;
	hr:location_id hr:locations_iri(locations_tbl.LOCATION_ID) where (^{departments_tbl.}^.LOCATION_ID = ^{locations_tbl.}^.LOCATION_ID) as virtrdf:departments_location_id ;
	hr:manager_id hr:employees_iri(employees_tbl.EMPLOYEE_ID) where (^{departments_tbl.}^.MANAGER_ID = ^{employees_tbl.}^.EMPLOYEE_ID) as virtrdf:departments_manager_id .

	hr:employees_iri(employees_tbl.EMPLOYEE_ID) a hr:employees as virtrdf:employees_employee_id ;
	hr:department_id hr:departments_iri(departments_tbl.DEPARTMENT_ID) where (^{employees_tbl.}^.DEPARTMENT_ID = ^{departments_tbl.}^.DEPARTMENT_ID) as virtrdf:employees_department_id ;
	hr:job_id hr:jobs_iri(jobs_tbl.JOB_ID) where (^{employees_tbl.}^.JOB_ID = ^{jobs_tbl.}^.JOB_ID) as virtrdf:employees_job_id ;
	hr:manager_id employees_tbl.MANAGER_ID as virtrdf:employees_manager_id ;
	hr:commissin_pct employees_tbl.COMMISSION_PCT as virtrdf:employees_commission_pct ;
	hr:email employees_tbl.EMAIL as virtrdf:employees_email ;
	hr:first_name employees_tbl.FIRST_NAME as virtrdf:employees_first_name ;
	hr:hire_date employees_tbl.HIRE_DATE as virtrdf:employees_hire_date ;
	hr:last_name employees_tbl.LAST_NAME as virtrdf:employees_last_name ;
	hr:phone_number employees_tbl.PHONE_NUMBER as virtrdf:employees_phone_number ;
	hr:salary employees_tbl.SALARY as virtrdf:employees_salary ;
	hr:has_job_history hr:job_history_iri(job_history_tbl.EMPLOYEE_ID, job_history_tbl.START_DATE) where (^{employees_tbl.}^.EMPLOYEE_ID = ^{job_history_tbl.}^.EMPLOYEE_ID) as virtrdf:employees_has_job_history;
	hr:has_manager hr:employees_iri(employees_tbl_1.EMPLOYEE_ID) where (^{employees_tbl.}^.MANAGER_ID = ^{employees_tbl_1.}^.EMPLOYEE_ID) as virtrdf:employees_has_manager.

	hr:locations_iri(locations_tbl.LOCATION_ID) a hr:locations as virtrdf:locations_location_id ;
	hr:country_id hr:countries_iri(countries_tbl.COUNTRY_ID) where (^{locations_tbl.}^.COUNTRY_ID = ^{countries_tbl.}^.COUNTRY_ID) as virtrdf:locations_country_id ;
	hr:city locations_tbl.CITY as virtrdf:locations_city ;
	hr:postal_code locations_tbl.POSTAL_CODE as virtrdf:locations_postal_code ;
	hr:state_province locations_tbl.STATE_PROVINCE as virtrdf:locations_state_province ;
	hr:street_address locations_tbl.STREET_ADDRESS as virtrdf:locations_street_address .

	hr:jobs_iri(jobs_tbl.JOB_ID) a hr:jobs as virtrdf:jobs_job_id ;
	hr:job_title jobs_tbl.JOB_TITLE as virtrdf:jobs_job_title ;
	hr:max_salary jobs_tbl.MAX_SALARY as virtrdf:jobs_max_salary ;
	hr:min_salary jobs_tbl.MIN_SALARY as virtrdf:jobs_min_salary .

	hr:job_history_iri(job_history_tbl.EMPLOYEE_ID, job_history_tbl.START_DATE) a hr:job_history as virtrdf:job_history_pk ;
	hr:employee_id hr:employees_iri(employees_tbl.EMPLOYEE_ID) where (^{job_history_tbl.}^.EMPLOYEE_ID = ^{employees_tbl.}^.EMPLOYEE_ID) as virtrdf:job_history_employee_id ;
	hr:department_id hr:departments_iri(departments_tbl.DEPARTMENT_ID) where (^{job_history_tbl.}^.DEPARTMENT_ID = ^{departments_tbl.}^.DEPARTMENT_ID) as virtrdf:job_history_department_id ;
	hr:job_id hr:jobs_iri(jobs_tbl.JOB_ID) where (^{job_history_tbl.}^.JOB_ID = ^{jobs_tbl.}^.JOB_ID) as virtrdf:job_history_job_id ;
	hr:start_date job_history_tbl.START_DATE as virtrdf:job_history_start_date ;
	hr:end_date job_history_tbl.END_DATE as virtrdf:job_history_end_date .

  } .
} .
;

delete from db.dba.url_rewrite_rule_list where urrl_list like 'oraclehr_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'oraclehr_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oraclehr_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );


DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oraclehr_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=DESCRIBE+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+FROM+%%3Chttp%%3A//localhost%%3A8890/oraclehr%%3E&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'oraclehr_rule_list1',
    1,
    vector (
  	 	'oraclehr_rule1',
  	 	'oraclehr_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/oraclehr');

VHOST_DEFINE (
	lpath=>'/oraclehr',
	ppath=>'/DAV/oraclehr/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'oraclehr_rule_list1')
	);

delete from db.dba.url_rewrite_rule_list where urrl_list like 'oracle_schemas_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'oracle_schemas_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oracle_schemas_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oracle_schemas_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}%%0D%%0AFROM+%%3Chttp%%3A//localhost%%3A8890/schemas/oraclehr%%3E+%%0D%%0AWHERE+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path','path','*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'oracle_schemas_rule_list1',
    1,
    vector (
  	 	'oracle_schemas_rule1',
  	 	'oracle_schemas_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/schema/oraclehr');

VHOST_DEFINE (
	lpath=>'/schemas/oraclehr',
	ppath=>'/DAV/schemas/oraclehr/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'oracle_schemas_rule_list1')
	);

DB.DBA.XML_SET_NS_DECL ('hr', 'http://^{URIQADefaultHost}^/schemas/oraclehr/', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsenterprdb">
      <title>DB2 using the demonstration 'Sample' database	</title>
<para><emphasis>Version defined using explicit host - localhost:8890</emphasis></para>
<programlisting><![CDATA[
-- $Id$
-- Setup script for RDF view of portions of DB2 SAMPLE database included
-- in DB2 Express Edition v9.5
--
-- The script assumes external DB2 tables are linked into Virtuoso using
-- local schema name db2sample.

DB..vd_remote_data_source ('db2ma-smpl', '', '<uid>','<pwd>);

ATTACH TABLE  "DB2ADMIN"."ACT"      PRIMARY KEY ("ACTNO")              AS "DB"."db2sample"."ACT"      FROM 'db2ma-smpl';
ATTACH TABLE  "DB2ADMIN"."DEPARTMENT"      PRIMARY KEY ("DEPTNO")              AS "DB"."db2sample"."DEPARTMENT"      FROM 'db2ma-smpl';
ATTACH TABLE  "DB2ADMIN"."EMPLOYEE"      PRIMARY KEY ("EMPNO")              AS "DB"."db2sample"."EMPLOYEE"      FROM 'db2ma-smpl';
ATTACH TABLE  "DB2ADMIN"."EMPPROJACT"      PRIMARY KEY ("EMPNO", "PROJNO", "ACTNO", "EMSTDATE")              AS "DB"."db2sample"."EMPPROJACT"      FROM 'db2ma-smpl';
ATTACH TABLE  "DB2ADMIN"."EMP_RESUME"      PRIMARY KEY ("EMPNO", "RESUME_FORMAT)              AS "DB"."db2sample"."EMP_RESUME"      FROM 'db2ma-smpl';
ATTACH TABLE  "DB2ADMIN"."PROJACT"      PRIMARY KEY ("PROJNO", "ACTNO", "ACSTDATE")              AS "DB"."db2sample"."PROJACT"      FROM 'db2ma-smpl';
ATTACH TABLE  "DB2ADMIN"."PROJECT"      PRIMARY KEY ("PROJNO")              AS "DB"."db2sample"."PROJECT"      FROM 'db2ma-smpl';

COMMIT WORK;

GRANT SELECT ON DB.db2sample.ACT TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON DB.db2sample.DEPARTMENT TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON DB.db2sample.EMPLOYEE TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON DB.db2sample.EMPPROJACT TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON DB.db2sample.EMP_RESUME TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON DB.db2sample.PROJACT TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON DB.db2sample.PROJECT TO "SPARQL", "SPARQL_UPDATE";

create function DB.DBA.PROJ_ACT_IRI (
  in proj_no varchar,
  in act_no integer,
  in ac_st_date date
  ) returns varchar
{
  declare _act_no, _datetime, _date any;
  _act_no := cast(act_no as varchar);
  _datetime := cast(ac_st_date as varchar);
  _date := left(_datetime, 10);
  return sprintf('http://localhost:8890/db2sample/proj_act/%s_%s_%s#this',
    proj_no, _act_no, _date);
};

create function
DB.DBA.PROJ_ACT_IRI_INV_1 (in proj_act_iri varchar) returns varchar
{
  declare exit handler for sqlstate '*' { return NULL; };
  declare parts any;
  parts := sprintf_inverse (proj_act_iri,
   'http://localhost:8890/db2sample/proj_act/%s_%s_%s#this', 1);
  if (parts is not null)
  {
    return parts[0];
  }
  return NULL;
};

create function
DB.DBA.PROJ_ACT_IRI_INV_2 (in proj_act_iri varchar) returns integer
{
  declare exit handler for sqlstate '*' { return NULL; };
  declare parts any;
  parts := sprintf_inverse (proj_act_iri,
   'http://localhost:8890/db2sample/proj_act/%s_%s_%s#this', 1);
  if (parts is not null)
  {
    return cast(parts[1] as integer);
  }
  return NULL;
};

create function
DB.DBA.PROJ_ACT_IRI_INV_3 (in proj_act_iri varchar) returns date
{
  declare exit handler for sqlstate '*' { return NULL; };
  declare parts any;
  parts := sprintf_inverse (proj_act_iri,
   'http://localhost:8890/db2sample/proj_act/%s_%s_%s#this', 1);
  if (parts is not null)
  {
    return cast(parts[2] as date);
  }
  return NULL;
};

create function DB.DBA.EMP_PROJ_ACT_IRI (
  in emp_no varchar,
  in proj_no varchar,
  in act_no integer,
  in emp_start_date date
  ) returns varchar
{
  declare _act_no, _datetime, _date any;
  _act_no := cast(act_no as varchar);
  _datetime := cast(emp_start_date as varchar);
  _date := left(_datetime, 10);
  return sprintf(
      'http://localhost:8890/db2sample/emp_proj_act/%s_%s_%s_%s#this',
    emp_no, proj_no, _act_no, _date);
};

create function
DB.DBA.EMP_PROJ_ACT_IRI_INV_1 (in emp_proj_act_iri varchar) returns varchar
{
  declare exit handler for sqlstate '*' { return NULL; };
  declare parts any;
  parts := sprintf_inverse (emp_proj_act_iri,
   'http://localhost:8890/db2sample/emp_proj_act/%s_%s_%s_%s#this', 1);
  if (parts is not null)
  {
    return parts[0];
  }
  return NULL;
};

create function
DB.DBA.EMP_PROJ_ACT_IRI_INV_2 (in emp_proj_act_iri varchar) returns varchar
{
  declare exit handler for sqlstate '*' { return NULL; };
  declare parts any;
  parts := sprintf_inverse (emp_proj_act_iri,
   'http://localhost:8890/db2sample/emp_proj_act/%s_%s_%s_%s#this', 1);
  if (parts is not null)
  {
    return parts[1];
  }
  return NULL;
};

create function
DB.DBA.EMP_PROJ_ACT_IRI_INV_3 (in emp_proj_act_iri varchar) returns integer
{
  declare exit handler for sqlstate '*' { return NULL; };
  declare parts any;
  parts := sprintf_inverse (emp_proj_act_iri,
   'http://localhost:8890/db2sample/emp_proj_act/%s_%s_%s_%s#this', 1);
  if (parts is not null)
  {
    return cast(parts[2] as integer);
  }
  return NULL;
};

create function
DB.DBA.EMP_PROJ_ACT_IRI_INV_4 (in emp_proj_act_iri varchar) returns date
{
  declare exit handler for sqlstate '*' { return NULL; };
  declare parts any;
  parts := sprintf_inverse (emp_proj_act_iri,
   'http://localhost:8890/db2sample/emp_proj_act/%s_%s_%s_%s#this', 1);
  if (parts is not null)
  {
    return cast(parts[3] as date);
  }
  return NULL;
};

grant execute on DB.DBA.PROJ_ACT_IRI to "SPARQL", "SPARQL_UPDATE";
grant execute on DB.DBA.PROJ_ACT_IRI_INV_1 to "SPARQL", "SPARQL_UPDATE";
grant execute on DB.DBA.PROJ_ACT_IRI_INV_2 to "SPARQL", "SPARQL_UPDATE";
grant execute on DB.DBA.PROJ_ACT_IRI_INV_3 to "SPARQL", "SPARQL_UPDATE";

grant execute on DB.DBA.EMP_PROJ_ACT_IRI to "SPARQL", "SPARQL_UPDATE";
grant execute on DB.DBA.EMP_PROJ_ACT_IRI_INV_1 to "SPARQL", "SPARQL_UPDATE";
grant execute on DB.DBA.EMP_PROJ_ACT_IRI_INV_2 to "SPARQL", "SPARQL_UPDATE";
grant execute on DB.DBA.EMP_PROJ_ACT_IRI_INV_3 to "SPARQL", "SPARQL_UPDATE";
grant execute on DB.DBA.EMP_PROJ_ACT_IRI_INV_4 to "SPARQL", "SPARQL_UPDATE";

sparql drop graph <http://localhost:8890/schemas/db2sample> ;
sparql drop graph <http://localhost:8890/db2sample> ;

sparql drop quad map virtrdf:db2sample ;

--------------------------
-- RDFS class definitions
ttlp (
'
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix opl: <http://localhost:8890/schemas/db2sample/> .

opl:Act a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/db2sample> ;
	rdfs:label "Act" ;
	rdfs:comment "Activity" .

# ACTNO SMALLINT PRIMARY KEY
opl:act_no a rdf:Property ;
	rdfs:domain opl:Act ;
	rdfs:range xsd:integer ;
	rdfs:label "Activity number" .

# ACTKWD VARCHAR(6)
opl:act_kwd a rdf:Property ;
	rdfs:domain opl:Act ;
	rdfs:range xsd:string ;
	rdfs:label "Activity keyword" .

# ACTDESC VARCHAR(20)
opl:act_desc a rdf:Property ;
	rdfs:domain opl:Act ;
	rdfs:range xsd:string ;
	rdfs:label "Activity description" .

#####
opl:Department a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/db2sample> ;
	rdfs:label "Department" ;
	rdfs:comment "Department" .

# DEPTNO VARCHAR(3) PRIMARY KEY
opl:dept_no a rdf:Property ;
	rdfs:domain opl:Department ;
	rdfs:range xsd:string ;
	rdfs:label "Department number" .

# DEPTNAME VARCHAR(36)
opl:dept_name a rdf:Property ;
	rdfs:domain opl:Department ;
	rdfs:range xsd:string ;
	rdfs:label "Department name" .

# MGRNO CHAR(6)
opl:dept_manager a rdf:Property ;
	rdfs:domain opl:Department ;
	rdfs:range xsd:Employee ;
	rdfs:label "Department manager" .

# ADMRDEPT CHAR(3)
opl:supervising_dept a rdf:Property ;
	rdfs:domain opl:Department ;
	rdfs:range opl:Department ;
	rdfs:label "Department reported to" .

# LOCATION CHAR(6)
opl:location a rdf:Property ;
	rdfs:domain opl:Department ;
	rdfs:range xsd:string ;
	rdfs:label "Location" .

opl:employee_collection a rdf:Property ;
	rdfs:domain opl:Department ;
	rdfs:range opl:Employee ;
	rdfs:label "Department employees" .

opl:dept_project_collection a rdf:Property ;
	rdfs:domain opl:Department ;
	rdfs:range opl:Project ;
	rdfs:label "Department projects" .

#####
opl:Employee a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/db2sample> ;
	rdfs:label "Employee" ;
	rdfs:comment "Employee" .

# EMPNO VARCHAR(6) PRIMARY KEY
opl:emp_no a rdf:Property ;
	rdfs:domain opl:Employee;
	rdfs:range xsd:string ;
	rdfs:label "Employee number" .

# FIRSTNME VARCHAR(12)
opl:first_name a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:string ;
	rdfs:label "First name" .

# MIDINIT VARCHAR(1)
opl:middle_initial a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:string ;
	rdfs:label "Middle initial" .

# LASTNAME VARCHAR(15)
opl:last_name a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:string ;
	rdfs:label "Last name" .

# WORKDEPT VARCHAR(3)
opl:work_dept a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range opl:Department ;
	rdfs:label "Work department" .

# PHONENO VARCHAR(4)
opl:phone_no a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:string ;
	rdfs:label "Phone number" .

# HIREDATE DATE
opl:hire_date a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:date;
	rdfs:label "Hire date" .

# JOB VARCHAR(8)
opl:job a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:string ;
	rdfs:label "Job" .

# EDLEVEL SMALLINT
opl:education_level a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:integer ;
	rdfs:label "Education level" .

# SEX VARCHAR(1)
opl:gender a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:string ;
	rdfs:label "Gender" .

# BIRTHDATE DATE
opl:date_of_birth a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:date ;
	rdfs:label "Date of birth" .

# SALARY DECIMAL(9,2)
opl:salary a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:decimal ;
	rdfs:label "Salary" .

# BONUS DECIMAL(9,2)
opl:bonus a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:decimal ;
	rdfs:label "Bonus" .

# COMM DECIMAL(9,2)
opl:commission a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range xsd:decimal ;
	rdfs:label "Commission" .

opl:resume_collection a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range opl:EmployeeResume ;
	rdfs:label "Employee resumes" .

opl:projects_responsible_for_collection a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range opl:Project ;
	rdfs:label "reponsible for project" .

opl:activity_collection a rdf:Property ;
	rdfs:domain opl:Employee ;
	rdfs:range opl:EmpProjAct ;
	rdfs:label "project activities" .

#####
opl:EmpProjAct a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/db2sample> ;
	rdfs:label "EmpProjAct" ;
	rdfs:comment "Employee project activity" .

# EMPNO VARCHAR(6) PRIMARY KEY
opl:epa_emp_no a rdf:Property ;
	rdfs:domain opl:EmpProjAct ;
	rdfs:range xsd:string ;
	rdfs:label "Employee number" .

# PROJNO VARCHAR(6) PRIMARY KEY
opl:epa_proj_no a rdf:Property ;
	rdfs:domain opl:EmpProjAct ;
	rdfs:range xsd:string ;
	rdfs:label "Project number" .

# ACTNO SMALLINT PRIMARY KEY
opl:epa_act_no a rdf:Property ;
	rdfs:domain opl:EmpProjAct ;
	rdfs:range xsd:string ;
	rdfs:label "Activity number" .

# EMSTDATE DATE PRIMARY KEY
opl:emp_start_date a rdf:Property ;
	rdfs:domain opl:EmpProjAct ;
	rdfs:range xsd:date ;
	rdfs:label "Employee activity start date" .

# EMPTIME DECIMAL(5,2)
opl:emp_time a rdf:Property ;
	rdfs:domain opl:EmpProjAct ;
	rdfs:range xsd:decimal ;
	rdfs:label "Employee time" .

# EMENDATE DATE PRIMARY KEY
opl:emp_end_date a rdf:Property ;
	rdfs:domain opl:EmpProjAct ;
	rdfs:range xsd:date ;
	rdfs:label "Employee activity end date" .

opl:assigned_to a rdf:Property ;
	rdfs:domain opl:EmpProjAct ;
	rdfs:range opl:Employee ;
	rdfs:label "Assigned to" .

opl:project_activity a rdf:Property ;
	rdfs:domain opl:EmpProjAct ;
	rdfs:range opl:ProjAct ;
	rdfs:label "Project activity" .

#####
opl:EmployeeResume a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/db2sample> ;
	rdfs:label "EmployeeResume" ;
	rdfs:comment "Employee resume" .

# EMPNO VARCHAR(6) PRIMARY KEY
opl:er_emp_no a rdf:Property ;
	rdfs:domain opl:EmployeeResume ;
	rdfs:range xsd:string ;
	rdfs:label "Employee number" .

# RESUME_FORMAT VARCHAR(10) PRIMARY KEY
opl:resume_format a rdf:Property ;
	rdfs:domain opl:EmployeeResume ;
	rdfs:range xsd:string ;
	rdfs:label "Resume format" .

# RESUME VARCHAR(5120)
opl:resume a rdf:Property ;
	rdfs:domain opl:EmployeeResume ;
	rdfs:range xsd:string ;
	rdfs:label "Resume" .

opl:resume_of a rdf:Property ;
	rdfs:domain opl:EmployeeResume ;
	rdfs:range opl:Employee ;
	rdfs:label "Resume subject" .

#####
opl:ProjAct a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/db2sample> ;
	rdfs:label "ProjAct" ;
	rdfs:comment "Project activity" .

# PROJNO VARCHAR(6) PRIMARY KEY
opl:pa_proj_no a rdf:Property ;
	rdfs:domain opl:ProjAct ;
	rdfs:range xsd:string ;
	rdfs:label "Project number" .

# ACTNO SMALLINT PRIMARY KEY
opl:pa_act_no a rdf:Property ;
	rdfs:domain opl:ProjAct ;
	rdfs:range xsd:string ;
	rdfs:label "Activity number" .

# ACSTDATE DATE PRIMARY KEY
opl:ac_st_date a rdf:Property ;
	rdfs:domain opl:ProjAct ;
	rdfs:range xsd:date ;
	rdfs:label "Activity start date" .

# ACSTAFF DECIMAL(5,2)
opl:ac_staff a rdf:Property ;
	rdfs:domain opl:ProjAct ;
	rdfs:range xsd:decimal ;
	rdfs:label "Acstaff" .

# ACENDATE DATE
opl:ac_en_date a rdf:Property ;
	rdfs:domain opl:ProjAct ;
	rdfs:range xsd:date ;
	rdfs:label "Activity end date" .

opl:project a rdf:Property ;
	rdfs:domain opl:ProjAct ;
	rdfs:range opl:Project ;
	rdfs:label "Project" .

opl:activity a rdf:Property ;
	rdfs:domain opl:ProjAct ;
	rdfs:range opl:Act ;
	rdfs:label "Activity" .

opl:employee_activity_collection a rdf:Property ;
	rdfs:domain opl:ProjAct ;
	rdfs:range opl:EmpProjAct ;
	rdfs:label "Employee activity collection" .

#####
opl:Project a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/db2sample> ;
	rdfs:label "Project" ;
	rdfs:comment "Project" .

# PROJNO VARCHAR(6) PRIMARY KEY
opl:proj_no a rdf:Property ;
	rdfs:domain opl:Project ;
	rdfs:range xsd:string ;
	rdfs:label "Project number" .

# PROJNAME VARCHAR(24)
opl:proj_name a rdf:Property ;
	rdfs:domain opl:Project ;
	rdfs:range xsd:string ;
	rdfs:label "Project name" .

# DEPTNO CHAR(3)
opl:is_project_of_department a rdf:Property ;
	rdfs:domain opl:Project ;
	rdfs:range opl:Department ;
	rdfs:label "is project of department" .

# RESPEMP VARCHAR(6)
opl:resp_emp a rdf:Property ;
	rdfs:domain opl:Project ;
	rdfs:range opl:Employee ;
	rdfs:label "Employee responsible" .

# PRSTAFF DECIMAL(5,2)
opl:pr_staff a rdf:Property ;
	rdfs:domain opl:Project ;
	rdfs:range xsd:decimal ;
	rdfs:label "PrStaff" .

# PRSTDATE DATE
opl:pr_st_date a rdf:Property ;
	rdfs:domain opl:Project ;
	rdfs:range xsd:date ;
	rdfs:label "Project start date" .

# PRENDATE DATE
opl:pr_en_date a rdf:Property ;
	rdfs:domain opl:Project ;
	rdfs:range xsd:date ;
	rdfs:label "Project end date" .

# MAJPROJ VARCHAR(6)
opl:maj_proj a rdf:Property ;
	rdfs:domain opl:Project ;
	rdfs:range xsd:string ;
	rdfs:label "MajProj" .

opl:proj_activity_collection a rdf:Property ;
	rdfs:domain opl:Project ;
	rdfs:range opl:ProjAct ;
	rdfs:label "Project activities" .

', '', 'http://localhost:8890/schemas/db2sample', 0);

--------------------------

sparql
prefix opl: <http://localhost:8890/schemas/db2sample/>

create iri class
<http://localhost:8890/schemas/db2sample/act_iri>
	"http://localhost:8890/db2sample/act/%d#this"
	(
	 in act_no integer not null
	) .

create iri class
<http://localhost:8890/schemas/db2sample/department_iri>
	"http://localhost:8890/db2sample/department/%s#this"
	(
	 in dept_no varchar not null
	) .

create iri class
<http://localhost:8890/schemas/db2sample/employee_iri>
	"http://localhost:8890/db2sample/employee/%s#this"
	(
	 in emp_no varchar not null
	) .

create iri class opl:emp_proj_act_iri using
	function DB.DBA.EMP_PROJ_ACT_IRI (
	 	in emp_no varchar,
	 	in proj_no varchar,
	 	in act_no integer,
	 	in emp_start_date date
		) returns varchar,
	function DB.DBA.EMP_PROJ_ACT_IRI_INV_1 (in emp_proj_act_iri varchar)
		returns varchar ,
	function DB.DBA.EMP_PROJ_ACT_IRI_INV_2 (in emp_proj_act_iri varchar)
		returns varchar ,
	function DB.DBA.EMP_PROJ_ACT_IRI_INV_3 (in emp_proj_act_iri varchar)
		returns integer ,
	function DB.DBA.EMP_PROJ_ACT_IRI_INV_4 (in emp_proj_act_iri varchar)
		returns date
	option (bijection, returns
	  "http://localhost:8890/db2sample/emp_proj_act/%s_%s_%s_%s#this")
	.


create iri class
<http://localhost:8890/schemas/db2sample/employee_resume_iri>
	"http://localhost:8890/db2sample/employee_resume/%s_%s#this"
	(
	 in emp_no varchar not null,
	 in resume_format varchar not null
	) .

create iri class opl:proj_act_iri using
	function DB.DBA.PROJ_ACT_IRI (
		in proj_no varchar,
		in act_no integer,
		in ac_st_date date
		) returns varchar,
	function DB.DBA.PROJ_ACT_IRI_INV_1 (in proj_act_iri varchar)
		returns varchar ,
	function DB.DBA.PROJ_ACT_IRI_INV_2 (in proj_act_iri varchar)
		returns integer ,
	function DB.DBA.PROJ_ACT_IRI_INV_3 (in proj_act_iri varchar)
		returns date
	option (bijection, returns
		"http://localhost:8890/db2sample/proj_act/%s_%s_%s#this")
	.

create iri class
<http://localhost:8890/schemas/db2sample/project_iri>
	"http://localhost:8890/db2sample/project/%s#this"
	(
	 in proj_no varchar not null
	) .
;

sparql
prefix opl: <http://localhost:8890/schemas/db2sample/>

alter quad storage virtrdf:DefaultQuadStorage
from DB.db2sample.ACT as act_tbl
from DB.db2sample.DEPARTMENT as dept_tbl
from DB.db2sample.EMPLOYEE as emp_tbl
from DB.db2sample.EMPPROJACT as emp_proj_act_tbl
from DB.db2sample.EMP_RESUME as emp_resume_tbl
from DB.db2sample.PROJACT as proj_act_tbl
from DB.db2sample.PROJECT as project_tbl
{
	create virtrdf:db2sample as
		graph <http://localhost:8890/db2sample>
	{
	opl:act_iri(act_tbl.ACTNO) a opl:Act
		as virtrdf:act_id ;
	opl:act_no act_tbl.ACTNO
		as virtrdf:act_act_no ;
	opl:act_kwd act_tbl.ACTKWD
		as virtrdf:act_act_kwd ;
	opl:act_desc act_tbl.ACTDESC
		as virtrdf:act_act_desc .

	opl:department_iri(dept_tbl.DEPTNO) a opl:Department
		as virtrdf:dept_id ;
	opl:dept_no dept_tbl.DEPTNO
		as virtrdf:dept_dept_no ;
	opl:dept_name dept_tbl.DEPTNAME
		as virtrdf:dept_dept_name ;
	opl:dept_manager opl:employee_iri(dept_tbl.MGRNO)
		as virtrdf:dept_mgr_no ;
	opl:supervising_dept opl:department_iri(dept_tbl.ADMRDEPT)
		as virtrdf:dept_supervising_dept ;
	opl:location dept_tbl.LOCATION
		as virtrdf:dept_location ;
	opl:employee_collection opl:employee_iri(emp_tbl.EMPNO)
		where (^{emp_tbl.}^.WORKDEPT = ^{dept_tbl.}^.DEPTNO)
		as virtrdf:dept_employee_collection ;
	opl:dept_project_collection opl:project_iri(project_tbl.PROJNO)
		where (^{project_tbl.}^.DEPTNO = ^{dept_tbl.}^.DEPTNO)
		as virtrdf:dept_project_collection .

	opl:employee_iri(emp_tbl.EMPNO) a opl:Employee
		as virtrdf:employee_id ;
	opl:emp_no emp_tbl.EMPNO
		as virtrdf:employee_emp_no ;
	opl:first_name emp_tbl.FIRSTNME
		as virtrdf:employee_first_name ;
	opl:middle_initial emp_tbl.MIDINIT
		as virtrdf:employee_middle_initial ;
	opl:last_name emp_tbl.LASTNAME
		as virtrdf:employee_last_name ;
	opl:work_dept opl:department_iri(emp_tbl.WORKDEPT)
		as virtrdf:employee_work_dept ;
	opl:phone_no emp_tbl.PHONENO
		as virtrdf:employee_phone_no ;
	opl:hire_date emp_tbl.HIREDATE
		as virtrdf:employee_hire_date ;
	opl:job emp_tbl.JOB
		as virtrdf:employee_job ;
	opl:education_level emp_tbl.EDLEVEL
		as virtrdf:employee_education_level ;
	opl:gender emp_tbl.SEX
		as virtrdf:employee_gender ;
	opl:date_of_birth emp_tbl.BIRTHDATE
		as virtrdf:employee_date_of_birth ;
	opl:salary emp_tbl.SALARY
		as virtrdf:employee_salary ;
	opl:bonus emp_tbl.BONUS
		as virtrdf:employee_bonus ;
	opl:commission emp_tbl.COMM
		as virtrdf:employee_commission ;
	opl:resume_collection opl:employee_resume_iri(
		emp_resume_tbl.EMPNO,
		emp_resume_tbl.RESUME_FORMAT
		)
		where (^{emp_tbl.}^.EMPNO = ^{emp_resume_tbl.}^.EMPNO)
		as virtrdf:employee_resume_collection ;
	opl:projects_responsible_for_collection
 		opl:project_iri(project_tbl.PROJNO)
		where (^{project_tbl.}^.RESPEMP = ^{emp_tbl.}^.EMPNO)
		as virtrdf:employee_projects_responsible_for_collection ;
	opl:activity_collection opl:emp_proj_act_iri(
		emp_proj_act_tbl.EMPNO,
		emp_proj_act_tbl.PROJNO,
		emp_proj_act_tbl.ACTNO,
		emp_proj_act_tbl.EMSTDATE
		)
		where (^{emp_tbl.}^.EMPNO = ^{emp_proj_act_tbl.}^.EMPNO)
		as virtrdf:employee_activity_collection .

	opl:emp_proj_act_iri(
		emp_proj_act_tbl.EMPNO,
		emp_proj_act_tbl.PROJNO,
		emp_proj_act_tbl.ACTNO,
		emp_proj_act_tbl.EMSTDATE
		) a opl:EmpProjAct
		as virtrdf:empprojact_id ;
	opl:epa_emp_no emp_proj_act_tbl.EMPNO
		as virtrdf:empprojact_emp_no ;
	opl:epa_proj_no emp_proj_act_tbl.PROJNO
		as virtrdf:empprojact_proj_no ;
	opl:epa_act_no emp_proj_act_tbl.ACTNO
		as virtrdf:empprojact_act_no ;
	opl:emp_start_date emp_proj_act_tbl.EMSTDATE
		as virtrdf:empprojact_emp_start_date ;
	opl:emp_time emp_proj_act_tbl.EMPTIME
		as virtrdf:empprojact_emp_time ;
	opl:emp_end_date emp_proj_act_tbl.EMENDATE
		as virtrdf:empprojact_emp_end_date ;
	opl:assigned_to opl:employee_iri(emp_proj_act_tbl.EMPNO)
		as virtrdf:empprojact_assigned_to ;
	opl:project_activity opl:proj_act_iri(
		emp_proj_act_tbl.PROJNO,
		emp_proj_act_tbl.ACTNO,
		emp_proj_act_tbl.EMSTDATE
		)
		as virtrdf:empprojact_project_activity .

	opl:employee_resume_iri(
		emp_resume_tbl.EMPNO,
		emp_resume_tbl.RESUME_FORMAT
		) a opl:EmployeeResume
		as virtrdf:employee_resume_id ;
	opl:er_emp_no emp_resume_tbl.EMPNO
		as virtrdf:employee_resume_emp_no ;
	opl:resume_format emp_resume_tbl.RESUME_FORMAT
		as virtrdf:employee_resume_resume_format ;
	opl:resume emp_resume_tbl.RESUME
		as virtrdf:employee_resume_resume ;
	opl:resume_of opl:employee_iri(emp_resume_tbl.EMPNO)
		as virtrdf:employee_resume_resume_of .

	opl:proj_act_iri(
		proj_act_tbl.PROJNO,
		proj_act_tbl.ACTNO,
		proj_act_tbl.ACSTDATE
		) a opl:ProjAct
		as virtrdf:projact_id;
	opl:pa_proj_no proj_act_tbl.PROJNO
		as virtrdf:projact_proj_no ;
	opl:pa_act_no proj_act_tbl.ACTNO
		as virtrdf:projact_act_no ;
	opl:ac_st_date proj_act_tbl.ACSTDATE
		as virtrdf:projact_ac_st_date ;
	opl:ac_staff proj_act_tbl.ACSTAFF
		as virtrdf:projact_ac_staff ;
	opl:ac_en_date proj_act_tbl.ACENDATE
		as virtrdf:projact_ac_en_date ;
	opl:project opl:project_iri(proj_act_tbl.PROJNO)
		as virtrdf:projact_project ;
	opl:activity opl:act_iri(proj_act_tbl.ACTNO)
		as virtrdf:projact_activity ;
	opl:employee_activity_collection opl:emp_proj_act_iri(
		emp_proj_act_tbl.EMPNO,
		emp_proj_act_tbl.PROJNO,
		emp_proj_act_tbl.ACTNO,
		emp_proj_act_tbl.EMSTDATE
		)
		where (
		^{proj_act_tbl.}^.PROJNO = ^{emp_proj_act_tbl.}^.PROJNO AND
	        ^{proj_act_tbl.}^.ACTNO = ^{emp_proj_act_tbl.}^.ACTNO AND
	        ^{proj_act_tbl.}^.ACSTDATE = ^{emp_proj_act_tbl.}^.EMSTDATE
	        )
		as virtrdf:project_employee_activity_collection .

	opl:project_iri(project_tbl.PROJNO) a opl:Project
		as virtrdf:project_id ;
	opl:proj_no project_tbl.PROJNO
		as virtrdf:project_proj_no ;
	opl:proj_name project_tbl.PROJNAME
		as virtrdf:project_proj_name ;
	opl:is_project_of_department opl:department_iri(project_tbl.DEPTNO)
		as virtrdf:project_is_project_of_department ;
	opl:resp_emp opl:employee_iri(project_tbl.RESPEMP)
		as virtrdf:project_resp_emp ;
	opl:pr_staff project_tbl.PRSTAFF
		as virtrdf:project_pr_staff ;
	opl:pr_st_date project_tbl.PRSTDATE
		as virtrdf:project_pr_st_date ;
	opl:pr_en_date project_tbl.PRENDATE
		as virtrdf:project_pr_en_date ;
	opl:maj_proj project_tbl.MAJPROJ
		as virtrdf:project_maj_proj ;
	opl:proj_activity_collection opl:proj_act_iri(
		proj_act_tbl.PROJNO,
		proj_act_tbl.ACTNO,
		proj_act_tbl.ACSTDATE
		)
		where (^{project_tbl.}^.PROJNO = ^{proj_act_tbl.}^.PROJNO)
		as virtrdf:project_activity_collection .
	} .
} .
;

delete from db.dba.url_rewrite_rule_list where urrl_list like 'db2sample_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'db2sample_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'db2sample_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://localhost:8890%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'db2sample_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=DESCRIBE+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+FROM+%%3Chttp%%3A//localhost%%3A8890/db2sample%%3E&format=%U',

    vector('path','path','*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'db2sample_rule_list1',
    1,
    vector (
  	 	'db2sample_rule1',
  	 	'db2sample_rule2'
	  ));


-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/db2sample');

VHOST_DEFINE (
	lpath=>'/db2sample',
	ppath=>'/DAV/db2sample/',
	vsp_user=>'dba',
    	is_dav=>1,
	is_brws=>0,
	opts=>vector ('url_rewrite', 'db2sample_rule_list1')
	);
delete from db.dba.url_rewrite_rule_list where urrl_list like 'db2sample_schema_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'db2sample_schema_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'db2sample_schema_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://localhost:8890%U',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'db2sample_schema_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}%%0D%%0AFROM+%%3Chttp%%3A//localhost%%3A8890/schemas/db2sample%%3E+%%0D%%0AWHERE+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path','path','*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'db2sample_schema_rule_list1',
    1,
    vector (
  	 	'db2sample_schema_rule1',
  	 	'db2sample_schema_rule2'
	  ));


-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/schemas/db2sample');

VHOST_DEFINE (
	lpath=>'/schemas/db2sample',
	ppath=>'/DAV/schemas_db2sample/',
	vsp_user=>'dba',
    	is_dav=>1,
	is_brws=>0,
	opts=>vector ('url_rewrite', 'db2sample_schema_rule_list1')
	);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsenterprinf">
      <title>Informix using demonstration 'Stores' database</title>
<programlisting><![CDATA[
DB..vd_remote_data_source ('inf10_stores_demo_rdf', '', '<uid>','<pwd>');

ATTACH TABLE  "informix"."call_type"  PRIMARY KEY ("call_code")                  AS "stores_demo_rdf"."inf10_stores_demo_rdf"."call_type"  FROM 'inf10_stores_demo_rdf';
ATTACH TABLE  "informix"."catalog"    PRIMARY KEY ("catalog_num")                AS "stores_demo_rdf"."inf10_stores_demo_rdf"."catalog"    FROM 'inf10_stores_demo_rdf';
ATTACH TABLE  "informix"."cust_calls" PRIMARY KEY ("customer_num", "call_dtime") AS "stores_demo_rdf"."inf10_stores_demo_rdf"."cust_calls" FROM 'inf10_stores_demo_rdf';
ATTACH TABLE  "informix"."customer"   PRIMARY KEY ("customer_num")               AS "stores_demo_rdf"."inf10_stores_demo_rdf"."customer"   FROM 'inf10_stores_demo_rdf';
ATTACH TABLE  "informix"."items"      PRIMARY KEY ("item_num", "order_num")      AS "stores_demo_rdf"."inf10_stores_demo_rdf"."items"      FROM 'inf10_stores_demo_rdf';
ATTACH TABLE  "informix"."manufact"   PRIMARY KEY ("manu_code")                  AS "stores_demo_rdf"."inf10_stores_demo_rdf"."manufact"   FROM 'inf10_stores_demo_rdf';
ATTACH TABLE  "informix"."msgs"       PRIMARY KEY ("lang", "number", "message")  AS "stores_demo_rdf"."inf10_stores_demo_rdf"."msgs"       FROM 'inf10_stores_demo_rdf';
ATTACH TABLE  "informix"."orders"     PRIMARY KEY ("order_num")                  AS "stores_demo_rdf"."inf10_stores_demo_rdf"."orders"     FROM 'inf10_stores_demo_rdf';
ATTACH TABLE  "informix"."state"      PRIMARY KEY ("code", "sname")              AS "stores_demo_rdf"."inf10_stores_demo_rdf"."state"      FROM 'inf10_stores_demo_rdf';
ATTACH TABLE  "informix"."stock"      PRIMARY KEY ("stock_num", "manu_code")     AS "stores_demo_rdf"."inf10_stores_demo_rdf"."stock"      FROM 'inf10_stores_demo_rdf';

COMMIT WORK;

GRANT SELECT ON stores_demo_rdf.inf10_stores_demo_rdf.items      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON stores_demo_rdf.inf10_stores_demo_rdf.catalog    TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON stores_demo_rdf.inf10_stores_demo_rdf.msgs       TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON stores_demo_rdf.inf10_stores_demo_rdf.state      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON stores_demo_rdf.inf10_stores_demo_rdf.orders     TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON stores_demo_rdf.inf10_stores_demo_rdf.stock      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON stores_demo_rdf.inf10_stores_demo_rdf.customer   TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON stores_demo_rdf.inf10_stores_demo_rdf.call_type  TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON stores_demo_rdf.inf10_stores_demo_rdf.manufact   TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON stores_demo_rdf.inf10_stores_demo_rdf.cust_calls TO "SPARQL", "SPARQL_UPDATE";
GRANT SPARQL_UPDATE to "SPARQL";


create function DB.DBA.CUST_CALLS_IRI (in customer_num integer, in call_dtime datetime) returns varchar
{
	declare _call_dtime any;
	_call_dtime := cast(call_dtime as varchar);
	return sprintf('http://localhost:8890/informix/stores_demo/cust_calls/%d_%U#this', customer_num, _call_dtime);
};

create function DB.DBA.CUST_CALLS_IRI_INV_1 (in cust_calls_iri varchar) returns integer
{
	declare parts any;
	parts := sprintf_inverse(cust_calls_iri, 'http://localhost:8890/informix/stores_demo/cust_calls/%d_%U#this', 1);
	if(parts is not null)
	{
		return parts[0];
	}
	return NULL;
};

create function DB.DBA.CUST_CALLS_IRI_INV_2 (in cust_calls_iri varchar) returns datetime
{
	declare parts any;
	parts := sprintf_inverse(cust_calls_iri, 'http://localhost:8890/informix/stores_demo/cust_calls/%d_%U#this', 1);
	if(parts is not null)
	{
		return parts[1];
	}
	return NULL;
};


grant execute on DB.DBA.CUST_CALLS_IRI to "SPARQL", "SPARQL_UPDATE";
grant execute on DB.DBA.CUST_CALLS_IRI_INV_1 to "SPARQL", "SPARQL_UPDATE";
grant execute on DB.DBA.CUST_CALLS_IRI_INV_2 to "SPARQL", "SPARQL_UPDATE";


-------- Create rdfs:Class definitions ----------------------------

ttlp (
'
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix items:   <http://localhost:8890/schemas/informix/stores_demo/items/> .
@prefix catalog: <http://localhost:8890/schemas/informix/stores_demo/catalog/> .
@prefix stock:   <http://localhost:8890/schemas/informix/stores_demo/stock/> .
@prefix msgs:    <http://localhost:8890/schemas/informix/stores_demo/msgs/> .
@prefix state:   <http://localhost:8890/schemas/informix/stores_demo/state/> .
@prefix orders:  <http://localhost:8890/schemas/informix/stores_demo/orders/> .
@prefix manuf:   <http://localhost:8890/schemas/informix/stores_demo/manufact/> .
@prefix cust:    <http://localhost:8890/schemas/informix/stores_demo/customer/> .
@prefix callt:   <http://localhost:8890/schemas/informix/stores_demo/call_type/> .
@prefix custc:   <http://localhost:8890/schemas/informix/stores_demo/cust_calls/> .



items:Items a rdfs:Class ;
	rdfs:label "Items" ;
	rdfs:comment "Informix SD items table" .

items:item_num a rdf:Property ;
	rdfs:domain items:Items ;
	rdfs:range xsd:integer ;
	rdfs:label "ITEM NUMBER" .

items:quantity a rdf:Property ;
	rdfs:domain items:Items ;
	rdfs:range xsd:integer ;
	rdfs:label "QUANTITY" .

items:total_price a rdf:Property ;
	rdfs:domain items:Items ;
	rdfs:range xsd:decimal ;
	rdfs:label "TOTAL PRICE" .

items:order_num_fk a rdf:Property ;
	rdfs:domain items:Items ;
	rdfs:range orders:Orders ;
	rdfs:label "ORDER NUMBER" .

items:stock_num_fk a rdf:Property ;
	rdfs:domain items:Items ;
	rdfs:range stock:Stock ;
	rdfs:label "STOCK NUMBER" .

items:manu_code_fk a rdf:Property ;
	rdfs:domain items:Items ;
	rdfs:range stock:Stock ;
	rdfs:label "MANUAL CODE" .



catalog:Catalog a rdfs:Class ;
	rdfs:label "Catalog" ;
	rdfs:comment "Informix SD catalog table" .

catalog:manu_code a rdf:Property ;
	rdfs:domain catalog:Catalog ;
	rdfs:range xsd:integer ;
	rdfs:label "MANUAL CODE" .

catalog:cat_descr a rdf:Property ;
	rdfs:domain catalog:Catalog ;
	rdfs:range xsd:string ;
	rdfs:label "CATALOG DESCRIPTION" .

catalog:cat_picture a rdf:Property ;
	rdfs:domain catalog:Catalog ;
	rdfs:range xsd:byte ;
	rdfs:label "CATALOG PICTURE" .

catalog:cat_advert a rdf:Property ;
	rdfs:domain catalog:Catalog ;
	rdfs:range xsd:string ;
	rdfs:label "CATALOG ADVERT" .

catalog:catalog_num_fk a rdf:Property ;
	rdfs:domain catalog:Catalog ;
	rdfs:range stock:Stock ;
	rdfs:label "CATALOG NUMBER" .

catalog:stock_num_fk a rdf:Property ;
	rdfs:domain catalog:Catalog ;
	rdfs:range stock:Stock ;
	rdfs:label "STOCK NUMBER" .



msgs:Msgs a rdfs:Class ;
	rdfs:label "Msgs" ;
	rdfs:comment "Informix SD msgs table" .

msgs:lang a rdf:Property ;
	rdfs:domain msgs:Msgs ;
	rdfs:range xsd:string ;
	rdfs:label "LANGUAGE" .

msgs:number a rdf:Property ;
	rdfs:domain msgs:Msgs ;
	rdfs:range xsd:integer ;
	rdfs:label "NUMBER" .

msgs:message a rdf:Property ;
	rdfs:domain msgs:Msgs ;
	rdfs:range xsd:string ;
	rdfs:label "MESSAGE" .



state:State a rdfs:Class ;
	rdfs:label "State" ;
	rdfs:comment "Informix SD state table" .

state:code a rdf:Property ;
	rdfs:domain state:State ;
	rdfs:range xsd:string ;
	rdfs:label "STATE CODE" .

state:sname a rdf:Property ;
	rdfs:domain state:State ;
	rdfs:range xsd:string ;
	rdfs:label "STATE NAME" .



orders:Orders a rdfs:Class ;
	rdfs:label "Orders" ;
	rdfs:comment "Informix SD orders table" .

orders:order_num a rdf:Property ;
	rdfs:domain orders:Orders ;
	rdfs:range xsd:integer ;
	rdfs:label "ORDER NUMBER" .

orders:order_date a rdf:Property ;
	rdfs:domain orders:Orders ;
	rdfs:range xsd:date ;
	rdfs:label "ORDER DATE" .

orders:ship_instruct a rdf:Property ;
	rdfs:domain orders:Orders ;
	rdfs:range xsd:string ;
	rdfs:label "SHIPPING INSTRUCTION" .

orders:backlog a rdf:Property ;
	rdfs:domain orders:Orders ;
	rdfs:range xsd:string ;
	rdfs:label "BACKLOG" .

orders:po_num a rdf:Property ;
	rdfs:domain orders:Orders ;
	rdfs:range xsd:string ;
	rdfs:label "PURCHASE ORDER NUMBER" .

orders:ship_date a rdf:Property ;
	rdfs:domain orders:Orders ;
	rdfs:range xsd:date ;
	rdfs:label "SHIPPING DATE" .

orders:ship_weight a rdf:Property ;
	rdfs:domain orders:Orders ;
	rdfs:range xsd:decimal ;
	rdfs:label "SHIPPING WEIGHT" .

orders:ship_charge a rdf:Property ;
	rdfs:domain orders:Orders ;
	rdfs:range xsd:decimal ;
	rdfs:label "SHIPPING CHARGE" .

orders:paid_date a rdf:Property ;
	rdfs:domain orders:Orders ;
	rdfs:range xsd:date ;
	rdfs:label "PAID DATE" .

orders:customer_num_fk a rdf:Property ;
	rdfs:domain orders:Orders ;
	rdfs:range cust:Customer ;
	rdfs:label "CUSTOMER NUMBER" .



stock:Stock a rdfs:Class ;
	rdfs:label "Stock" ;
	rdfs:comment "Informix SD stock table" .

stock:stock_num a rdf:Property ;
	rdfs:domain stock:Stock ;
	rdfs:range xsd:integer ;
	rdfs:label "STOCK NUMBER" .

stock:description a rdf:Property ;
	rdfs:domain stock:Stock ;
	rdfs:range xsd:string ;
	rdfs:label "DESCRIPTION" .

stock:unit_price a rdf:Property ;
	rdfs:domain stock:Stock ;
	rdfs:range xsd:decimal ;
	rdfs:label "UNIT PRICE" .

stock:unit a rdf:Property ;
	rdfs:domain stock:Stock ;
	rdfs:range xsd:string ;
	rdfs:label "UNIT" .

stock:unit_descr a rdf:Property ;
	rdfs:domain stock:Stock ;
	rdfs:range xsd:decimal ;
	rdfs:label "UNIT DESCRIPTION" .

stock:manu_code_fk a rdf:Property ;
	rdfs:domain stock:Stock ;
	rdfs:range manuf:Manufact ;
	rdfs:label "MANUAL CODE" .



cust:Customer a rdfs:Class ;
	rdfs:label "Customer" ;
	rdfs:comment "Informix SD customer table" .

cust:customer_num a rdf:Property ;
	rdfs:domain cust:Customer ;
	rdfs:range xsd:integer ;
	rdfs:label "CUSTOMER NUMBER" .

cust:fname a rdf:Property ;
	rdfs:domain cust:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "FIRST NAME" .

cust:lname a rdf:Property ;
	rdfs:domain cust:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "LAST NAME" .

cust:company a rdf:Property ;
	rdfs:domain cust:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "COMPANY" .

cust:address1 a rdf:Property ;
	rdfs:domain cust:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "ADDRESS1" .

cust:address2 a rdf:Property ;
	rdfs:domain cust:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "ADDRESS2" .

cust:city a rdf:Property ;
	rdfs:domain cust:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "CITY" .

cust:state a rdf:Property ;
	rdfs:domain cust:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "STATE" .

cust:zipcode a rdf:Property ;
	rdfs:domain cust:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "ZIP CODE" .

cust:phone a rdf:Property ;
	rdfs:domain cust:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "PHONE NUMBER" .



callt:Call_type a rdfs:Class ;
	rdfs:label "Call_type" ;
	rdfs:comment "Informix SD call_type table" .

callt:call_code a rdf:Property ;
	rdfs:domain callt:Call_type ;
	rdfs:range xsd:string ;
	rdfs:label "CALL CODE" .

callt:code_descr a rdf:Property ;
	rdfs:domain callt:Call_type ;
	rdfs:range xsd:string ;
	rdfs:label "CODE DESCRIPTION" .



manuf:Manufact a rdfs:Class ;
	rdfs:label "Manufact" ;
	rdfs:comment "Informix SD manufact table" .

manuf:manu_code a rdf:Property ;
	rdfs:domain manuf:Manufact ;
	rdfs:range xsd:string ;
	rdfs:label "MANUFACTURE CODE" .

manuf:manu_name a rdf:Property ;
	rdfs:domain manuf:Manufact ;
	rdfs:range xsd:string ;
	rdfs:label "MANUFACTURE NAME" .

manuf:lead_time a rdf:Property ;
	rdfs:domain manuf:Manufact ;
	rdfs:range xsd:integer ;
	rdfs:label "LEAD TIME" .



custc:Cust_calls a rdfs:Class ;
	rdfs:label "Cust_calls" ;
	rdfs:comment "Informix SD cust_calls table" .

custc:call_dtime a rdf:Property ;
	rdfs:domain manuf:Cust_calls ;
	rdfs:range xsd:datetime ;
	rdfs:label "CALL TIME" .

custc:user_id a rdf:Property ;
	rdfs:domain manuf:Cust_calls ;
	rdfs:range xsd:string ;
	rdfs:label "USER ID" .

custc:call_descr a rdf:Property ;
	rdfs:domain manuf:Cust_calls ;
	rdfs:range xsd:string ;
	rdfs:label "CALL DESCRIPTION" .

custc:res_dtime a rdf:Property ;
	rdfs:domain manuf:Cust_calls ;
	rdfs:range xsd:datetime ;
	rdfs:label "RES TIME" .

custc:res_descr a rdf:Property ;
	rdfs:domain manuf:Cust_calls ;
	rdfs:range xsd:string ;
	rdfs:label "RES DESCRIPTION" .

custc:customer_num_fk a rdf:Property ;
	rdfs:domain manuf:Cust_calls ;
	rdfs:range cust:Customer ;
	rdfs:label "CUSTOMER NUM" .

custc:call_code_fk a rdf:Property ;
	rdfs:domain manuf:Cust_calls ;
	rdfs:range callt:Call_type ;
	rdfs:label "CALL CODE" .


', '', 'http://localhost:8890/schemas/informix/stores_demo', 0);



----------- Create IRI Classes -------------




sparql

prefix items:   <http://localhost:8890/schemas/informix/stores_demo/items/>
prefix catalog: <http://localhost:8890/schemas/informix/stores_demo/catalog/>
prefix stock:   <http://localhost:8890/schemas/informix/stores_demo/stock/>
prefix msgs:    <http://localhost:8890/schemas/informix/stores_demo/msgs/>
prefix state:   <http://localhost:8890/schemas/informix/stores_demo/state/>
prefix orders:  <http://localhost:8890/schemas/informix/stores_demo/orders/>
prefix manuf:   <http://localhost:8890/schemas/informix/stores_demo/manufact/>
prefix cust:    <http://localhost:8890/schemas/informix/stores_demo/customer/>
prefix callt:   <http://localhost:8890/schemas/informix/stores_demo/call_type/>
prefix custc:   <http://localhost:8890/schemas/informix/stores_demo/cust_calls/>

create iri class items:items_iri
	"http://localhost:8890/informix/stores_demo/items/%d_%d#this"
	(in item_num integer not null, in order_num integer not null) .

create iri class catalog:catalog_iri
	"http://localhost:8890/informix/stores_demo/catalog/%d#this"
    	(in catalog_num integer not null) .

create iri class msgs:msgs_iri
	"http://localhost:8890/informix/stores_demo/msgs/%U_%d_%U#this"
    	(in _lang varchar not null, in number integer not null, in message varchar not null) .

create iri class state:state_iri
	"http://localhost:8890/informix/stores_demo/state/%U#this"
    	(in code varchar not null) .

create iri class orders:orders_iri
	"http://localhost:8890/informix/stores_demo/orders/%d#this"
    	(in order_num integer not null) .

create iri class stock:stock_iri
	"http://localhost:8890/informix/stores_demo/stock/%d_%U#this"
    	(in stock_num integer not null, in manu_code varchar not null) .

create iri class cust:customer_iri
	"http://localhost:8890/informix/stores_demo/customer/%d#this"
    	(in customer_num integer not null) .

create iri class callt:call_type_iri
	"http://localhost:8890/informix/stores_demo/call_type/%U#this"
    	(in call_code varchar not null) .

create iri class manuf:manufact_iri
	"http://localhost:8890/informix/stores_demo/manufact/%U#this"
    	(in manu_code varchar not null) .

create iri class custc:cust_calls_iri using
	function DB.DBA.CUST_CALLS_IRI (in customer_num integer, in call_dtime datetime) returns varchar,
	function DB.DBA.CUST_CALLS_IRI_INV_1 (in cust_calls_iri varchar) returns integer,
        function DB.DBA.CUST_CALLS_IRI_INV_2 (in cust_calls_iri varchar) returns datetime .
;







------------- Create Quad Store ------------------------------------

sparql

prefix items:   <http://localhost:8890/schemas/informix/stores_demo/items/>
prefix catalog: <http://localhost:8890/schemas/informix/stores_demo/catalog/>
prefix stock:   <http://localhost:8890/schemas/informix/stores_demo/stock/>
prefix msgs:    <http://localhost:8890/schemas/informix/stores_demo/msgs/>
prefix state:   <http://localhost:8890/schemas/informix/stores_demo/state/>
prefix orders:  <http://localhost:8890/schemas/informix/stores_demo/orders/>
prefix manuf:   <http://localhost:8890/schemas/informix/stores_demo/manufact/>
prefix cust:    <http://localhost:8890/schemas/informix/stores_demo/customer/>
prefix callt:   <http://localhost:8890/schemas/informix/stores_demo/call_type/>
prefix custc:   <http://localhost:8890/schemas/informix/stores_demo/cust_calls/>

alter quad storage virtrdf:DefaultQuadStorage
  from stores_demo_rdf.inf10_stores_demo_rdf.items      as items_tbl
  from stores_demo_rdf.inf10_stores_demo_rdf.catalog    as catalog_tbl
  from stores_demo_rdf.inf10_stores_demo_rdf.msgs       as msgs_tbl
  from stores_demo_rdf.inf10_stores_demo_rdf.state      as state_tbl
  from stores_demo_rdf.inf10_stores_demo_rdf.orders     as orders_tbl
  from stores_demo_rdf.inf10_stores_demo_rdf.stock      as stock_tbl
  from stores_demo_rdf.inf10_stores_demo_rdf.customer   as customer_tbl
  from stores_demo_rdf.inf10_stores_demo_rdf.call_type  as call_type_tbl
  from stores_demo_rdf.inf10_stores_demo_rdf.manufact   as manufact_tbl
  from stores_demo_rdf.inf10_stores_demo_rdf.cust_calls as cust_calls_tbl
{
  create virtrdf:informix_stores_demo as graph <http://localhost:8890/informix/stores_demo>
  {
    items:items_iri (items_tbl.item_num, items_tbl.order_num) a items:Items as virtrdf:items_pk ;
    items:item_num    items_tbl.item_num       as virtrdf:items_item_num ;
    items:order_num   items_tbl.order_num      as virtrdf:items_order_num ;
    items:stock_num   items_tbl.stock_num      as virtrdf:items_stock_num ;
    items:manu_code   items_tbl.manu_code      as virtrdf:items_manu_code ;
    items:quantity    items_tbl.quantity       as virtrdf:items_quantity ;
    items:total_price items_tbl.total_price    as virtrdf:items_total_price ;
    items:from_order  orders:orders_iri (orders_tbl.order_num) where (^{items_tbl.}^.order_num = ^{orders_tbl.}^.order_num) as virtrdf:Items-from_order ;
    items:has_stock   stock:stock_iri (stock_tbl.stock_num, stock_tbl.manu_code) where (^{items_tbl.}^.stock_num = ^{stock_tbl.}^.stock_num and ^{items_tbl.}^.manu_code = ^{stock_tbl.}^.manu_code)  as virtrdf:Item-has_stock .

    catalog:catalog_iri (catalog_tbl.catalog_num) a catalog:Catalog as virtrdf:catalog_num;
    catalog:stock_num   catalog_tbl.stock_num    as virtrdf:catalog_stock_num ;
    catalog:manu_code   catalog_tbl.manu_code    as virtrdf:catalog_manu_code ;
    catalog:cat_descr   catalog_tbl.cat_descr    as virtrdf:catalog_cat_descr ;
    catalog:cat_picture catalog_tbl.cat_picture  as virtrdf:catalog_cat_picture ;
    catalog:cat_advert  catalog_tbl.cat_advert   as virtrdf:catalog_cat_advert ;
    catalog:has_stock   stock:stock_iri (stock_tbl.stock_num, stock_tbl.manu_code) where (^{catalog_tbl.}^.stock_num = ^{stock_tbl.}^.stock_num and ^{catalog_tbl.}^.manu_code = ^{stock_tbl.}^.manu_code)  as virtrdf:Catalog-has_stock .

    msgs:msgs_iri (msgs_tbl.lang, msgs_tbl.number, msgs_tbl.message) a msgs:Msgs as virtrdf:msgs_pk ;
    msgs:lang     msgs_tbl.lang    as virtrdf:msgs_lang ;
    msgs:number   msgs_tbl.number  as virtrdf:msgs_number ;
    msgs:message  msgs_tbl.message as virtrdf:msgs_message .

    state:state_iri (state_tbl.code) a state:State as virtrdf:code ;
    state:code   state_tbl.code   as virtrdf:state_code ;
    state:sname  state_tbl.sname  as virtrdf:state_sname .

    orders:orders_iri (orders_tbl.order_num) a orders:Orders as virtrdf:order_num ;
    orders:order_num     orders_tbl.order_num     as virtrdf:orders_order_num ;
    orders:order_date    orders_tbl.order_date    as virtrdf:orders_order_date ;
    orders:customer_num  orders_tbl.customer_num  as virtrdf:orders_customer_num ;
    orders:ship_instruct orders_tbl.ship_instruct as virtrdf:orders_ship_instruct ;
    orders:backlog       orders_tbl.backlog       as virtrdf:orders_backlog ;
    orders:po_num        orders_tbl.po_num        as virtrdf:orders_po_num ;
    orders:ship_date     orders_tbl.ship_date     as virtrdf:orders_ship_date ;
    orders:ship_weight   orders_tbl.ship_weight   as virtrdf:orders_ship_weight ;
    orders:ship_charge   orders_tbl.ship_charge   as virtrdf:orders_ship_charge ;
    orders:paid_date     orders_tbl.paid_date     as virtrdf:orders_paid_date ;
    orders:has_customer cust:customer_iri (customer_tbl.customer_num) where (^{orders_tbl.}^.customer_num = ^{customer_tbl.}^.customer_num) as virtrdf:Orders-has_customer ;
    orders:has_item     items:items_iri (items_tbl.item_num, items_tbl.order_num) where (^{orders_tbl.}^.order_num = ^{items_tbl.}^.order_num) as virtrdf:Orders-has_item .

    stock:stock_iri (stock_tbl.stock_num, stock_tbl.manu_code) a stock:Stock as virtrdf:stock_pk ;
    stock:stock_num    stock_tbl.stock_num    as virtrdf:stock_stock_num ;
    stock:manu_code    stock_tbl.manu_code    as virtrdf:stock_manu_code ;
    stock:description  stock_tbl.description  as virtrdf:stock_description ;
    stock:unit_price   stock_tbl.unit_price   as virtrdf:stock_unit_price ;
    stock:unit         stock_tbl.unit         as virtrdf:stock_unit ;
    stock:unit_descr   stock_tbl.unit_descr   as virtrdf:stock_unit_descr ;
    stock:manufactured_by manuf:manufact_iri (manufact_tbl.manu_code) where (^{stock_tbl.}^.manu_code = ^{manufact_tbl.}^.manu_code) as virtrdf:Stock-manufactured_by ;
    stock:in_catalog  catalog:catalog_iri (catalog_tbl.catalog_num) where (^{stock_tbl.}^.stock_num = ^{catalog_tbl.}^.stock_num and ^{stock_tbl.}^.manu_code = ^{catalog_tbl.}^.manu_code) as virtrdf:Stock-in_catalog ;
    stock:in_item     items:items_iri (items_tbl.item_num, items_tbl.order_num) where (^{stock_tbl.}^.stock_num = ^{items_tbl.}^.stock_num and ^{stock_tbl.}^.manu_code = ^{items_tbl.}^.manu_code) as virtrdf:Stock-in_items .


    cust:customer_iri (customer_tbl.customer_num) a cust:Customer as virtrdf:customer_num ;
    cust:customer_num  customer_tbl.customer_num  as virtrdf:customer_customer_num ;
    cust:fname         customer_tbl.fname         as virtrdf:customer_fname ;
    cust:lname         customer_tbl.lname         as virtrdf:customer_lname ;
    cust:company       customer_tbl.company       as virtrdf:customer_company ;
    cust:address1      customer_tbl.address1      as virtrdf:customer_address1 ;
    cust:address2      customer_tbl.address2      as virtrdf:customer_address2 ;
    cust:city          customer_tbl.city          as virtrdf:customer_city ;
    cust:state         customer_tbl.state         as virtrdf:customer_state ;
    cust:zipcode       customer_tbl.zipcode       as virtrdf:customer_zipcode ;
    cust:phone         customer_tbl.phone         as virtrdf:customer_phone ;
    cust:placed_order orders:orders_iri (orders_tbl.order_num) where (^{customer_tbl.}^.customer_num = ^{orders_tbl.}^.customer_num) as virtrdf:Customer-placed_order ;
    cust:made_call    custc:cust_calls_iri (cust_calls_tbl.customer_num, cust_calls_tbl.call_dtime ) where (^{customer_tbl.}^.customer_num = ^{cust_calls_tbl.}^.customer_num) as virtrdf:Cust_calls-made_call .

    callt:call_type_iri (call_type_tbl.call_code) a callt:Call_type as virtrdf:call_code ;
    callt:call_code   call_type_tbl.call_code as virtrdf:call_type_call_code ;
    callt:code_descr  call_type_tbl.code_descr as virtrdf:call_type_code_descr ;
    callt:call_is_type  custc:cust_calls_iri (cust_calls_tbl.customer_num, cust_calls_tbl.call_dtime) where (^{call_type_tbl.}^.call_code = ^{cust_calls_tbl.}^.call_code) as virtrdf:Call_type-call_is_type .

    manuf:manufact_iri (manufact_tbl.manu_code) a manuf:Manufact as virtrdf:manu_code ;
    manuf:manu_code     manufact_tbl.manu_code   as virtrdf:manufact_tbl_manu_code ;
    manuf:manu_name     manufact_tbl.manu_name   as virtrdf:manufact_tbl_manu_name ;
    manuf:lead_time     manufact_tbl.lead_time   as virtrdf:manufact_tbl_lead_time ;
    manuf:manufactures stock:stock_iri (stock_tbl.stock_num, stock_tbl.manu_code) where (^{manufact_tbl.}^.manu_code = ^{stock_tbl.}^.manu_code) as virtrdf:Manufact-manufactures .

    custc:cust_calls_iri  (cust_calls_tbl.customer_num, cust_calls_tbl.call_dtime) a custc:Cust_calls as virtrdf:cust_calls_pk ;
    custc:user_id    cust_calls_tbl.user_id      as virtrdf:cust_calls_user_id ;
    custc:call_code  cust_calls_tbl.call_code    as virtrdf:cust_calls_call_code ;
    custc:call_descr cust_calls_tbl.call_descr   as virtrdf:cust_calls_call_descr ;
    custc:res_dtime  cust_calls_tbl.res_dtime    as virtrdf:cust_calls_res_dtime ;
    custc:res_descr  cust_calls_tbl.res_descr    as virtrdf:cust_calls_res_descr ;
    custc:made_by_customer cust:customer_iri   (customer_tbl.customer_num) where (^{cust_calls_tbl.}^.customer_num = ^{customer_tbl.}^.customer_num) as virtrdf:Cust_calls-made_by_customer ;
    custc:is_call_type     callt:call_type_iri (call_type_tbl.call_code)   where (^{cust_calls_tbl.}^.call_code    = ^{call_type_tbl.}^.call_code)   as virtrdf:Cust_calls-is_call_type .

  } .
} .
;

delete from db.dba.url_rewrite_rule_list where urrl_list like 'informix_sd_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'informix_sd_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'informix_sd_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );


DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'informix_sd_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=DESCRIBE+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+FROM+%%3Chttp%%3A//localhost%%3A8890/informix/stores_demo%%3E&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'informix_sd_rule_list1',
    1,
    vector (
  	 	'informix_sd_rule1',
  	 	'informix_sd_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/informix/stores_demo');

VHOST_DEFINE (
	lpath=>'/informix/stores_demo',
	ppath=>'/DAV/informix/stores_demo/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'informix_sd_rule_list1')
	);

delete from db.dba.url_rewrite_rule_list where urrl_list like 'informix_sd_schemas_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'informix_sd_schemas_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'informix_sd_schemas_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'informix_sd_schemas_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}%%0D%%0AFROM+%%3Chttp%%3A//localhost%%3A8890/schemas/informix/stores_demo%%3E+%%0D%%0AWHERE+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path','path','*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'informix_sd_schemas_rule_list1',
    1,
    vector (
  	 	'informix_sd_schemas_rule1',
  	 	'informix_sd_schemas_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/schemas/informix/stores_demo');

VHOST_DEFINE (
	lpath=>'/schemas/informix/stores_demo',
	ppath=>'/DAV/schemas/informix/stores_demo/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'informix_sd_schemas_rule_list1')
	);

DB.DBA.XML_SET_NS_DECL ('items',   'http://^{URIQADefaultHost}^/schemas/informix/stores_demo/items/', 2);
DB.DBA.XML_SET_NS_DECL ('catalog', 'http://^{URIQADefaultHost}^/schemas/informix/stores_demo/catalog/', 2);
DB.DBA.XML_SET_NS_DECL ('stock',   'http://^{URIQADefaultHost}^/schemas/informix/stores_demo/stock/', 2);
DB.DBA.XML_SET_NS_DECL ('msgs',    'http://^{URIQADefaultHost}^/schemas/informix/stores_demo/msgs/', 2);
DB.DBA.XML_SET_NS_DECL ('state',   'http://^{URIQADefaultHost}^/schemas/informix/stores_demo/state/', 2);
DB.DBA.XML_SET_NS_DECL ('orders',  'http://^{URIQADefaultHost}^/schemas/informix/stores_demo/orders/', 2);
DB.DBA.XML_SET_NS_DECL ('manuf',   'http://^{URIQADefaultHost}^/schemas/informix/stores_demo/manufact/', 2);
DB.DBA.XML_SET_NS_DECL ('cust',    'http://^{URIQADefaultHost}^/schemas/informix/stores_demo/customer/', 2);
DB.DBA.XML_SET_NS_DECL ('callt',   'http://^{URIQADefaultHost}^/schemas/informix/stores_demo/call_type/', 2);
DB.DBA.XML_SET_NS_DECL ('custc',   'http://^{URIQADefaultHost}^/schemas/informix/stores_demo/cust_calls/', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsenterpringr">
      <title>Ingres using demonstration 'Tutorial' database</title>
<programlisting><![CDATA[
-- Setup script for RDF views of Ingres R3 Tutorial Sample Database --

DB..vd_remote_data_source ('ingiima-tut', '', '<uid>','<pwd>');

ATTACH TABLE  "ingres"."book_list"      PRIMARY KEY ("book_no")              AS "TUT"."ingiima"."book_list"      FROM 'ingiima-tut';
ATTACH TABLE  "ingres"."book_orders"      PRIMARY KEY ("order_no")              AS "TUT"."ingiima"."book_orders"      FROM 'ingiima-tut';
ATTACH TABLE  "ingres"."cust_info"      PRIMARY KEY ("cust_no")              AS "TUT"."ingiima"."cust_info"      FROM 'ingiima-tut';
ATTACH TABLE  "ingres"."cust_orders"      PRIMARY KEY ("order_no")              AS "TUT"."ingiima"."cust_orders"      FROM 'ingiima-tut';

COMMIT WORK;

GRANT SELECT ON TUT.ingiima.book_list TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON TUT.ingiima.book_orders TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON TUT.ingiima.cust_info TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON TUT.ingiima.cust_orders TO "SPARQL", "SPARQL_UPDATE";

-------------------------------------------------------------------

-------- Create rdfs:Class definitions ----------------------------

ttlp (
'
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix tut: <http://localhost:8890/schemas/ingrestut/> .

tut:book_list a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/ingrestut> ;
	rdfs:label "book_list" ;
	rdfs:comment "Ingres Tutorial Database book_list table" .

tut:book_no a rdf:Property ;
	rdfs:domain tut:book_list ;
	rdfs:range xsd:integer ;
	rdfs:label "Book No" .

tut:title a rdf:Property ;
	rdfs:domain tut:book_list ;
	rdfs:range xsd:string ;
	rdfs:label "Title" .

tut:author a rdf:Property ;
	rdfs:domain tut:book_list ;
	rdfs:range xsd:string ;
	rdfs:label "Author" .

tut:price a rdf:Property ;
	rdfs:domain tut:book_list ;
	rdfs:range xsd:money;
	rdfs:label "Price" .

tut:category a rdf:Property ;
	rdfs:domain tut:book_list ;
	rdfs:range xsd:string ;
	rdfs:label "Category" .

tut:stock a rdf:Property ;
	rdfs:domain tut:book_list ;
	rdfs:range xsd:integer ;
	rdfs:label "Stock" .

tut:dist_no a rdf:Property ;
	rdfs:domain tut:book_list ;
	rdfs:range xsd:integer ;
	rdfs:label "Dist No" .

tut:book_orders a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/ingrestut> ;
	rdfs:label "Book Orders" ;
	rdfs:comment "Ingres Tutorial Database book_orders table" .

tut:order_no a rdf:Property ;
	rdfs:domain tut:book_orders ;
	rdfs:range xsd:integer ;
         rdfs:label "Order No" .

tut:book_no_no a rdf:Property ;
	rdfs:domain tut:book_orders ;
	rdfs:range tut:book_list ;
         rdfs:label "Book No" .

tut:sale_price a rdf:Property ;
	rdfs:domain tut:book_orders ;
	rdfs:range xsd:money ;
         rdfs:label "Sale Price" .

tut:quantity a rdf:Property ;
	rdfs:domain tut:book_orders ;
	rdfs:range xsd:integer ;
         rdfs:label "Quantity" .

tut:extension a rdf:Property ;
	rdfs:domain tut:book_orders ;
	rdfs:range xsd:money ;
         rdfs:label "Extension" .

tut:cust_info a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/ingrestut> ;
	rdfs:label "Customer Information" ;
	rdfs:comment "Ingres Tutorial Database cust_info table" .

tut:cust_no a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:integer ;
         rdfs:label "Customer No" .

tut:name a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:string ;
         rdfs:label "Name" .

tut:company a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:string ;
         rdfs:label "Company" .

tut:street a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:string;
         rdfs:label "Street" .

tut:city a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:string;
         rdfs:label "City" .

tut:state a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:string;
         rdfs:label "State" .

tut:city a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:string;
         rdfs:label "City" .

tut:state a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:string;
         rdfs:label "State" .

tut:zip a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:string;
         rdfs:label "Zip Code" .

tut:card_no a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:string;
         rdfs:label "Card No" .

tut:exp_date a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:date;
         rdfs:label "Expire Date" .

tut:ship_to a rdf:Property ;
	rdfs:domain tut:cust_info ;
	rdfs:range xsd:string;
         rdfs:label "Ship To" .

tut:cust_orders a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/ingrestut> ;
	rdfs:label "Customer Orders" ;
	rdfs:comment "Ingres Tutorial Database cust_orders table" .

tut:order_no a rdf:Property ;
	rdfs:domain tut:cust_orders ;
	rdfs:range tut:book_orders ;
         rdfs:label "Order No" .

tut:book_no a rdf:Property ;
	rdfs:domain tut:cust_orders ;
	rdfs:range tut:cust_info ;
         rdfs:label "Book No" .

tut:order_date a rdf:Property ;
	rdfs:domain tut:cust_orders ;
	rdfs:range xsd:date ;
         rdfs:label "Order Date" .

tut:status a rdf:Property ;
	rdfs:domain tut:cust_orders ;
	rdfs:range xsd:string ;
         rdfs:label "Status" .

tut:order_total a rdf:Property ;
	rdfs:domain tut:cust_orders ;
	rdfs:range xsd:money ;
         rdfs:label "Order Total" .
', '', 'http://localhost:8890/schemas/ingrestut', 0);

---------------------------------------------------------------

----------- Create IRI Classes -------------

sparql

	create iri class <http://localhost:8890/schemas/ingrestut/book_list_iri>
	"http://^{URIQADefaultHost}^/ingrestut/book_list/%d#this"
    	(in book_no integer not null) .

	create iri class <http://localhost:8890/schemas/ingrestut/book_orders_iri>
	"http://^{URIQADefaultHost}^/ingrestut/book_orders/%d_%d#this"
	 (in order_no integer not null, in book_no integer not null ) .

	create iri class <http://localhost:8890/schemas/ingrestut/cust_info_iri>
	"http://^{URIQADefaultHost}^/ingrestut/cust_info/%d#this"
    	(in cust_no integer not null) .

	create iri class <http://localhost:8890/schemas/ingrestut/cust_orders_iri>
	"http://^{URIQADefaultHost}^/ingrestut/cust_orders/%d#this"
    	(in order_no integer not null) .

	;

--------------------------------------------------------------------

------------- Create Quad Store ------------------------------------

sparql

prefix tut:	<http://localhost:8890/schemas/ingrestut/>

alter quad storage virtrdf:DefaultQuadStorage
  from TUT.ingiima.book_list as book_list_tbl
  from TUT.ingiima.book_orders as book_orders_tbl
  from TUT.ingiima.cust_info as cust_info_tbl
  from TUT.ingiima.cust_orders as cust_orders_tbl
{
  create virtrdf:ingrestut as
      graph <http://localhost:8890/ingrestut>
  {
        tut:book_list_iri(book_list_tbl.book_no) a tut:book_list
               as virtrdf:book_list_book_no ;
        tut:title book_list_tbl.title
	     as virtrdf:book_list_title;
        tut:author book_list_tbl.author
              as virtrdf:book_list_author;
        tut:price book_list_tbl.price
              as virtrdf:book_list_price;
        tut:category book_list_tbl.category
              as virtrdf:book_list_category;
        tut:stock book_list_tbl.stock
              as virtrdf:book_list_stock;
        tut:dist_no book_list_tbl.dist_no
              as virtrdf:book_list_dist_no .

	tut:book_orders_iri(book_orders_tbl.order_no, book_orders_tbl.book_no) a tut:book_orders
		as virtrdf:book_orders_pk;
	tut:order_no book_orders_tbl.order_no
		as virtrdf:book_orders_order_no;
	tut:book_no tut:book_list_iri(book_list_tbl.book_no)
		where(^{book_orders_tbl.}^.book_no = ^{book_list_tbl.}^.book_no)
		as virtrdf:book_orders_book_no;
	tut:sale_price book_orders_tbl.sale_price
		as virtrdf:book_orders_sale_price;
	tut:quantity book_orders_tbl.quantity
		as virtrdf:book_orders_quantity;
	tut:extension book_orders_tbl.extension
		as virtrdf:book_orders_extension .

 	tut:cust_info_iri(cust_info_tbl.cust_no) a tut:cust_info
		as virtrdf:cust_info_cust_no;
	tut:name cust_info_tbl.name
		as virtrdf:cust_info_name;
	tut:company cust_info_tbl.company
		as virtrdf:cust_info_company;
	tut:street cust_info_tbl.street
		as virtrdf:cust_info_street;
	tut:city cust_info_tbl.city
		as virtrdf:cust_info_city;
	tut:state cust_info_tbl.state
		as virtrdf:cust_info_state;
	tut:zip cust_info_tbl.zip
		as virtrdf:cust_info_zip;
	tut:card_no cust_info_tbl.card_no
		as virtrdf:cust_info_card_no;
	tut:exp_date cust_info_tbl.exp_date
		as virtrdf:cust_info_exp_date;
	tut:ship_to cust_info_tbl.ship_to
		as virtrdf:cust_info_ship_to .

 	tut:cust_orders_iri(cust_orders_tbl.order_no) a tut:cust_orders
		as virtrdf:cust_orders_order_no;

	tut:cust_no tut:cust_info_iri(cust_info_tbl.cust_no)
		where (^{cust_orders_tbl.}^.cust_no = ^{cust_info_tbl.}^.cust_no)
		as virtrdf:cust_orders_cust_no;
	tut:order_date cust_orders_tbl.order_date
		as virtrdf:cust_orders_order_date;
	tut:status cust_orders_tbl.status
		as virtrdf:cust_orders_status;
	tut:order_total cust_orders_tbl.order_total
		as virtrdf:cust_orders_order_total   .
  } .
} .
;

delete from db.dba.url_rewrite_rule_list where urrl_list like 'ingrestut_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'ingrestut_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ingrestut_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );


DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ingrestut_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=DESCRIBE+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+FROM+%%3Chttp%%3A//localhost%%3A8890/ingrestut%%3E&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'ingrestut_rule_list1',
    1,
    vector (
  	 	'ingrestut_rule1',
  	 	'ingrestut_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/ingrestut');

VHOST_DEFINE (
	lpath=>'/ingrestut',
	ppath=>'/DAV/ingrestut/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'ingrestut_rule_list1')
	);

delete from db.dba.url_rewrite_rule_list where urrl_list like 'ingres_schemas_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'ingres_schemas_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ingres_schemas_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ingres_schemas_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}%%0D%%0AFROM+%%3Chttp%%3A//localhost%%3A8890/schemas/ingrestut%%3E+%%0D%%0AWHERE+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path','path','*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'ingres_schemas_rule_list1',
    1,
    vector (
  	 	'ingres_schemas_rule1',
  	 	'ingres_schemas_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/schema/ingrestut');

VHOST_DEFINE (
	lpath=>'/schemas/ingrestut',
	ppath=>'/DAV/schemas/ingrestut/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'ingres_schemas_rule_list1')
	);

DB.DBA.XML_SET_NS_DECL ('tut', 'http://^{URIQADefaultHost}^/schemas/ingrestut/', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsenterprsyb">
      <title>Sybase using demonstration 'pubs2' database</title>
<programlisting><![CDATA[
-- Setup script for RDF views of Sybase 15 PUBS2 Sample Database --

DB..vd_remote_data_source ('syb15ma-pubs2', '', '<uid>','<pwd>');

ATTACH TABLE  "pubs2.dbo.au_pix"  PRIMARY KEY ("au_id")                  AS "pubs2"."syb"."au_pix"  FROM 'syb15ma-pubs2';
ATTACH TABLE  "pubs2.dbo.authors"  PRIMARY KEY ("au_id")                  AS "pubs2"."syb"."authors"  FROM 'syb15ma-pubs2';
ATTACH TABLE  "pubs2.dbo.discounts"  PRIMARY KEY ("stor_id")                  AS "pubs2"."syb"."discounts"  FROM 'syb15ma-pubs2';
ATTACH TABLE  "pubs2.dbo.publishers"  PRIMARY KEY ("pub_id")                  AS "pubs2"."syb"."publishers"  FROM 'syb15ma-pubs2';
ATTACH TABLE  "pubs2.dbo.roysched"  PRIMARY KEY ("title_id")                  AS "pubs2"."syb"."roysched"  FROM 'syb15ma-pubs2';
ATTACH TABLE  "pubs2.dbo.sales"  PRIMARY KEY ("stor_id", "ord_num")                  AS "pubs2"."syb"."sales"  FROM 'syb15ma-pubs2';
ATTACH TABLE  "pubs2.dbo.salesdetail"  PRIMARY KEY ("stor_id", "ord_num", "title_id")                   AS "pubs2"."syb"."salesdetail"  FROM 'syb15ma-pubs2';
ATTACH TABLE  "pubs2.dbo.stores"  PRIMARY KEY ("stor_id")                  AS "pubs2"."syb"."stores"  FROM 'syb15ma-pubs2';
ATTACH TABLE  "pubs2.dbo.titleauthor"  PRIMARY KEY ("au_id", "title_id")                  AS "pubs2"."syb"."titleauthor"  FROM 'syb15ma-pubs2';
ATTACH TABLE  "pubs2.dbo.titles"  PRIMARY KEY ("title_id", "pub_id")                  AS "pubs2"."syb"."titles"  FROM 'syb15ma-pubs2';

COMMIT WORK;

GRANT SELECT ON pubs2.syb.au_pix TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON pubs2.syb.authors TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON pubs2.syb.discounts TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON pubs2.syb.publishers TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON pubs2.syb.roysched TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON pubs2.syb.sales TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON pubs2.syb.salesdetail TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON pubs2.syb.stores TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON pubs2.syb.titleauthor TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON pubs2.syb.titles TO "SPARQL", "SPARQL_UPDATE";

-------------------------------------------------------------------

-------- Create rdfs:Class definitions ----------------------------

ttlp (
'
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix syb: <http://localhost:8890/schemas/sybasepubs2/> .

syb:titles a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/sybasepubs2> ;
	rdfs:label "titles" ;
	rdfs:comment "Sybase Pubs2 titles table" .

syb:title_id a rdf:Property ;
	rdfs:domain syb:titles ;
	rdfs:range xsd:string ;
	rdfs:label "title id" .

syb:title a rdf:Property ;
	rdfs:domain syb:titles ;
	rdfs:range xsd:string ;
	rdfs:label "title" .

syb:type a rdf:Property ;
	rdfs:domain syb:titles ;
	rdfs:range xsd:string ;
	rdfs:label "type" .

syb:pub_id a rdf:Property ;
	rdfs:domain syb:titles ;
	rdfs:range syb:publishers ;
	rdfs:label "pub_id" .

syb:advance a rdf:Property ;
	rdfs:domain syb:titles ;
	rdfs:range xsd:decimal ;
	rdfs:label "advance" .

syb:price a rdf:Property ;
	rdfs:domain syb:titles ;
	rdfs:range xsd:decimal ;
	rdfs:label "price" .

syb:total_sales a rdf:Property ;
	rdfs:domain syb:titles ;
	rdfs:range xsd:integer ;
	rdfs:label "total_sales" .

syb:notes a rdf:Property ;
	rdfs:domain syb:titles ;
	rdfs:range xsd:string ;
	rdfs:label "notes" .

syb:contract a rdf:Property ;
	rdfs:domain syb:titles ;
	rdfs:range xsd:integer ;
	rdfs:label "contract" .

syb:pubdate a rdf:Property ;
	rdfs:domain syb:titles ;
	rdfs:range xsd:dateTime ;
	rdfs:label "publish date" .

syb:authors a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/sybasepubs2> ;
	rdfs:label "authors" ;
	rdfs:comment "Sybase Pubs2 authors table" .

syb:au_id a rdf:Property ;
	rdfs:domain syb:authors ;
	rdfs:range xsd:string ;
	rdfs:label "author id" .

syb:au_lname a rdf:Property ;
	rdfs:domain syb:authors ;
	rdfs:range xsd:string ;
	rdfs:label "author last name" .

syb:au_fname a rdf:Property ;
	rdfs:domain syb:authors ;
	rdfs:range xsd:string ;
	rdfs:label "author first name" .

syb:phone a rdf:Property ;
	rdfs:domain syb:authors ;
	rdfs:range xsd:string ;
	rdfs:label "phone number" .

syb:address a rdf:Property ;
	rdfs:domain syb:authors ;
	rdfs:range xsd:string ;
	rdfs:label "address" .

syb:city a rdf:Property ;
	rdfs:domain syb:authors ;
	rdfs:range xsd:string ;
	rdfs:label "city" .

syb:state a rdf:Property ;
	rdfs:domain syb:authors ;
	rdfs:range xsd:string ;
	rdfs:label "state" .

syb:country a rdf:Property ;
	rdfs:domain syb:authors ;
	rdfs:range xsd:string ;
	rdfs:label "country" .

syb:postalcode a rdf:Property ;
	rdfs:domain syb:authors ;
	rdfs:range xsd:string ;
	rdfs:label "postalcode" .

syb:stores a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/sybasepubs2> ;
	rdfs:label "stores" ;
	rdfs:comment "Sybase Pubs2 stores table" .

syb:stor_id a rdf:Property ;
	rdfs:domain syb:stores ;
	rdfs:range xsd:string ;
	rdfs:label "store id" .

syb:stor_name a rdf:Property ;
	rdfs:domain syb:stores ;
	rdfs:range xsd:string ;
	rdfs:label "store name" .

syb:stor_address a rdf:Property ;
	rdfs:domain syb:stores ;
	rdfs:range xsd:string ;
	rdfs:label "store address" .

syb:city a rdf:Property ;
	rdfs:domain syb:stores ;
	rdfs:range xsd:string ;
	rdfs:label "city" .

syb:state a rdf:Property ;
	rdfs:domain syb:stores ;
	rdfs:range xsd:string ;
	rdfs:label "state" .

syb:country a rdf:Property ;
	rdfs:domain syb:stores ;
	rdfs:range xsd:string ;
	rdfs:label "country" .

syb:postalcode a rdf:Property ;
	rdfs:domain syb:stores ;
	rdfs:range xsd:string ;
	rdfs:label "postal code" .

syb:payterms a rdf:Property ;
	rdfs:domain syb:stores ;
	rdfs:range xsd:string ;
	rdfs:label "payment terms" .

syb:au_pix a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/sybasepubs2> ;
	rdfs:label "authors pictures" ;
	rdfs:comment "Sybase Pubs2 au_pix table" .

syb:au_id a rdf:Property ;
	rdfs:domain syb:au_pix ;
	rdfs:range syb:authors ;
	rdfs:label "author id" .

syb:format_type a rdf:Property ;
	rdfs:domain syb:au_pix ;
	rdfs:range xsd:string ;
	rdfs:label "format type" .

syb:bytesize a rdf:Property ;
	rdfs:domain syb:au_pix ;
	rdfs:range xsd:integer ;
	rdfs:label "byte size" .

syb:pixwidth_hor a rdf:Property ;
	rdfs:domain syb:au_pix ;
	rdfs:range xsd:string ;
	rdfs:label "picture horizontal width" .

syb:pixwidth_vert a rdf:Property ;
	rdfs:domain syb:au_pix ;
	rdfs:range xsd:string ;
	rdfs:label "picture vertical width" .

syb:discounts a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/sybasepubs2> ;
	rdfs:label "discounts" ;
	rdfs:comment "Sybase Pubs2 discount table" .

syb:discounttype a rdf:Property ;
	rdfs:domain syb:discounts ;
	rdfs:range xsd:string ;
	rdfs:label "discounttype" .

syb:stor_id a rdf:Property ;
	rdfs:domain syb:discounts ;
	rdfs:range syb:stores ;
	rdfs:label "store id" .

syb:lowqty a rdf:Property ;
	rdfs:domain syb:discounts ;
	rdfs:range xsd:integer ;
	rdfs:label "min quantity" .

syb:highqty a rdf:Property ;
	rdfs:domain syb:discounts ;
	rdfs:range xsd:integer ;
	rdfs:label "max quantity" .

syb:discount a rdf:Property ;
	rdfs:domain syb:discounts ;
	rdfs:range xsd:decimal ;
	rdfs:label "min quantity" .

syb:salesdetail a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/sybasepubs2> ;
	rdfs:label "sales details" ;
	rdfs:comment "Sybase Pubs2 sales detail table" .

syb:store_id a rdf:Property ;
	rdfs:domain syb:salesdetail ;
	rdfs:range syb:stores ;
	rdfs:label "store id" .

syb:ord_num a rdf:Property ;
	rdfs:domain syb:salesdetail ;
	rdfs:range syb:sales ;
	rdfs:label "order number" .

syb:title_id a rdf:Property ;
	rdfs:domain syb:salesdetail ;
	rdfs:range syb:titles ;
	rdfs:label "title id" .

syb:qty a rdf:Property ;
	rdfs:domain syb:salesdetail ;
	rdfs:range xsd:integer ;
	rdfs:label "quantity" .

syb:discount a rdf:Property ;
	rdfs:domain syb:salesdetail ;
	rdfs:range xsd:decimal ;
	rdfs:label "discount" .

syb:publishers a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/sybasepubs2> ;
	rdfs:label "Publishers" ;
	rdfs:comment "Sybase Pubs2 publishers table" .

syb:pub_id a rdf:Property ;
	rdfs:domain syb:publishers ;
	rdfs:range xsd:string ;
	rdfs:label "publisher id" .

syb:pub_name a rdf:Property ;
	rdfs:domain syb:publishers ;
	rdfs:range xsd:string ;
	rdfs:label "publisher name" .

syb:city a rdf:Property ;
	rdfs:domain syb:publishers ;
	rdfs:range xsd:string ;
	rdfs:label "city" .

syb:state a rdf:Property ;
	rdfs:domain syb:publishers ;
	rdfs:range xsd:string ;
	rdfs:label "state" .

syb:titleauthor a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/sybasepubs2> ;
	rdfs:label "title author" ;
	rdfs:comment "Sybase Pubs2 titleauthor table" .

syb:au_id a rdf:Property ;
	rdfs:domain syb:titleauthor ;
	rdfs:range syb:authors ;
	rdfs:label "author id" .

syb:title_id a rdf:Property ;
	rdfs:domain syb:titleauthor ;
	rdfs:range syb:titles ;
	rdfs:label "title id" .

syb:au_ord a rdf:Property ;
	rdfs:domain syb:titleauthor ;
	rdfs:range xsd:integer ;
	rdfs:label "author order" .

syb:royaltyper a rdf:Property ;
	rdfs:domain syb:titleauthor ;
	rdfs:range xsd:integer ;
	rdfs:label "royalty per book" .

syb:roysched a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/sybasepubs2> ;
	rdfs:label "Royalty Schedule" ;
	rdfs:comment "Sybase Pubs2 roysched table" .

syb:title_id a rdf:Property ;
	rdfs:domain syb:roysched ;
	rdfs:range syb:titles ;
	rdfs:label "title id" .

syb:lorange a rdf:Property ;
	rdfs:domain syb:roysched ;
	rdfs:range xsd:integer ;
	rdfs:label "low range" .

syb:hirange a rdf:Property ;
	rdfs:domain syb:roysched ;
	rdfs:range xsd:integer ;
	rdfs:label "high range" .

syb:royalty a rdf:Property ;
	rdfs:domain syb:roysched ;
	rdfs:range xsd:integer ;
	rdfs:label "royalty" .

syb:sales a rdfs:Class ;
	rdfs:isDefinedBy <http://localhost:8890/schemas/sybasepubs2> ;
	rdfs:label "Sales" ;
	rdfs:comment "Sybase Pubs2 sales table" .

syb:stor_id a rdf:Property ;
	rdfs:domain syb:sales ;
	rdfs:range xsd:string ;
	rdfs:label "store id" .

syb:ord_num a rdf:Property ;
	rdfs:domain syb:sales ;
	rdfs:range xsd:string ;
	rdfs:label "order number" .

syb:date a rdf:Property ;
	rdfs:domain syb:sales ;
	rdfs:range xsd:dateTime ;
	rdfs:label "date" .
', '', 'http://localhost:8890/schemas/sybasepubs2', 0);

---------------------------------------------------------------

----------- Create IRI Classes -------------

sparql

	create iri class <http://localhost:8890/schemas/sybasepubs2/titles_iri>
	"http://^{URIQADefaultHost}^/sybasepubs2/titles/%s_%s#this"
    	(in title_id varchar not null, in title varchar not null) .

	create iri class <http://localhost:8890/schemas/sybasepubs2/authors_iri>
	"http://^{URIQADefaultHost}^/sybasepubs2/authors/%s#this"
    	(in au_id varchar not null) .

	create iri class <http://localhost:8890/schemas/sybasepubs2/stores_iri>
	"http://^{URIQADefaultHost}^/sybasepubs2/stores/%s#this"
    	(in stor_id varchar not null) .

	create iri class <http://localhost:8890/schemas/sybasepubs2/au_pix_iri>
	"http://^{URIQADefaultHost}^/sybasepubs2/au_pix/%s#this"
    	(in au_id varchar not null) .

	create iri class <http://localhost:8890/schemas/sybasepubs2/discounts_iri>
	"http://^{URIQADefaultHost}^/sybasepubs2/discounts/%s#this"
    	(in discounttype varchar not null) .

	create iri class <http://localhost:8890/schemas/sybasepubs2/salesdetail_iri>
	"http://^{URIQADefaultHost}^/sybasepubs2/salesdetail/%s_%s_%s#this"
    	(in stor_id varchar not null, in ord_num varchar not null, in title_id varchar not null) .

	create iri class <http://localhost:8890/schemas/sybasepubs2/publishers_iri>
	"http://^{URIQADefaultHost}^/sybasepubs2/publishers/%s#this"
    	(in pub_id varchar not null) .

	create iri class <http://localhost:8890/schemas/sybasepubs2/titleauthor_iri>
	"http://^{URIQADefaultHost}^/sybasepubs2/titleauthor/%s_%s#this"
    	(in au_id varchar not null, in title_id varchar not null) .

	create iri class <http://localhost:8890/schemas/sybasepubs2/roysched_iri>
	"http://^{URIQADefaultHost}^/sybasepubs2/roysched/%s#this"
    	(in title_id varchar not null) .

	create iri class <http://localhost:8890/schemas/sybasepubs2/sales_iri>
	"http://^{URIQADefaultHost}^/sybasepubs2/sales/%s_%s#this"
    	(in stor_id varchar not null, in ord_num varchar not null) .

;

--------------------------------------------------------------------

------------- Create Quad Store ------------------------------------

sparql

prefix syb: <http://localhost:8890/schemas/sybasepubs2/>

alter quad storage virtrdf:DefaultQuadStorage
  from pubs2.syb.au_pix as au_pix_tbl
  from pubs2.syb.authors as authors_tbl
  from pubs2.syb.discounts as discounts_tbl
  from pubs2.syb.publishers as publishers_tbl
  from pubs2.syb.roysched as roysched_tbl
  from pubs2.syb.sales as sales_tbl
  from pubs2.syb.salesdetail as salesdetail_tbl
  from pubs2.syb.stores as stores_tbl
  from pubs2.syb.titleauthor as titleauthor_tbl
  from pubs2.syb.titles as titles_tbl
{
  create virtrdf:sybasepubs2 as
      graph <http://localhost:8890/sybasepubs2>
  {
	syb:au_pix_iri (au_pix_tbl.au_id) a syb:au_pix as virtrdf:au_pix_id;
	syb:au_id au_pix_tbl.au_id as virtrdf:au_pix_au_id;
	syb:format_type au_pix_tbl.format_type as virtrdf:au_pix_format_type;
	syb:bytesize au_pix_tbl.bytesize as virtrdf:au_pix_bytesize;
	syb:pixwidth_hor au_pix_tbl.pixwidth_hor as virtrdf:au_pix_pixwidth_hor;
	syb:pixwidth_vert au_pix_tbl.pixwidth_vert as virtrdf:au_pix_pixwidth_vert ;
       	syb:has_author syb:authors_iri(authors_tbl.au_id) where (^{authors_tbl.}^.au_id = ^{au_pix_tbl.}^.au_id) as virtrdf:au_pix_has_author .

        syb:authors_iri (authors_tbl.au_id) a syb:authors as virtrdf:authors_pk ;
	syb:au_id authors_tbl.au_id as virtrdf:authors_au_id;
       	syb:au_lname authors_tbl.au_lname as virtrdf:authors_au_lname;
       	syb:au_fname authors_tbl.au_fname as virtrdf:authors_au_fname;
       	syb:phone authors_tbl.phone  as virtrdf:authors_phone;
       	syb:address authors_tbl.address  as virtrdf:authors_address;
       	syb:city authors_tbl.city as virtrdf:authors_city;
       	syb:state authors_tbl.state  as virtrdf:authors_state;
       	syb:country authors_tbl.country as virtrdf:authors_country;
       	syb:postalcode authors_tbl.postalcode as virtrdf:authors_postalcode;
      	syb:has_title syb:titleauthor_iri(titleauthor_tbl.au_id, titleauthor_tbl.title_id) where (^{titleauthor_tbl.}^.au_id = ^{authors_tbl.}^.au_id) as virtrdf:authors_has_title;
      	syb:has_pix syb:au_pix_iri(au_pix_tbl.au_id) where (^{au_pix_tbl.}^.au_id = ^{authors_tbl.}^.au_id) as virtrdf:authors_has_pix .

	syb:discounts_iri (discounts_tbl.stor_id) a syb:discounts as virtrdf:discounts_pk;
	syb:discounttype discounts_tbl.discounttype as virtrdf:discounts_discounttype;
	syb:stor_id syb:stores_iri(stores_tbl.stor_id) where (^{stores_tbl.}^.stor_id = ^{stores_tbl.}^.stor_id) as virtrdf:discounts_stor_id;
	syb:lowqty discounts_tbl.lowqty as virtrdf:discounts_lowqty;
	syb:highqty discounts_tbl.highqty as virtrdf:discounts_highqty;
	syb:discount discounts_tbl.discount as virtrdf:discounts_discount .

	syb:publishers_iri (publishers_tbl.pub_id) a syb:publishers as virtrdf:publishers_pk;
	syb:pub_id syb:titles_iri(titles_tbl.title_id, titles_tbl.pub_id) where (^{titles_tbl.}^.pub_id = ^{titles_tbl.}^.pub_id) as virtrdf:publisherss_pub_id;
	syb:pub_name publishers_tbl.pub_name as virtrdf:publisherss_pub_name;
	syb:city publishers_tbl.city as virtrdf:publisherss_city;
	syb:state publishers_tbl.state as virtrdf:publisherss_state .

	syb:roysched_iri (roysched_tbl.title_id) a syb:roysched as virtrdf:roysched_pk;
       	syb:title_id syb:titleauthor_iri(titleauthor_tbl.au_id, titleauthor_tbl.title_id) where (^{titleauthor_tbl.}^.title_id = ^{roysched_tbl.}^.title_id) as virtrdf:roysched_title_id;
	syb:lorange roysched_tbl.lorange as virtrdf:roysched_lorange;
	syb:hirange roysched_tbl.hirange as virtrdf:roysched_hirange;
	syb:royalty roysched_tbl.royalty as virtrdf:roysched_royalty .

	syb:sales_iri (sales_tbl.stor_id, sales_tbl.ord_num) a syb:sales as virtrdf:sales_pk;
	syb:stor_id sales_tbl.stor_id as virtrdf:sales_stor_id;
	syb:ord_num sales_tbl.ord_num as virtrdf:sales_ord_num;
	syb:date sales_tbl.date as virtrdf:sales_date;
       	syb:has_salesdetail syb:salesdetail_iri(salesdetail_tbl.stor_id, salesdetail_tbl.ord_num, salesdetail_tbl.title_id) where (^{salesdetail_tbl.}^.stor_id = ^{sales_tbl.}^.stor_id and ^{salesdetail_tbl.}^.ord_num = ^{sales_tbl.}^.ord_num)  as virtrdf:sales_has_salesdetail;
       	syb:has_stores syb:stores_iri(stores_tbl.stor_id) where (^{stores_tbl.}^.stor_id = ^{sales_tbl.}^.stor_id)  as virtrdf:sales_has_stores .

	syb:salesdetail_iri (salesdetail_tbl.stor_id, salesdetail_tbl.ord_num, salesdetail_tbl.title_id) a syb:salesdetail as virtrdf:salesdetail_pk;
	syb:stor_id salesdetail_tbl.stor_id as virtrdf:salesdetail_stor_id;
	syb:ord_num salesdetail_tbl.ord_num as virtrdf:salesdetail_ord_num;
	syb:title_id salesdetail_tbl.title_id as virtrdf:salesdetail_title_id;
	syb:qty salesdetail_tbl.qty as virtrdf:salesdeail_qty;
	syb:discount salesdetail_tbl.discount as virtrdf:salesdetail_discount;
	syb:has_title  syb:titles_iri (titles_tbl.title_id, titles_tbl.pub_id) where (^{titles_tbl.}^.title_id = ^{salesdetail_tbl.}^.title_id) as virtrdf:salesdetail_has_title;
       	syb:has_sales syb:sales_iri(sales_tbl.stor_id, sales_tbl.ord_num) where (^{salesdetail_tbl.}^.stor_id = ^{sales_tbl.}^.stor_id and ^{salesdetail_tbl.}^.ord_num = ^{sales_tbl.}^.ord_num ) as virtrdf:salesdetail_has_sales .

	syb:stores_iri (stores_tbl.stor_id) a syb:stores as virtrdf:stores_pk;
       	syb:stor_id stores_tbl.stor_id as virtrdf:stores_stor_id;
	syb:stor_name stores_tbl.stor_name as virtrdf:stores_stor_name;
	syb:stor_address stores_tbl.stor_address as virtrdf:stores_stor_address;
	syb:city stores_tbl.city as virtrdf:stores_city;
	syb:state stores_tbl.state as virtrdf:stores_state;
	syb:country stores_tbl.country as virtrdf:stores_country;
	syb:postalcode stores_tbl.postalcode as virtrdf:stores_postalcode;
	syb:payterms stores_tbl.payterms as virtrdf:stores_payterms;
       	syb:has_sales syb:sales_iri(sales_tbl.stor_id, sales_tbl.ord_num) where (^{sales_tbl.}^.stor_id = ^{stores_tbl.}^.stor_id) as virtrdf:stores_has_sales .

	syb:titleauthor_iri (titleauthor_tbl.au_id, titleauthor_tbl.title_id) a syb:titleauthor as virtrdf:titleauthor_pk;
	syb:au_id titleauthor_tbl.au_id as virtrdf:titleauthor_au_id;
	syb:title_id titleauthor_tbl.title_id as virtrdf:titleauthor_title_id;
	syb:au_ord titleauthor_tbl.au_ord as virtrdf:titleauthor_au_ord;
	syb:royaltyper titleauthor_tbl.royaltyper as virtrdf:titleauthor_royaltyper;
	syb:has_author syb:authors_iri(authors_tbl.au_id) where (^{authors_tbl.}^.au_id = ^{titleauthor_tbl.}^.au_id) as virtrdf:titleauthor_has_author;
	syb:has_titles syb:titles_iri(titles_tbl.title_id, titles_tbl.pub_id) where (^{titles_tbl.}^.title_id = ^{titleauthor_tbl.}^.title_id) as virtrdf:titleauthor_has_titles .

	syb:titles_iri (titles_tbl.title_id, titles_tbl.pub_id) a syb:titles as virtrdf:titles_pk;
	syb:title_id titles_tbl.title_id as virtrdf:titles_title_idd;
	syb:title titles_tbl.title as virtrdf:titles_title;
	syb:type titles_tbl.type as virtrdf:titles_type;
	syb:pub_id titles_tbl.pub_id as virtrdf:titles_pub_id;
	syb:price titles_tbl.price as virtrdf:titles_price;
	syb:advance titles_tbl.advance as virtrdf:titles_advance;
	syb:total_sales titles_tbl.total_sales as virtrdf:titles_total_sales;
	syb:notes titles_tbl.notes as virtrdf:titles_notes;
	syb:pubdate titles_tbl.pubdate as virtrdf:titles_pubdate;
	syb:contract titles_tbl.contract as virtrdf:titles_contract;
       	syb:has_titleauthor syb:titleauthor_iri(titleauthor_tbl.au_id, titleauthor_tbl.title_id) where (^{titleauthor_tbl.}^.title_id = ^{titles_tbl.}^.title_id) as virtrdf:titles_has_titleauthor;
       	syb:has_salesdetail syb:salesdetail_iri (salesdetail_tbl.stor_id, salesdetail_tbl.ord_num, salesdetail_tbl.title_id) where (^{salesdetail_tbl.}^.title_id = ^{titles_tbl.}^.title_id) as virtrdf:titles_has_salesdetail .

  } .
} .
;

delete from db.dba.url_rewrite_rule_list where urrl_list like 'sybasepubs2_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'sybasepubs2_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'sybasepubs2_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );


DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'sybasepubs2_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=DESCRIBE+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+FROM+%%3Chttp%%3A//localhost%%3A8890/sybasepubs2%%3E&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'sybasepubs2_rule_list1',
    1,
    vector (
  	 	'sybasepubs2_rule1',
  	 	'sybasepubs2_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/sybasepubs2');

VHOST_DEFINE (
	lpath=>'/sybasepubs2',
	ppath=>'/DAV/sybasepubs2/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'sybasepubs2_rule_list1')
	);

delete from db.dba.url_rewrite_rule_list where urrl_list like 'sybase_schemas_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'sybase_schemas_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'sybase_schemas_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'sybase_schemas_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}%%0D%%0AFROM+%%3Chttp%%3A//localhost%%3A8890/schemas/sybasepubs2%%3E+%%0D%%0AWHERE+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path','path','*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'sybase_schemas_rule_list1',
    1,
    vector (
  	 	'sybase_schemas_rule1',
  	 	'sybase_schemas_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/schema/sybasepubs2');

VHOST_DEFINE (
	lpath=>'/schemas/sybasepubs2',
	ppath=>'/DAV/schemas/sybasepubs2/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'sybase_schemas_rule_list1')
	);

DB.DBA.XML_SET_NS_DECL ('hr', 'http://^{URIQADefaultHost}^/schemas/sybasepubs2', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsenterprs89">
      <title>Progress (SQL-89) using demonstratino 'iSports' database</title>
<programlisting><![CDATA[
ATTACH TABLE  "ISPORTS_RDF"."Customer" PRIMARY KEY ("Cust-Num")
AS "isports_rdf"."pro91_isports_rdf"."Customer"
FROM 'pro91_isports_rdf';

ATTACH TABLE  "ISPORTS_RDF"."Invoice" PRIMARY KEY ("Invoice-Num")
AS "isports_rdf"."pro91_isports_rdf"."Invoice"
FROM 'pro91_isports_rdf';

ATTACH TABLE  "ISPORTS_RDF"."Item" PRIMARY KEY ("Item-num")
AS "isports_rdf"."pro91_isports_rdf"."Item"
FROM 'pro91_isports_rdf';

ATTACH TABLE  "ISPORTS_RDF"."Local-Default" PRIMARY KEY ("Country")
AS "isports_rdf"."pro91_isports_rdf"."Local-Default"
FROM 'pro91_isports_rdf';

ATTACH TABLE  "ISPORTS_RDF"."Order" PRIMARY KEY ("Order-num")
AS "isports_rdf"."pro91_isports_rdf"."Order"
FROM 'pro91_isports_rdf';

ATTACH TABLE  "ISPORTS_RDF"."Order-Line"  PRIMARY KEY ("Order-num", "Line-num")
AS "isports_rdf"."pro91_isports_rdf"."Order-Line"
FROM 'pro91_isports_rdf';

ATTACH TABLE  "ISPORTS_RDF"."Ref-Call" PRIMARY KEY ("Call-Num")
AS "isports_rdf"."pro91_isports_rdf"."Ref-Call"
FROM 'pro91_isports_rdf';

ATTACH TABLE  "ISPORTS_RDF"."Salesrep" PRIMARY KEY ("Sales-Rep")
AS "isports_rdf"."pro91_isports_rdf"."Salesrep"
FROM 'pro91_isports_rdf';

ATTACH TABLE  "ISPORTS_RDF"."State" PRIMARY KEY ("State")
AS "isports_rdf"."pro91_isports_rdf"."State"
FROM 'pro91_isports_rdf';

COMMIT WORK;

GRANT SELECT ON isports_rdf.pro91_isports_rdf.Customer        TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf."Order"         TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.Item            TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf."Order-Line"    TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.Invoice         TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf."Local-Default" TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf."Ref-Call"      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.Salesrep        TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.State           TO "SPARQL", "SPARQL_UPDATE";

GRANT SPARQL_UPDATE to "SPARQL";

CREATE VIEW isports_rdf.pro91_isports_rdf.VCustomer      AS SELECT "Cust-Num" AS Cust_Num, Name, Address, Address2, City, State, Country, Phone, Contact, "Sales-Rep" AS Sales_Rep, Comments, "Credit-Limit" AS Credit_Limit, Balance, Terms, Discount, "Postal-Code" AS Postal_Code FROM "isports_rdf"."pro91_isports_rdf"."Customer";
CREATE VIEW isports_rdf.pro91_isports_rdf.VOrder         AS SELECT "Order-num" AS Order_num, "Cust-Num" AS Cust_Num, "Order-Date" AS Order_Date, "Ship-Date" AS Ship_Date, "Promise-Date" AS Promise_Date, Carrier, Instructions, PO, Terms, "Sales-Rep" AS Sales_Rep FROM isports_rdf.pro91_isports_rdf."Order";
CREATE VIEW isports_rdf.pro91_isports_rdf.VItem          AS SELECT "Item-num" AS Item_num, "Item-Name" AS Item_Name, "Cat-Page" AS Cat_Page, Price, "Cat-Description" AS Cat_Description, "On-hand" AS On_hand, Allocated, "Re-Order" AS Re_Order, "On-Order" AS On_Order FROM isports_rdf.pro91_isports_rdf.Item;
CREATE VIEW isports_rdf.pro91_isports_rdf.VOrder_Line    AS SELECT "Order-num" AS Order_num, "Line-num" AS Line_num, "Item-num" AS Item_num, Price, Qty, Discount, "Extended-Price" AS Extended_Price, Backorder FROM isports_rdf.pro91_isports_rdf."Order-Line";
CREATE VIEW isports_rdf.pro91_isports_rdf.VInvoice       AS SELECT "Invoice-Num" AS Invoice_Num, "Cust-Num" AS Cust_Num, "Invoice-Date" AS Invoice_Date, Amount, "Total-Paid" AS Total_Paid, Adjustment, "Order-Num" AS Order_Num, "Ship-Charge" AS Ship_Charge FROM isports_rdf.pro91_isports_rdf.Invoice;
CREATE VIEW isports_rdf.pro91_isports_rdf.VLocal_Default AS SELECT Country, "Region1-Label" AS Region1_Label, "Region2-Label" AS Region2_Label, "Postal-Label" AS Postal_Label, "Postal-Format" AS Postal_Format, "Tel-Format" AS Tel_Format, "Date-Format" AS Date_Format, "Currency-Symbol" AS Currency_Symbol FROM isports_rdf.pro91_isports_rdf."Local-Default";
CREATE VIEW isports_rdf.pro91_isports_rdf.VRef_Call      AS SELECT "Call-Num" AS Call_Num, "Cust-Num" AS Cust_Num, "Call-Date" AS Call_Date, "Sales-Rep" AS Sales_Rep, Parent, Txt FROM isports_rdf.pro91_isports_rdf."Ref-Call";
CREATE VIEW isports_rdf.pro91_isports_rdf.VSalesrep      AS SELECT "Rep-Name" AS Rep_Name, Region, "Sales-Rep" AS Sales_Rep, "Month-Quota@1" AS Month_Quota_1, "Month-Quota@2" AS Month_Quota_2, "Month-Quota@3" AS Month_Quota_3, "Month-Quota@4" AS Month_Quota_4, "Month-Quota@5" AS Month_Quota_5, "Month-Quota@6" AS Month_Quota_6, "Month-Quota@7" AS Month_Quota_7, "Month-Quota@8" AS Month_Quota_8, "Month-Quota@9" AS Month_Quota_9, "Month-Quota@10" AS Month_Quota_10, "Month-Quota@11" AS Month_Quota_11, "Month-Quota@12" AS Month_Quota_12 FROM isports_rdf.pro91_isports_rdf.Salesrep;
CREATE VIEW isports_rdf.pro91_isports_rdf.VState         AS SELECT State, "State-Name" AS State_Name, Region FROM isports_rdf.pro91_isports_rdf.State;

GRANT SELECT ON isports_rdf.pro91_isports_rdf.VCustomer      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.VOrder         TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.VItem          TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.VOrder_Line    TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.VInvoice       TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.VLocal_Default TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.VRef_Call      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.VSalesrep      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.pro91_isports_rdf.VState         TO "SPARQL", "SPARQL_UPDATE";


-------- Create rdfs:Class definitions ----------------------------

ttlp (
'
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix customer:     <http://localhost:8890/schemas/progress/isports/customer/> .
@prefix order:        <http://localhost:8890/schemas/progress/isports/order/> .
@prefix item:         <http://localhost:8890/schemas/progress/isports/item/> .
@prefix orderline:    <http://localhost:8890/schemas/progress/isports/order_line/> .
@prefix invoice:      <http://localhost:8890/schemas/progress/isports/invoice/> .
@prefix localdefault: <http://localhost:8890/schemas/progress/isports/local_default/> .
@prefix refcall:      <http://localhost:8890/schemas/progress/isports/ref_call/> .
@prefix salesrep:     <http://localhost:8890/schemas/progress/isports/salesrep/> .
@prefix state:        <http://localhost:8890/schemas/progress/isports/state/> .



customer:Customer a rdfs:Class ;
	rdfs:label "Customer" ;
	rdfs:comment "Progress isports Customer table" .

customer:Cust-Num a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:integer ;
	rdfs:label "Cust-Num" .

customer:Name a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Name" .

customer:Address a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Address" .

customer:Address2 a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Address2" .

customer:City a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "City" .

customer:State a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "State" .

customer:Country a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Country" .

customer:Phone a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Phone" .

customer:Contact a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Contact" .

customer:Sales-Rep a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Sales-Rep" .

customer:Comments a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Comments" .

customer:Credit-Limit a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:decimal ;
	rdfs:label "Credit-Limit" .

customer:Balance a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:decimal ;
	rdfs:label "Balance" .

customer:Terms a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Terms" .

customer:Discount a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:integer ;
	rdfs:label "Discount" .

customer:Postal-Code a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Postal-Code" .



order:Order a rdfs:Class ;
	rdfs:label "Order" ;
	rdfs:comment "Progress isports Order table" .

order:Order-num a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:integer ;
	rdfs:label "Order-num" .

order:Cust-Num a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:integer ;
	rdfs:label "Cust-Num" .

order:Order-Date a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:date ;
	rdfs:label "Order-Date" .

order:Ship-Date a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:date ;
	rdfs:label "Ship-Date" .

order:Promise-Date a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:date ;
	rdfs:label "Promise-Date" .

order:Carrier a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:string ;
	rdfs:label "Carrier" .

order:Instructions a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:string ;
	rdfs:label "Instructions" .

order:PO a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:string ;
	rdfs:label "PO" .

order:Terms a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:string ;
	rdfs:label "Terms" .

order:Sales-Rep a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:string ;
	rdfs:label "Sales-Rep" .



item:Item a rdfs:Class ;
	rdfs:label "Item" ;
	rdfs:comment "Progress isports Item table" .

item:Item-num a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "Item-num" .

item:Item-Name a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:string ;
	rdfs:label "Item-Name" .

item:Cat-Page a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "Cat-Page" .

item:Price a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:decimal ;
	rdfs:label "Price" .

item:Cat-Description a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:string ;
	rdfs:label "Cat-Description" .

item:On-hand a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "On-hand" .

item:Allocated a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "Allocated" .

item:Re-Order a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "Re-Order" .

item:On-Order a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "On-Order" .



orderline:Order-Line a rdfs:Class ;
	rdfs:label "Order-Line" ;
	rdfs:comment "Progress isports Order-Line table" .

orderline:Order-num a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:integer ;
	rdfs:label "Order-num" .

orderline:Line-num a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:integer ;
	rdfs:label "Line-num" .

orderline:Item-num a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:integer ;
	rdfs:label "Item-num" .

orderline:Price a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:decimal ;
	rdfs:label "Price" .

orderline:Qty a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:integer ;
	rdfs:label "Qty" .

orderline:Discount a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:integer ;
	rdfs:label "Discount" .

orderline:Extended-Price a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:decimal ;
	rdfs:label "Extended-Price" .

orderline:Backorder a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:byte ;
	rdfs:label "Backorder" .



invoice:Invoice a rdfs:Class ;
	rdfs:label "Invoice" ;
	rdfs:comment "Progress isports Invoice table" .

invoice:Invoice-Num a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:integer ;
	rdfs:label "Invoice-Num" .

invoice:Cust-Num a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:integer ;
	rdfs:label "Cust-Num" .

invoice:Invoice-Date a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:date ;
	rdfs:label "Invoice-Date" .

invoice:Amount a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:decimal ;
	rdfs:label "Amount" .

invoice:Total-Paid a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:decimal ;
	rdfs:label "Total-Paid" .

invoice:Adjustment a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:decimal ;
	rdfs:label "Adjustmant" .

invoice:Order-Num a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:integer ;
	rdfs:label "Order-Num" .

invoice:Ship-Charge a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:decimal ;
	rdfs:label "Ship-Charge" .



localdefault:Local-Default a rdfs:Class ;
	rdfs:label "Local-Default" ;
	rdfs:comment "Progress isports Local-Default table" .

localdefault:Country a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Country" .

localdefault:Region1-Label a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Region1-Label" .

localdefault:Region2-Label a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Region2-Label" .

localdefault:Postal-Label a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Postal-Label" .

localdefault:Postal-Format a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Postal-Format" .

localdefault:Tel-Format a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Tel-Format" .

localdefault:Date-Format a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Date-Format" .

localdefault:Currency-Symbol a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Currency-Symbol" .



refcall:Ref-Call a rdfs:Class ;
	rdfs:label "Ref-Call" ;
	rdfs:comment "Progress isports Ref-Call table" .

refcall:Call-Num a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:string ;
	rdfs:label "Call-Num" .

refcall:Cust-Num a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:integer ;
	rdfs:label "Cust-Num" .

refcall:Call-Date a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:date ;
	rdfs:label "Call-Date" .

refcall:Sales-Rep a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:string ;
	rdfs:label "Sales-Rep" .

refcall:Parent a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:string ;
	rdfs:label "Parent" .

refcall:Txt a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:string ;
	rdfs:label "Txt" .



salesrep:Salesrep a rdfs:Class ;
	rdfs:label "Salesrep" ;
	rdfs:comment "Progress isports Salesrep table" .

salesrep:Sales-Rep a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Sales-Rep" .

salesrep:Rep-Name a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Rep-Name" .

salesrep:Region a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Region" .

salesrep:Month-Quota-1 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@1" .

salesrep:Month-Quota-2 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@2" .

salesrep:Month-Quota-3 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@3" .

salesrep:Month-Quota-4 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@4" .

salesrep:Month-Quota-5 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@5" .

salesrep:Month-Quota-6 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@6" .

salesrep:Month-Quota-7 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@7" .

salesrep:Month-Quota-8 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@8" .

salesrep:Month-Quota-9 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@9" .

salesrep:Month-Quota-10 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@10" .

salesrep:Month-Quota-11 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@11" .

salesrep:Month-Quota-12 a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota@12" .



state:State a rdfs:Class ;
	rdfs:label "State" ;
	rdfs:comment "Progress isports State table" .

state:State_ a rdf:Property ;
	rdfs:domain state:State ;
	rdfs:range xsd:string ;
	rdfs:label "State" .

state:State-Name a rdf:Property ;
	rdfs:domain state:State ;
	rdfs:range xsd:string ;
	rdfs:label "State-Name" .

state:Region a rdf:Property ;
	rdfs:domain state:State ;
	rdfs:range xsd:string ;
	rdfs:label "Region" .

', '', 'http://localhost:8890/schemas/progress/isports', 0);



----------- Create IRI Classes -------------




sparql

prefix customer:     <http://localhost:8890/schemas/progress/isports/customer/>
prefix order:        <http://localhost:8890/schemas/progress/isports/order/>
prefix item:         <http://localhost:8890/schemas/progress/isports/item/>
prefix orderline:    <http://localhost:8890/schemas/progress/isports/order_line/>
prefix invoice:      <http://localhost:8890/schemas/progress/isports/invoice/>
prefix localdefault: <http://localhost:8890/schemas/progress/isports/local_default/>
prefix refcall:      <http://localhost:8890/schemas/progress/isports/ref_call/>
prefix salesrep:     <http://localhost:8890/schemas/progress/isports/salesrep/>
prefix state:        <http://localhost:8890/schemas/progress/isports/state/>

create iri class customer:customer_iri
	"http://localhost:8890/progress/isports/customer/%d#this"
	(in Cust_Num integer not null) .

create iri class order:order_iri
	"http://localhost:8890/progress/isports/order/%d#this"
	(in Order_Num integer not null) .

create iri class item:item_iri
	"http://localhost:8890/progress/isports/item/%d#this"
	(in Item_num integer not null) .

create iri class orderline:order-line_iri
	"http://localhost:8890/progress/isports/order-line/%d_%d#this"
	(in Order_num integer not null, in Line_num integer not null) .

create iri class invoice:invoice_iri
	"http://localhost:8890/progress/isports/invoice/%d#this"
	(in Invoice_Num integer not null) .

create iri class localdefault:local-default_iri
	"http://localhost:8890/progress/isports/local-default/%U#this"
	(in Country varchar not null) .

create iri class refcall:ref-call_iri
	"http://localhost:8890/progress/isports/ref-call/%U#this"
	(in Call_Num varchar not null) .

create iri class salesrep:salesrep_iri
	"http://localhost:8890/progress/isports/salesrep/%U#this"
	(in Sales_Rep varchar not null) .

create iri class state:state_iri
	"http://localhost:8890/progress/isports/state/%U#this"
	(in State varchar not null) .

;







------------- Create Quad Store ------------------------------------

sparql

prefix customer:     <http://localhost:8890/schemas/progress/isports/customer/>
prefix order:        <http://localhost:8890/schemas/progress/isports/order/>
prefix item:         <http://localhost:8890/schemas/progress/isports/item/>
prefix orderline:    <http://localhost:8890/schemas/progress/isports/order_line/>
prefix invoice:      <http://localhost:8890/schemas/progress/isports/invoice/>
prefix localdefault: <http://localhost:8890/schemas/progress/isports/local_default/>
prefix refcall:      <http://localhost:8890/schemas/progress/isports/ref_call/>
prefix salesrep:     <http://localhost:8890/schemas/progress/isports/salesrep/>
prefix state:        <http://localhost:8890/schemas/progress/isports/state/>

alter quad storage virtrdf:DefaultQuadStorage
  from isports_rdf.pro91_isports_rdf.VCustomer      as Customer_tbl
  from isports_rdf.pro91_isports_rdf.VOrder         as Order_tbl
  from isports_rdf.pro91_isports_rdf.VItem          as Item_tbl
  from isports_rdf.pro91_isports_rdf.VOrder_Line    as Order_Line_tbl
  from isports_rdf.pro91_isports_rdf.VInvoice       as Invoice_tbl
  from isports_rdf.pro91_isports_rdf.VRef_Call      as Ref_Call_tbl
  from isports_rdf.pro91_isports_rdf.VRef_Call      as Ref_Call_tbl_1
  from isports_rdf.pro91_isports_rdf.VLocal_Default as Local_Default_tbl
  from isports_rdf.pro91_isports_rdf.VSalesrep      as Salesrep_tbl
  from isports_rdf.pro91_isports_rdf.VState         as State_tbl
{
  create virtrdf:progress_isports as graph <http://localhost:8890/progress/isports>
  {
    customer:customer_iri (Customer_tbl.Cust_Num) a customer:Customer as virtrdf:customer_pk ;
    customer:Cust-Num     Customer_tbl.Cust_Num     as virtrdf:Customer_cust-num ;
    customer:Name         Customer_tbl.Name         as virtrdf:Customer_name ;
    customer:Address      Customer_tbl.Address      as virtrdf:Customer_address ;
    customer:Address2     Customer_tbl.Address2     as virtrdf:Customer_address2 ;
    customer:City         Customer_tbl.City         as virtrdf:Customer_city ;
    customer:State        Customer_tbl.State        as virtrdf:Customer_state ;
    customer:Country      Customer_tbl.Country      as virtrdf:Customer_country ;
    customer:Phone        Customer_tbl.Phone        as virtrdf:Customer_phone ;
    customer:Contact      Customer_tbl.Contact      as virtrdf:Customer_contact ;
    customer:Sales-Rep    Customer_tbl.Sales_Rep    as virtrdf:Customer_sales_rep ;
    customer:Comments     Customer_tbl.Comments     as virtrdf:Customer_comments ;
    customer:Credit-Limit Customer_tbl.Credit_Limit as virtrdf:Customer_credit-limit ;
    customer:Balance      Customer_tbl.Balance      as virtrdf:Customer_balance ;
    customer:Terms        Customer_tbl.Terms        as virtrdf:Customer_terms ;
    customer:Discount     Customer_tbl.Discount     as virtrdf:Customer_discount ;
    customer:Postal-Code  Customer_tbl.Postal_Code  as virtrdf:Customer_postal-code ;
    customer:from_state        state:state_iri (State_tbl.State)                           where ( ^{Customer_tbl.}^.State     = ^{State_tbl.}^.State )           as virtrdf:Customer_from_state ;
    customer:has_sales_rep     salesrep:salesrep_iri (Salesrep_tbl.Sales_Rep)              where ( ^{Customer_tbl.}^.Sales_Rep = ^{Salesrep_tbl.}^.Sales_Rep )    as virtrdf:Customer_has_sales_rep ;
    customer:has_local_default localdefault:local-default_iri (Local_Default_tbl.Country)  where ( ^{Customer_tbl.}^.Country   = ^{Local_Default_tbl.}^.Country ) as virtrdf:Customer_has_local_default ;
    customer:placed_order      order:order_iri (Order_tbl.Order_num)                       where ( ^{Customer_tbl.}^.Cust_Num  = ^{Order_tbl.}^.Cust_Num )        as virtrdf:Customer_placed_order ;
    customer:has_invoice       invoice:invoice_iri (Invoice_tbl.Invoice_Num)               where ( ^{Customer_tbl.}^.Cust_Num  = ^{Invoice_tbl.}^.Cust_Num )      as virtrdf:Customer_has_invoice ;
    customer:ref_call          refcall:ref-call_iri (Ref_Call_tbl.Call_Num)                where ( ^{Customer_tbl.}^.Cust_Num  = ^{Ref_Call_tbl.}^.Cust_Num )     as virtrdf:Customer_ref-call .

    order:order_iri (Order_tbl.Order_num) a order:Order as virtrdf:order_pk ;
    order:Order-num    Order_tbl.Order_num    as virtrdf:Order_order-num ;
    order:Cust-Num     Order_tbl.Cust_Num     as virtrdf:Order_cust_num ;
    order:Order-Date   Order_tbl.Order_Date   as virtrdf:Order_order-date ;
    order:Ship-Date    Order_tbl.Ship_Date    as virtrdf:Order_ship-date ;
    order:Promise-Date Order_tbl.Promise_Date as virtrdf:Order_promise-date ;
    order:Carrier      Order_tbl.Carrier      as virtrdf:Order_carrier ;
    order:Instructions Order_tbl.Instructions as virtrdf:Order_instructions ;
    order:PO           Order_tbl.PO           as virtrdf:Order_po ;
    order:Terms        Order_tbl.Terms        as virtrdf:Order_terms ;
    order:placed_by    customer:customer_iri (Customer_tbl.Cust_Num)                                 where ( ^{Order_tbl.}^.Cust_Num  = ^{Customer_tbl.}^.Cust_Num )    as virtrdf:Order_placed_by ;
    order:Sales-Rep    salesrep:salesrep_iri (Salesrep_tbl.Sales_Rep)                                where ( ^{Order_tbl.}^.Sales_Rep = ^{Salesrep_tbl.}^.Sales_Rep )   as virtrdf:Order_sales_rep ;
    order:invoiced_on  invoice:invoice_iri (Invoice_tbl.Invoice_Num)                                 where ( ^{Order_tbl.}^.Order_num = ^{Invoice_tbl.}^.Order_Num )    as virtrdf:Order_invoiced_on ;
    order:has_lines    orderline:order-line_iri (Order_Line_tbl.Order_num, Order_Line_tbl.Line_num)  where ( ^{Order_tbl.}^.Order_num = ^{Order_Line_tbl.}^.Order_num ) as virtrdf:Order_has_lines .

    item:item_iri (Item_tbl.Item_num) a item:Item as virtrdf:item_pk ;
    item:Item-num        Item_tbl.Item_num        as virtrdf:item_item-num ;
    item:Item-Name       Item_tbl.Item_Name       as virtrdf:Item_item-Name ;
    item:Cat-Page        Item_tbl.Cat_Page        as virtrdf:Item_cat-page ;
    item:Price           Item_tbl.Price           as virtrdf:Item_price ;
    item:Cat-Description Item_tbl.Cat_Description as virtrdf:Item_cat-description ;
    item:On-hand         Item_tbl.On_hand         as virtrdf:Item_on-hand ;
    item:Allocated       Item_tbl.Allocated       as virtrdf:Item_allocated ;
    item:Re-Order        Item_tbl.Re_Order        as virtrdf:Item_re-order ;
    item:On-Order        Item_tbl.On_Order        as virtrdf:Item_on-order ;
    item:order_line  orderline:order-line_iri (Order_Line_tbl.Order_num, Order_Line_tbl.Line_num)  where ( ^{Item_tbl.}^.Item_num  = ^{Order_Line_tbl.}^.Item_num )   as virtrdf:Item_order_line .

    orderline:order-line_iri (Order_Line_tbl.Order_num, Order_Line_tbl.Line_num) a orderline:Order-Line as virtrdf:order-line_pk ;
    orderline:Line-num       Order_Line_tbl.Line_num       as virtrdf:Order-Line_line-num ;
    orderline:Price          Order_Line_tbl.Price          as virtrdf:Order-Line_price ;
    orderline:Qty            Order_Line_tbl.Qty            as virtrdf:Order-Line_qty ;
    orderline:Discount       Order_Line_tbl.Discount       as virtrdf:Order-Line_discount ;
    orderline:Extended-Price Order_Line_tbl.Extended_Price as virtrdf:Order-Line_extended-price ;
    orderline:Backorder      Order_Line_tbl.Backorder      as virtrdf:Order-Line_backorder ;
    orderline:Order-num  order:order_iri (Order_tbl.Order_num)  where ( ^{Order_Line_tbl.}^.Order_num = ^{Order_tbl.}^.Order_num ) as virtrdf:Order_Line_order_num ;
    orderline:Item-num   item:item_iri (Item_tbl.Item_num)      where ( ^{Order_Line_tbl.}^.Item_num  = ^{Item_tbl.}^.Item_num )   as virtrdf:Order_Line_item_num .

    invoice:invoice_iri (Invoice_tbl.Invoice_Num) a invoice:Invoice as virtrdf:invoice_pk ;
    invoice:Invoice-Num  Invoice_tbl.Invoice_Num  as virtrdf:Invoice_invoice-num ;
    invoice:Cust-Num     Invoice_tbl.Cust_Num    as virtrdf:Invoice_cust_num ;
    invoice:Invoice-Date Invoice_tbl.Invoice_Date as virtrdf:Invoice_invoice-date ;
    invoice:Amount       Invoice_tbl.Amount       as virtrdf:Invoice_amount ;
    invoice:Total-Paid   Invoice_tbl.Total_Paid   as virtrdf:Invoice_total-paid ;
    invoice:Adjustment   Invoice_tbl.Adjustment   as virtrdf:Invoice_adjustment ;
    invoice:Order-Num    Invoice_tbl.Order_Num    as virtrdf:Invoice_order-num ;
    invoice:Ship-Charge  Invoice_tbl.Ship_Charge  as virtrdf:Invoice_ship-charge ;
    invoice:invoiced_to  customer:customer_iri (Customer_tbl.Cust_Num)  where ( ^{Invoice_tbl.}^.Cust_Num  = ^{Customer_tbl.}^.Cust_Num ) as virtrdf:Invoice_invoiced_to ;
    invoice:Order-Num    order:order_iri (Order_tbl.Order_num)          where ( ^{Invoice_tbl.}^.Order_Num = ^{Order_tbl.}^.Order_num )   as virtrdf:Invoice_order_num .

    localdefault:local-default_iri (Local_Default_tbl.Country) a localdefault:Local-Default as virtrdf:local-default_pk ;
    localdefault:Country         Local_Default_tbl.Country as virtrdf:local-default_country ;
    localdefault:Region1-Label   Local_Default_tbl.Region1_Label   as virtrdf:Local-Default_region1-label ;
    localdefault:Region2-Label   Local_Default_tbl.Region2_Label   as virtrdf:Local-Default_region2-label ;
    localdefault:Postal-Label    Local_Default_tbl.Postal_Label    as virtrdf:Local-Default_postal-label ;
    localdefault:Postal-Format   Local_Default_tbl.Postal_Format   as virtrdf:Local-Default_postal-format ;
    localdefault:Tel-Format      Local_Default_tbl.Tel_Format      as virtrdf:Local-Default_tel-format ;
    localdefault:Date-Format     Local_Default_tbl.Date_Format     as virtrdf:Local-Default_date-format ;
    localdefault:Currency-Symbol Local_Default_tbl.Currency_Symbol as virtrdf:Local-Default_currency-symbol ;
    localdefault:has_customer customer:customer_iri (Customer_tbl.Cust_Num) where ( ^{Local_Default_tbl.}^.Country = ^{Customer_tbl.}^.Country ) as virtrdf:Local-Default_has_customer .


    refcall:ref-call_iri (Ref_Call_tbl.Call_Num) a refcall:Ref-Call as virtrdf:ref-call_pk ;
    refcall:Call-Num   Ref_Call_tbl.Call_Num   as virtrdf:Ref-Call_call-num ;
    refcall:Cust-Num   Ref_Call_tbl.Cust_Num   as virtrdf:Ref-Call_cust-num ;
    refcall:Call-Date  Ref_Call_tbl.Call_Date  as virtrdf:Ref-Call_call-date ;
    refcall:Sales-Rep  Ref_Call_tbl.Sales_Rep  as virtrdf:Ref-sales-rep ;
    refcall:Parent     Ref_Call_tbl.Parent     as virtrdf:Ref-Call_parent ;
    refcall:Txt        Ref_Call_tbl.Txt        as virtrdf:Ref-Call_txt ;
    refcall:made_to     customer:customer_iri (Customer_tbl.Cust_Num)   where  ( ^{Ref_Call_tbl.}^.Cust_Num  = ^{Customer_tbl.}^.Cust_Num )   as virtrdf:Ref-Call_made_to ;
    refcall:made_by     salesrep:salesrep_iri (Salesrep_tbl.Sales_Rep)  where  ( ^{Ref_Call_tbl.}^.Sales_Rep = ^{Salesrep_tbl.}^.Sales_Rep )  as virtrdf:Ref-Call_made-by ;
    refcall:has_parent  refcall:ref-call_iri (Ref_Call_tbl_1.Call_Num)    where  ( ^{Ref_Call_tbl.}^.Parent    = ^{Ref_Call_tbl_1.}^.Call_Num )   as virtrdf:Ref-Call_has_parent .

    salesrep:salesrep_iri (Salesrep_tbl.Sales_Rep) a salesrep:Salesrep as virtrdf:salesrep_pk ;
    salesrep:Sales-Rep      Salesrep_tbl.Sales_Rep       as virtrdf:Salesrep_sales-rep ;
    salesrep:Region         Salesrep_tbl.Region          as virtrdf:Salesrep_region ;
    salesrep:Rep-Name       Salesrep_tbl.Rep_Name        as virtrdf:Salesrep_rep-name ;
    salesrep:Month-Quota-1  Salesrep_tbl.Month_Quota_1   as virtrdf:Salesrep_month-quota-1 ;
    salesrep:Month-Quota-2  Salesrep_tbl.Month_Quota_2   as virtrdf:Salesrep_month-quota-2 ;
    salesrep:Month-Quota-3  Salesrep_tbl.Month_Quota_3   as virtrdf:Salesrep_month-quota-3 ;
    salesrep:Month-Quota-4  Salesrep_tbl.Month_Quota_4   as virtrdf:Salesrep_month-quota-4 ;
    salesrep:Month-Quota-5  Salesrep_tbl.Month_Quota_5   as virtrdf:Salesrep_month-quota-5 ;
    salesrep:Month-Quota-6  Salesrep_tbl.Month_Quota_6   as virtrdf:Salesrep_month-quota-6 ;
    salesrep:Month-Quota-7  Salesrep_tbl.Month_Quota_7   as virtrdf:Salesrep_month-quota-7 ;
    salesrep:Month-Quota-8  Salesrep_tbl.Month_Quota_8   as virtrdf:Salesrep_month-quota-8 ;
    salesrep:Month-Quota-9  Salesrep_tbl.Month_Quota_9   as virtrdf:Salesrep_month-quota-9 ;
    salesrep:Month-Quota-10 Salesrep_tbl.Month_Quota_10  as virtrdf:Salesrep_month-quota-10 ;
    salesrep:Month-Quota-11 Salesrep_tbl.Month_Quota_11  as virtrdf:Salesrep_month-quota-11 ;
    salesrep:Month-Quota-12 Salesrep_tbl.Month_Quota_12  as virtrdf:Salesrep_month-quota-12 ;
    salesrep:is_sales_rep_for customer:customer_iri (Customer_tbl.Cust_Num) where ( ^{Salesrep_tbl.}^.Sales_Rep = ^{Customer_tbl.}^.Sales_Rep ) as virtrdf:Salesrep_is_sales_rep_for ;
    salesrep:has_order        order:order_iri (Order_tbl.Order_num)         where ( ^{Salesrep_tbl.}^.Sales_Rep = ^{Order_tbl.}^.Sales_Rep )    as virtrdf:Salesrep_has_order ;
    salesrep:manages_region   state:state_iri (State_tbl.State)             where ( ^{Salesrep_tbl.}^.Region    = ^{State_tbl.}^.Region )       as virtrdf:Salesrep_manages_region ;
    salesrep:made_call        refcall:ref-call_iri (Ref_Call_tbl.Call_Num)  where ( ^{Salesrep_tbl.}^.Sales_Rep = ^{Ref_Call_tbl.}^.Sales_Rep ) as virtrdf:Ref-Call_made_call .

    state:state_iri (State_tbl.State) a state:State as virtrdf:state_pk ;
    state:State_     State_tbl.State        as virtrdf:State_state ;
    state:State-Name State_tbl.State_Name   as virtrdf:State_state-name ;
    state:Region     State_tbl.Region       as virtrdf:State_region ;
    state:has_customer   customer:customer_iri (Customer_tbl.Cust_Num)   where ( ^{State_tbl.}^.State  = ^{Customer_tbl.}^.State )  as virtrdf:State_has_customer ;
    state:has_sales_rep  salesrep:salesrep_iri (Salesrep_tbl.Sales_Rep)  where ( ^{State_tbl.}^.Region = ^{Salesrep_tbl.}^.Region ) as virtrdf:State_has_sales_rep .


  } .
} .
;

delete from db.dba.url_rewrite_rule_list where urrl_list like 'progress_isports_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'progress_isports_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'progress_isports_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );


DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'progress_isports_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=DESCRIBE+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+FROM+%%3Chttp%%3A//localhost%%3A8890/progress/isports%%3E&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'progress_isports_rule_list1',
    1,
    vector (
  	 	'progress_isports_rule1',
  	 	'progress_isports_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/progress/isports');

VHOST_DEFINE (
	lpath=>'/progress/isports',
	ppath=>'/DAV/progress/isports/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'progress_isports_rule_list1')
	);

delete from db.dba.url_rewrite_rule_list where urrl_list like 'progress_isports_schemas_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'progress_isports_schemas_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'progress_isports_schemas_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'progress_isports_schemas_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}%%0D%%0AFROM+%%3Chttp%%3A//localhost%%3A8890/schemas/progress/isports%%3E+%%0D%%0AWHERE+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path','path','*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'progress_isports_schemas_rule_list1',
    1,
    vector (
  	 	'progress_isports_schemas_rule1',
  	 	'progress_isports_schemas_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/schemas/progress/isports');

VHOST_DEFINE (
	lpath=>'/schemas/progress/isports',
	ppath=>'/DAV/schemas/progress/isports/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'progress_isports_schemas_rule_list1')
	);

DB.DBA.XML_SET_NS_DECL ('customer',     'http://^{URIQADefaultHost}^/schemas/progress/isports/customer/', 2);
DB.DBA.XML_SET_NS_DECL ('order',        'http://^{URIQADefaultHost}^/schemas/progress/isports/order/', 2);
DB.DBA.XML_SET_NS_DECL ('item',         'http://^{URIQADefaultHost}^/schemas/progress/isports/item/', 2);
DB.DBA.XML_SET_NS_DECL ('orderline',    'http://^{URIQADefaultHost}^/schemas/progress/isports/order_line/', 2);
DB.DBA.XML_SET_NS_DECL ('invoice',      'http://^{URIQADefaultHost}^/schemas/progress/isports/invoice/', 2);
DB.DBA.XML_SET_NS_DECL ('localdefault', 'http://^{URIQADefaultHost}^/schemas/progress/isports/local_default/', 2);
DB.DBA.XML_SET_NS_DECL ('refcall',      'http://^{URIQADefaultHost}^/schemas/progress/isports/ref_call/', 2);
DB.DBA.XML_SET_NS_DECL ('salesrep',     'http://^{URIQADefaultHost}^/schemas/progress/isports/salesrep/', 2);
DB.DBA.XML_SET_NS_DECL ('state',        'http://^{URIQADefaultHost}^/schemas/progress/isports/state/', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsenterprs92">
      <title>Progress (SQL-92) using demonstratino 'iSports' database</title>
<programlisting><![CDATA[
ATTACH TABLE  "PUB"."Customer"      PRIMARY KEY ("Cust-Num")              AS "isports_rdf"."prs10_isports_rdf"."Customer"      FROM 'prs10_isports_rdf';
ATTACH TABLE  "PUB"."Invoice"       PRIMARY KEY ("Invoice-Num")           AS "isports_rdf"."prs10_isports_rdf"."Invoice"       FROM 'prs10_isports_rdf';
ATTACH TABLE  "PUB"."Item"          PRIMARY KEY ("Item-num")              AS "isports_rdf"."prs10_isports_rdf"."Item"          FROM 'prs10_isports_rdf';
ATTACH TABLE  "PUB"."Local-Default" PRIMARY KEY ("Country")               AS "isports_rdf"."prs10_isports_rdf"."Local-Default" FROM 'prs10_isports_rdf';
ATTACH TABLE  "PUB"."Order"         PRIMARY KEY ("Order-num")             AS "isports_rdf"."prs10_isports_rdf"."Order"         FROM 'prs10_isports_rdf';
ATTACH TABLE  "PUB"."Order-Line"    PRIMARY KEY ("Order-num", "Line-num") AS "isports_rdf"."prs10_isports_rdf"."Order-Line"    FROM 'prs10_isports_rdf';
ATTACH TABLE  "PUB"."Ref-Call"      PRIMARY KEY ("Call-Num")              AS "isports_rdf"."prs10_isports_rdf"."Ref-Call"      FROM 'prs10_isports_rdf';
ATTACH TABLE  "PUB"."Salesrep"      PRIMARY KEY ("Sales-Rep")             AS "isports_rdf"."prs10_isports_rdf"."Salesrep"      FROM 'prs10_isports_rdf';
ATTACH TABLE  "PUB"."State"         PRIMARY KEY ("State")                 AS "isports_rdf"."prs10_isports_rdf"."State"         FROM 'prs10_isports_rdf';

COMMIT WORK;

GRANT SELECT ON isports_rdf.prs10_isports_rdf.Customer        TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf."Order"         TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.Item            TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf."Order-Line"    TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.Invoice         TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf."Local-Default" TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf."Ref-Call"      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.Salesrep        TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.State           TO "SPARQL", "SPARQL_UPDATE";

GRANT SPARQL_UPDATE to "SPARQL";


CREATE VIEW isports_rdf.prs10_isports_rdf.VCustomer      AS SELECT "Cust-Num" AS Cust_Num, Name, Address, Address2, City, State, Country, Phone, Contact, "Sales-Rep" AS Sales_Rep, Comments, "Credit-Limit" AS Credit_Limit, Balance, Terms, Discount, "Postal-Code" AS Postal_Code FROM isports_rdf.prs10_isports_rdf.Customer;
CREATE VIEW isports_rdf.prs10_isports_rdf.VOrder         AS SELECT "Order-num" AS Order_num, "Cust-Num" AS Cust_Num, "Order-Date" AS Order_Date, "Ship-Date" AS Ship_Date, "Promise-Date" AS Promise_Date, Carrier, Instructions, PO, Terms, "Sales-Rep" AS Sales_Rep FROM isports_rdf.prs10_isports_rdf."Order";
CREATE VIEW isports_rdf.prs10_isports_rdf.VItem          AS SELECT "Item-num" AS Item_num, "Item-Name" AS Item_Name, "Cat-Page" AS Cat_Page, Price, "Cat-Description" AS Cat_Description, "On-hand" AS On_hand, Allocated, "Re-Order" AS Re_Order, "On-Order" AS On_Order FROM isports_rdf.prs10_isports_rdf.Item;
CREATE VIEW isports_rdf.prs10_isports_rdf.VOrder_Line    AS SELECT "Order-num" AS Order_num, "Line-num" AS Line_num, "Item-num" AS Item_num, Price, Qty, Discount, "Extended-Price" AS Extended_Price, Backorder FROM isports_rdf.prs10_isports_rdf."Order-Line";
CREATE VIEW isports_rdf.prs10_isports_rdf.VInvoice       AS SELECT "Invoice-Num" AS Invoice_Num, "Cust-Num" AS Cust_Num, "Invoice-Date" AS Invoice_Date, Amount, "Total-Paid" AS Total_Paid, Adjustment, "Order-Num" AS Order_Num, "Ship-Charge" AS Ship_Charge FROM isports_rdf.prs10_isports_rdf.Invoice;
CREATE VIEW isports_rdf.prs10_isports_rdf.VLocal_Default AS SELECT Country, "Region1-Label" AS Region1_Label, "Region2-Label" AS Region2_Label, "Postal-Label" AS Postal_Label, "Postal-Format" AS Postal_Format, "Tel-Format" AS Tel_Format, "Date-Format" AS Date_Format, "Currency-Symbol" AS Currency_Symbol FROM isports_rdf.prs10_isports_rdf."Local-Default";
CREATE VIEW isports_rdf.prs10_isports_rdf.VRef_Call      AS SELECT "Call-Num" AS Call_Num, "Cust-Num" AS Cust_Num, "Call-Date" AS Call_Date, "Sales-Rep" AS Sales_Rep, Parent, Txt FROM isports_rdf.prs10_isports_rdf."Ref-Call";
CREATE VIEW isports_rdf.prs10_isports_rdf.VSalesrep      AS SELECT "Rep-Name" AS Rep_Name, Region, "Sales-Rep" AS Sales_Rep, "Month-Quota" AS Month_Quota FROM isports_rdf.prs10_isports_rdf.Salesrep;
CREATE VIEW isports_rdf.prs10_isports_rdf.VState         AS SELECT State, "State-Name" AS State_Name, Region FROM isports_rdf.prs10_isports_rdf.State;


GRANT SELECT ON isports_rdf.prs10_isports_rdf.VCustomer      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.VOrder         TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.VItem          TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.VOrder_Line    TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.VInvoice       TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.VLocal_Default TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.VRef_Call      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.VSalesrep      TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON isports_rdf.prs10_isports_rdf.VState         TO "SPARQL", "SPARQL_UPDATE";


-------- Create rdfs:Class definitions ----------------------------

ttlp (
'
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

@prefix customer:     <http://localhost:8890/schemas/progress/isports/customer/> .
@prefix order:        <http://localhost:8890/schemas/progress/isports/order/> .
@prefix item:         <http://localhost:8890/schemas/progress/isports/item/> .
@prefix orderline:    <http://localhost:8890/schemas/progress/isports/order_line/> .
@prefix invoice:      <http://localhost:8890/schemas/progress/isports/invoice/> .
@prefix localdefault: <http://localhost:8890/schemas/progress/isports/local_default/> .
@prefix refcall:      <http://localhost:8890/schemas/progress/isports/ref_call/> .
@prefix salesrep:     <http://localhost:8890/schemas/progress/isports/salesrep/> .
@prefix state:        <http://localhost:8890/schemas/progress/isports/state/> .



customer:Customer a rdfs:Class ;
	rdfs:label "Customer" ;
	rdfs:comment "Progress isports Customer table" .

customer:Cust-Num a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:integer ;
	rdfs:label "Cust-Num" .

customer:Name a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Name" .

customer:Address a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Address" .

customer:Address2 a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Address2" .

customer:City a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "City" .

customer:State a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "State" .

customer:Country a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Country" .

customer:Phone a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Phone" .

customer:Contact a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Contact" .

customer:Sales-Rep a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Sales-Rep" .

customer:Comments a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Comments" .

customer:Credit-Limit a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:decimal ;
	rdfs:label "Credit-Limit" .

customer:Balance a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:decimal ;
	rdfs:label "Balance" .

customer:Terms a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Terms" .

customer:Discount a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:integer ;
	rdfs:label "Discount" .

customer:Postal-Code a rdf:Property ;
	rdfs:domain customer:Customer ;
	rdfs:range xsd:string ;
	rdfs:label "Postal-Code" .



order:Order a rdfs:Class ;
	rdfs:label "Order" ;
	rdfs:comment "Progress isports Order table" .

order:Order-num a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:integer ;
	rdfs:label "Order-num" .

order:Cust-Num a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:integer ;
	rdfs:label "Cust-Num" .

order:Order-Date a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:date ;
	rdfs:label "Order-Date" .

order:Ship-Date a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:date ;
	rdfs:label "Ship-Date" .

order:Promise-Date a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:date ;
	rdfs:label "Promise-Date" .

order:Carrier a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:string ;
	rdfs:label "Carrier" .

order:Instructions a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:string ;
	rdfs:label "Instructions" .

order:PO a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:string ;
	rdfs:label "PO" .

order:Terms a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:string ;
	rdfs:label "Terms" .

order:Sales-Rep a rdf:Property ;
	rdfs:domain order:Order ;
	rdfs:range xsd:string ;
	rdfs:label "Sales-Rep" .



item:Item a rdfs:Class ;
	rdfs:label "Item" ;
	rdfs:comment "Progress isports Item table" .

item:Item-num a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "Item-num" .

item:Item-Name a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:string ;
	rdfs:label "Item-Name" .

item:Cat-Page a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "Cat-Page" .

item:Price a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:decimal ;
	rdfs:label "Price" .

item:Cat-Description a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:string ;
	rdfs:label "Cat-Description" .

item:On-hand a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "On-hand" .

item:Allocated a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "Allocated" .

item:Re-Order a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "Re-Order" .

item:On-Order a rdf:Property ;
	rdfs:domain item:Item ;
	rdfs:range xsd:integer ;
	rdfs:label "On-Order" .



orderline:Order-Line a rdfs:Class ;
	rdfs:label "Order-Line" ;
	rdfs:comment "Progress isports Order-Line table" .

orderline:Order-num a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:integer ;
	rdfs:label "Order-num" .

orderline:Line-num a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:integer ;
	rdfs:label "Line-num" .

orderline:Item-num a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:integer ;
	rdfs:label "Item-num" .

orderline:Price a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:decimal ;
	rdfs:label "Price" .

orderline:Qty a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:integer ;
	rdfs:label "Qty" .

orderline:Discount a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:integer ;
	rdfs:label "Discount" .

orderline:Extended-Price a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:decimal ;
	rdfs:label "Extended-Price" .

orderline:Backorder a rdf:Property ;
	rdfs:domain orderline:Order-Line ;
	rdfs:range xsd:byte ;
	rdfs:label "Backorder" .



invoice:Invoice a rdfs:Class ;
	rdfs:label "Invoice" ;
	rdfs:comment "Progress isports Invoice table" .

invoice:Invoice-Num a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:integer ;
	rdfs:label "Invoice-Num" .

invoice:Cust-Num a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:integer ;
	rdfs:label "Cust-Num" .

invoice:Invoice-Date a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:date ;
	rdfs:label "Invoice-Date" .

invoice:Amount a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:decimal ;
	rdfs:label "Amount" .

invoice:Total-Paid a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:decimal ;
	rdfs:label "Total-Paid" .

invoice:Adjustment a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:decimal ;
	rdfs:label "Adjustmant" .

invoice:Order-Num a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:integer ;
	rdfs:label "Order-Num" .

invoice:Ship-Charge a rdf:Property ;
	rdfs:domain invoice:Invoice ;
	rdfs:range xsd:decimal ;
	rdfs:label "Ship-Charge" .



localdefault:Local-Default a rdfs:Class ;
	rdfs:label "Local-Default" ;
	rdfs:comment "Progress isports Local-Default table" .

localdefault:Country a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Country" .

localdefault:Region1-Label a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Region1-Label" .

localdefault:Region2-Label a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Region2-Label" .

localdefault:Postal-Label a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Postal-Label" .

localdefault:Postal-Format a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Postal-Format" .

localdefault:Tel-Format a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Tel-Format" .

localdefault:Date-Format a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Date-Format" .

localdefault:Currency-Symbol a rdf:Property ;
	rdfs:domain localdefault:Local-Default ;
	rdfs:range xsd:string ;
	rdfs:label "Currency-Symbol" .



refcall:Ref-Call a rdfs:Class ;
	rdfs:label "Ref-Call" ;
	rdfs:comment "Progress isports Ref-Call table" .

refcall:Call-Num a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:string ;
	rdfs:label "Call-Num" .

refcall:Cust-Num a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:integer ;
	rdfs:label "Cust-Num" .

refcall:Call-Date a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:date ;
	rdfs:label "Call-Date" .

refcall:Sales-Rep a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:string ;
	rdfs:label "Sales-Rep" .

refcall:Parent a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:string ;
	rdfs:label "Parent" .

refcall:Txt a rdf:Property ;
	rdfs:domain refcall:Ref-Call ;
	rdfs:range xsd:string ;
	rdfs:label "Txt" .



salesrep:Salesrep a rdfs:Class ;
	rdfs:label "Salesrep" ;
	rdfs:comment "Progress isports Salesrep table" .

salesrep:Sales-Rep a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Sales-Rep" .

salesrep:Rep-Name a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Rep-Name" .

salesrep:Region a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Region" .

salesrep:Month-Quota a rdf:Property ;
	rdfs:domain salesrep:Salesrep ;
	rdfs:range xsd:string ;
	rdfs:label "Month-Quota" .



state:State a rdfs:Class ;
	rdfs:label "State" ;
	rdfs:comment "Progress isports State table" .

state:State_ a rdf:Property ;
	rdfs:domain state:State ;
	rdfs:range xsd:string ;
	rdfs:label "State" .

state:State-Name a rdf:Property ;
	rdfs:domain state:State ;
	rdfs:range xsd:string ;
	rdfs:label "State-Name" .

state:Region a rdf:Property ;
	rdfs:domain state:State ;
	rdfs:range xsd:string ;
	rdfs:label "Region" .

', '', 'http://localhost:8890/schemas/progress/isports', 0);



----------- Create IRI Classes -------------




sparql

prefix customer:     <http://localhost:8890/schemas/progress/isports/customer/>
prefix order:        <http://localhost:8890/schemas/progress/isports/order/>
prefix item:         <http://localhost:8890/schemas/progress/isports/item/>
prefix orderline:    <http://localhost:8890/schemas/progress/isports/order_line/>
prefix invoice:      <http://localhost:8890/schemas/progress/isports/invoice/>
prefix localdefault: <http://localhost:8890/schemas/progress/isports/local_default/>
prefix refcall:      <http://localhost:8890/schemas/progress/isports/ref_call/>
prefix salesrep:     <http://localhost:8890/schemas/progress/isports/salesrep/>
prefix state:        <http://localhost:8890/schemas/progress/isports/state/>

create iri class customer:customer_iri
	"http://localhost:8890/progress/isports/customer/%d#this"
	(in Cust_Num integer not null) .

create iri class order:order_iri
	"http://localhost:8890/progress/isports/order/%d#this"
	(in Order_Num integer not null) .

create iri class item:item_iri
	"http://localhost:8890/progress/isports/item/%d#this"
	(in Item_num integer not null) .

create iri class orderline:order-line_iri
	"http://localhost:8890/progress/isports/order-line/%d_%d#this"
	(in Order_num integer not null, in Line_num integer not null) .

create iri class invoice:invoice_iri
	"http://localhost:8890/progress/isports/invoice/%d#this"
	(in Invoice_Num integer not null) .

create iri class localdefault:local-default_iri
	"http://localhost:8890/progress/isports/local-default/%U#this"
	(in Country varchar not null) .

create iri class refcall:ref-call_iri
	"http://localhost:8890/progress/isports/ref-call/%U#this"
	(in Call_Num varchar not null) .

create iri class salesrep:salesrep_iri
	"http://localhost:8890/progress/isports/salesrep/%U#this"
	(in Sales_Rep varchar not null) .

create iri class state:state_iri
	"http://localhost:8890/progress/isports/state/%U#this"
	(in State varchar not null) .

;







------------- Create Quad Store ------------------------------------

sparql

prefix customer:     <http://localhost:8890/schemas/progress/isports/customer/>
prefix order:        <http://localhost:8890/schemas/progress/isports/order/>
prefix item:         <http://localhost:8890/schemas/progress/isports/item/>
prefix orderline:    <http://localhost:8890/schemas/progress/isports/order_line/>
prefix invoice:      <http://localhost:8890/schemas/progress/isports/invoice/>
prefix localdefault: <http://localhost:8890/schemas/progress/isports/local_default/>
prefix refcall:      <http://localhost:8890/schemas/progress/isports/ref_call/>
prefix salesrep:     <http://localhost:8890/schemas/progress/isports/salesrep/>
prefix state:        <http://localhost:8890/schemas/progress/isports/state/>

alter quad storage virtrdf:DefaultQuadStorage
  from isports_rdf.prs10_isports_rdf.VCustomer      as Customer_tbl
  from isports_rdf.prs10_isports_rdf.VOrder         as Order_tbl
  from isports_rdf.prs10_isports_rdf.VItem          as Item_tbl
  from isports_rdf.prs10_isports_rdf.VOrder_Line    as Order_Line_tbl
  from isports_rdf.prs10_isports_rdf.VInvoice       as Invoice_tbl
  from isports_rdf.prs10_isports_rdf.VRef_Call      as Ref_Call_tbl
  from isports_rdf.prs10_isports_rdf.VRef_Call      as Ref_Call_tbl_1  -- Additional Ref_Call_tbl_1 alias required to represent recursive FK relationship (refcall:has_parent) below.
  from isports_rdf.prs10_isports_rdf.VLocal_Default as Local_Default_tbl
  from isports_rdf.prs10_isports_rdf.VSalesrep      as Salesrep_tbl
  from isports_rdf.prs10_isports_rdf.VState         as State_tbl
{
  create virtrdf:progress_isports as graph <http://localhost:8890/progress/isports>
  {
    customer:customer_iri (Customer_tbl.Cust_Num) a customer:Customer as virtrdf:customer_pk ;
    customer:Cust-Num     Customer_tbl.Cust_Num     as virtrdf:Customer_cust-num ;
    customer:Name         Customer_tbl.Name         as virtrdf:Customer_name ;
    customer:Address      Customer_tbl.Address      as virtrdf:Customer_address ;
    customer:Address2     Customer_tbl.Address2     as virtrdf:Customer_address2 ;
    customer:City         Customer_tbl.City         as virtrdf:Customer_city ;
    customer:State        Customer_tbl.State        as virtrdf:Customer_state ;
    customer:Country      Customer_tbl.Country      as virtrdf:Customer_country ;
    customer:Phone        Customer_tbl.Phone        as virtrdf:Customer_phone ;
    customer:Contact      Customer_tbl.Contact      as virtrdf:Customer_contact ;
    customer:Sales-Rep    Customer_tbl.Sales_Rep    as virtrdf:Customer_sales_rep ;
    customer:Comments     Customer_tbl.Comments     as virtrdf:Customer_comments ;
    customer:Credit-Limit Customer_tbl.Credit_Limit as virtrdf:Customer_credit-limit ;
    customer:Balance      Customer_tbl.Balance      as virtrdf:Customer_balance ;
    customer:Terms        Customer_tbl.Terms        as virtrdf:Customer_terms ;
    customer:Discount     Customer_tbl.Discount     as virtrdf:Customer_discount ;
    customer:Postal-Code  Customer_tbl.Postal_Code  as virtrdf:Customer_postal-code ;
    customer:from_state        state:state_iri (State_tbl.State)                           where ( ^{Customer_tbl.}^.State     = ^{State_tbl.}^.State )           as virtrdf:Customer_from_state ;
    customer:has_sales_rep     salesrep:salesrep_iri (Salesrep_tbl.Sales_Rep)              where ( ^{Customer_tbl.}^.Sales_Rep = ^{Salesrep_tbl.}^.Sales_Rep )    as virtrdf:Customer_has_sales_rep ;
    customer:has_local_default localdefault:local-default_iri (Local_Default_tbl.Country)  where ( ^{Customer_tbl.}^.Country   = ^{Local_Default_tbl.}^.Country ) as virtrdf:Customer_has_local_default ;
    customer:placed_order      order:order_iri (Order_tbl.Order_num)                       where ( ^{Customer_tbl.}^.Cust_Num  = ^{Order_tbl.}^.Cust_Num )        as virtrdf:Customer_placed_order ;
    customer:has_invoice       invoice:invoice_iri (Invoice_tbl.Invoice_Num)               where ( ^{Customer_tbl.}^.Cust_Num  = ^{Invoice_tbl.}^.Cust_Num )      as virtrdf:Customer_has_invoice ;
    customer:ref_call          refcall:ref-call_iri (Ref_Call_tbl.Call_Num)                where ( ^{Customer_tbl.}^.Cust_Num  = ^{Ref_Call_tbl.}^.Cust_Num )     as virtrdf:Customer_ref-call .

    order:order_iri (Order_tbl.Order_num) a order:Order as virtrdf:order_pk ;
    order:Order-num    Order_tbl.Order_num    as virtrdf:Order_order-num ;
    order:Cust-Num     Order_tbl.Cust_Num     as virtrdf:Order_cust_num ;
    order:Order-Date   Order_tbl.Order_Date   as virtrdf:Order_order-date ;
    order:Ship-Date    Order_tbl.Ship_Date    as virtrdf:Order_ship-date ;
    order:Promise-Date Order_tbl.Promise_Date as virtrdf:Order_promise-date ;
    order:Carrier      Order_tbl.Carrier      as virtrdf:Order_carrier ;
    order:Instructions Order_tbl.Instructions as virtrdf:Order_instructions ;
    order:PO           Order_tbl.PO           as virtrdf:Order_po ;
    order:Terms        Order_tbl.Terms        as virtrdf:Order_terms ;
    order:placed_by    customer:customer_iri (Customer_tbl.Cust_Num)                                 where ( ^{Order_tbl.}^.Cust_Num  = ^{Customer_tbl.}^.Cust_Num )    as virtrdf:Order_placed_by ;
    order:Sales-Rep    salesrep:salesrep_iri (Salesrep_tbl.Sales_Rep)                                where ( ^{Order_tbl.}^.Sales_Rep = ^{Salesrep_tbl.}^.Sales_Rep )   as virtrdf:Order_sales_rep ;
    order:invoiced_on  invoice:invoice_iri (Invoice_tbl.Invoice_Num)                                 where ( ^{Order_tbl.}^.Order_num = ^{Invoice_tbl.}^.Order_Num )    as virtrdf:Order_invoiced_on ;
    order:has_lines    orderline:order-line_iri (Order_Line_tbl.Order_num, Order_Line_tbl.Line_num)  where ( ^{Order_tbl.}^.Order_num = ^{Order_Line_tbl.}^.Order_num ) as virtrdf:Order_has_lines .

    item:item_iri (Item_tbl.Item_num) a item:Item as virtrdf:item_pk ;
    item:Item-num        Item_tbl.Item_num        as virtrdf:item_item-num ;
    item:Item-Name       Item_tbl.Item_Name       as virtrdf:Item_item-Name ;
    item:Cat-Page        Item_tbl.Cat_Page        as virtrdf:Item_cat-page ;
    item:Price           Item_tbl.Price           as virtrdf:Item_price ;
    item:Cat-Description Item_tbl.Cat_Description as virtrdf:Item_cat-description ;
    item:On-hand         Item_tbl.On_hand         as virtrdf:Item_on-hand ;
    item:Allocated       Item_tbl.Allocated       as virtrdf:Item_allocated ;
    item:Re-Order        Item_tbl.Re_Order        as virtrdf:Item_re-order ;
    item:On-Order        Item_tbl.On_Order        as virtrdf:Item_on-order ;
    item:order_line  orderline:order-line_iri (Order_Line_tbl.Order_num, Order_Line_tbl.Line_num)  where ( ^{Item_tbl.}^.Item_num  = ^{Order_Line_tbl.}^.Item_num )   as virtrdf:Item_order_line .

    orderline:order-line_iri (Order_Line_tbl.Order_num, Order_Line_tbl.Line_num) a orderline:Order-Line as virtrdf:order-line_pk ;
    orderline:Line-num       Order_Line_tbl.Line_num       as virtrdf:Order-Line_line-num ;
    orderline:Price          Order_Line_tbl.Price          as virtrdf:Order-Line_price ;
    orderline:Qty            Order_Line_tbl.Qty            as virtrdf:Order-Line_qty ;
    orderline:Discount       Order_Line_tbl.Discount       as virtrdf:Order-Line_discount ;
    orderline:Extended-Price Order_Line_tbl.Extended_Price as virtrdf:Order-Line_extended-price ;
    orderline:Backorder      Order_Line_tbl.Backorder      as virtrdf:Order-Line_backorder ;
    orderline:Order-num  order:order_iri (Order_tbl.Order_num)  where ( ^{Order_Line_tbl.}^.Order_num = ^{Order_tbl.}^.Order_num ) as virtrdf:Order_Line_order_num ;
    orderline:Item-num   item:item_iri (Item_tbl.Item_num)      where ( ^{Order_Line_tbl.}^.Item_num  = ^{Item_tbl.}^.Item_num )   as virtrdf:Order_Line_item_num .

    invoice:invoice_iri (Invoice_tbl.Invoice_Num) a invoice:Invoice as virtrdf:invoice_pk ;
    invoice:Invoice-Num  Invoice_tbl.Invoice_Num  as virtrdf:Invoice_invoice-num ;
    invoice:Cust-Num     Invoice_tbl.Cust_Num    as virtrdf:Invoice_cust_num ;
    invoice:Invoice-Date Invoice_tbl.Invoice_Date as virtrdf:Invoice_invoice-date ;
    invoice:Amount       Invoice_tbl.Amount       as virtrdf:Invoice_amount ;
    invoice:Total-Paid   Invoice_tbl.Total_Paid   as virtrdf:Invoice_total-paid ;
    invoice:Adjustment   Invoice_tbl.Adjustment   as virtrdf:Invoice_adjustment ;
    invoice:Order-Num    Invoice_tbl.Order_Num    as virtrdf:Invoice_order-num ;
    invoice:Ship-Charge  Invoice_tbl.Ship_Charge  as virtrdf:Invoice_ship-charge ;
    invoice:invoiced_to  customer:customer_iri (Customer_tbl.Cust_Num)  where ( ^{Invoice_tbl.}^.Cust_Num  = ^{Customer_tbl.}^.Cust_Num ) as virtrdf:Invoice_invoiced_to ;
    invoice:Order-Num    order:order_iri (Order_tbl.Order_num)          where ( ^{Invoice_tbl.}^.Order_Num = ^{Order_tbl.}^.Order_num )   as virtrdf:Invoice_order_num .

    localdefault:local-default_iri (Local_Default_tbl.Country) a localdefault:Local-Default as virtrdf:local-default_pk ;
    localdefault:Country         Local_Default_tbl.Country as virtrdf:local-default_country ;
    localdefault:Region1-Label   Local_Default_tbl.Region1_Label   as virtrdf:Local-Default_region1-label ;
    localdefault:Region2-Label   Local_Default_tbl.Region2_Label   as virtrdf:Local-Default_region2-label ;
    localdefault:Postal-Label    Local_Default_tbl.Postal_Label    as virtrdf:Local-Default_postal-label ;
    localdefault:Postal-Format   Local_Default_tbl.Postal_Format   as virtrdf:Local-Default_postal-format ;
    localdefault:Tel-Format      Local_Default_tbl.Tel_Format      as virtrdf:Local-Default_tel-format ;
    localdefault:Date-Format     Local_Default_tbl.Date_Format     as virtrdf:Local-Default_date-format ;
    localdefault:Currency-Symbol Local_Default_tbl.Currency_Symbol as virtrdf:Local-Default_currency-symbol ;
    localdefault:has_customer customer:customer_iri (Customer_tbl.Cust_Num) where ( ^{Local_Default_tbl.}^.Country = ^{Customer_tbl.}^.Country ) as virtrdf:Local-Default_has_customer .

    refcall:ref-call_iri (Ref_Call_tbl.Call_Num) a refcall:Ref-Call as virtrdf:ref-call_pk ;
    refcall:Call-Num   Ref_Call_tbl.Call_Num   as virtrdf:Ref-Call_call-num ;
    refcall:Cust-Num   Ref_Call_tbl.Cust_Num   as virtrdf:Ref-Call_cust-num ;
    refcall:Call-Date  Ref_Call_tbl.Call_Date  as virtrdf:Ref-Call_call-date ;
    refcall:Sales-Rep  Ref_Call_tbl.Sales_Rep  as virtrdf:Ref-sales-rep ;
    refcall:Parent     Ref_Call_tbl.Parent     as virtrdf:Ref-Call_parent ;
    refcall:Txt        Ref_Call_tbl.Txt        as virtrdf:Ref-Call_txt ;
    refcall:made_to     customer:customer_iri (Customer_tbl.Cust_Num)   where  ( ^{Ref_Call_tbl.}^.Cust_Num  = ^{Customer_tbl.}^.Cust_Num )    as virtrdf:Ref-Call_made_to ;
    refcall:made_by     salesrep:salesrep_iri (Salesrep_tbl.Sales_Rep)  where  ( ^{Ref_Call_tbl.}^.Sales_Rep = ^{Salesrep_tbl.}^.Sales_Rep )   as virtrdf:Ref-Call_made-by ;
    refcall:has_parent  refcall:ref-call_iri (Ref_Call_tbl_1.Call_Num)  where  ( ^{Ref_Call_tbl.}^.Parent    = ^{Ref_Call_tbl_1.}^.Call_Num )  as virtrdf:Ref-Call_has_parent .

    salesrep:salesrep_iri (Salesrep_tbl.Sales_Rep) a salesrep:Salesrep as virtrdf:salesrep_pk ;
    salesrep:Sales-Rep   Salesrep_tbl.Sales_Rep   as virtrdf:Salesrep_sales-rep ;
    salesrep:Region      Salesrep_tbl.Region      as virtrdf:Salesrep_region ;
    salesrep:Rep-Name    Salesrep_tbl.Rep_Name    as virtrdf:Salesrep_rep-name ;
    salesrep:Month-Quota Salesrep_tbl.Month_Quota as virtrdf:Salesrep_month-quota ;
    salesrep:is_sales_rep_for customer:customer_iri (Customer_tbl.Cust_Num) where ( ^{Salesrep_tbl.}^.Sales_Rep = ^{Customer_tbl.}^.Sales_Rep ) as virtrdf:Salesrep_is_sales_rep_for ;
    salesrep:has_order        order:order_iri (Order_tbl.Order_num)         where ( ^{Salesrep_tbl.}^.Sales_Rep = ^{Order_tbl.}^.Sales_Rep )    as virtrdf:Salesrep_has_order ;
    salesrep:manages_region   state:state_iri (State_tbl.State)             where ( ^{Salesrep_tbl.}^.Region    = ^{State_tbl.}^.Region )       as virtrdf:Salesrep_manages_region ;
    salesrep:made_call        refcall:ref-call_iri (Ref_Call_tbl.Call_Num)  where ( ^{Salesrep_tbl.}^.Sales_Rep = ^{Ref_Call_tbl.}^.Sales_Rep ) as virtrdf:Ref-Call_made_call .

    state:state_iri (State_tbl.State) a state:State as virtrdf:state_pk ;
    state:State_     State_tbl.State        as virtrdf:State_state ;
    state:State-Name State_tbl.State_Name   as virtrdf:State_state-name ;
    state:Region     State_tbl.Region       as virtrdf:State_region ;
    state:has_customer   customer:customer_iri (Customer_tbl.Cust_Num)   where ( ^{State_tbl.}^.State  = ^{Customer_tbl.}^.State )  as virtrdf:State_has_customer ;
    state:has_sales_rep  salesrep:salesrep_iri (Salesrep_tbl.Sales_Rep)  where ( ^{State_tbl.}^.Region = ^{Salesrep_tbl.}^.Region ) as virtrdf:State_has_sales_rep .


  } .
} .
;


-- Setup re-write rules that enable de-referencing of RDF based descriptions of
-- iSports Entities

-- Cleanup old rules

delete from db.dba.url_rewrite_rule_list where urrl_list like 'progress_isports_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'progress_isports_rule%';

-- Create rules for handling HTML representation of Entity (resource) description requests

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'progress_isports_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

-- Create rules for handling RDF based representations (N3 or RDF/XML) of Entity (resource) descriptions

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'progress_isports_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=DESCRIBE+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+%%3Chttp%%3A//localhost%%3A8890%U%%23this%%3E+FROM+%%3Chttp%%3A//localhost%%3A8890/progress/isports%%3E&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'progress_isports_rule_list1',
    1,
    vector (
  	 	'progress_isports_rule1',
  	 	'progress_isports_rule2'
	  ));

-- Setup OWL ontology data space that describes iSports entities

-- Create Virtual Directory access point

VHOST_REMOVE (lpath=>'/progress/isports');

VHOST_DEFINE (
	lpath=>'/progress/isports',
	ppath=>'/DAV/progress/isports/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'progress_isports_rule_list1')
	);

delete from db.dba.url_rewrite_rule_list where urrl_list like 'progress_isports_schemas_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'progress_isports_schemas_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'progress_isports_schemas_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'progress_isports_schemas_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}%%0D%%0AFROM+%%3Chttp%%3A//localhost%%3A8890/schemas/progress/isports%%3E+%%0D%%0AWHERE+{+%%3Chttp%%3A//localhost%%3A8890%U%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path','path','*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'progress_isports_schemas_rule_list1',
    1,
    vector (
  	 	'progress_isports_schemas_rule1',
  	 	'progress_isports_schemas_rule2'
	  ));

-- ensure a VD for the IRIs which begins with /
VHOST_REMOVE (lpath=>'/schemas/progress/isports');

VHOST_DEFINE (
	lpath=>'/schemas/progress/isports',
	ppath=>'/DAV/schemas/progress/isports/',
    	is_dav=>1,
	vsp_user=>'dba',
	is_brws=>0,
	opts=>vector ('url_rewrite', 'progress_isports_schemas_rule_list1')
	);

DB.DBA.XML_SET_NS_DECL ('customer',     'http://^{URIQADefaultHost}^/schemas/progress/isports/customer/', 2);
DB.DBA.XML_SET_NS_DECL ('order',        'http://^{URIQADefaultHost}^/schemas/progress/isports/order/', 2);
DB.DBA.XML_SET_NS_DECL ('item',         'http://^{URIQADefaultHost}^/schemas/progress/isports/item/', 2);
DB.DBA.XML_SET_NS_DECL ('orderline',    'http://^{URIQADefaultHost}^/schemas/progress/isports/order_line/', 2);
DB.DBA.XML_SET_NS_DECL ('invoice',      'http://^{URIQADefaultHost}^/schemas/progress/isports/invoice/', 2);
DB.DBA.XML_SET_NS_DECL ('localdefault', 'http://^{URIQADefaultHost}^/schemas/progress/isports/local_default/', 2);
DB.DBA.XML_SET_NS_DECL ('refcall',      'http://^{URIQADefaultHost}^/schemas/progress/isports/ref_call/', 2);
DB.DBA.XML_SET_NS_DECL ('salesrep',     'http://^{URIQADefaultHost}^/schemas/progress/isports/salesrep/', 2);
DB.DBA.XML_SET_NS_DECL ('state',        'http://^{URIQADefaultHost}^/schemas/progress/isports/state/', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsenterprbsm">
      <title>BSBM to RDF</title>
<programlisting><![CDATA[
use DB;

CREATE TABLE DB.DBA.ProductFeature (
  nr integer primary key,
  label varchar(100) not null,
  comment varchar(1500) not null,
  publisher integer not null,
  publishDate date not null
)
;

grant select on DB.DBA.ProductFeature to public
;

CREATE TABLE DB.DBA.ProductType (
  nr integer primary key,
  label varchar(100) not null,
  comment varchar(1500) not null,
  parent integer,
  publisher integer not null,
  publishDate date not null
)
;

grant select on DB.DBA.ProductType to public
;

CREATE TABLE DB.DBA.Producer (
  nr integer primary key,
  label varchar(100) not null,
  comment varchar(1500) not null,
  homepage varchar(100) not null,
  country char(2) not null,
  publisher integer not null,
  publishDate date not null
)
;

grant select on DB.DBA.Producer to public
;
create index producer_homepage on DB.DBA.Producer (homepage)
;

CREATE TABLE DB.DBA.Product (
  nr integer primary key,
  label varchar(100) not null,
  comment varchar not null,
  producer integer not null,
  propertyNum1 integer,
  propertyNum2 integer,
  propertyNum3 integer,
  propertyNum4 integer,
  propertyNum5 integer,
  propertyNum6 integer,
  propertyTex1 varchar(200),
  propertyTex2 varchar(200),
  propertyTex3 varchar(200),
  propertyTex4 varchar(200),
  propertyTex5 varchar(200),
  propertyTex6 varchar(200),
  publisher integer not null,
  publishDate date not null
)
;

grant select on DB.DBA.Product to public
;

create index product_lbl on DB.DBA.Product (label)
;
create unique index product_producer_nr on DB.DBA.Product (producer, nr)
;
create index product_pn1 on DB.DBA.Product (propertyNum1)
;
create index product_pn2 on DB.DBA.Product (propertyNum2)
;
create index product_pn3 on DB.DBA.Product (propertyNum3)
;

create text index on DB.DBA.Product (label) with key nr
;

CREATE TABLE DB.DBA.ProductTypeProduct (
  product integer not null,
  productType integer not null,
  PRIMARY KEY (product, productType)
)
;

grant select on DB.DBA.ProductTypeProduct to public
;

create index ptype_inv on DB.DBA.ProductTypeProduct (productType, product)
;

CREATE TABLE DB.DBA.ProductFeatureProduct (
  product integer not null,
  productFeature integer not null,
  PRIMARY KEY (product, productFeature)
)
;

grant select on DB.DBA.ProductFeatureProduct to public
;

create index pfeature_inv on DB.DBA.ProductFeatureProduct (productFeature, product)
;

CREATE TABLE DB.DBA.Vendor (
  nr integer primary key,
  label varchar(100) not null,
  comment varchar not null,
  homepage varchar(100) not null,
  country char(2) not null,
  publisher integer not null,
  publishDate date not null
)
;

grant select on DB.DBA.Vendor to public
;

create index vendor_country on DB.DBA.Vendor (country)
;
create index vendor_homepage on DB.DBA.Vendor (homepage)
;

CREATE TABLE DB.DBA.Offer (
  nr integer primary key,
  product integer not null,
  producer integer,
  vendor integer not null,
  price double precision not null,
  validFrom date not null,
  validTo date not null,
  deliveryDays integer not null,
  offerWebpage varchar(100) not null,
  publisher integer not null,
  publishDate date not null
)
;

grant select on DB.DBA.Offer to public
;

create index offer_product on DB.DBA.Offer (product, deliveryDays)
;
create unique index offer_producer_product on DB.DBA.Offer (producer, product, nr)
;
create index offer_validto on DB.DBA.Offer (validTo)
;
create index offer_vendor_product on DB.DBA.Offer (vendor, product)
;
create index offer_webpage on DB.DBA.Offer (offerWebpage)
;

CREATE TABLE DB.DBA.Person (
  nr integer primary key,
  name varchar(30) not null,
  mbox_sha1sum char(40) not null,
  country char(2) not null,
  publisher integer not null,
  publishDate date not null
)
;

grant select on DB.DBA.Person to public
;

CREATE TABLE DB.DBA.Review (
  nr integer primary key,
  product integer not null,
  producer integer,
  person integer not null,
  reviewDate date not null,
  title varchar(200) not null,
  text long varchar not null,
  textlang char(2) not null,
  rating1 integer,
  rating2 integer,
  rating3 integer,
  rating4 integer,
  publisher integer not null,
  publishDate date not null
)
;

grant select on DB.DBA.Review to public
;

create unique index review_product on DB.DBA.Review (product, producer, nr)
;

create unique index review_producer_product on DB.DBA.Review (producer, product, nr)
;

create bitmap index review_textlang on DB.DBA.Review (textlang)
;

DB.DBA.XML_SET_NS_DECL ('foaf', 'http://xmlns.com/foaf/0.1/', 2)
;
DB.DBA.XML_SET_NS_DECL ('dc', 'http://purl.org/dc/elements/1.1/', 2)
;
DB.DBA.XML_SET_NS_DECL ('xsd', 'http://www.w3.org/2001/XMLSchema-datatypes/', 2)
;
DB.DBA.XML_SET_NS_DECL ('rev', 'http://purl.org/stuff/rev#', 2)
;
DB.DBA.XML_SET_NS_DECL ('bsbm', 'http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/vocabulary/', 2)
;
DB.DBA.XML_SET_NS_DECL ('bsbm-inst', 'http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/', 2)
;

sparql drop quad map bsbm:SingleGraphView
;

sparql create iri class bsbm:ProductFeature-iri "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/ProductFeature%d" (in nr integer not null)
;

sparql create iri class bsbm:ProductType-iri "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/ProductType%d" (in nr integer not null)
;

sparql create iri class bsbm:Producer-iri "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer%d/Producer%d" (in nr_ integer not null, in nr integer not null)
;

sparql create iri class bsbm:Product-iri "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer%d/Product%d" (in producer integer not null, in nr integer not null)
;

sparql create iri class bsbm:Vendor-iri "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromVendor%d/Vendor%d" (in nr_ integer not null, in nr integer not null)
;

sparql create iri class bsbm:Offer-iri "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromVendor%d/Offer%d" (in vendor integer not null, in nr integer not null)
;

sparql create iri class bsbm:StdInst-iri "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/StandardizationInstitution%d" (in publisher integer not null)
;

sparql create iri class bsbm:Person-iri "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromRatingSite%d/Person%d" (in publisher integer not null, in nr integer not null)
;

sparql create iri class bsbm:Review-iri "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromRatingSite%d/Review%d" (in site integer, in nr integer not null)
;

sparql create iri class bsbm:ISO3166-country-iri "http://downlode.org/rdf/iso-3166/countries#%s" (in code varchar not null)
;

sparql create iri class bsbm:homepage-iri "%s" (in homepage varchar not null) option (returns "http://%s")
;

sparql create iri class bsbm:RatingSite-iri "http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromRatingSite%d/RatingSite%d" (in nr_ integer not null, in nr integer not null)
;

sparql
alter quad storage virtrdf:DefaultQuadStorage
from DB.DBA.ProductFeature as pfeature
from DB.DBA.ProductType as ptype
from DB.DBA.Producer as producer
from DB.DBA.Product as product text literal product.label
from DB.DBA.ProductTypeProduct as ptypeproduct
from DB.DBA.ProductFeatureProduct as pfeatureproduct
from DB.DBA.Vendor as vendor
from DB.DBA.Offer as offer
from DB.DBA.Person as person
from DB.DBA.Review as review
where (^{product.}^.nr = ^{ptypeproduct.}^.product)
where (^{product.}^.nr = ^{pfeatureproduct.}^.product)
  {
    create bsbm:SingleGraphView as graph <BSBM> option (exclusive)
      {
	bsbm:Product-iri (product.producer, product.nr)
          a bsbm:Product ;
	  rdfs:label product.label ;
          rdfs:comment product.comment ;
          bsbm:producer bsbm:Producer-iri (product.producer, product.producer) ;
          bsbm:productPropertyTextual1 product.propertyTex1 ;
          bsbm:productPropertyTextual2 product.propertyTex2 ;
          bsbm:productPropertyTextual3 product.propertyTex3 ;
          bsbm:productPropertyTextual4 product.propertyTex4 ;
          bsbm:productPropertyTextual5 product.propertyTex5 ;
          bsbm:productPropertyTextual6 product.propertyTex6 ;
          bsbm:productPropertyNumeric1 product.propertyNum1 ;
          bsbm:productPropertyNumeric2 product.propertyNum2 ;
          bsbm:productPropertyNumeric3 product.propertyNum3 ;
          bsbm:productPropertyNumeric4 product.propertyNum4 ;
          bsbm:productPropertyNumeric5 product.propertyNum5 ;
          bsbm:productPropertyNumeric6 product.propertyNum6 ;
          rdf:type bsbm:ProductType-iri (ptypeproduct.productType) ;
          bsbm:productFeature bsbm:ProductFeature-iri (pfeatureproduct.productFeature) ;
          dc:publisher bsbm:Producer-iri (product.publisher, product.publisher) ;
          dc:date product.publishDate .

        bsbm:ProductType-iri (ptype.nr)
          a bsbm:ProductType ;
          rdfs:label ptype.label ;
          rdfs:comment ptype.comment ;
          rdfs:subClassOf bsbm:ProductType-iri (ptype.parent) ;
          dc:publisher bsbm:StdInst-iri (ptype.publisher) ;
          dc:date ptype.publishDate .

        bsbm:ProductFeature-iri (pfeature.nr)
          a bsbm:ProductFeature ;
          rdfs:label pfeature.label ;
          rdfs:comment pfeature.comment ;
          dc:publisher bsbm:StdInst-iri (pfeature.publisher) ;
          dc:date pfeature.publishDate .

        bsbm:Producer-iri (producer.nr, producer.nr)
          a bsbm:Producer ;
          rdfs:label producer.label ;
          rdfs:comment producer.comment ;
          foaf:homepage bsbm:homepage-iri (producer.homepage) ;
          bsbm:country bsbm:ISO3166-country-iri (producer.country) ;
          dc:publisher bsbm:Producer-iri (producer.nr, producer.nr) ;
          dc:date producer.publishDate .

        bsbm:Vendor-iri (vendor.nr, vendor.nr)
          a bsbm:Vendor ;
          rdfs:label vendor.label ;
          rdfs:comment vendor.comment ;
          foaf:homepage bsbm:homepage-iri (vendor.homepage) ;
          bsbm:country bsbm:ISO3166-country-iri (vendor.country) ;
          dc:publisher bsbm:Vendor-iri (vendor.publisher, vendor.publisher) ;
          dc:date vendor.publishDate .

        bsbm:Offer-iri (offer.vendor, offer.nr)
          a bsbm:Offer ;
          bsbm:product bsbm:Product-iri (offer.producer, offer.product) ;
          bsbm:vendor bsbm:Vendor-iri (offer.vendor, offer.vendor) ;
          bsbm:vendor bsbm:Vendor-iri (offer.vendor, offer.vendor) ;
          bsbm:price offer.price ;
          bsbm:validFrom offer.validFrom ;
          bsbm:validTo offer.validTo ;
          bsbm:deliveryDays offer.deliveryDays ;
          bsbm:offerWebpage bsbm:homepage-iri (offer.offerWebpage) ;
          dc:publisher bsbm:Vendor-iri (offer.publisher, offer.publisher) ;
          dc:date offer.publishDate .

        bsbm:Person-iri (person.publisher, person.nr)
          a foaf:Person ;
          foaf:name person.name ;
          foaf:mbox_sha1sum person.mbox_sha1sum ;
          bsbm:country bsbm:ISO3166-country-iri (person.country) ;
          dc:publisher bsbm:RatingSite-iri (person.publisher, person.publisher) ;
          dc:date person.publishDate .

        bsbm:Review-iri (review.publisher, review.nr)
          a rev:Review ;
          bsbm:reviewFor bsbm:Product-iri (review.producer, review.product) ;
          bsbm:producer bsbm:Producer-iri (review.producer, review.producer) ;
          rev:reviewer bsbm:Person-iri (review.publisher, review.person) ;
          bsbm:reviewDate review.reviewDate ;
          dc:title review.title ;
          rev:text review.text lang review.textlang ;
          bsbm:rating1 review.rating1 ;
          bsbm:rating2 review.rating2 ;
          bsbm:rating3 review.rating3 ;
          bsbm:rating4 review.rating4 ;
          dc:publisher bsbm:RatingSite-iri (review.publisher, review.publisher) ;
          dc:date review.publishDate .
      }
  }
;
]]></programlisting>
    </sect3>
  </sect2>
  <sect2 id="rdfviewsbusint"><title>Business Intelligence</title>
    <sect3 id="rdfviewsbusinttpc">
      <title>TPCH to RDF</title>
<programlisting><![CDATA[
use DB;

GRANT SELECT ON TPCH.DBA.PARTSUPP  TO "SPARQL";
GRANT SELECT ON TPCH.DBA.SUPPLIER  TO "SPARQL";
GRANT SELECT ON TPCH.DBA.CUSTOMER  TO "SPARQL";
GRANT SELECT ON TPCH.DBA.HISTORY   TO "SPARQL";
GRANT SELECT ON TPCH.DBA.PART      TO "SPARQL";
GRANT SELECT ON TPCH.DBA.LINEITEM  TO "SPARQL";
GRANT SELECT ON TPCH.DBA.ORDERS    TO "SPARQL";
GRANT SELECT ON TPCH.DBA.NATION    TO "SPARQL";
GRANT SELECT ON TPCH.DBA.REGION    TO "SPARQL";

SPARQL
drop quad map virtrdf:TPCH
;

SPARQL
prefix tpch: <http://www.openlinksw.com/schemas/tpch#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
create iri class tpch:customer "http://^{URIQADefaultHost}^/tpch/customer/%U%d#this" (in custname varchar, in c_custkey integer not null) option (bijection, deref) .
create iri class tpch:lineitem "http://^{URIQADefaultHost}^/tpch/lineitem/%d/%d#this" (in l_orderkey integer not null, in l_linenumber integer not null) option (bijection, deref) .
create iri class tpch:nation "http://^{URIQADefaultHost}^/tpch/nation/%U%d#this" (in name varchar, in l_nationkey integer not null) option (bijection, deref) .
create iri class tpch:order "http://^{URIQADefaultHost}^/tpch/order/%d#this" (in o_orderkey integer not null) option (bijection, deref) .
create iri class tpch:part "http://^{URIQADefaultHost}^/tpch/part/%U%d#this" (in p_partname varchar, in p_partkey integer not null) option (bijection, deref) .
create iri class tpch:partsupp "http://^{URIQADefaultHost}^/tpch/partsupp/%d/%d#this" (in ps_partkey integer not null, in ps_suppkey integer not null) option (bijection, deref) .
create iri class tpch:region "http://^{URIQADefaultHost}^/tpch/region/%U%d#this" (in name varchar, in r_regionkey integer not null) option (bijection, deref) .
create iri class tpch:supplier "http://^{URIQADefaultHost}^/tpch/supplier/%U%d#this" (in name varchar, in s_supplierkey integer not null) option (bijection, deref) .
;

SPARQL
prefix tpch: <http://www.openlinksw.com/schemas/tpch#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
alter quad storage virtrdf:DefaultQuadStorage
from TPCH.DBA.LINEITEM as lineitems
from TPCH.DBA.CUSTOMER as customers
from TPCH.DBA.NATION as nations
from TPCH.DBA.ORDERS as orders
from TPCH.DBA.PART as parts
from TPCH.DBA.PARTSUPP as partsupps
from TPCH.DBA.REGION as regions
from TPCH.DBA.SUPPLIER as suppliers
where (^{suppliers.}^.S_NATIONKEY = ^{nations.}^.N_NATIONKEY)
where (^{customers.}^.C_NATIONKEY = ^{nations.}^.N_NATIONKEY)
{
    create virtrdf:TPCH as graph iri ("http://^{URIQADefaultHost}^/tpch") option (exclusive)
    {
# Customers
        tpch:customer (customers.C_NAME, customers.C_CUSTKEY)
            a  tpch:customer
                as virtrdf:customer-tpch-type ;
            a  foaf:Organization
                as virtrdf:customer-foaf-type ;
            tpch:custkey customers.C_CUSTKEY
                as virtrdf:customer-c_custkey ;
            foaf:name customers.C_NAME
                as virtrdf:customer-foaf_name ;
            tpch:companyName customers.C_NAME
                as virtrdf:customer-c_name ;
            tpch:has_nation tpch:nation (nations.N_NAME, customers.C_NATIONKEY)
                as virtrdf:customer-c_nationkey ;
            tpch:address customers.C_ADDRESS
                as virtrdf:customer-c_address ;
            foaf:phone customers.C_PHONE
                as virtrdf:customer-foaf_phone ;
            tpch:phone customers.C_PHONE
                as virtrdf:customer-phone ;
            tpch:acctbal customers.C_ACCTBAL
                as virtrdf:customer-acctbal ;
            tpch:mktsegment customers.C_MKTSEGMENT
                as virtrdf:customer-c_mktsegment ;
            tpch:comment customers.C_COMMENT
                as virtrdf:customer-c_comment .

# Nations
        tpch:nation (nations.N_NAME, customers.C_NATIONKEY)
            tpch:nation_of tpch:customer (customers.C_NAME, customers.C_CUSTKEY)
            as virtrdf:customer-nation_of .

        tpch:lineitem (lineitems.L_ORDERKEY, lineitems.L_LINENUMBER)
            a tpch:lineitem
                as virtrdf:lineitem-lineitems ;
            tpch:has_order tpch:order (lineitems.L_ORDERKEY)
                as virtrdf:lineitem-l_orderkey ;
            tpch:has_part tpch:part (parts.P_NAME, lineitems.L_PARTKEY)
                where (^{parts.}^.P_PARTKEY = ^{lineitems.}^.L_PARTKEY)
                as virtrdf:lineitem-l_partkey ;
            tpch:has_supplier tpch:supplier (suppliers.S_NAME, lineitems.L_SUPPKEY)
                where (^{suppliers.}^.S_SUPPKEY = ^{lineitems.}^.L_SUPPKEY)
                as virtrdf:lineitem-l_suppkey ;
            tpch:linenumber lineitems.L_LINENUMBER
                as virtrdf:lineitem-l_linenumber ;
            tpch:linequantity lineitems.L_QUANTITY
                as virtrdf:lineitem-l_linequantity ;
            tpch:lineextendedprice lineitems.L_EXTENDEDPRICE
                as virtrdf:lineitem-l_lineextendedprice ;
            tpch:linediscount lineitems.L_DISCOUNT
                as virtrdf:lineitem-l_linediscount ;
            tpch:linetax lineitems.L_TAX
                as virtrdf:lineitem-l_linetax ;
            tpch:returnflag lineitems.L_RETURNFLAG
                as virtrdf:lineitem-l_returnflag ;
            tpch:linestatus lineitems.L_LINESTATUS
                as virtrdf:lineitem-l_linestatus ;
            tpch:shipdate lineitems.L_SHIPDATE
                as virtrdf:lineitem-l_shipdate ;
            tpch:commitdate lineitems.L_COMMITDATE
                as virtrdf:lineitem-l_commitdate ;
            tpch:receiptdate lineitems.L_RECEIPTDATE
                as virtrdf:lineitem-l_receiptdate ;
            tpch:shipinstruct lineitems.L_SHIPINSTRUCT
                as virtrdf:lineitem-l_shipinstruct ;
            tpch:shipmode lineitems.L_SHIPMODE
                as virtrdf:lineitem-l_shipmode ;
            tpch:comment lineitems.L_COMMENT
                as virtrdf:lineitem-l_comment .

        tpch:part (parts.P_NAME, lineitems.L_PARTKEY)
            tpch:part_of tpch:lineitem (lineitems.L_ORDERKEY, lineitems.L_LINENUMBER)
            where (^{parts.}^.P_PARTKEY = ^{lineitems.}^.L_PARTKEY)
            as virtrdf:lineitem-part_of .

        tpch:order (lineitems.L_ORDERKEY)
            tpch:order_of tpch:lineitem (lineitems.L_ORDERKEY, lineitems.L_LINENUMBER) as virtrdf:lineitem-order_of .

        tpch:supplier (suppliers.S_NAME, lineitems.L_SUPPKEY)
            tpch:supplier_of tpch:lineitem (lineitems.L_ORDERKEY, lineitems.L_LINENUMBER)
            where (^{suppliers.}^.S_SUPPKEY = ^{lineitems.}^.L_SUPPKEY)
            as virtrdf:lineitem-supplier_of .

# Nation
        tpch:nation (nations.N_NAME, nations.N_NATIONKEY)
            a tpch:nation
                as virtrdf:nation-nations ;
            tpch:name nations.N_NAME
                as virtrdf:nation-n_name ;
            tpch:has_region tpch:region (regions.R_NAME, nations.N_REGIONKEY)
                where (^{regions.}^.R_REGIONKEY = ^{nations.}^.N_REGIONKEY)
                as virtrdf:nation-n_regionkey ;
            tpch:comment nations.N_COMMENT
                as virtrdf:nation-n_comment .

        tpch:region (regions.R_NAME, nations.N_REGIONKEY)
            tpch:region_of tpch:nation (nations.N_NAME, nations.N_NATIONKEY)
            where (^{regions.}^.R_REGIONKEY = ^{nations.}^.N_REGIONKEY)
            as virtrdf:nation-region_of .

# Order
        tpch:order (orders.O_ORDERKEY)
            a tpch:order
                as virtrdf:order-orders ;
            tpch:orderkey orders.O_ORDERKEY
                as virtrdf:order-o_orderkey ;
            tpch:has_customer tpch:customer (customers.C_NAME, orders.O_CUSTKEY)
                where (^{orders.}^.O_CUSTKEY = ^{customers.}^.C_CUSTKEY)
                as virtrdf:order-o_custkey ;
            tpch:orderstatus orders.O_ORDERSTATUS
                as virtrdf:order-o_orderstatus ;
            tpch:ordertotalprice orders.O_TOTALPRICE
                as virtrdf:order-o_totalprice ;
            tpch:orderdate orders.O_ORDERDATE
                as virtrdf:order-o_orderdate ;
            tpch:orderpriority orders.O_ORDERPRIORITY
                as virtrdf:order-o_orderpriority ;
            tpch:clerk orders.O_CLERK
                as virtrdf:order-o_clerk ;
            tpch:shippriority orders.O_SHIPPRIORITY
                as virtrdf:order-o_shippriority ;
            tpch:comment orders.O_COMMENT
                as virtrdf:order-o_comment .

        tpch:customer (customers.C_CUSTKEY, orders.O_CUSTKEY)
            tpch:customer_of tpch:order (orders.O_ORDERKEY)
            where (^{orders.}^.O_CUSTKEY = ^{customers.}^.C_CUSTKEY)
            as virtrdf:order-customer_of .

# Part
        tpch:part (parts.P_NAME, parts.P_PARTKEY)
            a tpch:part
                as virtrdf:part-parts ;
            tpch:partkey parts.P_PARTKEY
                as virtrdf:part-p_partkey ;
            tpch:name parts.P_NAME
                as virtrdf:part-p_name ;
            tpch:mfgr parts.P_MFGR
                as virtrdf:part-p_mfgr ;
            tpch:brand parts.P_BRAND
                as virtrdf:part-p_brand ;
            tpch:type parts.P_TYPE
                as virtrdf:part-p_type ;
            tpch:size parts.P_SIZE
                as virtrdf:part-p_size ;
            tpch:container parts.P_CONTAINER
                as virtrdf:part-p_container ;
            tpch:comment parts.P_COMMENT
                as virtrdf:part-p_comment .

# Partsupp
        tpch:partsupp (partsupps.PS_PARTKEY, partsupps.PS_SUPPKEY)
            a tpch:partsupp
                as virtrdf:partsupp-partsupps ;
            tpch:has_part tpch:part (parts.P_NAME, partsupps.PS_PARTKEY)
                where (^{parts.}^.P_PARTKEY = ^{partsupps.}^.PS_PARTKEY)
                as virtrdf:partsupp-ps_partkey ;
            tpch:has_supplier tpch:supplier (suppliers.S_NAME, partsupps.PS_SUPPKEY)
                where (^{suppliers.}^.S_SUPPKEY = ^{partsupps.}^.PS_SUPPKEY)
                as virtrdf:partsupp-ps_suppkey ;
            tpch:availqty partsupps.PS_AVAILQTY
                as virtrdf:partsupp-ps_availqty ;
            tpch:supplycost partsupps.PS_SUPPLYCOST
                as virtrdf:partsupp-ps_supplycost ;
            tpch:comment partsupps.PS_COMMENT
                as virtrdf:partsupp-ps_comment .

        tpch:part (parts.P_NAME, partsupps.PS_PARTKEY)
            tpch:part_of tpch:partsupp (partsupps.PS_PARTKEY, partsupps.PS_SUPPKEY)
            where (^{parts.}^.P_PARTKEY = ^{partsupps.}^.PS_PARTKEY)
            as virtrdf:partsupp-part_of .

        tpch:supplier (suppliers.S_NAME, partsupps.PS_SUPPKEY)
            tpch:supplier_of tpch:partsupp (partsupps.PS_PARTKEY, partsupps.PS_SUPPKEY)
            where (^{suppliers.}^.S_SUPPKEY = ^{partsupps.}^.PS_SUPPKEY)
            as virtrdf:partsupp-supplier_of .

# Region
        tpch:region (regions.R_NAME, regions.R_REGIONKEY)
            a tpch:region
                as virtrdf:region-regions ;
            tpch:name regions.R_NAME
                as virtrdf:region-r_name ;
            tpch:comment regions.R_COMMENT
                as virtrdf:region-r_comment .

# Supplier
        tpch:supplier (suppliers.S_NAME, suppliers.S_SUPPKEY)
            a tpch:supplier
                as virtrdf:supplier-suppliers ;
            tpch:name suppliers.S_NAME
                as virtrdf:supplier-s_name ;
            tpch:address suppliers.S_ADDRESS
                as virtrdf:supplier-s_address ;
            tpch:has_nation tpch:nation (nations.N_NAME, suppliers.S_NATIONKEY)
                where (^{nations.}^.N_NATIONKEY = ^{suppliers.}^.S_NATIONKEY)
                as virtrdf:supplier-s_nationkey ;
            foaf:phone suppliers.S_PHONE
                as virtrdf:supplier-foaf_phone ;
            tpch:phone suppliers.S_PHONE
                as virtrdf:supplier-s_phone ;
            tpch:acctbal suppliers.S_ACCTBAL
                as virtrdf:supplier-s_acctbal ;
            tpch:comment suppliers.S_COMMENT
                as virtrdf:supplier-s_comment .

        tpch:nation (nations.N_NAME, suppliers.S_NATIONKEY)
            tpch:nation_of tpch:supplier (suppliers.S_NAME, suppliers.S_SUPPKEY)
            where (^{nations.}^.N_NATIONKEY = ^{suppliers.}^.S_NATIONKEY)
            as virtrdf:supplier-nation_of .
    } .
} .
;

delete from db.dba.url_rewrite_rule_list where urrl_list like 'tpch_rule%';
delete from db.dba.url_rewrite_rule where urr_rule like 'tpch_rule%';

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tpch_rule2',
    1,
    '([^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Fp+%%3Fo+}+FROM+%%3Chttp%%3A//^{URIQADefaultHost}^/tpch%%3E+WHERE+{+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );


DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tpch_rule1',
    1,
    '([^#]*)',
    vector('path'),
    1,
    '/about/html/http://^{URIQADefaultHost}^%s%%23this',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tpch_rule3',
    1,
    '(/[^#]*)/\x24',
    vector('path'),
    1,
    '%s',
    vector('path'),
    null,
    null,
    0,
    null
    );

create procedure DB.DBA.REMOVE_TPCH_RDF_DET()
{
  declare colid int;
  colid := DAV_SEARCH_ID('/DAV/home/demo/tpch', 'C');
  if (colid < 0)
    return;
  update WS.WS.SYS_DAV_COL set COL_DET=null where COL_ID = colid;
}
;

DB.DBA.REMOVE_TPCH_RDF_DET();

drop procedure DB.DBA.REMOVE_TPCH_RDF_DET;

create procedure DB.DBA.TPCH_MAKE_RDF_DET()
{
    declare uriqa_str varchar;
    uriqa_str := cfg_item_value(virtuoso_ini_path(), 'URIQA','DefaultHost');
    uriqa_str := 'http://' || uriqa_str || '/tpch';
    DB.DBA."RDFData_MAKE_DET_COL" ('/DAV/home/demo/tpch/RDFData/', uriqa_str, NULL);
    VHOST_REMOVE (lpath=>'/tpch/data/rdf');
    DB.DBA.VHOST_DEFINE (lpath=>'/tpch/data/rdf', ppath=>'/DAV/home/demo/tpch/RDFData/All/', is_dav=>1, vsp_user=>'dba');
}
;

DB.DBA.TPCH_MAKE_RDF_DET();

drop procedure DB.DBA.TPCH_MAKE_RDF_DET;

create procedure DB.DBA.TPCH_DET_REF (in par varchar, in fmt varchar, in val varchar)
{
  declare res, iri any;
  declare uriqa_str varchar;
  uriqa_str := cfg_item_value(virtuoso_ini_path(), 'URIQA','DefaultHost');
  uriqa_str := 'http://' || uriqa_str || '/tpch';
  iri := uriqa_str || val;
  res := sprintf ('iid (%d).rdf', iri_id_num (iri_to_id (iri)));
  return sprintf (fmt, res);
}
;

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('tpch_rdf', 1,
    '/tpch/(.*)', vector('path'), 1,
    '/tpch/data/rdf/%U', vector('path'),
    'DB.DBA.TPCH_DET_REF',
    'application/rdf.xml',
    2,
    303);

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'tpch_rule_list1',
    1,
    vector (
                'tpch_rule1',
                'tpch_rule2',
                'tpch_rule3',
                'tpch_rdf'
          ));

DB.DBA.VHOST_REMOVE (lpath=>'/tpch');
DB.DBA.VHOST_DEFINE (lpath=>'/tpch', ppath=>'/DAV/home/demo/tpch/', vsp_user=>'dba', is_dav=>1,
          is_brws=>0, opts=>vector ('url_rewrite', 'tpch_rule_list1'));


DB.DBA.VHOST_REMOVE (lpath=>'/tpch/linkeddata');
DB.DBA.VHOST_DEFINE (lpath=>'/tpch/linkeddata', ppath=>'/DAV/home/demo/tpch/', vsp_user=>'dba', is_dav=>1,
          is_brws=>1);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsbusinttpcd">
      <title>TPCD to RDF</title>
<para>Please load ~\binsrc\dav\DET_RDFData.sql before loadding this script (tpc-d has no vad to do this automatic)</para>
<programlisting><![CDATA[
use DB;

create procedure DB.DBA.exec_no_error (in expr varchar) {
  declare state, message, meta, result any;
  exec(expr, state, message, vector(), 0, meta, result);
}
;

DB.DBA.exec_no_error('GRANT \"SPARQL_UPDATE\" TO \"SPARQL\"')
;
GRANT SELECT ON tpcd.DBA.partsupp  TO "SPARQL";
GRANT SELECT ON tpcd.DBA.supplier  TO "SPARQL";
GRANT SELECT ON tpcd.DBA.customer  TO "SPARQL";
GRANT SELECT ON tpcd.DBA.history   TO "SPARQL";
GRANT SELECT ON tpcd.DBA.part      TO "SPARQL";
GRANT SELECT ON tpcd.DBA.lineitem  TO "SPARQL";
GRANT SELECT ON tpcd.DBA.orders    TO "SPARQL";
GRANT SELECT ON tpcd.DBA.nation    TO "SPARQL";
GRANT SELECT ON tpcd.DBA.region    TO "SPARQL";

SPARQL
prefix tpcd: <http://demo.openlinksw.com/schemas/tpcd#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
drop quad map graph iri("http://^{URIQADefaultHost}^/tpcd") .
;

SPARQL
prefix tpcd: <http://demo.openlinksw.com/schemas/tpcd#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
drop quad map virtrdf:TpcdDemo .
;

SPARQL
prefix tpcd: <http://demo.openlinksw.com/schemas/tpcd#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
create iri class tpcd:customer "http://^{URIQADefaultHost}^/tpcd/customer/%d#this" (in c_custkey integer not null) .
create iri class tpcd:lineitem "http://^{URIQADefaultHost}^/tpcd/lineitem/%d/%d#this" (in l_orderkey integer not null, in l_linenumber integer not null) .
create iri class tpcd:nation "http://^{URIQADefaultHost}^/tpcd/nation/%d#this" (in l_nationkey integer not null) .
create iri class tpcd:order "http://^{URIQADefaultHost}^/tpcd/order/%d#this" (in o_orderkey integer not null) .
create iri class tpcd:part "http://^{URIQADefaultHost}^/tpcd/part/%d#this" (in p_partkey integer not null) .
create iri class tpcd:partsupp "http://^{URIQADefaultHost}^/tpcd/partsupp/%d/%d#this" (in ps_partkey integer not null, in ps_suppkey integer not null) .
create iri class tpcd:region "http://^{URIQADefaultHost}^/tpcd/region/%d#this" (in r_regionkey integer not null) .
create iri class tpcd:supplier "http://^{URIQADefaultHost}^/tpcd/supplier/%d#this" (in s_supplierkey integer not null) .
;

SPARQL
prefix tpcd: <http://demo.openlinksw.com/schemas/tpcd#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
alter quad storage virtrdf:DefaultQuadStorage
from tpcd.DBA.lineitem as lineitems
from tpcd.DBA.customer as customers
from tpcd.DBA.nation as nations
from tpcd.DBA.orders as orders
from tpcd.DBA.part as parts
from tpcd.DBA.partsupp as partsupps
from tpcd.DBA.region as regions
from tpcd.DBA.supplier as suppliers
where (^{suppliers.}^.s_nationkey = ^{nations.}^.n_nationkey)
where (^{customers.}^.c_nationkey = ^{nations.}^.n_nationkey)
{
    create virtrdf:TpcdDemo as graph iri ("http://^{URIQADefaultHost}^/tpcd") option (exclusive)
    {
        tpcd:customer (customers.c_custkey)
            a  tpcd:customer
                as virtrdf:tpcdcustomer-c_custkey2 ;
            a  foaf:Organization
                as virtrdf:tpcdcustomer-c_custkey ;
            foaf:name customers.c_name
                as virtrdf:tpcdcustomer-foaf_name ;
            tpcd:companyName customers.c_name
                as virtrdf:tpcdcustomer-c_name ;
            tpcd:has_nation tpcd:nation (customers.c_nationkey)
                as virtrdf:tpcdcustomer-c_nationkey ;
            tpcd:address customers.c_address
                as virtrdf:tpcdcustomer-c_address ;
            foaf:phone customers.c_phone
                as virtrdf:tpcdcustomer-foaf_phone ;
            tpcd:phone customers.c_phone
                as virtrdf:tpcdcustomer-phone ;
            tpcd:mktsegment customers.c_mktsegment
                as virtrdf:tpcdcustomer-c_mktsegment ;
            tpcd:comment customers.c_comment
                as virtrdf:tpcdcustomer-c_comment .

        tpcd:nation (customers.c_nationkey)
            tpcd:nation_of tpcd:customer (customers.c_custkey) as virtrdf:tpcdcustomer-nation_of .

        tpcd:lineitem (lineitems.l_orderkey, lineitems.l_linenumber)
            a tpcd:lineitem
                as virtrdf:tpcdlineitem-lineitems ;
            tpcd:has_order tpcd:order (lineitems.l_orderkey)
                as virtrdf:tpcdlineitem-l_orderkey ;
            tpcd:has_part tpcd:part (lineitems.l_partkey)
                as virtrdf:tpcdlineitem-l_partkey ;
            tpcd:has_supplier tpcd:supplier (lineitems.l_suppkey)
                as virtrdf:tpcdlineitem-l_suppkey ;
            tpcd:linenumber lineitems.l_linenumber
                as virtrdf:tpcdlineitem-l_linenumber ;
            tpcd:returnflag lineitems.l_returnflag
                as virtrdf:tpcdlineitem-l_returnflag ;
            tpcd:linestatus lineitems.l_linestatus
                as virtrdf:tpcdlineitem-l_linestatus ;
            tpcd:shipdate lineitems.l_shipdate
                as virtrdf:tpcdlineitem-l_shipdate ;
            tpcd:commitdate lineitems.l_commitdate
                as virtrdf:tpcdlineitem-l_commitdate ;
            tpcd:receiptdate lineitems.l_receiptdate
                as virtrdf:tpcdlineitem-l_receiptdate ;
            tpcd:shipinstruct lineitems.l_shipinstruct
                as virtrdf:tpcdlineitem-l_shipinstruct ;
            tpcd:shipmode lineitems.l_shipmode
                as virtrdf:tpcdlineitem-l_shipmode ;
            tpcd:comment lineitems.l_comment
                as virtrdf:tpcdlineitem-l_comment .

        tpcd:part (lineitems.l_partkey)
            tpcd:part_of tpcd:lineitem (lineitems.l_orderkey, lineitems.l_linenumber) as virtrdf:tpcdlineitem-part_of .

        tpcd:order (lineitems.l_orderkey)
            tpcd:order_of tpcd:lineitem (lineitems.l_orderkey, lineitems.l_linenumber) as virtrdf:tpcdlineitem-order_of .

        tpcd:supplier (lineitems.l_suppkey)
            tpcd:supplier_of tpcd:lineitem (lineitems.l_orderkey, lineitems.l_linenumber) as virtrdf:tpcdlineitem-supplier_of .

        tpcd:nation (nations.n_nationkey)
            a tpcd:nation
                as virtrdf:tpcdnation-nations ;
            tpcd:name nations.n_name
                as virtrdf:tpcdnation-n_name ;
            tpcd:has_region tpcd:region (nations.n_regionkey)
                as virtrdf:tpcdnation-n_regionkey ;
            tpcd:comment nations.n_comment
                as virtrdf:tpcdnation-n_comment .

        tpcd:region (nations.n_regionkey)
            tpcd:region_of tpcd:nation (nations.n_nationkey) as virtrdf:tpcdnation-region_of .

        tpcd:order (orders.o_orderkey)
            a tpcd:order
                as virtrdf:tpcdorder-orders ;
            tpcd:has_customer tpcd:customer (orders.o_custkey)
                as virtrdf:tpcdorder-o_custkey ;
            tpcd:orderstatus orders.o_orderstatus
                as virtrdf:tpcdorder-o_orderstatus ;
            tpcd:orderdate orders.o_orderdate
                as virtrdf:tpcdorder-o_orderdate ;
            tpcd:orderpriority orders.o_orderpriority
                as virtrdf:tpcdorder-o_orderpriority ;
            tpcd:clerk orders.o_clerk
                as virtrdf:tpcdorder-o_clerk ;
            tpcd:shippriority orders.o_shippriority
                as virtrdf:tpcdorder-o_shippriority ;
            tpcd:comment orders.o_comment
                as virtrdf:tpcdorder-o_comment .

        tpcd:customer (orders.o_custkey)
            tpcd:customer_of tpcd:order (orders.o_orderkey) as virtrdf:tpcdorder-customer_of .

        tpcd:part (parts.p_partkey)
            a tpcd:part
                as virtrdf:tpcdpart-parts ;
            tpcd:name parts.p_name
                as virtrdf:tpcdpart-p_name ;
            tpcd:mfgr parts.p_mfgr
                as virtrdf:tpcdpart-p_mfgr ;
            tpcd:brand parts.p_brand
                as virtrdf:tpcdpart-p_brand ;
            tpcd:type parts.p_type
                as virtrdf:tpcdpart-p_type ;
            tpcd:size parts.p_size
                as virtrdf:tpcdpart-p_size ;
            tpcd:container parts.p_container
                as virtrdf:tpcdpart-p_container ;
            tpcd:comment parts.p_comment
                as virtrdf:tpcdpart-p_comment .

        tpcd:partsupp (partsupps.ps_partkey, partsupps.ps_suppkey)
            a tpcd:partsupp
                as virtrdf:tpcdpartsupp-partsupps ;
            tpcd:has_part tpcd:part (partsupps.ps_partkey)
                as virtrdf:tpcdpartsupp-ps_partkey ;
            tpcd:has_supplier tpcd:supplier (partsupps.ps_suppkey)
                as virtrdf:tpcdpartsupp-ps_suppkey ;
            tpcd:availqty partsupps.ps_availqty
                as virtrdf:tpcdpartsupp-ps_availqty ;
            tpcd:comment partsupps.ps_comment
                as virtrdf:tpcdpartsupp-ps_comment .

        tpcd:part (partsupps.ps_partkey)
            tpcd:part_of tpcd:partsupp (partsupps.ps_partkey, partsupps.ps_suppkey) as virtrdf:tpcdpartsupp-part_of .

        tpcd:supplier (partsupps.ps_suppkey)
            tpcd:supplier_of tpcd:partsupp (partsupps.ps_partkey, partsupps.ps_suppkey) as virtrdf:tpcdpartsupp-supplier_of .

        tpcd:region (regions.r_regionkey)
            a tpcd:region
                as virtrdf:tpcdregion-regions ;
            tpcd:name regions.r_name
                as virtrdf:tpcdregion-r_name ;
            tpcd:comment regions.r_comment
                as virtrdf:tpcdregion-r_comment .

        tpcd:supplier (suppliers.s_suppkey)
            a tpcd:supplier
                as virtrdf:tpcdsupplier-suppliers ;
            tpcd:name suppliers.s_name
                as virtrdf:tpcdsupplier-s_name ;
            tpcd:address suppliers.s_address
                as virtrdf:tpcdsupplier-s_address ;
            tpcd:has_nation tpcd:nation (suppliers.s_nationkey)
                as virtrdf:tpcdsupplier-s_nationkey ;
            foaf:phone customers.c_phone
                as virtrdf:tpcdsupplier-foaf_phone ;
            tpcd:phone suppliers.s_phone
                as virtrdf:tpcdsupplier-s_phone ;
            tpcd:comment suppliers.s_comment
                as virtrdf:tpcdsupplier-s_comment .

        tpcd:nation (suppliers.s_nationkey)
            tpcd:nation_of tpcd:supplier (suppliers.s_suppkey) as virtrdf:tpcdsupplier-nation_of .
    } .
} .
;

create procedure tcpd_rdf_doc (in path varchar)
{
  declare r any;
  r := regexp_match ('[^/]*\x24', path);
  return r||'#this';
};

create procedure tcpd_html_doc (in path varchar)
{
  declare r any;
  r := regexp_match ('[^/]*#', path);
  return subseq (r, 0, length (r)-1);
};

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tcpd_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Fp+%%3Fo+}+FROM+%%3Chttp%%3A//^{URIQADefaultHost}^/tpcd%%3E+WHERE+{+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tcpd_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/rdfbrowser/index.html?uri=http%%3A//^{URIQADefaultHost}^%U%%23this',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tcpd_rule3',
    1,
    '(/[^#]*)/\x24',
    vector('path'),
    1,
    '%s',
    vector('path'),
    null,
    null,
    0,
    null
    );

DB.DBA."RDFData_MAKE_DET_COL" ('/DAV/home/tpcd/RDFData/', 'http://^{URIQADefaultHost}^/tpcd', NULL);
VHOST_REMOVE (lpath=>'/tpcd/data/rdf');
DB.DBA.VHOST_DEFINE (lpath=>'/tpcd/data/rdf', ppath=>'/DAV/home/tpcd/RDFData/All/', is_dav=>1, vsp_user=>'dba');

-- procedure to convert path to DET resource name
create procedure DB.DBA.TPCD_DET_REF (in par varchar, in fmt varchar, in val varchar)
{
  declare res, iri any;
  iri := 'http://^{URIQADefaultHost}^/tpcd' || val;
  res := sprintf ('iid (%d).rdf', iri_id_num (iri_to_id (iri)));
  return sprintf (fmt, res);
}
;

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('tpcd_rdf', 1,
    '/tpcd/(.*)', vector('path'), 1,
    '/tpcd/data/rdf/%U', vector('path'),
    'DB.DBA.TPCD_DET_REF',
    'application/rdf.xml',
    2,
    303);

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'tpcd_rule_list1',
    1,
    vector (
                'tcpd_rule1',
                'tcpd_rule2',
                'tcpd_rule3',
                'tpcd_rdf'
          ));


VHOST_REMOVE (lpath=>'/tpcd');
DB.DBA.VHOST_DEFINE (lpath=>'/tpcd', ppath=>'/DAV/home/', vsp_user=>'dba', is_dav=>1, def_page=>'sfront.vspx',
    is_brws=>0, opts=>vector ('url_rewrite', 'tpcd_rule_list1'));

DB.DBA.XML_SET_NS_DECL ('tpcd', 'http://demo.openlinksw.com/schemas/tpcd#', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsbusintthalia">
      <title>Thalia to RDF</title>
<programlisting><![CDATA[
use DB;

create procedure DB.DBA.SPARQL_THALIA_RUN (in txt varchar)
{
  declare REPORT, stat, msg, sqltext varchar;
  declare metas, rowset any;
  result_names (REPORT);
  sqltext := string_output_string (sparql_to_sql_text (txt));
  stat := '00000';
  msg := '';
  rowset := null;
  exec (sqltext, stat, msg, vector (), 1000, metas, rowset);
  --result ('STATE=' || stat || ': ' || msg);
  --if (rowset is not null)
  --  {
  --    foreach (any r in rowset) do
  --      result (r[0] || ': ' || r[1]);
  --  }
}
;

use thalia;

DB.DBA.exec_no_error('drop View thalia.Demo.asu_v');
create View thalia.Demo.asu_v as select left(Title,3) code,* from thalia.Demo.asu;
DB.DBA.exec_no_error('drop View thalia.Demo.gatech_v');
create View thalia.Demo.gatech_v as select *, Room||' '||Building Place from thalia.Demo.gatech;

use DB;

DB.DBA.exec_no_error('GRANT \"SPARQL_UPDATE\" TO \"SPARQL\"');
GRANT SELECT ON thalia.Demo.asu TO "SPARQL";
GRANT SELECT ON thalia.Demo.asu_v TO "SPARQL";
GRANT SELECT ON thalia.Demo.brown TO "SPARQL";
GRANT SELECT ON thalia.Demo.cmu TO "SPARQL";
GRANT SELECT ON thalia.Demo.gatech TO "SPARQL";
GRANT SELECT ON thalia.Demo.gatech_v TO "SPARQL";
GRANT SELECT ON thalia.Demo.toronto TO "SPARQL";
GRANT SELECT ON thalia.Demo.ucsd TO "SPARQL";
GRANT SELECT ON thalia.Demo.umd TO "SPARQL";


DB.DBA.SPARQL_THALIA_RUN('drop quad map graph iri("http://^{URIQADefaultHost}^/Thalia") .
')
;

DB.DBA.SPARQL_THALIA_RUN('drop quad map graph iri("http://^{URIQADefaultHost}^/thalia") .
');

DB.DBA.SPARQL_THALIA_RUN('drop quad map virtrdf:ThaliaDemo .
');


DB.DBA.SPARQL_THALIA_RUN('
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix xsd: <http://www.w3.org/2001/XMLSchema#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix dc: <http://purl.org/dc/elements/1.1/>
prefix time: <http://www.w3.org/2006/time#>
prefix event: <http://purl.org/NET/c4dm/event.owl#>
prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix skos: <http://www.w3.org/2004/02/skos/core#>
prefix th: <http://purl.org/ontology/thalia/1.0/>

create iri class th:Asu "http://^{URIQADefaultHost}^/thalia/asu/course/%U#this" (in code varchar not null) .
create iri class th:Brown "http://^{URIQADefaultHost}^/thalia/brown/course/%U#this" (in Code varchar not null) .
create iri class th:BrownInstructor "http://^{URIQADefaultHost}^/thalia/brown/instructor/%U#this" (in Code varchar not null) .
create iri class th:BrownLecture "http://^{URIQADefaultHost}^/thalia/brown/lecture/%U#this" (in Code varchar not null) .
create iri class th:BrownPlace "http://^{URIQADefaultHost}^/thalia/brown/place/%U#this" (in Code varchar not null) .

create iri class th:Cmu "http://^{URIQADefaultHost}^/thalia/cmu/course/%U/%U#this" (in Code varchar not null, in Sec varchar) .
create iri class th:CmuInstructor "http://^{URIQADefaultHost}^/thalia/cmu/instructor/%U/%U#this" (in Code varchar not null, in Sec varchar) .
create iri class th:CmuLecture "http://^{URIQADefaultHost}^/thalia/cmu/lecture/%U/%U#this" (in Code varchar not null, in Sec varchar) .
create iri class th:CmuPlace "http://^{URIQADefaultHost}^/thalia/cmu/place/%U/%U#this" (in Code varchar not null, in Sec varchar) .
create iri class th:CmuEventTime "http://^{URIQADefaultHost}^/thalia/cmu/eventtime/%U/%U#this" (in Code varchar not null, in Sec varchar) .
create iri class th:CmuDatetime "http://^{URIQADefaultHost}^/thalia/cmu/datetime/%U/%U#this" (in Code varchar not null, in Sec varchar) .

create iri class th:Gatech "http://^{URIQADefaultHost}^/thalia/gatech/course/%U/%d/%U#this" (in Department varchar, in Code integer, in Section varchar) .
create iri class th:GatechInstructor "http://^{URIQADefaultHost}^/thalia/gatech/instructor/%U/%d/%U#this" (in Department varchar, in Code integer, in Section varchar) .
create iri class th:GatechLecture "http://^{URIQADefaultHost}^/thalia/gatech/lecture/%U/%d/%U#this" (in Department varchar, in Code integer, in Section varchar) .
create iri class th:GatechEventTime "http://^{URIQADefaultHost}^/thalia/gatech/eventtime/%U/%d/%U#this" (in Department varchar, in Code integer, in Section varchar) .
create iri class th:GatechDatetime "http://^{URIQADefaultHost}^/thalia/gatech/datetime/%U/%d/%U#this" (in Department varchar, in Code integer, in Section varchar) .
create iri class th:GatechPlace "http://^{URIQADefaultHost}^/thalia/gatech/place/%U/%d/%U#this" (in Department varchar, in Code integer, in Section varchar) .

create iri class th:Toronto "http://^{URIQADefaultHost}^/thalia/toronto/course/%U#this" (in No_ varchar) .
create iri class th:TorontoInstructor "http://^{URIQADefaultHost}^/thalia/toronto/instructor/%U#this" (in No_ varchar) .
create iri class th:TorontoLecture "http://^{URIQADefaultHost}^/thalia/toronto/lecture/%U#this" (in No_ varchar) .
create iri class th:TorontoPlace "http://^{URIQADefaultHost}^/thalia/toronto/place/%U#this" (in No_ varchar) .

create iri class th:Ucsd "http://^{URIQADefaultHost}^/thalia/ucsd/course/%U#this" (in Number varchar) .
create iri class th:UcsdInstructor1 "http://^{URIQADefaultHost}^/thalia/ucsd/instructor1/%U#this" (in Number varchar) .
create iri class th:UcsdInstructor2 "http://^{URIQADefaultHost}^/thalia/ucsd/instructor2/%U#this" (in Number varchar) .
create iri class th:UcsdInstructor3 "http://^{URIQADefaultHost}^/thalia/ucsd/instructor3/%U#this" (in Number varchar) .

create iri class th:Umd "http://^{URIQADefaultHost}^/thalia/umd/course/%U#this" (in Code varchar) .
create iri class th:UmdLecture "http://^{URIQADefaultHost}^/thalia/umd/lecture/%U#this" (in Code varchar) .
create iri class th:UmdEventTime "http://^{URIQADefaultHost}^/thalia/umd/eventtime/%U#this" (in Code varchar) .
create iri class th:UmdDatetime "http://^{URIQADefaultHost}^/thalia/umd/datetime/%U#this" (in Code varchar) .
')
;


DB.DBA.RDF_AUDIT_METADATA (1, '*');

DB.DBA.SPARQL_THALIA_RUN('prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix xsd: <http://www.w3.org/2001/XMLSchema#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix dc: <http://purl.org/dc/elements/1.1/>
prefix time: <http://www.w3.org/2006/time#>
prefix event: <http://purl.org/NET/c4dm/event.owl#>
prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix skos: <http://www.w3.org/2004/02/skos/core#>
prefix th: <http://purl.org/ontology/thalia/1.0/>
alter quad storage virtrdf:DefaultQuadStorage
from thalia.demo.asu_v as asus
from thalia.demo.brown as browns
from thalia.demo.cmu as cmus
from thalia.demo.gatech_v as gatechs
from thalia.demo.toronto as torontos
from thalia.demo.ucsd as ucsds
from thalia.demo.umd as umds
{
        create virtrdf:ThaliaDemo as graph iri ("http://^{URIQADefaultHost}^/thalia") option (exclusive)
        {
                th:Asu (asus.code)
                	a th:Course
                		as virtrdf:Asu-Course ;
                	dc:title asus.Title
                		as virtrdf:Asu-Title ;
                	dc:description asus.Description
                		as virtrdf:Asu-Description ;
                	rdfs:seeAlso asus.MoreInfoURL
                		as virtrdf:Asu-MoreInfoURL ;
                        th:forUniversity "http://purl.org/thalia/university/asu"
                        	as virtrdf:Asu-University ;
                        skos:subject "http://purl.org/subject/thalia/ComputerScience"
                        	as virtrdf:Asu-Subject
                        	.

                th:Brown (browns.Code)
                        a th:Course
                                as virtrdf:Brown-Course ;
                        dc:title browns.Title
                        	as virtrdf:Brown-Title ;
                        th:hasInstructor th:BrownInstructor (browns.Code)
                        	as virtrdf:Brown-hasInstructor ;
                        th:hasLecture th:BrownLecture(browns.Code)
                        	as virtrdf:Brown-hasLecture ;
                        th:forUniversity "http://purl.org/thalia/university/brown"
                        	as virtrdf:Brown-University ;
                        skos:subject "http://purl.org/subject/thalia/ComputerScience"
                        	as virtrdf:Brown-Subject
                        	.
                th:BrownInstructor (browns.Code)
                        a th:Instructor
                                as virtrdf:Brown-Instructor ;
                        dc:homepage browns.Instructor
                        	as virtrdf:Brown-Instructor-Homepage
                        	.
                th:BrownLecture (browns.Code)
                        a event:Event
                                as virtrdf:Brown-Lecture ;
                        event:place th:BrownPlace(browns.Code)
                        	as virtrdf:Brown-hasPlace
                        	.
                th:BrownPlace (browns.Code)
                        a geo:Point
                                as virtrdf:Brown-Place;
                        dc:title browns.Room
                        	as virtrdf:Brown-Room
                        	.

                th:Cmu (cmus.Code, cmus.Sec)
                	a th:Course
                		as virtrdf:Cmu-Course ;
                	dc:title cmus.CourseTitle
                		as virtrdf:Cmu-CourseTitle ;
                        th:hasInstructor th:CmuInstructor (cmus.Code, cmus.Sec)
                        	as virtrdf:Cmu-hasInstructor ;
                        th:hasLecture th:CmuLecture(cmus.Code, cmus.Sec)
                        	as virtrdf:Cmu-hasLecture ;
                        th:hasUnits cmus.Units
                        	as virtrdf:Cmu-hasUnits ;
                        th:forUniversity "http://purl.org/thalia/university/cmu"
                        	as virtrdf:Cmu-University ;
                        skos:subject "http://purl.org/subject/thalia/ComputerScience"
                        	as virtrdf:Cmu-Subject
                		.
		th:CmuInstructor (cmus.Code, cmus.Sec)
                        a th:Instructor
                                as virtrdf:Cmu-Instructor ;
                	foaf:name cmus.Lecturer
                		as virtrdf:Cmu-Lecturer
                        	.
		th:CmuLecture (cmus.Code, cmus.Sec)
                        a event:Event
                                as virtrdf:Cmu-Lecture ;
                        event:time th:CmuEventTime(cmus.Code, cmus.Sec)
                        	as virtrdf:Cmu-hasEventTime ;
                        event:place th:CmuPlace(cmus.Code, cmus.Sec)
                        	as virtrdf:Cmu-hasPlace
                        	.
		th:CmuPlace (cmus.Code, cmus.Sec)
                        a geo:Point
                                as virtrdf:Cmu-Place;
                        dc:title cmus.Room
                        	as virtrdf:Cmu-Room
                        	.
		th:CmuEventTime (cmus.Code, cmus.Sec)
                        a time:Interval
                                as virtrdf:Cmu-EventTime;
                        time:inDateTime th:CmuDatetime(cmus.Code, cmus.Sec)
                        	as virtrdf:Cmu-inDateTime
                        	.
		th:CmuDatetime (cmus.Code, cmus.Sec)
                        a time:DateTimeDescription
                                as virtrdf:Cmu-Datetime;
                	time:dayOfWeek cmus.Day_
                		as virtrdf:Cmu-Day ;
                	time:hour cmus.Time_
                		as virtrdf:Cmu-Time
                        	.

                th:Gatech (gatechs.Department, gatechs.Code, gatechs.Section)
                	a th:Course
                		as virtrdf:Gatech-Course ;
                	dc:title gatechs.Title
                		as virtrdf:Gatech-Title ;
                        th:hasInstructor th:GatechInstructor(gatechs.Department, gatechs.Code, gatechs.Section)
                        	as virtrdf:Gatech-hasInstructor ;
                	dc:description gatechs.Description
                		as virtrdf:Gatech-Description ;
                        th:hasLecture th:GatechLecture(gatechs.Department, gatechs.Code, gatechs.Section)
                        	as virtrdf:Gatech-hasLecture ;
                        th:forUniversity "http://purl.org/thalia/university/gatech"
                        	as virtrdf:Gatech-University ;
                        skos:subject "http://purl.org/subject/thalia/ComputerScience"
                        	as virtrdf:Gatech-Subject
                        	.
		th:GatechInstructor (gatechs.Department, gatechs.Code, gatechs.Section)
                        a th:Instructor
                                as virtrdf:Gatech-Instructor ;
                	foaf:name gatechs.Instructor
                		as virtrdf:Gatech-InstructorName
				.
		th:GatechLecture (gatechs.Department, gatechs.Code, gatechs.Section)
                        a event:Event
                                as virtrdf:Gatech-Lecture ;
                        event:time th:GatechEventTime(gatechs.Department, gatechs.Code, gatechs.Section)
                        	as virtrdf:Gatech-hasEventTime ;
                        event:place th:GatechPlace(gatechs.Department, gatechs.Code, gatechs.Section)
                        	as virtrdf:Gatech-hasPlace
				.
		th:GatechEventTime (gatechs.Department, gatechs.Code, gatechs.Section)
                        a time:Interval
                                as virtrdf:Gatech-EventTime ;
                        time:inDateTime th:GatechDatetime(gatechs.Department, gatechs.Code, gatechs.Section)
                        	as virtrdf:Gatech-inDateTime
				.
		th:GatechDatetime (gatechs.Department, gatechs.Code, gatechs.Section)
                        a time:DateTimeDescription
                                as virtrdf:Gatech-Datetime ;
                	time:dayOfWeek gatechs.Days
                		as virtrdf:Gatech-Days ;
                	time:hour gatechs.Time_
                		as virtrdf:Gatech-Time_
				.
		th:GatechPlace (gatechs.Department, gatechs.Code, gatechs.Section)
                        a geo:Point
                                as virtrdf:Gatech-Place ;
                        dc:title gatechs.Place
                        	as virtrdf:Gatech-RoomBuilding
				.

                th:Toronto (torontos.No_)
                        a th:Course
                                as virtrdf:Toronto-Course ;
                        dc:title torontos.title
                        	as virtrdf:Toronto-Title ;
                        dc:description torontos.text_
                        	as virtrdf:Toronto-Description ;
                        th:hasInstructor th:TorontoInstructor(torontos.No_)
                        	as virtrdf:Toronto-hasInstructor ;
                        th:hasLecture th:TorontoLecture(torontos.No_)
                        	as virtrdf:Toronto-hasLecture ;
                        rdfs:seeAlso torontos.coursewebsite
                        	as virtrdf:Toronto-CourseWebSite ;
                        th:hasPrerequisite torontos.prereq
                        	as virtrdf:Toronto-prereq ;
                        th:text torontos.text_
                        	as virtrdf:Toronto-text;
                        th:forUniversity "http://purl.org/thalia/university/toronto"
                        	as virtrdf:Toronto-University ;
                        skos:subject "http://purl.org/subject/thalia/ComputerScience"
                        	as virtrdf:Toronto-Subject
                        	.
		th:TorontoInstructor (torontos.No_)
                        a th:Instructor
                                as virtrdf:Toronto-Instructor ;
                        foaf:name torontos.instructorName
                        	as virtrdf:Toronto-InstructorName ;
                        foaf:mbox torontos.instructorEmail
                        	as virtrdf:Toronto-InstructorEmail
				.
		th:TorontoLecture (torontos.No_)
                        a event:Event
                                as virtrdf:Toronto-Lecture ;
                        event:place th:TorontoPlace(torontos.No_)
                        	as virtrdf:Toronto-hasPlace
				.
		th:TorontoPlace (torontos.No_)
                        a geo:Point
                                as virtrdf:Toronto-Place ;
                        dc:title torontos.location
                        	as virtrdf:Toronto-Location
				.

                th:Ucsd (ucsds.Number)
                        a th:Course
                                as virtrdf:Ucsd-Course ;
                        dc:title ucsds.Title
                        	as virtrdf:Ucsd-Title ;
                        th:hasInstructor1 th:UcsdInstructor1 (ucsds.Number)
                        	as virtrdf:Ucsd-hasInstructor1 ;
                        th:hasInstructor2 th:UcsdInstructor2 (ucsds.Number)
                        	as virtrdf:Ucsd-hasInstructor2 ;
                        th:hasInstructor3 th:UcsdInstructor3 (ucsds.Number)
                        	as virtrdf:Ucsd-hasInstructor3 ;
                        th:forUniversity "http://purl.org/thalia/university/ucsd"
                        	as virtrdf:Ucsd-University ;
                        skos:subject "http://purl.org/subject/thalia/ComputerScience"
                        	as virtrdf:Ucsd-Subject
                        	.
                th:UcsdInstructor1 (ucsds.Number)
                        a th:Instructor
                                as virtrdf:Ucsd-Instructor1 ;
                        foaf:name ucsds.Fall2003
                        	as virtrdf:Ucsd-Instructor-Fall2003
                        	.
                th:UcsdInstructor2 (ucsds.Number)
                        a th:Instructor
                                as virtrdf:Ucsd-Instructor2 ;
                        foaf:name ucsds.Winter2004
                        	as virtrdf:Ucsd-Instructor-Winter2004
                        	.
                th:UcsdInstructor3 (ucsds.Number)
                        a th:Instructor
                                as virtrdf:Ucsd-Instructor3 ;
                        foaf:name ucsds.Spring2004
                        	as virtrdf:Ucsd-Instructor-Spring2004
                        	.

                th:Umd (umds.Code)
                	a th:Course
                		as virtrdf:Umd-Course ;
                	dc:title umds.CourseName
                		as virtrdf:Umd-Title ;
                        th:hasSection th:SectionTitle
                        	as virtrdf:Umd-hasSection ;
                        th:hasLecture th:UmdLecture(umds.Code)
                        	as virtrdf:Umd-hasLecture ;
                        th:forUniversity "http://purl.org/thalia/university/umd"
                        	as virtrdf:Umd-University ;
                        skos:subject "http://purl.org/subject/thalia/ComputerScience"
                        	as virtrdf:Umd-Subject
                        	.
		th:UmdLecture (umds.Code)
                        a event:Event
                                as virtrdf:Umd-Lecture ;
                        event:time th:UmdEventTime(umds.Code)
                        	as virtrdf:Umd-hasEventTime
				.
		th:UmdEventTime (umds.Code)
                        a time:Interval
                                as virtrdf:Umd-EventTime ;
                        time:inDateTime th:UmdDatetime(umds.Code)
                        	as virtrdf:Umd-inDateTime
				.
		th:UmdDatetime (umds.Code)
                        a time:DateTimeDescription
                                as virtrdf:Umd-Datetime ;
                	time:hour umds.SectionTime
                		as virtrdf:Umd-SectionTime
				.
        }
}
')
;

DB.DBA.RDF_AUDIT_METADATA (1, '*');


create procedure tut_th_rdf_doc (in path varchar)
{
  declare r any;
  r := regexp_match ('[^/]*\x24', path);
  return r||'#this';
};

create procedure tut_th_html_doc (in path varchar)
{
  declare r any;
  r := regexp_match ('[^/]*#', path);
  return subseq (r, 0, length (r)-1);
};

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tut_th_rule2',
    1,
    '(/[^#]*)\x24',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Fp+%%3Fo+}+FROM+%%3Chttp%%3A//^{URIQADefaultHost}^/Thalia%%3E+WHERE+{+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'tut_th_rule1',
    1,
    '(/[^#]*)\x24',
    vector('path'),
    1,
    '/isparql/execute.html?query=SELECT%%20%%3Fp%%20%%3Fo%%20FROM%%20%%3Chttp%%3A//^{URIQADefaultHost}^/Thalia%%3E%%20WHERE%%20{%%20%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E%%20%%3Fp%%20%%3Fo%%20}&endpoint=/sparql',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_RULELIST (
    'tut_th_rule_list1',
    1,
    vector (
                'tut_th_rule1',
                'tut_th_rule2'
          ));


DB.DBA.VHOST_REMOVE (lpath=>'/thalia');
DB.DBA.VHOST_DEFINE (lpath=>'/thalia', ppath=>'/DAV/Thalia/', is_dav=>1, vsp_user=>'dba', is_brws=>0, opts=>vector ('url_rewrite', 'tut_th_rule_list1'));

DB.DBA.XML_SET_NS_DECL ('th', 'http://purl.org/ontology/thalia/1.0/', 2);


    * Demo : Thalia test queries


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT distinct ?room
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
              dc:title ?title;
	      th:hasLecture ?lecture.
    ?lecture event:place [dc:title ?room].
    FILTER regex(?title, "Software Engineering")
}


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT ?day, ?hour ?course
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
    th:hasLecture [event:time ?time];
    dc:title ?title.
    ?time time:inDateTime [time:dayOfWeek ?day];
    time:inDateTime [time:hour ?hour].
    FILTER regex(?title, "Computer Networks")
  }



#service:/sparql
#should-sponge:soft

PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT distinct ?course
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
              dc:title ?Title;
              th:hasLecture ?lecture.
    ?lecture event:time [time:inDateTime ?dateTime].
    ?dateTime time:hour ?hour.
    FILTER regex(?Title, "Database System")
    FILTER regex(?hour, "1:30 - 2:50")
  }


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT distinct ?course ?instructor ?name
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
              th:hasInstructor ?instructor.
    ?instructor foaf:name ?name.

  }


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT distinct ?instructor
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
	      th:hasInstructor ?instructor;
	      dc:title  ?title.
    FILTER regex(?title, "Database")
  }


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT distinct ?instructor
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
              dc:title ?title;
              th:hasInstructor ?instructor.
    FILTER regex(?title, "Software")
  }


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT DISTINCT ?course
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
              dc:title ?title;
              th:forUniversity 'http://purl.org/thalia/university/umd'.
    FILTER regex(?title, "Data Structures")
  }


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT distinct ?course
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
              dc:title ?Title;
              th:hasUnits ?credits.
    FILTER (xsd:integer(?credits) > 10)
    FILTER regex(?Title, "Database")
  }


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT distinct ?course
FORM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
              dc:title ?title;
              th:forUniversity 'http://purl.org/thalia/university/umd'.
    FILTER regex(?title, "Database")
  }


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT distinct ?course
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
              dc:title ?Title;
              th:hasUnits ?credits.
    FILTER (xsd:integer(?credits) > 10)
    FILTER regex(?Title, "Database")
  }


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX th: <http://purl.org/ontology/thalia/1.0/>

SELECT distinct ?text_
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
             dc:title ?title;
             th:text ?text_.
    FILTER regex(?title, "Verification")
  }


#service:/sparql
#should-sponge:soft
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
PREFIX time: <http://www.w3.org/2006/time#>
PREFIX event: <http://purl.org/NET/c4dm/event.owl#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX : <http://purl.org/ontology/thalia/1.0/>

SELECT distinct ?course
FROM <http://demo.openlinksw.com/thalia>
WHERE
  {
    ?course a th:Course;
              dc:description ?description;
              th:forUniversity 'http://purl.org/thalia/university/gatech'.
    FILTER regex(?description, "JR")
  }
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsbusintmbr">
      <title>Musicbrainz to RDF</title>
<para>The following code creates the Musicbrainz RDF Views Deployment and Demo Scripts:</para>
<programlisting><![CDATA[
create text index on ZITGIST.MO.artist ("name") with key id;
create text index on ZITGIST.MO.artistalias ("name") with key id;
create text index on ZITGIST.MO.album ("name") with key id;
create text index on ZITGIST.MO.track ("name") with key id;
vt_batch_update (fix_identifier_case ('ZITGIST.MO.artist'), 'ON', NULL);
vt_batch_update (fix_identifier_case ('ZITGIST.MO.artistalias'), 'ON', NULL);
vt_batch_update (fix_identifier_case ('ZITGIST.MO.album'), 'ON', NULL);
vt_batch_update (fix_identifier_case ('ZITGIST.MO.track'), 'ON', NULL);
VT_INC_INDEX_DB_MO_artist ();
VT_INC_INDEX_DB_MO_artistalias ();
VT_INC_INDEX_DB_MO_album ();
VT_INC_INDEX_DB_MO_track ();
]]></programlisting>
<para>Note: Making sure that the graphs and views are deleting to clean Virtuoso from the old definitions</para>
<programlisting><![CDATA[
sparql
drop quad storage virtrdf:MBZROOT.
;

sparql
prefix mbz: <http://musibrainz.org/schemas/mbz#>
drop literal class mbz:duration
;

sparql
prefix mbz: <http://musibrainz.org/schemas/mbz#>
drop literal class mbz:created.
drop literal class mbz:official_iri.
drop literal class mbz:bootleg_iri.
drop literal class mbz:promotion_iri.
drop literal class mbz:album_iri.
drop literal class mbz:single_iri.
drop literal class mbz:ep_iri.
drop literal class mbz:compilation_iri.
drop literal class mbz:soundtrack_iri.
drop literal class mbz:spokenword_iri.
drop literal class mbz:interview_iri.
drop literal class mbz:audiobook_iri.
drop literal class mbz:live_iri.
drop literal class mbz:remix_iri.
;
]]></programlisting>
<para>The following SPARQL query will fix an issue Virtuoso has with its JSO system. Perform this query for now, the issue should be fixed in a future release</para>
<programlisting><![CDATA[
sparql define input:storage ""
delete from graph (iri(bif:JSO_SYS_GRAPH NIL)) { ?s virtrdf:version ?o }
where { graph `iri(bif:JSO_SYS_GRAPH NIL)` {?s virtrdf:version ?o}};
SPARQL_RELOAD_QM_GRAPH();
]]></programlisting>
<para>Creation of IRIs classes.</para>
<programlisting><![CDATA[
sparql

prefix mbz: <http://musibrainz.org/schemas/mbz#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix dc: <http://purl.org/dc/elements/1.1/>
prefix bio: <http://vocab.org/bio/0.1/#>
prefix rel: <http://vocab.org/relationship/#>
prefix mo: <http://purl.org/ontology/mo/>
prefix timeline: <http://purl.org/NET/c4dm/timeline.owl#>
prefix event: <http://purl.org/NET/c4dm/event.owl#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix sim: <http://purl.org/ontology/sim/>

create iri class mbz:artist_iri  "http://zitgist.com/music/artist/%U" (in gid varchar not null) option (bijection) .
create iri class mbz:artist_birth_event_iri  "http://zitgist.com/music/artist/birth/%U" (in gid varchar not null) option (bijection) .
create iri class mbz:artist_death_event_iri  "http://zitgist.com/music/artist/death/%U" (in gid varchar not null) option (bijection) .
create iri class mbz:sim_link_iri  "http://zitgist.com/music/artist/simlink/%U" (in gid varchar not null) option (bijection) .

#create iri class mbz:band_iri  "http://zitgist.com/music/band/%U" (in gid varchar not null) option (bijection) .
#create iri class mbz:band_birth_event_iri  "http://zitgist.com/music/band/birth/%U" (in gid varchar not null) option (bijection) .
#create iri class mbz:band_death_event_iri  "http://zitgist.com/music/band/death/%U" (in gid varchar not null) option (bijection) .

create iri class mbz:record_iri  "http://zitgist.com/music/record/%U" (in gid varchar not null) option (bijection) .
create iri class mbz:performance_iri  "http://zitgist.com/music/performance/%U" (in gid varchar not null) option (bijection) .
create iri class mbz:composition_iri  "http://zitgist.com/music/composition/%U" (in gid varchar not null) option (bijection) .
create iri class mbz:musicalwork_iri  "http://zitgist.com/music/musicalwork/%U" (in gid varchar not null) option (bijection) .
create iri class mbz:sound_iri  "http://zitgist.com/music/sound/%U" (in gid varchar not null) option (bijection) .
create iri class mbz:recording_iri  "http://zitgist.com/music/recording/%U" (in gid varchar not null) option (bijection) .
create iri class mbz:signal_iri  "http://zitgist.com/music/signal/%U" (in gid varchar not null) option (bijection) .

create iri class mbz:track_iri  "http://zitgist.com/music/track/%U" (in gid varchar not null) option (bijection) .

create iri class mbz:image_iri  "http://ec1.images-amazon.com/images/P/%U.01.MZZZZZZZ.jpg" (in image varchar not null) option (bijection) .

create iri class mbz:amazon_asin_iri  "http://amazon.com/exec/obidos/ASIN/%U/searchcom07-20" (in gid varchar not null) option (bijection) .


create literal class mbz:created using
    function ZITGIST.MO.RECORD_CREATION_DATE (in datestring varchar) returns varchar,
    function ZITGIST.MO.RECORD_CREATION_DATE_INVERSE (in datestring varchar) returns varchar .

create iri class mbz:official_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_OFFICIAL (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/official') .

create iri class mbz:promotion_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_PROMOTION (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/promotion') .

create iri class mbz:bootleg_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_BOOTLEG (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/bootleg') .

create iri class mbz:album_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_ALBUM (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/album') .

create iri class mbz:single_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_SINGLE (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/single') .

create iri class mbz:ep_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_EP (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/ep') .

create iri class mbz:compilation_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_COMPILATION (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/compilation') .

create iri class mbz:soundtrack_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_SOUNDTRACK (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/soundtrack') .

create iri class mbz:spokenword_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_SPOKENWORD (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/spokenword') .

create iri class mbz:interview_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_INTERVIEW (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/interview') .

create iri class mbz:audiobook_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_AUDIOBOOK (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/audiobook') .

create iri class mbz:live_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_LIVE (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/live') .

create iri class mbz:remix_iri using
    function ZITGIST.MO.RECORD_ATTRIBUTE_REMIX (in attributes varchar) returns varchar
    option (returns 'http://purl.org/ontology/mo/remix') .

create iri class mbz:duration_iri  "http://zitgist.com/music/track/duration/%U" (in gid varchar not null) .

create literal class mbz:duration using
    function ZITGIST.MO.TRACK_DURATION (in duration integer) returns varchar ,
    function ZITGIST.MO.TRACK_DURATION_INVERSE (in durationXSD varchar) returns integer .

create iri class mbz:geoname_country_iri  "http://www.geonames.org/countries/#%U" (in country varchar not null) .

create iri class mbz:url_iri  "%s" (in url varchar not null) .
create iri class mbz:mbz_release_url_iri  "http://musicbrainz.org/release/%s.html" (in mbz_gid varchar not null) .
create iri class mbz:mbz_track_url_iri  "http://musicbrainz.org/track/%s.html" (in mbz_gid varchar not null) .
create iri class mbz:mbz_artist_url_iri  "http://musicbrainz.org/artist/%s.html" (in mbz_gid varchar not null) .
;
]]></programlisting>
<para><emphasis>List of functions used to compute some IRI classes:</emphasis></para>
<para>Note:These functions have been developed to handle some weird user cases of the Musicbrainz data model (like the Attritube column of the album table, etc).</para>
<programlisting><![CDATA[
create function ZITGIST.MO.TRACK_DURATION_INVERSE(in durationXSD varchar)
{
    return null;
};

create function ZITGIST.MO.TRACK_DURATION(in duration integer)
{
    declare minutes, seconds, milliseconds integer;

    minutes := ((duration / 1000) / 60);

    if(minutes >= 1)
    {
        minutes := cast(minutes as integer);
    }
    else
    {
        minutes := 0;
    }

    seconds := (duration / 1000) - (minutes * 60);

    if(seconds >= 1)
    {
        seconds := cast(seconds as integer);
    }

    milliseconds := duration - (seconds * 1000) - (minutes * 60000);

    return sprintf('PT%dM%dS', minutes, seconds);
}
;


create function ZITGIST.MO.RECORD_CREATION_DATE(in datestring varchar)
{
    return sprintf('%sT00:00:00Z', datestring);
};

create function ZITGIST.MO.RECORD_CREATION_DATE_INVERSE(in datestring varchar)
{
    declare pos integer;
    pos := locate('T00:00:00Z', datestring) - 1;
    return substring(datestring, 1, pos);
};


create function ZITGIST.MO.RECORD_ATTRIBUTE(in attribute integer, in attributes varchar)
{
    declare attributes_array any;

    attributes_array := split_and_decode(ltrim(rtrim(attributes, '}'), '{'), 0, '\0\0,');

    foreach(int attr in attributes_array) do
    {
        attr := cast(attr as integer);
        if(attr = attribute)
        {
            if(attr = 100) return 'http://purl.org/ontology/mo/official';
            if(attr = 101) return 'http://purl.org/ontology/mo/promotion';
            if(attr = 102) return 'http://purl.org/ontology/mo/bootleg';
            if(attr = 1)   return 'http://purl.org/ontology/mo/album';
            if(attr = 2)   return 'http://purl.org/ontology/mo/single';
            if(attr = 3)   return 'http://purl.org/ontology/mo/ep';
            if(attr = 4)   return 'http://purl.org/ontology/mo/compilation';
            if(attr = 5)   return 'http://purl.org/ontology/mo/soundtrack';
            if(attr = 6)   return 'http://purl.org/ontology/mo/spokenword';
            if(attr = 7)   return 'http://purl.org/ontology/mo/interview';
            if(attr = 8)   return 'http://purl.org/ontology/mo/audiobook';
            if(attr = 9)   return 'http://purl.org/ontology/mo/live';
            if(attr = 10)  return 'http://purl.org/ontology/mo/remix';
        }
    }
    return null;
}
;

create function ZITGIST.MO.RECORD_ATTRIBUTE_OFFICIAL(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(100, attributes); }
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_PROMOTION(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(101, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_BOOTLEG(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(102, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_ALBUM(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(1, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_SINGLE(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(2, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_EP(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(3, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_COMPILATION(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(4, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_SOUNDTRACK(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(5, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_SPOKENWORD(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(6, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_INTERVIEW(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(7, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_AUDIOBOOK(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(8, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_LIVE(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(9, attributes);}
;
create function ZITGIST.MO.RECORD_ATTRIBUTE_REMIX(in attributes varchar)
{    return ZITGIST.MO.RECORD_ATTRIBUTE(10, attributes);}
;
]]></programlisting>
<para><emphasis>Definition of the quad map patterns</emphasis></para>
<para>This what creates the RDF triples from the musicbrainz relational database schema.</para>
<programlisting><![CDATA[
sparql
prefix mbz: <http://musibrainz.org/schemas/mbz#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix dc: <http://purl.org/dc/elements/1.1/>
prefix dcterms: <http://purl.org/dc/terms/>
prefix bio: <http://vocab.org/bio/0.1/#>
prefix rel: <http://vocab.org/relationship/#>
prefix mo: <http://purl.org/ontology/mo/>
prefix timeline: <http://purl.org/NET/c4dm/timeline.owl#>
prefix event: <http://purl.org/NET/c4dm/event.owl#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix sim: <http://purl.org/ontology/sim/>

create quad storage virtrdf:MBZROOT


#
# Defitions of the source tables from the mbz relational database and their joints.
#########

from ZITGIST.MO.track as track text literal name
from ZITGIST.MO.artist as track_artist
from ZITGIST.MO.puid as track_puid
from ZITGIST.MO.track as track_track
from ZITGIST.MO.url as track_url

from ZITGIST.MO.artist as track_artist_creator where (^{track.}^.artist = ^{track_artist_creator.}^.id)

from ZITGIST.MO.albumjoin as track_albumjoin where (^{track.}^.id = ^{track_albumjoin.}^.track)

from ZITGIST.MO.l_artist_track as l_artist_track2 where (^{track.}^.id = ^{l_artist_track2.}^.link1)
                                                      where (^{track_artist.}^.id = ^{l_artist_track2.}^.link0)


from ZITGIST.MO.puidjoin as puidjoin where (^{track.}^.id = ^{puidjoin.}^.track)
                                         where (^{puidjoin.}^.puid = ^{track_puid.}^.id)


from ZITGIST.MO.l_track_track as l_track_track where (^{track.}^.id = ^{l_track_track.}^.link0)
                                                   where (^{track_track.}^.id = ^{l_track_track.}^.link1)


from ZITGIST.MO.l_track_url as l_track_url where (^{track.}^.id = ^{l_track_url.}^.link0)
                                               where (^{track_url.}^.id = ^{l_track_url.}^.link1)



from ZITGIST.MO.album as album text literal name
from ZITGIST.MO.artist as album_artist
from ZITGIST.MO.album as album_album
from ZITGIST.MO.url as album_url
from ZITGIST.MO.country as album_release_country
from ZITGIST.MO.track as album_albumjoin_track

from ZITGIST.MO.artist as album_artist_creator where (^{album.}^.artist = ^{album_artist_creator.}^.id)

from ZITGIST.MO.album_amazon_asin as album_amazon_asin where (^{album.}^.id = ^{album_amazon_asin.}^.album)


from ZITGIST.MO.albumjoin as album_albumjoin where (^{album.}^.id = ^{album_albumjoin.}^.album)
                                                 where (^{album_albumjoin.}^.track = ^{album_albumjoin_track.}^.id)


from ZITGIST.MO.l_album_artist as l_album_artist2 where (^{album.}^.id = ^{l_album_artist2.}^.link0)
                                                      where (^{album_artist.}^.id = ^{l_album_artist2.}^.link1)


from ZITGIST.MO.l_album_album as l_album_album where (^{album.}^.id = ^{l_album_album.}^.link0)
                                                   where (^{album_album.}^.id = ^{l_album_album.}^.link1)


from ZITGIST.MO.l_album_url as l_album_url where (^{album.}^.id = ^{l_album_url.}^.link0)
                                               where (^{album_url.}^.id = ^{l_album_url.}^.link1)


from ZITGIST.MO.release as album_release where (^{album.}^.id = ^{album_release.}^.album)
                                             where (^{album_release.}^.country = ^{album_release_country.}^.id)





from ZITGIST.MO.artist as sim_band
from ZITGIST.MO.artist as sim_artist
from ZITGIST.MO.url as band_url
from ZITGIST.MO.artist as band_member
from ZITGIST.MO.album as band_album
from ZITGIST.MO.track as band_track
from ZITGIST.MO.artist as band text literal name where (^{band.}^.type = 2)
#from ZITGIST.MO.artist as artist text literal name where (^{artist.}^.type <> 2)
from ZITGIST.MO.artist as artist text literal name where (__or (neq(^{artist.}^.type, 2), isnull (^{artist.}^.type)))
from ZITGIST.MO.artist as artist_untyped text literal name where (^{artist_untyped.}^.type <> 2)
                                                      where (^{artist.}^.gid = ^{artist_untyped.}^.gid)



from ZITGIST.MO.album as band_album_creatorOf where (^{band_album_creatorOf.}^.artist = ^{band.}^.id)
from ZITGIST.MO.track as band_track_creatorOf where (^{band_track_creatorOf.}^.artist = ^{band.}^.id)

from ZITGIST.MO.artistalias as bandalias text literal name where (^{band.}^.id = ^{bandalias.}^."ref")

from ZITGIST.MO.l_artist_artist as band_l_artist_artist where (^{band_member.}^.id = ^{band_l_artist_artist.}^.link0)
                                                            where (^{band.}^.id = ^{band_l_artist_artist.}^.link1)
                                                            where (^{band_l_artist_artist.}^.link_type = 2)


from ZITGIST.MO.artist_relation as band_relation
where (^{artist.}^.id = ^{band_relation.}^.artist)
where (^{band.}^.id = ^{band_relation.}^.artist)
where (^{sim_band.}^.id = ^{band_relation.}^."ref")

from ZITGIST.MO.artist_relation as artist_relation
where (^{artist.}^.id = ^{artist_relation.}^.artist)
where (^{band.}^.id = ^{artist_relation.}^.artist)
where (^{sim_artist.}^.id = ^{artist_relation.}^."ref")



from ZITGIST.MO.l_artist_url as l_artist_url3 where (^{band.}^.id = ^{l_artist_url3.}^.link0)
                                                  where (^{band_url.}^.id = ^{l_artist_url3.}^.link1)


from ZITGIST.MO.l_album_artist as l_album_artist3 where (^{band.}^.id = ^{l_album_artist3.}^.link1)
                                                      where (^{band_album.}^.id = ^{l_album_artist3.}^.link0)


from ZITGIST.MO.l_artist_track as l_artist_track3 where (^{band.}^.id = ^{l_artist_track3.}^.link0)
                                                      where (^{band_track.}^.id = ^{l_artist_track3.}^.link1)

from ZITGIST.MO.url as artist_url
from ZITGIST.MO.artist as artist_artist
from ZITGIST.MO.track as artist_track
from ZITGIST.MO.album as artist_album

from ZITGIST.MO.album as artist_album_creatorOf where (^{artist_album_creatorOf.}^.artist = ^{artist.}^.id)
from ZITGIST.MO.track as artist_track_creatorOf where (^{artist_track_creatorOf.}^.artist = ^{artist.}^.id)

from ZITGIST.MO.artistalias as artistalias text literal name where (^{artist.}^.id = ^{artistalias.}^."ref")
from ZITGIST.MO.l_artist_url as l_artist_url where (^{artist.}^.id = ^{l_artist_url.}^.link0)
                                                 where (^{artist_url.}^.id = ^{l_artist_url.}^.link1)

from ZITGIST.MO.l_artist_artist as l_artist_artist where (^{artist.}^.id = ^{l_artist_artist.}^.link0)
                                                       where (^{artist_artist.}^.id = ^{l_artist_artist.}^.link1)

from ZITGIST.MO.l_artist_track as l_artist_track where (^{artist.}^.id = ^{l_artist_track.}^.link0)
                                                     where (^{artist_track.}^.id = ^{l_artist_track.}^.link1)
from ZITGIST.MO.l_album_artist as l_album_artist where (^{artist.}^.id = ^{l_album_artist.}^.link1)
                                                     where (^{artist_album.}^.id = ^{l_album_artist.}^.link0)

{
  create virtrdf:MBZ as graph iri ("http://musicbrainz.org/") option (exclusive)
    {

        # Track Composition Event
        mbz:composition_iri (track.gid)
            a mo:Composition as mbz:track_is_composition;
            dc:title track.name as mbz:title_of_track;
            mo:composer mbz:artist_iri (track_artist_creator.gid) as mbz:creator_composer_of_track;
            mo:composer mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 14) option (using l_artist_track2) as mbz:composer14_of_track;
            mo:producesWork mbz:musicalwork_iri (track.gid) as mbz:track_producesWork.

        # Track Musical Work
        mbz:musicalwork_iri (track.gid)
            a mo:MusicalWork as mbz:track_is_mw;
            dc:title track.name as mbz:name_of_mw;

            mo:productOfComposition mbz:composition_iri(track.gid) as mbz:mw_is_productOfComposition_of;
            mo:usedInPerformance mbz:performance_iri(track.gid) as mbz:mw_usedInPerformance.

        # Track Performance Event
        mbz:performance_iri (track.gid)
            a mo:Performance;
            dc:title track.name;
            mo:performer mbz:artist_iri (track_artist_creator.gid);
            mo:performer mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 2) option (using l_artist_track2);
            mo:conductor mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 9) option (using l_artist_track2);

            mo:usesWork mbz:musicalwork_iri (track.gid);
            mo:producesSound mbz:sound_iri (track.gid);

            mo:recordedAs mbz:signal_iri(track.gid).

        # Track Sound
        mbz:sound_iri (track.gid)
            a mo:Sound;
            dc:title track.name;

            mo:productOfPerformance mbz:performance_iri (track.gid);
            mo:usedInRecording mbz:recording_iri (track.gid).

        # Track Recording Event
        mbz:recording_iri (track.gid)
            a mo:Recording;
            dc:title track.name;

            mo:recordsSound mbz:sound_iri (track.gid);
            mo:producesSignal mbz:signal_iri (track.gid).

        # Track Signal (Musical Expression)
        mbz:signal_iri (track.gid)
            a mo:Signal;
            dc:title track.name;

            mo:remixer mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 11) option (using l_artist_track2);
            mo:sampler mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 12) option (using l_artist_track2);
            mo:djmixed mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 40) option (using l_artist_track2);

            mo:djmix_of mbz:track_iri (track_track.gid) where (^{l_track_track.}^.link_type = 13) option (using l_track_track);
            mo:remix_of mbz:track_iri (track_track.gid) where (^{l_track_track.}^.link_type = 6) option (using l_track_track);
            mo:remix_of mbz:track_iri (track_track.gid) where (^{l_track_track.}^.link_type = 11) option (using l_track_track);
            mo:mashup_of mbz:track_iri (track_track.gid) where (^{l_track_track.}^.link_type = 8) option (using l_track_track);
            mo:mashup_of mbz:track_iri (track_track.gid) where (^{l_track_track.}^.link_type = 4) option (using l_track_track);
            mo:remaster_of mbz:track_iri (track_track.gid) where (^{l_track_track.}^.link_type = 3) option (using l_track_track);
            mo:compilation_of mbz:track_iri (track_track.gid) where (^{l_track_track.}^.link_type = 10) option (using l_track_track);
            mo:compilation_of mbz:track_iri (track_track.gid) where (^{l_track_track.}^.link_type = 12) option (using l_track_track);
            mo:medley_of mbz:record_iri (track_track.gid) where (^{l_track_track.}^.link_type = 14) option (using l_track_track);

            mo:published_as mbz:track_iri (track.gid);
            mo:signalTime mbz:duration_iri(track.gid);
            mo:puid track_puid.puid option (using puidjoin).

        # Track duration
        mbz:duration_iri(track.gid)
            a timeline:Interval;
            timeline:durationXSD mbz:duration(track.length).


        mbz:track_iri(track.gid)
            a mo:Track;
            dc:title track.name;

            mo:trackNum track_albumjoin.sequence;


            dc:creator mbz:artist_iri (track_artist_creator.gid);
            dc:creator mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 14) option (using l_artist_track2);
			mo:compiler mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 39) option (using l_artist_track2);
            mo:producer mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 18) option (using l_artist_track2);
            mo:publisher mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 35) option (using l_artist_track2);
            mo:engineer mbz:artist_iri (track_artist.gid) where (^{l_artist_track2.}^.link_type = 19) option (using l_artist_track2);


            mo:licence mbz:url_iri(track_url.url) where (^{l_track_url.}^.link_type = 21) option (using l_track_url);
            mo:paiddownload mbz:url_iri(track_url.url) where (^{l_track_url.}^.link_type = 16) option (using l_track_url);
            mo:freedownload mbz:url_iri(track_url.url) where (^{l_track_url.}^.link_type = 17) option (using l_track_url);
            mo:olga mbz:url_iri(track_url.url) where (^{l_track_url.}^.link_type = 19) option (using l_track_url);

            mo:musicbrainz mbz:mbz_track_url_iri(track.gid);

            mo:duration track.length.

        # Record Composition Event
        mbz:composition_iri (album.gid)
            a mo:Composition;
            dc:title album.name;

            mo:composer mbz:artist_iri (album_artist_creator.gid);
            mo:composer mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 14) option (using l_album_artist2);

            mo:producesWork mbz:musicalwork_iri (album.gid).

        # Record Musical Work
        mbz:musicalwork_iri (album.gid)
            a mo:MusicalWork;
            dc:title album.name;

            mo:productOfComposition mbz:composition_iri(album.gid);
            mo:usedInPerformance mbz:performance_iri(album.gid).


        # Record Performance Event
        mbz:performance_iri (album.gid)
            a mo:Performance;
            dc:title album.name;
            mo:performer mbz:artist_iri (album_artist_creator.gid);
            mo:performer mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 2) option (using l_album_artist2);
            mo:conductor mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 9) option (using l_album_artist2);

            mo:usesWork mbz:musicalwork_iri (album.gid);
            mo:producesSound mbz:sound_iri (album.gid);

            mo:recordedAs mbz:record_iri(album.gid).


        # Record Sound
        mbz:sound_iri (album.gid)
            a mo:Sound;
            dc:title album.name;

            mo:productOfPerformance mbz:performance_iri (album.gid);
            mo:usedInRecording mbz:recording_iri (album.gid).

        # Record Recording Event
        mbz:recording_iri (album.gid)
            a mo:Recording;
            dc:title album.name;

            mo:recordsSound mbz:sound_iri (album.gid);
            mo:producesSignal mbz:signal_iri (album.gid).

        # Record Signal (Musical Expression)
        mbz:signal_iri (album.gid)
            a mo:Signal;
            dc:title album.name;

            mo:djmix_of mbz:record_iri (album_album.gid) where (^{l_album_album.}^.link_type = 9) option (using l_album_album);
            mo:remix_of mbz:record_iri (album_album.gid) where (^{l_album_album.}^.link_type = 7) option (using l_album_album);
            mo:remix_of mbz:record_iri (album_album.gid) where (^{l_album_album.}^.link_type = 4) option (using l_album_album);
            mo:mashup_of mbz:record_iri (album_album.gid) where (^{l_album_album.}^.link_type = 5) option (using l_album_album);
            mo:remaster_of mbz:record_iri (album_album.gid) where (^{l_album_album.}^.link_type = 3) option (using l_album_album);
            mo:tribute_to mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 44) option (using l_album_artist2);

            mo:remixer mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 11) option (using l_album_artist2);
            mo:djmixed mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 38) option (using l_album_artist2);
            mo:sampler mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 12) option (using l_album_artist2);

            mo:published_as mbz:record_iri (album.gid).


        # Record (Musical Manifestation)
        mbz:record_iri (album.gid)
            a mo:Record;
            dc:title album.name;

            dc:date mbz:created(album_release.releasedate);
            mo:image mbz:image_iri(album_amazon_asin.asin);

            #Empty for now.
            mo:compilation_of mbz:record_iri (album_album.gid) where (^{l_album_album.}^.link_type = 8) option (using l_album_album);
            mo:releaseStatus mbz:official_iri(album.attributes);
            mo:releaseStatus mbz:promotion_iri(album.attributes);
            mo:releaseStatus mbz:bootleg_iri(album.attributes);

            mo:releaseType mbz:album_iri(album.attributes);
            mo:releaseType mbz:single_iri(album.attributes);
            mo:releaseType mbz:ep_iri(album.attributes);
            mo:releaseType mbz:compilation_iri(album.attributes);
            mo:releaseType mbz:soundtrack_iri(album.attributes);
            mo:releaseType mbz:spokenword_iri(album.attributes);
            mo:releaseType mbz:interview_iri(album.attributes);
            mo:releaseType mbz:audiobook_iri(album.attributes);
            mo:releaseType mbz:live_iri(album.attributes);
            mo:releaseType mbz:remix_iri(album.attributes);


            dc:creator mbz:artist_iri (album_artist_creator.gid);
            dc:creator mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 14) option (using l_album_artist2);

            mo:compiler mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 41) option (using l_album_artist2);
            mo:producer mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 18) option (using l_album_artist2);
            mo:publisher mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 35) option (using l_album_artist2);
            mo:engineer mbz:artist_iri (album_artist.gid) where (^{l_album_artist2.}^.link_type = 19) option (using l_album_artist2);


            mo:musicbrainz mbz:mbz_release_url_iri(album.gid);

            mo:musicmoz mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 25) option (using l_album_url);
            mo:discogs mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 24) option (using l_album_url);
            mo:wikipedia mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 23) option (using l_album_url);
            mo:discography mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 1) option (using l_album_url);
            mo:freedownload mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 21) option (using l_album_url);
            mo:discography mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 16) option (using l_album_url);
            mo:mailorder mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 19) option (using l_album_url);
            mo:imdb mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 27) option (using l_album_url);
            mo:paiddownload mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 20) option (using l_album_url);
            mo:licence mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 32) option (using l_album_url);
            mo:review mbz:url_iri(album_url.url) where (^{l_album_url.}^.link_type = 17) option (using l_album_url);


            mo:amazon_asin mbz:amazon_asin_iri(album_amazon_asin.asin);

            mo:has_track mbz:track_iri (album_albumjoin_track.gid) option (using album_albumjoin).

       # Music Group (Band)
#       mbz:band_iri(band.gid)
        mbz:artist_iri(band.gid)
            a mo:MusicArtist;
            a mo:MusicGroup;
            a foaf:Group;
            foaf:name band.name;
            foaf:nick bandalias.name;

#           bio:event mbz:band_birth_event_iri(band.gid);
#           bio:event mbz:band_death_event_iri(band.gid);
            bio:event mbz:artist_birth_event_iri(band.gid);
            bio:event mbz:artist_death_event_iri(band.gid);

#           mo:similar_to mbz:band_iri(sim_band.gid) option (using band_relation);
            mo:similar_to mbz:artist_iri(sim_band.gid) option (using band_relation);
            mo:similar_to mbz:artist_iri(sim_artist.gid) option (using artist_relation);
#            sim:link mbz:sim_link_iri(sim_band.gid)  option (using band_relation);
#            sim:link mbz:sim_link_iri(sim_artist.gid)  option (using artist_relation);

            foaf:member mbz:artist_iri(band_member.gid) option (using band_l_artist_artist);

            # l_artist_url
            mo:myspace mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 19) option (using l_artist_url3);
            mo:musicmoz mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 12) option (using l_artist_url3);
            mo:discogs mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 11) option (using l_artist_url3);
            mo:wikipedia mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 10) option (using l_artist_url3);
            mo:discography mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 1) option (using l_artist_url3);
            mo:freedownload mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 8) option (using l_artist_url3);
            mo:fanpage mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 3) option (using l_artist_url3);
            mo:biography mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 4) option (using l_artist_url3);
            mo:discography mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 5) option (using l_artist_url3);
            mo:mailorder mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 15) option (using l_artist_url3);
            mo:imdb mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 17) option (using l_artist_url3);
            mo:paiddownload mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 7) option (using l_artist_url3);
            foaf:depiction mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 14) option (using l_artist_url3);
            foaf:homepage mbz:url_iri(band_url.url) where (^{l_artist_url3.}^.link_type = 2) option (using l_artist_url3);

            mo:musicbrainz mbz:mbz_artist_url_iri(band.gid);


            # l_album_artist
            mo:composed mbz:composition_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 14) option (using l_album_artist3);
            mo:performed mbz:performance_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 14) option (using l_album_artist3);
            mo:performed mbz:performance_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 2) option (using l_album_artist3);
            mo:conducted mbz:performance_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 9) option (using l_album_artist3);
            mo:compiled mbz:record_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 41) option (using l_album_artist3);
            mo:djmixed mbz:record_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 38) option (using l_album_artist3);
            mo:remixed mbz:record_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 11) option (using l_album_artist3);
            mo:sampled mbz:record_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 12) option (using l_album_artist3);
            mo:produced mbz:record_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 18) option (using l_album_artist3);
            mo:published mbz:record_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 35) option (using l_album_artist3);
            mo:engineered mbz:record_iri (band_album.gid) where (^{l_album_artist3.}^.link_type = 19) option (using l_album_artist3);

#    #      mo:creatorOfRecord mbz:record_iri(band_album_creatorOf.gid);
            foaf:made mbz:record_iri(band_album_creatorOf.gid);

            # l_artist_track
            mo:composed mbz:composition_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 14) option (using l_artist_track3);
            mo:performed mbz:performance_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 14) option (using l_artist_track3);
            mo:performed mbz:performance_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 2) option (using l_artist_track3);
            mo:conducted mbz:performance_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 9) option (using l_artist_track3);
            mo:compiled mbz:record_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 39) option (using l_artist_track3);
            mo:djmixed mbz:track_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 40) option (using l_artist_track3);
            mo:remixed mbz:track_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 11) option (using l_artist_track3);
            mo:sampled mbz:track_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 12) option (using l_artist_track3);
            mo:produced mbz:track_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 18) option (using l_artist_track3);
            mo:published mbz:track_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 35) option (using l_artist_track3);
            mo:engineered mbz:track_iri (band_track.gid) where (^{l_artist_track3.}^.link_type = 19) option (using l_artist_track3).

#    #      mo:creatorOfTrack mbz:track_iri(band_track_creatorOf.gid).




        # Music Group (Band)'s Birth Event
#       mbz:band_birth_event_iri(band.gid)
        mbz:artist_birth_event_iri(band.gid)
            a bio:Birth;
            bio:date band.begindate.

        # Music Group (Band)'s Death Event
#       mbz:band_death_event_iri(band.gid)
        mbz:artist_death_event_iri(band.gid)
            a bio:Death;
            bio:date band.enddate.

        # Similarity link
        #mbz:sim_link_iri(sim_band.gid)
        #    sim:relation mo:similar_to;
        #    sim:level band_relation.weight;
        #    sim:to sim_band.gid.


        # Music Artist
        mbz:artist_iri (artist.gid)

            # artist
            a mo:MusicArtist;
            a mo:SoloMusicArtist where (^{artist_untyped.}^.gid is not null) option (using artist_untyped);
            a foaf:Person where (^{artist_untyped.}^.gid is not null) option (using artist_untyped);
            foaf:name artist.name;
            foaf:nick artistalias.name;
            bio:event mbz:artist_birth_event_iri(artist.gid);
            bio:event mbz:artist_death_event_iri(artist.gid);

            mo:member_of mbz:artist_iri(artist_artist.gid) where (^{l_artist_artist.}^.link_type = 2) option (using l_artist_artist);

            # l_artist_artist
            rel:siblingOf mbz:artist_iri(artist_artist.gid) where (^{l_artist_artist.}^.link_type = 7) option (using l_artist_artist);
            rel:friendOf mbz:artist_iri(artist_artist.gid) where (^{l_artist_artist.}^.link_type = 5) option (using l_artist_artist);
            rel:parentOf mbz:artist_iri(artist_artist.gid) where (^{l_artist_artist.}^.link_type = 6) option (using l_artist_artist);
            rel:collaborated_with mbz:artist_iri(artist_artist.gid) where (^{l_artist_artist.}^.link_type = 11) option (using l_artist_artist);
            rel:engagedTo mbz:artist_iri(artist_artist.gid) where (^{l_artist_artist.}^.link_type = 9) option (using l_artist_artist);
            rel:spouseOf mbz:artist_iri(artist_artist.gid) where (^{l_artist_artist.}^.link_type = 8) option (using l_artist_artist);
            mo:supporting_musician mbz:artist_iri(artist_artist.gid) where (^{l_artist_artist.}^.link_type = 13) option (using l_artist_artist);
            mo:supporting_musician mbz:artist_iri(artist_artist.gid) where (^{l_artist_artist.}^.link_type = 14) option (using l_artist_artist);
            mo:supporting_musician mbz:artist_iri(artist_artist.gid) where (^{l_artist_artist.}^.link_type = 15) option (using l_artist_artist);

            mo:similar_to mbz:artist_iri(sim_artist.gid) option (using artist_relation);
#           mo:similar_to mbz:band_iri(sim_band.gid) option (using band_relation);
            mo:similar_to mbz:artist_iri(sim_band.gid) option (using band_relation);

#            sim:link mbz:sim_link_iri(sim_band.gid)  option (using band_relation);
#            sim:link mbz:sim_link_iri(sim_artist.gid)  option (using artist_relation);


            # l_artist_url
            mo:myspace mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 19) option (using l_artist_url);
            mo:musicmoz mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 12) option (using l_artist_url);
            mo:discogs mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 11) option (using l_artist_url);
            mo:wikipedia mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 10) option (using l_artist_url);
            mo:discography mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 1) option (using l_artist_url);
            mo:freedownload mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 8) option (using l_artist_url);
            mo:fanpage mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 3) option (using l_artist_url);
            mo:biography mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 4) option (using l_artist_url);
            mo:discography mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 5) option (using l_artist_url);
            mo:mailorder mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 15) option (using l_artist_url);
            mo:imdb mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 17) option (using l_artist_url);
            mo:paiddownload mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 7) option (using l_artist_url);
            foaf:depiction mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 14) option (using l_artist_url);
            foaf:homepage mbz:url_iri(artist_url.url) where (^{l_artist_url.}^.link_type = 2) option (using l_artist_url);

            mo:musicbrainz mbz:mbz_artist_url_iri(artist.gid);


            # l_album_artist
            mo:composed mbz:composition_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 14) option (using l_album_artist);
            mo:performed mbz:performance_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 14) option (using l_album_artist);
            mo:performed mbz:performance_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 2) option (using l_album_artist);
            mo:conducted mbz:performance_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 9) option (using l_album_artist);
            mo:compiled mbz:record_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 41) option (using l_album_artist);
            mo:djmixed mbz:record_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 38) option (using l_album_artist);
            mo:remixed mbz:record_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 11) option (using l_album_artist);
            mo:sampled mbz:record_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 12) option (using l_album_artist);
            mo:produced mbz:record_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 18) option (using l_album_artist);
            mo:published mbz:record_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 35) option (using l_album_artist);
            mo:engineered mbz:record_iri (artist_album.gid) where (^{l_album_artist.}^.link_type = 19) option (using l_album_artist);

     #      mo:creatorOfRecord mbz:record_iri(artist_album_creatorOf.gid);
            foaf:made mbz:record_iri(artist_album_creatorOf.gid);


            # l_artist_track
            mo:composed mbz:composition_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 14) option (using l_artist_track);
            mo:performed mbz:performance_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 14) option (using l_artist_track);
            mo:performed mbz:performance_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 2) option (using l_artist_track);
            mo:conducted mbz:performance_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 9) option (using l_artist_track);
            mo:compiled mbz:track_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 39) option (using l_artist_track);
            mo:djmixed mbz:track_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 40) option (using l_artist_track);
            mo:remixed mbz:track_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 11) option (using l_artist_track);
            mo:sampled mbz:track_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 12) option (using l_artist_track);
            mo:produced mbz:track_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 18) option (using l_artist_track);
            mo:published mbz:track_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 35) option (using l_artist_track);
            mo:engineered mbz:track_iri (artist_track.gid) where (^{l_artist_track.}^.link_type = 19) option (using l_artist_track).

     #       mo:creatorOfTrack mbz:track_iri(artist_track_creatorOf.gid).


        # Music Artist''s Birth Event
        mbz:artist_birth_event_iri(artist.gid)
            a bio:Birth;
            bio:date artist.begindate.

        # Music Artist''s Death Event
        mbz:artist_death_event_iri(artist.gid)
            a bio:Death;
            bio:date artist.enddate.

        # Similarity link
        #mbz:sim_link_iri(sim_artist.gid)
        #    sim:relation mo:similar_to;
        #    sim:level artist_relation.weight;
        #    sim:to sim_artist.gid.

        }
  }
;


grant execute on ZITGIST.MO.RECORD_CREATION_DATE to "SPARQL";
grant execute on ZITGIST.MO.RECORD_CREATION_DATE_INVERSE to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_OFFICIAL to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_PROMOTION to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_BOOTLEG to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_ALBUM to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_SINGLE to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_EP to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_COMPILATION to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_SOUNDTRACK to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_SPOKENWORD to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_INTERVIEW to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_AUDIOBOOK to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_LIVE to "SPARQL";
grant execute on ZITGIST.MO.RECORD_ATTRIBUTE_REMIX to "SPARQL";
grant execute on ZITGIST.MO.TRACK_DURATION to "SPARQL";
grant execute on ZITGIST.MO.TRACK_DURATION_INVERSE to "SPARQL";
grant execute on ZITGIST.MO.album_amazon_asin to "SPARQL";
grant execute on ZITGIST.MO.album_name_WORDS to "SPARQL";
grant execute on ZITGIST.MO.albumjoin to "SPARQL";
grant execute on ZITGIST.MO.albummeta to "SPARQL";
grant execute on ZITGIST.MO.artist to "SPARQL";
grant execute on ZITGIST.MO.artist_name_WORDS to "SPARQL";
grant execute on ZITGIST.MO.artist_relation to "SPARQL";
grant execute on ZITGIST.MO.artistalias to "SPARQL";
grant execute on ZITGIST.MO.artistalias_name_WORDS to "SPARQL";
grant execute on ZITGIST.MO.country to "SPARQL";
grant execute on ZITGIST.MO.l_album_album to "SPARQL";
grant execute on ZITGIST.MO.l_album_artist to "SPARQL";
grant execute on ZITGIST.MO.l_album_url to "SPARQL";
grant execute on ZITGIST.MO.l_artist_artist to "SPARQL";
grant execute on ZITGIST.MO.l_artist_track to "SPARQL";
grant execute on ZITGIST.MO.l_artist_url to "SPARQL";
grant execute on ZITGIST.MO.l_track_track to "SPARQL";
grant execute on ZITGIST.MO.l_track_url to "SPARQL";
grant execute on ZITGIST.MO."language" to "SPARQL";
grant execute on ZITGIST.MO.puid to "SPARQL";
grant execute on ZITGIST.MO.puidjoin to "SPARQL";
grant execute on ZITGIST.MO.release to "SPARQL";
grant execute on ZITGIST.MO.track to "SPARQL";
grant execute on ZITGIST.MO.track_name_WORDS to "SPARQL";
grant execute on ZITGIST.MO.url to "SPARQL";

DB.DBA.XML_SET_NS_DECL ('mbz', 'http://musibrainz.org/schemas/mbz#', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsbusintods">
      <title>Virtuoso ODS to RDF</title>
<para><emphasis>RDF View for ODS (the consolidated Graph)</emphasis></para>
<programlisting><![CDATA[
sparql drop quad map virtrdf:ODS_DS . ;

sparql prefix ods: <http://www.openlinksw.com/virtuoso/ods/>
       create iri class ods:graph "http://^{URIQADefaultHost}^/dataspace/%U" (in uname varchar not null)
			    option (returns "http://^{URIQADefaultHost}^/dataspace/%U") .
       create iri class ods:user "http://^{URIQADefaultHost}^/dataspace/%U#user" (in uname varchar not null)
			    option (returns "http://^{URIQADefaultHost}^/dataspace/%U#user") .
       create iri class ods:user_group "http://^{URIQADefaultHost}^/dataspace/%U#group" (in uname varchar not null)
			    option (returns "http://^{URIQADefaultHost}^/dataspace/%U#group") .
       create iri class ods:person "http://^{URIQADefaultHost}^/dataspace/%U#this" (in uname varchar not null)
			    option (returns "http://^{URIQADefaultHost}^/dataspace/%U#this") .
       create iri class ods:mbox "mailto:%s" (in email varchar not null)
			    option (returns "mailto:%s") .
       create iri class ods:phone "tel:%s" (in tel varchar not null)
       			    option (returns "tel:%s") .
       create iri class ods:geo_point "http://^{URIQADefaultHost}^/dataspace/%U#geo" (in uname varchar not null)
       			    option (returns "http://^{URIQADefaultHost}^/dataspace/%U#geo") .
       create iri class ods:forum "http://^{URIQADefaultHost}^/dataspace/%U/%U/%U"
	    ( in uname varchar not null, in forum_type varchar not null, in forum_name varchar not null)
	    		    option (returns "http://^{URIQADefaultHost}^/dataspace/%U/%U/%U") .
       create iri class ods:proxy "http://^{URIQADefaultHost}^/proxy/%U" (in url varchar not null)
       			    option (returns  "http://^{URIQADefaultHost}^/proxy/%U") .
       create iri class ods:site "http://^{URIQADefaultHost}^/dataspace/%U#site" (in uname varchar not null)
       			    option (returns "http://^{URIQADefaultHost}^/dataspace/%U#site") .
       create iri class ods:role "http://^{URIQADefaultHost}^/dataspace/%U/%U/%U#%U"
	    (in uname varchar not null, in tp varchar not null, in inst varchar not null, in role_name varchar not null)
			    option (returns  "http://^{URIQADefaultHost}^/dataspace/%U/%U/%U#%U" ) .
	# Blog
	create iri class ods:blog_forum "http://^{URIQADefaultHost}^/dataspace/%U/weblog/%U"
		(in uname varchar not null, in forum_name varchar not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/weblog/%U") .
	create iri class ods:blog_post "http://^{URIQADefaultHost}^/dataspace/%U/weblog/%U/%U"
		(in uname varchar not null, in forum_name varchar not null, in postid varchar not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/weblog/%U/%U" ) .
	create iri class ods:blog_comment "http://^{URIQADefaultHost}^/dataspace/%U/weblog/%U/%U/%d"
		(in uname varchar not null, in forum_name varchar not null, in postid varchar not null, in comment_id int not null)
 	        option (returns  "http://^{URIQADefaultHost}^/dataspace/%U/weblog/%U/%U/%d" ) .
	create iri class ods:tag "http://^{URIQADefaultHost}^/dataspace/%U/concept#%U"
		(in uname varchar not null, in tag varchar not null)
                option (returns  "http://^{URIQADefaultHost}^/dataspace/%U/concept#%U") .
	create iri class ods:blog_post_text "http://^{URIQADefaultHost}^/dataspace/%U/weblog-text/%U/%U"
		(in uname varchar not null, in forum_name varchar not null, in postid varchar not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/weblog-text/%U/%U" ) .
	#Feeds
	create iri class ods:feed "http://^{URIQADefaultHost}^/dataspace/feed/%d" (in feed_id integer not null)
          	option (returns "http://^{URIQADefaultHost}^/dataspace/feed/%d" ) .
	create iri class ods:feed_item "http://^{URIQADefaultHost}^/dataspace/feed/%d/%d" (in feed_id integer not null, in item_id integer not null)
	 	option (returns  "http://^{URIQADefaultHost}^/dataspace/feed/%d/%d" ) .
	create iri class ods:feed_item_text "http://^{URIQADefaultHost}^/dataspace/feed/%d/%d/text" (in feed_id integer not null, in item_id integer not null)
		option (returns  "http://^{URIQADefaultHost}^/dataspace/feed/%d/%d/text" ) .
	create iri class ods:feed_mgr "http://^{URIQADefaultHost}^/dataspace/%U/feeds/%U" (in uname varchar not null, in inst_name varchar not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/feeds/%U" ) .
	create iri class ods:feed_comment "http://^{URIQADefaultHost}^/dataspace/%U/feeds/%U/%d/%d"
		(in uname varchar not null, in inst_name varchar not null, in item_id integer not null, in comment_id integer not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/feeds/%U/%d/%d" ) .
	#Bookmark
	create iri class ods:bmk_post "http://^{URIQADefaultHost}^/dataspace/%U/bookmark/%U/%d"
		(in uname varchar not null, in inst_name varchar not null, in bmk_id integer not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/bookmark/%U/%d") .
	create iri class ods:bmk_post_text "http://^{URIQADefaultHost}^/dataspace/%U/bookmark/%U/%d/text"
		(in uname varchar not null, in inst_name varchar not null, in bmk_id integer not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/bookmark/%U/%d/text" ) .
	create iri class ods:bmk_forum "http://^{URIQADefaultHost}^/dataspace/%U/bookmark/%U"
		( in uname varchar not null, in forum_name varchar not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/bookmark/%U") .
	#Photo
	create iri class ods:photo_forum "http://^{URIQADefaultHost}^/dataspace/%U/photos/%U"
		(in uname varchar not null, in inst_name varchar not null)
		option (returns  "http://^{URIQADefaultHost}^/dataspace/%U/photos/%U") .
	create iri class ods:photo_post "http://^{URIQADefaultHost}^%s"
		(in path varchar not null) option (returns "http://^{URIQADefaultHost}^/DAV/%s") .
	create iri class ods:photo_post_text "http://^{URIQADefaultHost}^%s/text"
		(in path varchar not null) option (returns "http://^{URIQADefaultHost}^/DAV/%s/text") .
	create iri class ods:photo_comment "http://^{URIQADefaultHost}^%s:comment_%d"
		(in path varchar not null, in comment_id int not null)
		option (returns "http://^{URIQADefaultHost}^/DAV/%s:comment_%d") .
	# Community
	create iri class ods:community_forum "http://^{URIQADefaultHost}^/dataspace/%U/community/%U"
		(in uname varchar not null, in forum_name varchar not null)
		option (returns  "http://^{URIQADefaultHost}^/dataspace/%U/community/%U") .
	# Briefcase
	create iri class ods:odrive_forum "http://^{URIQADefaultHost}^/dataspace/%U/briefcase/%U"
		(in uname varchar not null, in inst_name varchar not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/briefcase/%U" ) .
	create iri class ods:odrive_post "http://^{URIQADefaultHost}^%s"
		(in path varchar not null) option (returns "http://^{URIQADefaultHost}^/DAV/%s") .
	create iri class ods:odrive_post_text "http://^{URIQADefaultHost}^%s/text"
		(in path varchar not null) option (returns "http://^{URIQADefaultHost}^/DAV/%s/text") .
	# Wiki
	create iri class ods:wiki_post "http://^{URIQADefaultHost}^/dataspace/%U/wiki/%U/%U"
		(in uname varchar not null, in inst_name varchar not null, in topic_id varchar not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/wiki/%U/%U") .
	create iri class ods:wiki_post_text "http://^{URIQADefaultHost}^/dataspace/%U/wiki/%U/%U/text"
		(in uname varchar not null, in inst_name varchar not null, in topic_id varchar not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/wiki/%U/%U/text" ) .
	create iri class ods:wiki_forum "http://^{URIQADefaultHost}^/dataspace/%U/wiki/%U"
		( in uname varchar not null, in forum_name varchar not null)
		option (returns  "http://^{URIQADefaultHost}^/dataspace/%U/wiki/%U" ) .
	#Calendar
	create iri class ods:calendar_event "http://^{URIQADefaultHost}^/dataspace/%U/calendar/%U/%d"
		(in uname varchar not null, in inst_name varchar not null, in calendar_id integer not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/calendar/%U/%d" ) .
	create iri class ods:calendar_event_text "http://^{URIQADefaultHost}^/dataspace/%U/calendar/%U/%d/text"
		(in uname varchar not null, in inst_name varchar not null, in calendar_id integer not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/%U/calendar/%U/%d/text" ) .
	create iri class ods:calendar_forum "http://^{URIQADefaultHost}^/dataspace/%U/calendar/%U"
		( in uname varchar not null, in forum_name varchar not null)
		option (returns  "http://^{URIQADefaultHost}^/dataspace/%U/calendar/%U") .
	# NNTPF
	create iri class ods:nntp_forum "http://^{URIQADefaultHost}^/dataspace/discussion/%U"
		( in forum_name varchar not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/discussion/%U").
	create iri class ods:nntp_post "http://^{URIQADefaultHost}^/dataspace/discussion/%U/%U"
		( in group_name varchar not null, in message_id varchar not null)
		option (returns  "http://^{URIQADefaultHost}^/dataspace/discussion/%U/%U" ) .
	create iri class ods:nntp_post_text "http://^{URIQADefaultHost}^/dataspace/discussion/%U/%U/text"
		( in group_name varchar not null, in message_id varchar not null)
		option (returns  "http://^{URIQADefaultHost}^/dataspace/discussion/%U/%U/text") .
	create iri class ods:nntp_role "http://^{URIQADefaultHost}^/dataspace/discussion/%U#reader"
		(in forum_name varchar not null)
		option (returns "http://^{URIQADefaultHost}^/dataspace/discussion/%U#reader") .
       ;


sparql
    prefix sioc: <http://rdfs.org/sioc/ns#>
    prefix sioct: <http://rdfs.org/sioc/types#>
    prefix atom: <http://atomowl.org/ontologies/atomrdf#>
    prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    prefix foaf: <http://xmlns.com/foaf/0.1/>
    prefix dc: <http://purl.org/dc/elements/1.1/>
    prefix dct: <http://purl.org/dc/terms/>
    prefix skos: <http://www.w3.org/2004/02/skos/core#>
    prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
    prefix bm: <http://www.w3.org/2002/01/bookmark#>
    prefix exif: <http://www.w3.org/2003/12/exif/ns/>
    prefix ann: <http://www.w3.org/2000/10/annotation-ns#>
    prefix wikiont: <http://sw.deri.org/2005/04/wikipedia/wikiont.owl#>
    prefix calendar: <http://www.w3.org/2002/12/cal#>
    prefix ods: <http://www.openlinksw.com/virtuoso/ods/>

    alter quad storage virtrdf:DefaultQuadStorage
      from DB.DBA.SIOC_USERS as users
      from DB.DBA.SIOC_ODS_FORUMS as forums
      from DB.DBA.SIOC_ROLES as roles
      from DB.DBA.SIOC_ROLE_GRANTS as grants
      from DB.DBA.SIOC_KNOWS as knows
      from DB.DBA.ODS_FOAF_PERSON as person
      where (^{person.}^.U_NAME = ^{users.}^.U_NAME)
      where (^{forums.}^.U_NAME = ^{users.}^.U_NAME)
      where (^{knows.}^.TO_NAME = ^{users.}^.U_NAME)
      where (^{knows.}^.FROM_NAME = ^{users.}^.U_NAME)
      where (^{grants.}^.U_NAME = ^{users.}^.U_NAME)
      where (^{roles.}^.U_NAME = ^{users.}^.U_NAME)

      from DB.DBA.ODS_BLOG_POSTS as blog_posts
      where (^{blog_posts.}^.B_OWNER = ^{users.}^.U_NAME)
      from DB.DBA.ODS_BLOG_POST_LINKS as blog_links
      where (^{blog_links.}^.B_OWNER = ^{users.}^.U_NAME)
      from DB.DBA.ODS_BLOG_POST_ATTS as blog_atts
      where (^{blog_atts.}^.B_OWNER = ^{users.}^.U_NAME)
      from DB.DBA.ODS_BLOG_POST_TAGS as blog_tags
      where (^{blog_tags.}^.U_NAME = ^{users.}^.U_NAME)
      from DB.DBA.ODS_BLOG_COMMENTS as blog_comms
      where (^{blog_comms.}^.U_NAME = ^{users.}^.U_NAME)

      from DB.DBA.ODS_BMK_POSTS as bmk_posts
      where (^{bmk_posts.}^.U_NAME = ^{users.}^.U_NAME)
      from DB.DBA.ODS_BMK_TAGS as bmk_tags
      where (^{bmk_tags.}^.U_NAME = ^{users.}^.U_NAME)

      from DB.DBA.ODS_ODRIVE_POSTS as odrv_posts
      where (^{odrv_posts.}^.U_MEMBER = ^{users.}^.U_NAME)
      from DB.DBA.ODS_ODRIVE_TAGS as odrv_tags
      where (^{odrv_tags.}^.U_OWNER = ^{users.}^.U_NAME)

      from DB.DBA.ODS_FEED_FEED_DOMAIN as feed_domain
      where (^{feed_domain.}^.U_NAME = ^{users.}^.U_NAME)
      from DB.DBA.ODS_FEED_POSTS as feed_posts
      where (^{feed_posts.}^.EFI_FEED_ID = ^{feed_domain.}^.EF_ID)
      from DB.DBA.ODS_FEED_COMMENTS as feed_comments
      where (^{feed_comments.}^.U_NAME = ^{users.}^.U_NAME)
      from DB.DBA.ODS_FEED_TAGS as feed_tags
      where (^{feed_tags.}^.U_NAME = ^{users.}^.U_NAME)
      from DB.DBA.ODS_FEED_LINKS as feed_links
      where (^{feed_links.}^.EFI_FEED_ID = ^{feed_domain.}^.EF_ID)
      from DB.DBA.ODS_FEED_ATTS as feed_atts
      where (^{feed_atts.}^.EFI_FEED_ID = ^{feed_domain.}^.EF_ID)

      from DB.DBA.ODS_PHOTO_POSTS as photo_posts
      where (^{photo_posts.}^.U_MEMBER = ^{users.}^.U_NAME)
      from DB.DBA.ODS_PHOTO_COMMENTS as photo_comments
      where (^{photo_comments.}^.U_MEMBER = ^{users.}^.U_NAME)
      from DB.DBA.ODS_PHOTO_TAGS as photo_tags
      where (^{photo_tags.}^.U_MEMBER = ^{users.}^.U_NAME)

      from DB.DBA.ODS_WIKI_POSTS as wiki_posts
      where (^{wiki_posts.}^.U_NAME = ^{users.}^.U_NAME)

      from DB.DBA.ODS_COMMUNITIES as community
      where (^{community.}^.C_OWNER = ^{users.}^.U_NAME)

      from DB.DBA.ODS_NNTP_GROUPS as nntp_groups
      from DB.DBA.ODS_NNTP_POSTS as nntp_posts
      from DB.DBA.ODS_NNTP_USERS as nntp_users
      where (^{nntp_users.}^.U_NAME = ^{users.}^.U_NAME)
      from DB.DBA.ODS_NNTP_LINKS as nntp_links


    {
	create virtrdf:ODS_DS as graph ods:graph (users.U_NAME) option (exclusive)
	  {
	    ods:user (users.U_NAME) a sioc:User ;
            sioc:id users.U_NAME ;
            sioc:name users.U_FULL_NAME ;
            sioc:email ods:mbox (users.E_MAIL) ;
            sioc:email_sha1 users.E_MAIL_SHA1 ;
            sioc:account_of ods:person (users.U_NAME) .

	    ods:person (person.U_NAME) a foaf:Person ;
            foaf:nick person.U_NAME ;
	    foaf:name person.U_FULL_NAME ;
	    foaf:mbox ods:mbox (person.E_MAIL) ;
            foaf:mbox_sha1sum person.E_MAIL_SHA1 ;
            foaf:holdsAccount ods:user (person.U_NAME) ;
            foaf:firstName person.FIRST_NAME ;
            foaf:family_name person.LAST_NAME ;
            foaf:gender person.GENDER ;
            foaf:icqChatID person.ICQ ;
            foaf:msnChatID person.MSN ;
            foaf:aimChatID person.AIM ;
            foaf:yahooChatID person.YAHOO ;
            foaf:birthday person.BIRTHDAY ;
            foaf:organization person.ORG ;
            foaf:phone ods:phone (person.PHONE) ;
	    foaf:based_near ods:geo_point (person.U_NAME)
	    .

	    ods:geo_point (person.U_NAME) a geo:Point ;
		 geo:lat person.LAT ;
		 geo:lng person.LNG .

	    ods:person (knows.FROM_NAME) foaf:knows ods:person (knows.TO_NAME) .
	    ods:person (knows.TO_NAME) foaf:knows ods:person (knows.FROM_NAME) .

	    ods:user_group (grants.G_NAME) a sioc:Usergroup ;
	    	sioc:id grants.G_NAME ;
		sioc:has_member ods:user (grants.U_NAME) .
	    ods:user (grants.U_NAME)  sioc:member_of ods:user_group (grants.G_NAME) .

	    ods:role (roles.U_NAME, roles.APP_TYPE, roles.WAM_INST, roles.WMT_NAME)
	      sioc:has_scope ods:forum (roles.U_NAME, roles.APP_TYPE, roles.WAM_INST) ;
	      sioc:function_of ods:user (roles.U_NAME) .

            ods:forum (roles.U_NAME, roles.APP_TYPE, roles.WAM_INST)
	    	sioc:scope_of ods:role (roles.U_NAME, roles.APP_TYPE, roles.WAM_INST, roles.WMT_NAME) .
            ods:user (roles.U_NAME)
	    	sioc:has_function ods:role (roles.U_NAME, roles.APP_TYPE, roles.WAM_INST, roles.WMT_NAME) .

	    ods:forum (forums.U_NAME, forums.APP_TYPE, forums.WAM_INST) a sioc:Container ;
            sioc:id forums.WAM_INST ;
	    sioc:type forums.APP_TYPE ;
            sioc:description forums.WAI_DESCRIPTION ;
            sioc:link ods:proxy (forums.LINK) ;
            sioc:has_space ods:site (forums.U_NAME) .

            # Weblog
	    ods:blog_post (blog_posts.B_OWNER, blog_posts.B_INST, blog_posts.B_POST_ID) a sioct:BlogPost ;
	    sioc:link ods:proxy (blog_posts.B_LINK) ;
	    sioc:has_creator ods:user (blog_posts.B_CREATOR) ;
	    foaf:maker ods:person (blog_posts.B_CREATOR) ;
	    sioc:has_container ods:blog_forum (blog_posts.B_OWNER, blog_posts.B_INST) ;
	    dc:title blog_posts.B_TITLE ;
	    dct:created blog_posts.B_CREATED ;
	    dct:modified blog_posts.B_MODIFIED ;
	    sioc:content blog_posts.B_CONTENT .

	    ods:blog_forum (blog_posts.B_OWNER, blog_posts.B_INST)
	    sioc:container_of
	    ods:blog_post (blog_posts.B_OWNER, blog_posts.B_INST, blog_posts.B_POST_ID) .

	    ods:user (blog_posts.B_CREATOR)
	    sioc:creator_of
	    ods:blog_post (blog_posts.B_OWNER, blog_posts.B_INST, blog_posts.B_POST_ID) .

	    ods:blog_post (blog_links.B_OWNER, blog_links.B_INST, blog_links.B_POST_ID)
	    sioc:links_to
	    ods:proxy (blog_links.PL_LINK) .
	    # end Weblog

            # Bookmark
	    ods:bmk_post (bmk_posts.U_NAME, bmk_posts.WAI_NAME, bmk_posts.BD_BOOKMARK_ID)
            a bm:Bookmark ;
	    dc:title bmk_posts.BD_NAME;
	    dct:created bmk_posts.BD_CREATED ;
	    dct:modified bmk_posts.BD_LAST_UPDATE ;
	    dc:date bmk_posts.BD_LAST_UPDATE ;
	    ann:created bmk_posts.BD_CREATED ;
	    dc:creator bmk_posts.U_NAME ;
	    bm:recalls ods:proxy (bmk_posts.B_URI) ;
	    sioc:link ods:proxy (bmk_posts.B_URI) ;
	    sioc:content bmk_posts.BD_DESCRIPTION ;
	    sioc:has_creator ods:user (bmk_posts.U_NAME) ;
	    foaf:maker ods:person (bmk_posts.U_NAME) ;
	    sioc:has_container ods:bmk_forum (bmk_posts.U_NAME, bmk_posts.WAI_NAME) .

            ods:bmk_forum (bmk_posts.U_NAME, bmk_posts.WAI_NAME)
	    sioc:container_of
	    ods:bmk_post (bmk_posts.U_NAME, bmk_posts.WAI_NAME, bmk_posts.BD_BOOKMARK_ID) .

	    ods:user (bmk_posts.U_NAME)
	    sioc:creator_of
	    ods:bmk_post (bmk_posts.U_NAME, bmk_posts.WAI_NAME, bmk_posts.BD_BOOKMARK_ID) .

	    ods:bmk_post (bmk_tags.U_NAME, bmk_tags.WAM_INST, bmk_tags.ITEM_ID)
	    sioc:topic
	    ods:tag (bmk_tags.U_NAME, bmk_tags.BD_TAG) .

	    ods:tag (bmk_tags.U_NAME, bmk_tags.BD_TAG) a skos:Concept ;
	    skos:prefLabel bmk_tags.BD_TAG ;
	    skos:isSubjectOf ods:bmk_post (bmk_tags.U_NAME, bmk_tags.WAM_INST, bmk_tags.ITEM_ID) .
	    # end Bookmark

            # Briefcase
	    ods:odrive_post (odrv_posts.RES_FULL_PATH) a foaf:Document ;
	    dc:title odrv_posts.RES_NAME ;
	    dct:created odrv_posts.RES_CREATED ;
	    dct:modified odrv_posts.RES_MODIFIED ;
	    sioc:content odrv_posts.RES_DESCRIPTION ;
	    sioc:has_creator ods:user (odrv_posts.U_OWNER) ;
	    foaf:maker ods:person (odrv_posts.U_OWNER) ;
	    sioc:has_container ods:odrive_forum (odrv_posts.U_MEMBER, odrv_posts.WAI_NAME) .

	    ods:odrive_forum (odrv_posts.U_MEMBER, odrv_posts.WAI_NAME)
	    sioc:container_of
	    ods:odrive_post (odrv_posts.RES_FULL_PATH) .

	    ods:user (odrv_posts.U_OWNER)
	    sioc:creator_of
	    ods:odrive_post (odrv_posts.RES_FULL_PATH) .

	    ods:odrive_post (odrv_tags.RES_FULL_PATH)
	    sioc:topic
	    ods:tag (odrv_tags.U_OWNER, odrv_tags.TAG) .

	    ods:tag (odrv_tags.U_OWNER, odrv_tags.TAG) a skos:Concept ;
	    skos:prefLabel odrv_tags.TAG ;
	    skos:isSubjectOf ods:odrive_post (odrv_tags.RES_FULL_PATH) .
            # end Briefcase

            # Feeds
	    ods:feed (feed_domain.EF_ID) a atom:Feed ;
	    sioc:link ods:proxy (feed_domain.EF_URI) ;
	    atom:link ods:proxy (feed_domain.EF_URI) ;
	    atom:title feed_domain.EF_TITLE ;
	    sioc:has_parent ods:feed_mgr (feed_domain.U_NAME, feed_domain.WAI_NAME) .

	    ods:feed_mgr (feed_domain.U_NAME, feed_domain.WAI_NAME)
	    sioc:parent_of ods:feed (feed_domain.EF_ID) .


	    ods:feed_item (feed_tags.EFI_FEED_ID, feed_tags.EFID_ITEM_ID)
	    sioc:topic
	    ods:tag (feed_tags.U_NAME, feed_tags.EFID_TAG) .

	    ods:tag (feed_tags.U_NAME, feed_tags.EFID_TAG) a skos:Concept ;
	    skos:prefLabel feed_tags.EFID_TAG ;
	    skos:isSubjectOf ods:feed_item (feed_tags.EFI_FEED_ID, feed_tags.EFID_ITEM_ID) .

	    ods:feed_comment (feed_comments.U_NAME, feed_comments.WAI_NAME, feed_comments.EFIC_ITEM_ID, feed_comments.EFIC_ID)
	    a sioct:Comment ;
	    dc:title feed_comments.EFIC_TITLE ;
	    sioc:content feed_comments.EFIC_COMMENT ;
	    dct:modified feed_comments.LAST_UPDATE ;
	    dct:created feed_comments.LAST_UPDATE ;
	    sioc:link ods:proxy (feed_comments.LINK) ;
	    sioc:has_container ods:feed (feed_comments.EFI_FEED_ID) ;
	    sioc:reply_of ods:feed_item (feed_comments.EFI_FEED_ID, feed_comments.EFIC_ITEM_ID) ;
	    foaf:maker ods:proxy (feed_comments.EFIC_U_URL) .

	    ods:proxy (feed_comments.EFIC_U_URL) a foaf:Person ;
	    foaf:name feed_comments.EFIC_U_NAME;
	    foaf:mbox ods:mbox (feed_comments.EFIC_U_MAIL) .

            ods:feed (feed_comments.EFI_FEED_ID)
	    sioc:container_of
            ods:feed_comment (feed_comments.U_NAME, feed_comments.WAI_NAME, feed_comments.EFIC_ITEM_ID, feed_comments.EFIC_ID) .

            ods:feed_item (feed_comments.EFI_FEED_ID, feed_comments.EFIC_ITEM_ID)
	    sioc:has_reply
	    ods:feed_comment (feed_comments.U_NAME, feed_comments.WAI_NAME, feed_comments.EFIC_ITEM_ID, feed_comments.EFIC_ID) .

            ods:feed_item (feed_links.EFI_FEED_ID, feed_links.EFI_ID)
	    sioc:links_to
	    ods:proxy (feed_links.EFIL_LINK) .

	    ods:feed_item (feed_atts.EFI_FEED_ID, feed_atts.EFI_ID)
	    sioc:attachment
	    ods:proxy (feed_atts.EFIE_URL) .

	    ods:feed_item (feed_posts.EFI_FEED_ID, feed_posts.EFI_ID) a atom:Entry ;
	    sioc:has_container ods:feed (feed_posts.EFI_FEED_ID) ;
	    dc:title feed_posts.EFI_TITLE ;
	    dct:created feed_posts.PUBLISH_DATE ;
	    dct:modified feed_posts.PUBLISH_DATE ;
	    sioc:link ods:proxy (feed_posts.EFI_LINK) ;
	    sioc:content feed_posts.EFI_DESCRIPTION ;
	    atom:title feed_posts.EFI_TITLE ;
	    atom:source ods:feed (feed_posts.EFI_FEED_ID) ;
	    atom:published feed_posts.PUBLISH_DATE ;
	    atom:updated feed_posts.PUBLISH_DATE ;
	    atom:content ods:feed_item_text (feed_posts.EFI_FEED_ID, feed_posts.EFI_ID) .

	    ods:feed (feed_posts.EFI_FEED_ID) sioc:container_of ods:feed_item (feed_posts.EFI_FEED_ID, feed_posts.EFI_ID) .

	    ods:feed_item_text (feed_posts.EFI_FEED_ID, feed_posts.EFI_ID) a atom:Content ;
	    atom:type "text/xhtml" ;
	    atom:lang "en-US" ;
	    atom:body feed_posts.EFI_DESCRIPTION .

	    ods:feed (feed_posts.EFI_FEED_ID)
	    atom:contains
	    ods:feed_item (feed_posts.EFI_FEED_ID, feed_posts.EFI_ID) .
            # end Feeds

	    # Photo
	    ods:photo_post (photo_posts.RES_FULL_PATH) a exif:IFD ;
	    dc:title photo_posts.RES_NAME ;
	    dct:created photo_posts.RES_CREATED ;
	    dct:modified photo_posts.RES_MODIFIED ;
	    sioc:content photo_posts.RES_DESCRIPTION ;
	    sioc:has_creator ods:user (photo_posts.U_OWNER) ;
	    foaf:maker ods:person (photo_posts.U_OWNER) ;
	    sioc:link ods:proxy (photo_posts.RES_LINK) ;
	    sioc:has_container ods:photo_forum (photo_posts.U_MEMBER, photo_posts.WAI_NAME) .

	    ods:photo_forum (photo_posts.U_MEMBER, photo_posts.WAI_NAME)
	    sioc:container_of
	    ods:photo_post (photo_posts.RES_FULL_PATH) .

	    ods:user (photo_posts.U_OWNER)
	    sioc:creator_of
	    ods:photo_post (photo_posts.RES_FULL_PATH) .

	    ods:photo_post (photo_tags.RES_FULL_PATH)
	    sioc:topic
	    ods:tag (photo_tags.U_MEMBER, photo_tags.RES_TAG) .

	    ods:tag (photo_tags.U_MEMBER, photo_tags.RES_TAG) a skos:Concept ;
	    skos:prefLabel photo_tags.RES_TAG ;
	    skos:isSubjectOf ods:photo_post (photo_tags.RES_FULL_PATH) .

	    ods:photo_comment (photo_comments.RES_FULL_PATH, photo_comments.COMMENT_ID) a sioct:Comment ;
	    sioc:reply_of ods:photo_post (photo_comments.RES_FULL_PATH) ;
	    sioc:has_container ods:photo_forum (photo_comments.U_MEMBER, photo_comments.WAI_NAME) ;
	    dc:title photo_comments.RES_NAME ;
	    dct:created photo_comments.CREATE_DATE ;
	    dct:modified photo_comments.MODIFY_DATE ;
	    sioc:content photo_comments.TEXT ;
	    foaf:maker ods:person (photo_comments.U_MAKER) .

	    ods:photo_post (photo_comments.RES_FULL_PATH)
	    sioc:has_reply
	    ods:photo_comment (photo_comments.RES_FULL_PATH, photo_comments.COMMENT_ID) .
	    # end Photo

	    # Polls
	    # end Polls

	    # Mail
	    # end Mail

	    # Wiki
            ods:wiki_post (wiki_posts.U_NAME, wiki_posts.CLUSTERNAME, wiki_posts.LOCALNAME) a wikiont:Article ;
	    dc:title wiki_posts.LOCALNAME ;
	    dct:created wiki_posts.RES_CREATED ;
	    dct:modified wiki_posts.RES_MODIFIED ;
	    sioc:content wiki_posts.RES_CONTENT ;
	    sioc:has_creator ods:user (wiki_posts.U_NAME) ;
	    foaf:maker ods:person (wiki_posts.U_NAME) ;
	    sioc:has_container ods:wiki_forum (wiki_posts.U_NAME, wiki_posts.CLUSTERNAME) .

	    ods:wiki_forum (wiki_posts.U_NAME, wiki_posts.CLUSTERNAME)
	    sioc:container_of
	    ods:wiki_post (wiki_posts.U_NAME, wiki_posts.CLUSTERNAME, wiki_posts.LOCALNAME) .

	    ods:user (wiki_posts.U_NAME)
	    sioc:creator_of
	    ods:wiki_post (wiki_posts.U_NAME, wiki_posts.CLUSTERNAME, wiki_posts.LOCALNAME) .

	    # end Wiki

            # Community
	    ods:community_forum (community.C_OWNER, community.CM_COMMUNITY_ID) a sioc:Community ;
	    sioc:has_part ods:forum (community.A_OWNER, community.A_TYPE, community.CM_MEMBER_APP) .

	    ods:forum (community.A_OWNER, community.A_TYPE, community.CM_MEMBER_APP)
	    sioc:part_of
	    ods:community_forum (community.C_OWNER, community.CM_COMMUNITY_ID) .
            # end Community

	    # NNTP
	    ods:nntp_forum (nntp_groups.NG_NAME) a sioct:MessageBoard ;
	    sioc:id nntp_groups.NG_NAME ;
	    sioc:description nntp_groups.NG_DESC .

	    ods:nntp_post (nntp_posts.NG_NAME, nntp_posts.NM_ID) a sioct:BoardPost ;
	    sioc:content nntp_posts.NM_BODY ;
	    dc:title nntp_posts.FTHR_SUBJ ;
	    dct:created  nntp_posts.REC_DATE ;
	    dct:modified nntp_posts.REC_DATE ;
	    foaf:maker ods:proxy (nntp_posts.MAKER) ;
	    sioc:reply_of ods:nntp_post (nntp_posts.NG_NAME, nntp_posts.FTHR_REFER) ;
	    sioc:has_container ods:nntp_forum (nntp_posts.NG_NAME) .

	    ods:nntp_post (nntp_posts.NG_NAME, nntp_posts.FTHR_REFER)
	    sioc:has_reply
	    ods:nntp_post (nntp_posts.NG_NAME, nntp_posts.NM_ID) .

	    ods:nntp_forum (nntp_posts.NG_NAME)
	    sioc:container_of
	    ods:nntp_post (nntp_posts.NG_NAME, nntp_posts.NM_ID) .


	    ods:nntp_role (nntp_groups.NG_NAME)
	    sioc:has_scope
	    ods:nntp_forum (nntp_groups.NG_NAME) .

	    ods:nntp_forum (nntp_groups.NG_NAME)
	    sioc:scope_of
	    ods:nntp_role (nntp_groups.NG_NAME) .

	    ods:user (nntp_users.U_NAME)
	    sioc:has_function
	    ods:nntp_role (nntp_users.NG_NAME) .

	    ods:nntp_role (nntp_users.NG_NAME)
	    sioc:function_of
	    ods:user (nntp_users.U_NAME) .

	    ods:nntp_post (nntp_links.NG_NAME, nntp_links.NML_MSG_ID)
	    sioc:links_to
	    ods:proxy (nntp_links.NML_URL) .
	    # end NNTP

	  } .
    } .
;
]]></programlisting>
<para><emphasis>URL Rewrite Rules for ODS</emphasis></para>
<programlisting><![CDATA[
create procedure DB.DBA.URL_REW_ODS_ACCEPT ()
{
  declare accept, ret any;
  accept := http_request_header (http_request_header (), 'Accept');
  if (not isstring (accept))
    return null;
  ret := null;
  if (regexp_match ('(application|text)/rdf.(xml|n3|turtle|ttl)', accept) is not null)
    {
      if (regexp_match ('application/rdf.xml', accept) is not null)
	{
	  ret := 'rdf';
	}
      else if (regexp_match ('text/rdf.n3', accept) is not null)
	{
	  ret := 'n3';
	}
      else if (regexp_match ('application/rdf.turtle', accept) is not null or
	    regexp_match ('application/rdf.ttl', accept) is not null)
	{
	  ret := 'n3';
	}
    }
  return ret;
};

create procedure  DB.DBA.URL_REW_ODS_SPQ (in graph varchar, in iri varchar, in acc varchar)
{
  declare q, ret any;
  iri := replace (iri, '''', '%27');
  iri := replace (iri, '<', '%3C');
  iri := replace (iri, '>', '%3E');
  q := sprintf ('define input:inference <%s> DESCRIBE <%s> FROM <%s>', graph, iri, graph);
  ret := sprintf ('/sparql?query=%U&format=%U', q, acc);
  return ret;
};

create procedure DB.DBA.URL_REW_ODS_USER (in par varchar, in fmt varchar, in val varchar)
{
--  dbg_obj_print (current_proc_name ());
  declare acc, ret any;
  declare q, iri, graph any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
      graph := sioc..get_graph ();
      iri := sprintf ('%s/%U', graph, val);
      if (val like 'person/%')
	{
	  val := substring (val, 8, length (val));
	  ret := sprintf ('/ods/foaf.vsp?uname=%U&fmt=%U', val, acc);
	}
      else
        ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
    }
  else
    {
      http_header (http_header_get ()||sprintf ('X-XRDS-Location: %s\r\n',
	    DB.DBA.wa_link (1, '/dataspace/'||val||'/yadis.xrds')));

      if (val like 'person/%')
	val := substring (val, 8, length (val));
      ret := sprintf ('/ods/uhome.vspx?page=1&ufname=%s', val);
    }
  return ret;
};

create procedure DB.DBA.URL_REW_ODS_USER_GEM (in par varchar, in fmt varchar, in val varchar)
{
--  dbg_obj_print (current_proc_name ());
  declare acc, ret any;
  declare q, iri, graph, path, is_person any;

  path := http_path ();
  if (path like '%.rdf')
    acc := 'rdf';
  else if (path like '%.n3')
    acc := 'n3';
  else if (path like '%.ttl')
    acc := 'n3';
  else if (path like '%/yadis.xrds')
    acc := 'yadis';
  else
    acc := 'rdf';

  if (acc <> 'yadis')
    {
      is_person := matches_like (path, '%/about.%');
      graph := sioc..get_graph ();
      if (is_person)
	{
          --iri := sprintf ('%s/person/%U', graph, val);
	  ret := sprintf ('/ods/foaf.vsp?uname=%U&fmt=%U', val, acc);
	}
      else
	{
          iri := sprintf ('%s/%U', graph, val);
          ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
	}
    }
  else
    {
      ret := sprintf ('/ods/yadis.vsp?uname=%U', val);
    }
  return ret;
};

create procedure DB.DBA.URL_REW_ODS_GEM (in par varchar, in fmt varchar, in val varchar)
{
--  dbg_obj_print (current_proc_name ());
  declare acc, ret any;
  declare q, iri, graph, path, pos any;

  path := http_path ();
  if (path like '%.rdf')
    acc := 'rdf';
  else if (path like '%.n3')
    acc := 'n3';
  else if (path like '%.ttl')
    acc := 'n3';
  else
    acc := 'rdf';
  graph := sioc..get_graph ();
  pos := strrchr (path, '/');
  path := subseq (path, 0, pos);

  if (val = 'person')
    {
      pos := strrchr (path, '/');
      val := subseq (path, pos+1, length (path));
      ret := sprintf ('/ods/foaf.vsp?uname=%U&fmt=%U', val, acc);
    }
  else
    {
      iri := sprintf ('http://%s%s', sioc..get_cname (), path);
      ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
    }
  return ret;
};


create procedure DB.DBA.URL_REW_ODS_APP (in par varchar, in fmt varchar, in val varchar)
{
--  dbg_obj_print (current_proc_name (), val);
  if (par = 'app')
    return sprintf (fmt, wa_app_to_type (val));
  return sprintf (fmt, val);
};

create procedure DB.DBA.URL_REW_ODS_BLOG (in par varchar, in fmt varchar, in val varchar)
{
--  dbg_obj_print (par, fmt, val);
--  dbg_obj_print (current_proc_name (), val);
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
      if (par = 'inst')
	{
          declare q, iri, graph any;
          graph := sioc..get_graph ();
          iri := 'http://' || sioc..get_cname () || http_path ();
          ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
          return ret;
	}
      else
	return '';
    }
  else if (par = 'inst')
    {
      declare url any;
      val := split_and_decode (val)[0];
      url := (select WAM_HOME_PAGE from WA_MEMBER where WAM_INST = val and WAM_MEMBER_TYPE = 1);
      if (url is not null)
        val := url;
      return sprintf (fmt, val);
    }
  else if (par = 'id' and val <> '')
    {
      if (atoi (val) = 0 and val <> '0')
	fmt := '%s';
      else
        fmt := '?id=%s';
      return sprintf (fmt, val);
    }
};

create procedure DB.DBA.URL_REW_ODS_NNTP (in par varchar, in fmt varchar, in val varchar)
{
--  dbg_obj_print (par, fmt, val);
--  dbg_obj_print (current_proc_name (), val);
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
       declare q, iri, graph any;
       graph := sioc..get_graph ();
       iri := 'http://' || sioc..get_cname () || http_path ();
--       dbg_obj_print (iri);
       ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
       return ret;
    }
  else if (par = 'grp')
    {
      declare gid int;
      val := split_and_decode (val)[0];
      gid := (select NG_GROUP from DB.DBA.NEWS_GROUPS where NG_NAME = val);
      ret := sprintf ('/nntpf/nntpf_nthread_view.vspx?group=%d', gid);
      return ret;
    }
  else if (par = 'post')
    {
      ret := sprintf ('/nntpf/nntpf_disp_article.vspx?id=%U', encode_base64 (val));
      return ret;
    }
}
;

create procedure DB.DBA.URL_REW_ODS_XD (in par varchar, in fmt varchar, in val varchar)
{
--  dbg_obj_print (par, fmt, val);
--  dbg_obj_print (current_proc_name (), val);
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
       declare q, iri, graph any;
       graph := sioc..get_graph ();
       iri := 'http://' || sioc..get_cname () || http_path ();
--       dbg_obj_print (iri);
       ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
       return ret;
    }
  else if (par = 'inst')
    {
      val := split_and_decode (val)[0];
      ret := (select WAM_HOME_PAGE from WA_MEMBER where WAM_INST = val and WAM_MEMBER_TYPE = 1);
      return ret;
    }
}
;

create procedure DB.DBA.URL_REW_ODS_WIKI (in par varchar, in fmt varchar, in val varchar)
{
--  dbg_obj_print (par, fmt, val);
--  dbg_obj_print (current_proc_name (), val);
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
       declare q, iri, graph any;
       graph := sioc..get_graph ();
       iri := 'http://' || sioc..get_cname () || http_path ();
--       dbg_obj_print (iri);
       ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
       return ret;
    }
  else if (par = 'inst')
    {
      declare _inst DB.DBA.web_app;
      _inst := (select WAI_INST from WA_INSTANCE where WAI_NAME = val);
      ret := _inst.wa_post_url (null, null, val, val);
--      dbg_obj_print ('ret', ret);
      return ret;
    }
  else if (par = 'post')
    {
      return '/'||val;
    }
}
;

create procedure DB.DBA.URL_REW_ODS_PHOTO (in par varchar, in fmt varchar, in val varchar)
{
--  dbg_obj_print (par, fmt, val);
--  dbg_obj_print (current_proc_name (), val);
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
       declare q, iri, graph any;
       graph := sioc..get_graph ();
       iri := 'http://' || sioc..get_cname () || http_path ();
--       dbg_obj_print (iri);
       ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
       return ret;
    }
  else if (par = 'inst')
    {
      val := split_and_decode (val)[0];
      ret := (select WAM_HOME_PAGE from WA_MEMBER where WAM_INST = val and WAM_MEMBER_TYPE = 1);
      return ret;
    }
  else if (par = 'post')
    {
      declare id int;
      declare col, nam varchar;
      declare exit handler for not found
	{
	  signal ('22023', sprintf ('The resource %d doesn''t exists', id));
	};
      id := atoi(ltrim(val, '/'));
      select RES_FULL_PATH into nam from WS.WS.SYS_DAV_RES where RES_ID = id;
      return nam;
    }
}
;

create procedure DB.DBA.URL_REW_ODS_ADDRESSBOOK (in par varchar, in fmt varchar, in val varchar)
{
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
      if (par = 'instance')
      	{
          declare q, iri, graph any;
          graph := sioc..get_graph ();
          iri := 'http://' || sioc..get_cname () || http_path ();
          ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
          return ret;
	      }
      else
	      return '';
    }
  else if (par = 'instance')
    {
      declare id, url any;
      val := split_and_decode (val)[0];
      id := AB.WA.domain_id (val);
      if (id is not null) {
        url := AB.WA.ab_url (id);
        if (url is not null)
          val := url;
      }
      return sprintf (fmt, val);
    }
  else if (par = 'params')
    {
      if (atoi (val) = 0 and val <> '0')
       	fmt := '%s';
      else
        fmt := '?id=%s';
      return sprintf (fmt, val);
    }
}
;

create procedure DB.DBA.URL_REW_ODS_BOOKMARK (in par varchar, in fmt varchar, in val varchar)
{
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
      if (par = 'instance')
      	{
          declare q, iri, graph any;
          graph := sioc..get_graph ();
          iri := 'http://' || sioc..get_cname () || http_path ();
          ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
          return ret;
	      }
      else
	      return '';
    }
  else if (par = 'instance')
    {
      declare id, url any;
      val := split_and_decode (val)[0];
      id := BMK.WA.domain_id (val);
      if (id is not null) {
        url := BMK.WA.bookmark_url (id);
        if (url is not null)
          val := url;
      }
      return sprintf (fmt, val);
    }
  else if (par = 'params')
    {
      if (atoi (val) = 0 and val <> '0')
       	fmt := '%s';
      else
        fmt := '?id=%s';
      return sprintf (fmt, val);
    }
}
;

create procedure DB.DBA.URL_REW_ODS_BRIEFCASE (in par varchar, in fmt varchar, in val varchar)
{
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
      if (par = 'instance')
      	{
          declare q, iri, graph any;
          graph := sioc..get_graph ();
          iri := 'http://' || sioc..get_cname () || http_path ();
          ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
          return ret;
	      }
      else
	      return '';
    }
  else if (par = 'instance')
    {
      declare id, url any;
      val := split_and_decode (val)[0];
      id := ODRIVE.WA.domain_id (val);
      if (id is not null) {
        url := ODRIVE.WA.odrive_url (id);
        if (url is not null)
          val := url;
      }
      return sprintf (fmt, val);
    }
  else if (par = 'params')
    {
      if (atoi (val) = 0 and val <> '0')
       	fmt := '%s';
      else
        fmt := '?id=%s';
      return sprintf (fmt, val);
    }
}
;

create procedure DB.DBA.URL_REW_ODS_CALENDAR (in par varchar, in fmt varchar, in val varchar)
{
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
      if (par = 'instance')
      	{
          declare q, iri, graph any;
          graph := sioc..get_graph ();
          iri := 'http://' || sioc..get_cname () || http_path ();
          ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
          return ret;
	      }
      else
	      return '';
    }
  else if (par = 'instance')
    {
      declare id, url any;
      val := split_and_decode (val)[0];
      id := CAL.WA.domain_id (val);
      if (id is not null) {
        url := CAL.WA.calendar_url (id);
        if (url is not null)
          val := url;
      }
      return sprintf (fmt, val);
    }
  else if (par = 'params')
    {
      if (atoi (val) = 0 and val <> '0')
       	fmt := '%s';
      else
        fmt := '?id=%s';
      return sprintf (fmt, val);
    }
}
;

create procedure DB.DBA.URL_REW_ODS_FEEDS (in par varchar, in fmt varchar, in val varchar)
{
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
      if (par = 'instance')
      	{
          declare q, iri, graph any;
          graph := sioc..get_graph ();
          iri := 'http://' || sioc..get_cname () || http_path ();
          ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
          return ret;
	      }
      else
	      return '';
    }
  else if (par = 'instance')
    {
      declare id, url any;
      val := split_and_decode (val)[0];
      id := ENEWS.WA.domain_id (val);
      if (id is not null) {
        url := ENEWS.WA.enews_url (id) || 'news.vspx';
        if (url is not null)
          val := url;
      }
      return sprintf (fmt, val);
    }
  else if (par = 'params')
    {
      if (atoi (val) = 0 and val <> '0')
       	fmt := '%s';
      else
        fmt := '?id=%s';
      return sprintf (fmt, val);
    }
}
;

create procedure DB.DBA.URL_REW_ODS_POLLS (in par varchar, in fmt varchar, in val varchar)
{
  declare acc, ret any;

  acc := DB.DBA.URL_REW_ODS_ACCEPT ();
  if (acc is not null)
    {
      if (par = 'instance')
      	{
          declare q, iri, graph any;
          graph := sioc..get_graph ();
          iri := 'http://' || sioc..get_cname () || http_path ();
          ret := DB.DBA.URL_REW_ODS_SPQ (graph, iri, acc);
          return ret;
	      }
      else
	      return '';
    }
  else if (par = 'instance')
    {
      declare id, url any;
      val := split_and_decode (val)[0];
      id := POLLS.WA.domain_id (val);
      if (id is not null) {
        url := POLLS.WA.polls_url (id);
        if (url is not null)
          val := url;
      }
      return sprintf (fmt, val);
    }
  else if (par = 'params')
    {
      if (atoi (val) = 0 and val <> '0')
       	fmt := '%s';
      else
        fmt := '?id=%s';
      return sprintf (fmt, val);
    }
}
;

create procedure DB.DBA.URL_REW_ODS_FOAF_EXT (in par varchar, in fmt varchar, in val varchar)
{
  if (par = '*accept*')
    {
      declare ext any;
      ext := 'rdf';
      if (val = 'text/rdf+n3')
	ext := 'n3';
      return sprintf (fmt, ext);
    }
  else
    return sprintf (fmt, val);
}
;

create procedure ur_ods_rdf_doc (in path varchar)
{
  declare r any;
  r := regexp_match ('[^/]*\x24', path);
  return r||'#this';
};

create procedure ur_ods_html_doc (in path varchar)
{
  declare pos, r any;
  if (path like '%/foaf.%')
    {
      pos := strrchr (path, '/');
    }
  else if (path like '%#%')
    {
      pos := strrchr (path, '#');
    }
  if (pos > 0)
    r := subseq (path, 0, pos);
  else
    r := '/';
  return r;
};
-- ODS Rules

-- http://cname/dataspace/uname
-- http://cname/dataspace/person/uname

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_rule1', 1,
    '/dataspace/((person/)?[^/#]*)', vector('ufname'), 1,
    '%s', vector('ufname'),
    'DB.DBA.URL_REW_ODS_USER');

-- http://cname/dataspace/uname with Accept will do 303 to the /sparql
DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_rule2', 1,
    '/dataspace/([^/]*)', vector('ufname'), 1,
    '/sparql?query=define+input%%3Ainference+%%3Chttp%%3A//^{URIQADefaultHost}^/dataspace%%3E+DESCRIBE+%%3Chttp%%3A//^{URIQADefaultHost}^/dataspace/%U%%3E+FROM+%%3Chttp%%3A//^{URIQADefaultHost}^/dataspace%%3E&format=%U', vector('ufname', '*accept*'),
    null,
    '(application|text)/rdf.(xml|n3|turtle|ttl)',
    0,
    303);

-- http://cname/dataspace/uname/app_type
DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_rule3', 1,
    '/dataspace/((?!person)[^/]*)/([^\\./]*)', vector('ufname', 'app'), 2,
    '/ods/app_inst.vspx?app=%s&ufname=%s&l=1', vector('app', 'ufname'),
    'DB.DBA.URL_REW_ODS_APP');

-- http://cname/dataspace/uname/file.ext
DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_rule4', 1,
    '/dataspace/([^/]*)/(sioc|about|yadis)\\.(rdf|n3|ttl|xrds)', vector('ufname', 'file', 'fmt'), 3,
    '%s', vector('ufname'),
    'DB.DBA.URL_REW_ODS_USER_GEM');

-- Rules for FOAF profile

-- http://cname/dataspace/person/uname with Accept, do 303 to http://cname/dataspace/person/uname/foaf.ext
DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_rule5', 1,
    '/dataspace/person/([^/#]*)/?', vector('ufname'), 1,
    '/dataspace/person/%U/foaf.%s', vector('ufname', '*accept*'),
    'DB.DBA.URL_REW_ODS_FOAF_EXT',
    '(application|text)/rdf.(xml|n3|turtle|ttl)',
    2,
    303);

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_rule6', 1,
    '/dataspace/person/([^/]*)/page/([^/]*)/?', vector('ufname', 'page'), 1,
    '/dataspace/person/%U/foaf.%s?page=%s', vector('ufname', '*accept*', 'page'),
    'DB.DBA.URL_REW_ODS_FOAF_EXT',
    '(application|text)/rdf.(xml|n3|turtle|ttl)',
    2,
    303);

-- http://cname/dataspace/person/uname/foaf.ext
DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_rule7', 1,
    '/dataspace/person/([^/]*)/foaf.(rdf|n3|ttl)', vector('ufname', 'fmt'), 1,
    '/ods/foaf.vsp?uname=%U&fmt=%U', vector('ufname', 'fmt'),
    null,
    null,
    2,
    null);

-- App Instance Gem

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_post_gem_rule', 1,
    '/dataspace/([^/]*)/([^/]*)/([^/]*/)?([^/]*/)?(sioc|about)\\.(rdf|n3|ttl)', vector('ufname', 'app', 'inst'), 4,
    '%s', vector('ufname'),
    'DB.DBA.URL_REW_ODS_GEM');


-- Weblog Rules

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_blog_rule1', 1,
    '/dataspace/([^/]*)/weblog/([^/]*)', vector('ufname', 'inst'), 2,
    '%s', vector('inst'),
    'DB.DBA.URL_REW_ODS_BLOG');

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_blog_rule2', 1,
    '/dataspace/([^/]*)/weblog/([^/]*)/([^/]*)', vector('ufname', 'inst', 'id'), 3,
    '%s%s', vector('inst', 'id'),
    'DB.DBA.URL_REW_ODS_BLOG');

-- Discussion rules

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_nntp_rule1', 1,
    '/dataspace/discussion/([^/]*)', vector('grp'), 1,
    '%s', vector('grp'),
    'DB.DBA.URL_REW_ODS_NNTP');

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_nntp_rule2', 1,
    '/dataspace/discussion/([^/]*)/((?!sioc)(?!about)[^/]*)', vector('grp', 'post'), 2,
    '%s', vector('post'),
    'DB.DBA.URL_REW_ODS_NNTP');

-- Community

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_xd_rule1', 1,
    '/dataspace/([^/]*)/community/([^/]*)', vector('ufname', 'inst'), 2,
    '%s', vector('inst'),
    'DB.DBA.URL_REW_ODS_XD');

-- Wiki

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_wiki_rule1', 1,
    '/dataspace/([^/]*)/wiki/([^/]*)', vector('ufname', 'inst'), 2,
    '%s', vector('inst'),
    'DB.DBA.URL_REW_ODS_WIKI');

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_wiki_rule2', 1,
    '/dataspace/([^/]*)/wiki/([^/]*)/([^/]*)', vector('ufname', 'inst', 'post'), 2,
    '%s%s', vector('inst', 'post'),
    'DB.DBA.URL_REW_ODS_WIKI');

-- Gallery

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_photo_rule1', 1,
    '/dataspace/([^/]*)/photos/([^/]*)', vector('ufname', 'inst'), 2,
    '%s', vector('inst'),
    'DB.DBA.URL_REW_ODS_PHOTO');

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('ods_photo_rule2', 1,
    '/dataspace/([^/]*)/photos/([^/]*)/([^/]*)', vector('ufname', 'inst', 'post'), 2,
    '%s', vector('post'),
    'DB.DBA.URL_REW_ODS_PHOTO');


-- AddressBook

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_addressbook_rule1',
    1,
    '/dataspace/([^/]*)/addressbook/([^/]*)',
    vector('uname', 'instance'),
    2,
    '%s', vector('instance'),
    'DB.DBA.URL_REW_ODS_ADDRESSBOOK');

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_addressbook_rule2',
    1,
    '/dataspace/([^/]*)/addressbook/([^/]*)/(.*)',
    vector('uname', 'instance', 'params'),
    3,
    '%s%s',
    vector('instance', 'params'),
    'DB.DBA.URL_REW_ODS_ADDRESSBOOK');

-- Bookmark

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_bookmark_rule1',
    1,
    '/dataspace/([^/]*)/bookmark/([^/]*)',
    vector('uname', 'instance'),
    2,
    '%s', vector('instance'),
    'DB.DBA.URL_REW_ODS_BOOKMARK');

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_bookmark_rule2',
    1,
    '/dataspace/([^/]*)/bookmark/([^/]*)/(.*)',
    vector('uname', 'instance', 'params'),
    3,
    '%s%s',
    vector('instance', 'params'),
    'DB.DBA.URL_REW_ODS_BOOKMARK');

-- Briefcase

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_briefcase_rule1',
    1,
    '/dataspace/([^/]*)/briefcase/([^/]*)',
    vector('uname', 'instance'),
    2,
    '%s', vector('instance'),
    'DB.DBA.URL_REW_ODS_BRIEFCASE');

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_briefcase_rule2',
    1,
    '/dataspace/([^/]*)/briefcase/([^/]*)/(.*)',
    vector('uname', 'instance', 'params'),
    3,
    '%s%s',
    vector('instance', 'params'),
    'DB.DBA.URL_REW_ODS_BRIEFCASE');

-- Calendar

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_calendar_rule1',
    1,
    '/dataspace/([^/]*)/calendar/([^/]*)',
    vector('uname', 'instance'),
    2,
    '%s', vector('instance'),
    'DB.DBA.URL_REW_ODS_CALENDAR');


DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_calendar_rule2',
    1,
    '/dataspace/([^/]*)/calendar/([^/]*)/(.*)',
    vector('uname', 'instance', 'params'),
    3,
    '%s%s',
    vector('instance', 'params'),
    'DB.DBA.URL_REW_ODS_CALENDAR');

-- Feeds

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_feeds_rule1',
    1,
    '/dataspace/([^/]*)/feeds/([^/]*)',
    vector('uname', 'instance'),
    2,
    '%s', vector('instance'),
    'DB.DBA.URL_REW_ODS_FEEDS');

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_feeds_rule2',
    1,
    '/dataspace/([^/]*)/feeds/([^/]*)/(.*)',
    vector('uname', 'instance', 'params'),
    3,
    '%s%s',
    vector('instance', 'params'),
    'DB.DBA.URL_REW_ODS_FEEDS');

-- Polls

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_polls_rule1',
    1,
    '/dataspace/([^/]*)/polls/([^/]*)',
    vector('uname', 'instance'),
    2,
    '%s', vector('instance'),
    'DB.DBA.URL_REW_ODS_POLLS');

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'ods_polls_rule2',
    1,
    '/dataspace/([^/]*)/polls/([^/]*)/(.*)',
    vector('uname', 'instance', 'params'),
    3,
    '%s%s',
    vector('instance', 'params'),
    'DB.DBA.URL_REW_ODS_POLLS');

-- ODS Base rules
DB.DBA.URLREWRITE_CREATE_RULELIST ('ods_base_rule_list1', 1,
    	vector(
	        'ods_rule1', 'ods_rule2', 'ods_rule3', 'ods_rule4'
	      ));

DB.DBA.URLREWRITE_CREATE_RULELIST ('ods_foaf_rule_list1', 1,
    	vector(
	        'ods_rule5', 'ods_rule6', 'ods_rule7'
	      ));

DB.DBA.URLREWRITE_CREATE_RULELIST ('ods_gems_rule_list1', 1,
    	vector(
	        'ods_post_gem_rule'
	      ));

-- ODS Blog rules
DB.DBA.URLREWRITE_CREATE_RULELIST ('ods_blog_rule_list1', 1,
    	vector(
	   	'ods_blog_rule1', 'ods_blog_rule2'
	      ));

-- ODS Discussion rules
DB.DBA.URLREWRITE_CREATE_RULELIST ('ods_nntp_rule_list1', 1,
    	vector(
	   	'ods_nntp_rule1', 'ods_nntp_rule2'
	      ));

-- ODS Community rules
DB.DBA.URLREWRITE_CREATE_RULELIST ('ods_xd_rule_list1', 1,
    	vector(
	   	'ods_xd_rule1'
	      ));

-- ODS Wiki rules
DB.DBA.URLREWRITE_CREATE_RULELIST ('ods_wiki_rule_list1', 1,
    	vector(
	   	'ods_wiki_rule1', 'ods_wiki_rule2'
	      ));

-- ODS Gallery rules
DB.DBA.URLREWRITE_CREATE_RULELIST ('ods_photo_rule_list1', 1,
    	vector(
	   	'ods_photo_rule1', 'ods_photo_rule2'
	      ));

-- ODS AddressBook rules
DB.DBA.URLREWRITE_CREATE_RULELIST (
    'ods_addressbook_rule_list1',
    1,
    vector (
  	 	'ods_addressbook_rule1',
	    'ods_addressbook_rule2'
	  ));

-- ODS Bookmark rules
DB.DBA.URLREWRITE_CREATE_RULELIST (
    'ods_bookmark_rule_list1',
    1,
    vector (
  	 	'ods_bookmark_rule1',
	    'ods_bookmark_rule2'
	  ));

-- ODS Briefcase rules
DB.DBA.URLREWRITE_CREATE_RULELIST (
    'ods_briefcase_rule_list1',
    1,
    vector (
  	 	'ods_briefcase_rule1',
	    'ods_briefcase_rule2'
	  ));

-- ODS Calendar rules
DB.DBA.URLREWRITE_CREATE_RULELIST (
    'ods_calendar_rule_list1',
    1,
    vector (
  	 	'ods_calendar_rule1',
	    'ods_calendar_rule2'
	  ));

-- ODS Feeds rules
DB.DBA.URLREWRITE_CREATE_RULELIST (
    'ods_feeds_rule_list1',
    1,
    vector (
  	 	'ods_feeds_rule1',
	    'ods_feeds_rule2'
	  ));

-- ODS Polls rules
DB.DBA.URLREWRITE_CREATE_RULELIST (
    'ods_polls_rule_list1',
    1,
    vector (
  	 	'ods_polls_rule1',
	    'ods_polls_rule2'
	  ));

-- All ODS Rules
DB.DBA.URLREWRITE_CREATE_RULELIST ('ods_rule_list1', 1,
    	vector(
	  'ods_base_rule_list1',
	  'ods_foaf_rule_list1',
	  'ods_blog_rule_list1',
	  'ods_nntp_rule_list1',
	  'ods_xd_rule_list1',
	  'ods_wiki_rule_list1',
	  'ods_photo_rule_list1',
	  'ods_addressbook_rule_list1',
	  'ods_bookmark_rule_list1',
	  'ods_briefcase_rule_list1',
	  'ods_calendar_rule_list1',
	  'ods_feeds_rule_list1',
	  'ods_polls_rule_list1',
	  'ods_gems_rule_list1'
	      ));

DB.DBA.XML_SET_NS_DECL ('ods', 'http://www.openlinksw.com/virtuoso/ods/', 2);
]]></programlisting>
    </sect3>
    <sect3 id="rdfviewsbusintoplweb">
      <title>Oplweb to RDF</title>
<programlisting><![CDATA[
-- Setup script for RDF view of OpenLink Product Portfolio version 2
--

/*
 * This view is currently designed to SPECIFICALLY load on data.openlinksw.com.  We recommend you
 * search for `openlinksw.com'  (as `http://' is sometimes encoded) and replace with either the default
 * URIQA macro or your own hostname as appropriate.
 */

-- views to get the codes out instead of the id's
---- in hindsight these should ALL have been handled with
---- proper IRI functions like the rest, oh well, no harm AFAIK
---- will know for next time or might even replace this later.
DROP VIEW oplweb2.oplweb.product_formats_categories;

CREATE VIEW oplweb2.oplweb.product_formats_categories (
    product_cat_code, product_cat_id, product_format_code, product_format_id, product_family_id
  ) as
select distinct
  pc.product_cat_code,
  pc.product_cat_id,
  pf.product_format_code,
  pf.product_format_id,
  pc.product_family_id
from
  oplweb2.oplweb.product_category pc,
  oplweb2.oplweb.product_format pf,
  oplweb2.oplweb.product p
where
  p.product_cat_id = pc.product_cat_id and
  p.product_format_id = pf.product_format_id
  and exists (
	select 1 from oplweb2.oplweb.component_archive ca
	where ca.product_id = p.product_id
	)
;


DROP VIEW oplweb2.oplweb.product_with_code;

CREATE VIEW oplweb2.oplweb.product_with_code as
  select p.*, pc.product_cat_code, pf.product_format_code
  from
  oplweb2.oplweb.product_category pc,
  oplweb2.oplweb.product_format pf,
  oplweb2.oplweb.product p
where
  p.product_cat_id = pc.product_cat_id and
  p.product_format_id = pf.product_format_id ;


DROP VIEW oplweb2.oplweb.product_category_with_code;

CREATE VIEW oplweb2.oplweb.product_category_with_code as
  select pc.*, pf.product_family_code
  from
  oplweb2.oplweb.product_category pc,
  oplweb2.oplweb.product_family pf
where
  pc.product_family_id = pf.product_family_id ;


DROP VIEW oplweb2.oplweb.product_family_features_with_code;

CREATE VIEW oplweb2.oplweb.product_family_features_with_code as
  select a.*, b.product_family_code
  from
  oplweb2.oplweb.product_family_features a,
  oplweb2.oplweb.product_family b
where
  a.product_family_id = b.product_family_id
;

DROP VIEW oplweb2.oplweb.product_format_features_with_code;

CREATE VIEW oplweb2.oplweb.product_format_features_with_code as
  select a.*, b.product_format_code
  from
  oplweb2.oplweb.product_format_features a,
  oplweb2.oplweb.product_format b
where
  a.product_format_id = b.product_format_id
;

DROP VIEW oplweb2.oplweb.product_category_features_with_code;

CREATE VIEW oplweb2.oplweb.product_category_features_with_code as
  select a.*, b.product_cat_code
  from
  oplweb2.oplweb.product_category_features a,
  oplweb2.oplweb.product_category b
where
  a.product_cat_id = b.product_cat_id
;

DROP VIEW oplweb2.oplweb.components_for_rdfs;

CREATE VIEW oplweb2.oplweb.components_for_rdfs as
  select *, cast(filesize as varchar) as str_filesize
  from
  oplweb2.oplweb.components
;


DROP VIEW oplweb2.oplweb.product_release_with_family;

CREATE VIEW oplweb2.oplweb.product_release_with_family as
  select a.*, b.opsys_family_id, c.dbms_family_id
  from
  oplweb2.oplweb.product_release a,
  oplweb2.oplweb.opsys b,
  oplweb2.oplweb.dbms_engine c
where
  a.opsys_name = b.opsys_name and
  a.dbms_name = c.dbms_name
;

drop view oplweb2.oplweb.archive_coverage_osdb;

create view oplweb2.oplweb.archive_coverage_osdb as
	select distinct
	  pfam.product_family_id, pfam.product_family_code,
	  p.product_format_id, pf.product_format_code,
	  p.product_cat_id, pc.product_cat_code,
	  p.product_id,
	  ca.opsys_name,
	  os.opsys_family_id,
	  ca.dbms_name,
	  db.dbms_family_id,
	  pr.processor_name,
	  pr.processor_mode_id,
	  pr.processor_family_id
	from
	   oplweb2.oplweb.product p
  join oplweb2.oplweb.product_category pc on (p.product_cat_id = pc.product_cat_id)
  join oplweb2.oplweb.product_format pf on (p.product_format_id = pf.product_format_id)
  join oplweb2.oplweb.product_family pfam on (pc.product_family_id = pfam.product_family_id)
  join oplweb2.oplweb.component_archive ca on (ca.product_id = p.product_id)
  join oplweb2.oplweb.opsys os on (os.opsys_name = ca.opsys_name)
  join oplweb2.oplweb.dbms_engine db on (db.dbms_name = ca.dbms_name)
  join oplweb2.oplweb.processors pr on (pr.processor_name = os.processor_name and pr.processor_mode_id = os.processor_mode_id)
;

GRANT SELECT ON oplweb2.oplweb.component_archive TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.component_archive_type TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.component_category TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.component_mode TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.component_type TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.components TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.components_for_rdfs TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.dbms_engine TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.dbms_family TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.download_location TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.download_protocol TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.download_partner TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.opsys TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.opsys_family TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.opsys_type TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.processor_family TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.processor_mode TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.processors TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_benefits TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_benefits_category TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_category TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_category_with_code TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_category_features TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_family TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_family_features TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_features TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_format TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_format_features TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_feature_category TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_release TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_release_features TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.vendor_category TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.vendor_category_family TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.vendors TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_formats_categories TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_with_code TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_family_features_with_code TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_format_features_with_code TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_category_features_with_code TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.product_release_with_family TO "SPARQL", "SPARQL_UPDATE";
GRANT SELECT ON oplweb2.oplweb.archive_coverage_osdb TO "SPARQL", "SPARQL_UPDATE";


drop index oplweb2_product_price_format_cat;

create index oplweb2_product_price_format_cat on oplweb2.oplweb.product_price(product_cat_id, product_format_id, product_price_type_id);

drop index oplweb2_product_discount_format_cat;

create index oplweb2_product_discount_format_cat on oplweb2.oplweb.product_general_discount(product_cat_id, product_format_id, product_price_type_id);


drop view oplweb2.DBA.license_model_type;

create view oplweb2.DBA.license_model_type (
	product_release_id, product_cat_id, product_format_id, product_id, product_price_type_id
	)
	as
	select distinct
	product_release_id,
	pp.product_cat_id, pp.product_format_id, product_id,
	product_price_type_id
	from
	  oplweb2.oplweb.product_price pp,
	  oplweb2.oplweb.product p
	where p.product_cat_id = pp.product_cat_id and
	p.product_format_id = pp.product_format_id
	;

grant select on oplweb2.DBA.license_model_type to "SPARQL", "SPARQL_UPDATE";--, rdf;



drop view oplweb2.DBA.license_model;

create view oplweb2.DBA.license_model as
  select  distinct
      product_release_id,
      pc.product_cat_id,
      pc.product_format_id,
      pc.product_cat_code,
      pc.product_format_code,
      pc.product_id,
      pp.opsys_family_id, pp.dbms_family_id,
      replace(oo.opsys_family_name, ' ', '') as opsys_family_name,
      replace(dd.dbms_family_name,  ' ', '') as dbms_family_name,
      pp.opsys_type_id,
      pp.product_price_type_id,
	  pp.product_price_unit_type_id
    from
      oplweb2.oplweb.product_price pp,
      oplweb2.oplweb.product_with_code pc, --category pc,
      --oplweb2.oplweb.product_format pf,
      oplweb2.oplweb.opsys os,
      oplweb2.oplweb.dbms_engine dbe,
      oplweb2.oplweb.dbms_family dd,
      oplweb2.oplweb.opsys_family oo
      --oplweb2.oplweb.product p
    where
      pp.product_format_id = pc.product_format_id and
      pp.product_cat_id = pc.product_cat_id and
      pp.opsys_family_id = oo.opsys_family_id and
      pp.dbms_family_id = dd.dbms_family_id
      --p.product_cat_id = pc.product_cat_id and
      --p.product_format_id = pf.product_format_id and
  ;

grant select on oplweb2.DBA.license_model to "SPARQL", "SPARQL_UPDATE";--, rdf;


drop view oplweb2.DBA.license_model_units;

create view oplweb2.DBA.license_model_units as
  select distinct
      lm1.product_release_id,
	  lm1.product_id,
	  lm1.opsys_family_
      pp.opsys_family_id, pp.dbms_family_id,
      replace(oo.opsys_family_name, ' ', '') as opsys_family_name,
      replace(dd.dbms_family_name,  ' ', '') as dbms_family_name,
      pp.opsys_type_id, ot.short_description as opsys_type_code
    from
      oplweb2.oplweb.product_price pp,
      oplweb2.oplweb.opsys_type ot,
      oplweb2.oplweb.dbms_family dd,
      oplweb2.oplweb.opsys_family oo
    where
      pp.opsys_type_id = ot.opsys_type_id and
      pp.opsys_family_id = oo.opsys_family_id and
      pp.dbms_family_id = dd.dbms_family_id
      and
      pp.product_release_id = '6.1'
  ;

grant select on oplweb2.DBA.license_model_units to "SPARQL", "SPARQL_UPDATE";--, rdf;



drop view oplweb2.DBA.product_general_discount_vc;

create view oplweb2.DBA.product_general_discount_vc as
  select  distinct
      product_release_id,
      pgd.product_cat_id, pc.product_cat_code,
      pgd.product_format_id, pc.product_format_code,
	  pc.product_id,
      pgd.opsys_family_id, pgd.dbms_family_id,
      pgd.opsys_type_id,
      product_discount_description,
      product_price_type_id,
      cast(unit_discount as varchar) as unit_discount,
      discount_start,
      discount_end,
      discount_token
    from
      oplweb2.oplweb.product_general_discount pgd,
      oplweb2.oplweb.product_with_code pc
    where
      pgd.product_format_id = pc.product_format_id and
      pgd.product_cat_id = pc.product_cat_id
  ;

drop view oplweb2.DBA.product_price_varchar;

create view oplweb2.DBA.product_price_varchar as
  select
      pp.product_price_id,
      pp.product_release_id,
      pp.product_cat_id, pc.product_cat_code,
      pp.product_format_id, pf.product_format_code,
      pp.opsys_family_id, pp.dbms_family_id,
      replace(oo.opsys_family_name, ' ', '') as opsys_family_name,
      replace(dd.dbms_family_name,  ' ', '') as dbms_family_name,
      pp.opsys_type_id, ot.short_description as opsys_type_code,
			pp.product_price_type_id,
      pp.product_price_unit_type_id, cast(pp.unit_price as varchar) as unit_price,
      pp.component_archive_available
    from
      oplweb2.oplweb.product_price pp,
      oplweb2.oplweb.product_category pc,
      oplweb2.oplweb.product_format pf,
      oplweb2.oplweb.opsys_type ot,
      oplweb2.oplweb.dbms_family dd,
      oplweb2.oplweb.opsys_family oo
    where
      pp.product_format_id = pf.product_format_id and
      pp.product_cat_id = pc.product_cat_id and
      pp.opsys_type_id = ot.opsys_type_id and
      pp.opsys_family_id = oo.opsys_family_id and
      pp.dbms_family_id = dd.dbms_family_id
      --and
      --pp.product_release_id = '6.1'
  ;

grant select on oplweb2.oplweb.product_price to "SPARQL", "SPARQL_UPDATE";--, rdf;
grant select on oplweb2.oplweb.product_price_type to "SPARQL", "SPARQL_UPDATE";--, rdf;
grant select on oplweb2.oplweb.product_price_unit_type to "SPARQL", "SPARQL_UPDATE";--, rdf;
grant select on oplweb2.DBA.product_general_discount_vc to "SPARQL", "SPARQL_UPDATE";--, rdf;
grant select on oplweb2.DBA.product_price_varchar to "SPARQL", "SPARQL_UPDATE";--, rdf;
grant select on oplweb2.DBA.license_model_type to "SPARQL", "SPARQL_UPDATE";--, rdf;



DB.DBA.RDF_AUDIT_METADATA (1, '*');
--DB.DBA.RDF_AUDIT_METADATA (2, '*');

--sparql drop graph <http://www.openlinksw.com/dataspace/organization/openlink/ProductPortfolioOntology/1.0/>;

--possible previous graph now merging with this oplweb graph
sparql drop graph <http://data.openlinksw.com/shop_pricing/>;

--others that have a dependency on this graph that may need kicking first
--sparql drop graph <http://data.openlinksw.com/customer/>;
--sparql drop graph <http://data.openlinksw.com/support/>;
--sparql drop graph <http://data.openlinksw.com/shop_pricing/>;

sparql drop graph <http://www.openlinksw.com/schemas/oplweb#> ;

sparql drop graph <http://www.openlinksw.com/dataspace/organization/openlink/oplweb#> ;
sparql drop graph <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/> ;


-- should now use <http://www.openlinksw.com/dataspace/organization/openlink#this>

sparql drop quad map virtrdf:product_portfolio ;

--only use this if you really really mean it, it will totally nuke your RDF data, useful on
--test boxes in a bit of jam (hasn't happened to me for a while now)
--rdf_global_reset();

--utility for stripping url killing stuff from friendly strings used as ids
create function oplweb2.oplweb.FIXUP4URI (in _string varchar)
	returns varchar
	{
	  declare _s varchar;
      _s := replace (_string, ' ', '');
      _s := replace (_s, '&', '_');
      _s := replace (_s, '/', '');
      return _s;
	}
	;

--URI-IRI mapping functions
create function oplweb2.oplweb.DOWNLOAD_LOCATION_URI (in uri varchar)
returns varchar
{
  return sprintf('http://data.openlinksw.com/oplweb/download_location/%s#this',
  	replace(uri, 'http://', ''));
};

create function oplweb2.oplweb.DOWNLOAD_LOCATION_URI_INVERSE (in dl_iri varchar)
returns varchar
{
  declare parts any;

  parts := sprintf_inverse(dl_iri,
  	'http://data.openlinksw.com/oplweb/download_location/%s#this', 1);
  if (parts is not null)
    {
      return sprintf('http://%s', parts[0]);
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.DOWNLOAD_LOCATION_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.DOWNLOAD_LOCATION_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.DBMS_FAMILY_URI (in _family_id integer)
returns varchar
{
  declare _family_string varchar;
  select dbms_family_name into _family_string
    from oplweb2.oplweb.dbms_family
    where dbms_family_id = _family_id ;

  return sprintf('http://data.openlinksw.com/oplweb/dbms_family/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_family_string));
};

create function oplweb2.oplweb.DBMS_FAMILY_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _family_id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/dbms_family/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 dbms_family_id into _family_id from oplweb2.oplweb.dbms_family
        where lower(oplweb2.oplweb.FIXUP4URI(dbms_family_name)) = lower(parts[0]);
      return _family_id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.DBMS_FAMILY_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.DBMS_FAMILY_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.COMPONENT_CATEGORY_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select short_description into _string
    from oplweb2.oplweb.component_category
    where component_category_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/component_category/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.COMPONENT_CATEGORY_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/component_category/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 component_category_id into _id from oplweb2.oplweb.component_category
        where lower(oplweb2.oplweb.FIXUP4URI(short_description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.COMPONENT_CATEGORY_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.COMPONENT_CATEGORY_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.COMPONENT_MODE_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select short_description into _string
    from oplweb2.oplweb.component_mode
    where component_mode_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/component_mode/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.COMPONENT_MODE_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/component_mode/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 component_mode_id into _id from oplweb2.oplweb.component_mode
        where lower(oplweb2.oplweb.FIXUP4URI(short_description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.COMPONENT_MODE_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.COMPONENT_MODE_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.COMPONENT_TYPE_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select short_description into _string
    from oplweb2.oplweb.component_type
    where component_type_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/component_type/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.COMPONENT_TYPE_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/component_type/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 component_type_id into _id from oplweb2.oplweb.component_type
        where lower(oplweb2.oplweb.FIXUP4URI(short_description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.COMPONENT_TYPE_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.COMPONENT_TYPE_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";



create function oplweb2.oplweb.COMPONENT_ARCHIVE_TYPE_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select component_archive_short_name into _string
    from oplweb2.oplweb.component_archive_type
    where component_archive_type_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/component_archive_type/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.COMPONENT_ARCHIVE_TYPE_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/component_archive_type/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 component_archive_type_id into _id from oplweb2.oplweb.component_archive_type
        where lower(oplweb2.oplweb.FIXUP4URI(component_archive_short_name)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.COMPONENT_ARCHIVE_TYPE_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.COMPONENT_ARCHIVE_TYPE_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";



create function oplweb2.oplweb.FEATURE_BENEFIT_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select product_benefit_desc into _string
    from oplweb2.oplweb.product_benefits
    where product_benefit_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/feature_benefit/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.FEATURE_BENEFIT_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/feature_benefit/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 product_benefit_id into _id from oplweb2.oplweb.product_benefits
        where lower(oplweb2.oplweb.FIXUP4URI(product_benefit_desc)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.FEATURE_BENEFIT_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.FEATURE_BENEFIT_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";



create function oplweb2.oplweb.OPSYS_FAMILY_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select opsys_family_name into _string
    from oplweb2.oplweb.opsys_family
    where opsys_family_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/opsys_family/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.OPSYS_FAMILY_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/opsys_family/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 opsys_family_id into _id from oplweb2.oplweb.opsys_family
        where lower(oplweb2.oplweb.FIXUP4URI(opsys_family_name)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.OPSYS_FAMILY_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.OPSYS_FAMILY_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";



create function oplweb2.oplweb.OPSYS_TYPE_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select short_description into _string
    from oplweb2.oplweb.opsys_type
    where opsys_type_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/opsys_type/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.OPSYS_TYPE_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/opsys_type/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 opsys_type_id into _id from oplweb2.oplweb.opsys_type
        where lower(oplweb2.oplweb.FIXUP4URI(short_description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.OPSYS_TYPE_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.OPSYS_TYPE_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.PROCESSOR_FAMILY_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select processor_family_name into _string
    from oplweb2.oplweb.processor_family
    where processor_family_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/processor_family/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.PROCESSOR_FAMILY_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/processor_family/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 processor_family_id into _id from oplweb2.oplweb.processor_family
        where lower(oplweb2.oplweb.FIXUP4URI(processor_family_name)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.PROCESSOR_FAMILY_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.PROCESSOR_FAMILY_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";

--FIXME might have to do something with possible & symbols
create function oplweb2.oplweb.PROCESSOR_MODE_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select processor_mode_name into _string
    from oplweb2.oplweb.processor_mode
    where processor_mode_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/processor_mode/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.PROCESSOR_MODE_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/processor_mode/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 processor_mode_id into _id from oplweb2.oplweb.processor_mode
        where lower(oplweb2.oplweb.FIXUP4URI(processor_mode_name)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.PROCESSOR_MODE_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.PROCESSOR_MODE_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.PRODUCT_CATEGORY_FEATURE_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select short_description into _string
    from oplweb2.oplweb.product_category_features
    where product_category_feature_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/product_category_feature/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.PRODUCT_CATEGORY_FEATURE_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/product_category_feature/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 product_category_feature_id into _id from oplweb2.oplweb.product_category_features
        where lower(oplweb2.oplweb.FIXUP4URI(short_description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_CATEGORY_FEATURE_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_CATEGORY_FEATURE_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.PRODUCT_FAMILY_FEATURE_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select short_description into _string
    from oplweb2.oplweb.product_family_features
    where product_family_feature_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/product_family_feature/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.PRODUCT_FAMILY_FEATURE_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/product_family_feature/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 product_family_feature_id into _id from oplweb2.oplweb.product_family_features
        where lower(oplweb2.oplweb.FIXUP4URI(short_description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_FAMILY_FEATURE_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_FAMILY_FEATURE_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.PRODUCT_FEATURE_CATEGORY_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select short_desc into _string
    from oplweb2.oplweb.product_feature_category
    where product_feature_category_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/product_feature_category/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.PRODUCT_FEATURE_CATEGORY_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/product_feature_category/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 product_feature_category_id into _id from oplweb2.oplweb.product_feature_category
        where lower(oplweb2.oplweb.FIXUP4URI(short_desc)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_FEATURE_CATEGORY_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_FEATURE_CATEGORY_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.PRODUCT_FEATURE_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select short_description into _string
    from oplweb2.oplweb.product_features
    where product_feature_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/product_feature/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.PRODUCT_FEATURE_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/product_feature/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 product_feature_id into _id from oplweb2.oplweb.product_features
        where lower(oplweb2.oplweb.FIXUP4URI(short_description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_FEATURE_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_FEATURE_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.PRODUCT_FORMAT_FEATURE_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select short_description into _string
    from oplweb2.oplweb.product_format_features
    where product_format_feature_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/product_format_feature/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.PRODUCT_FORMAT_FEATURE_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/product_format_feature/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 product_format_feature_id into _id from oplweb2.oplweb.product_format_features
        where lower(oplweb2.oplweb.FIXUP4URI(short_description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_FORMAT_FEATURE_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_FORMAT_FEATURE_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.PRODUCT_RELEASE_FEATURE_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select short_description into _string
    from oplweb2.oplweb.product_release_features
    where product_release_feature_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/product_release_feature/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.PRODUCT_RELEASE_FEATURE_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/product_release_feature/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 product_release_feature_id into _id from oplweb2.oplweb.product_release_features
        where lower(oplweb2.oplweb.FIXUP4URI(short_description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_RELEASE_FEATURE_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_RELEASE_FEATURE_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.PRODUCT_BENEFIT_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select product_benefit_desc into _string
    from oplweb2.oplweb.product_benefits
    where product_benefit_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/product_benefit/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.PRODUCT_BENEFIT_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/product_benefit/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 product_benefit_id into _id from oplweb2.oplweb.product_benefits
        where lower(oplweb2.oplweb.FIXUP4URI(product_benefit_desc)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_BENEFIT_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_BENEFIT_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.PRODUCT_BENEFIT_CATEGORY_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select description into _string
    from oplweb2.oplweb.product_benefits_category
    where product_benefit_category_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/product_benefit_category/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.PRODUCT_BENEFIT_CATEGORY_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/product_benefit_category/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 product_benefit_category_id into _id from oplweb2.oplweb.product_benefits_category
        where lower(oplweb2.oplweb.FIXUP4URI(description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_BENEFIT_CATEGORY_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.PRODUCT_BENEFIT_CATEGORY_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.VENDOR_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select vendor_name into _string
    from oplweb2.oplweb.vendors
    where vendor_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/vendor/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.VENDOR_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/vendor/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 vendor_id into _id from oplweb2.oplweb.vendors
        where lower(oplweb2.oplweb.FIXUP4URI(vendor_name)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.VENDOR_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.VENDOR_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.VENDOR_CATEGORY_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select vendor_category_description into _string
    from oplweb2.oplweb.vendor_category
    where vendor_category_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/vendor_category/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.VENDOR_CATEGORY_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/vendor_category/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 vendor_category_id into _id from oplweb2.oplweb.vendor_category
        where lower(oplweb2.oplweb.FIXUP4URI(vendor_category_description)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.VENDOR_CATEGORY_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.VENDOR_CATEGORY_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.VENDOR_CATEGORY_FAMILY_URI (in _id integer)
returns varchar
{
  declare _string varchar;
  select vendor_category_family_desc into _string
    from oplweb2.oplweb.vendor_category_family
    where vendor_category_family_id = _id ;

  return sprintf('http://data.openlinksw.com/oplweb/vendor_category_family/%s#this',
  	oplweb2.oplweb.FIXUP4URI(_string));
};

create function oplweb2.oplweb.VENDOR_CATEGORY_FAMILY_URI_INVERSE (in _iri varchar)
returns integer
{
  declare parts any;
  declare _id integer;

  parts := sprintf_inverse(_iri,
  	'http://data.openlinksw.com/oplweb/vendor_category_family/%s#this', 1);
  if (parts is not null)
    {
      declare exit handler for not found return null;
      select top 1 vendor_category_family_id into _id from oplweb2.oplweb.vendor_category_family
        where lower(oplweb2.oplweb.FIXUP4URI(vendor_category_family_desc)) = lower(parts[0]);
      return _id;
    }
  return NULL;
};

GRANT EXECUTE ON oplweb2.oplweb.VENDOR_CATEGORY_FAMILY_URI TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON oplweb2.oplweb.VENDOR_CATEGORY_FAMILY_URI_INVERSE TO "SPARQL", "SPARQL_UPDATE";





create function oplweb2.oplweb.LIT_PRODUCT_RELEASE_LABEL (
	in _product_id varchar, in _id integer, in _opsys_name varchar, in _dbms_name varchar
	)
returns varchar
{
  declare _string varchar;
  select 'OpenLink ' || poduct_description || ' (Release ' || product_release_id || ') on ' || commercial_name into _string
    from oplweb2.oplweb.product_release pr,
      oplweb2.oplweb.product p,
      oplweb2.oplweb.opsys o
    where
      p.product_id = pr.product_id and
      o.opsys_name = pr.opsys_name and
      pr.product_release_id = _id and
      pr.product_id = _product_id and
      pr.opsys_name = _opsys_name and
      pr.dbms_name = _dbms_name ;

  return _string;
};

GRANT EXECUTE ON oplweb2.oplweb.LIT_PRODUCT_RELEASE_LABEL TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.LIT_FORMAT_CAT_LABEL (
	in _format integer, in _cat integer
	)
returns varchar
{
  declare _string varchar;
  select top 1 'OpenLink ' || cast(product_format_description as varchar) || ' ' || cast(product_category_description as varchar) into _string
    from
      oplweb2.oplweb.product_formats_categories fc,
      oplweb2.oplweb.product_format f,
      oplweb2.oplweb.product_category c
    where
fc.product_format_id = f.product_format_id and
fc.product_cat_id = c.product_cat_id and
    fc.product_format_id = _format and
    fc.product_cat_id = _cat;

  return _string;
};

GRANT EXECUTE ON oplweb2.oplweb.LIT_FORMAT_CAT_LABEL TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.LITRDF_openlink_logo (in _code varchar)
returns varchar
{
  declare _string varchar;
  select top 1 product_family_logo_url into _string
    from oplweb2.oplweb.product_family
    where product_family_code = _code;

  return _string;
};

GRANT EXECUTE ON oplweb2.oplweb.LITRDF_openlink_logo TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.LITRDF_homepage (in _code varchar)
returns varchar
{
  declare _string varchar;
  select top 1 product_family_homepage into _string
    from oplweb2.oplweb.product_family
    where product_family_code = _code;

  return _string;
};

GRANT EXECUTE ON oplweb2.oplweb.LITRDF_homepage TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.LITRDF_opsys_icon (in _id integer)
returns varchar
{
  declare _string varchar; _string := '';
  select top 1 opsys_icon_name into _string
    from oplweb2.oplweb.opsys_family
    where opsys_family_id = _id;

  _string := 'http://download.openlinksw.com/download/images/'||_string;

  return _string;
};

GRANT EXECUTE ON oplweb2.oplweb.LITRDF_opsys_icon TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.LITRDF_to_shop (
	in release_id varchar,
	in product_id varchar,
	in opsys varchar,
	in dbms varchar
	)
returns varchar
{
  declare _string varchar; _string := '';
  declare _cat, _format, _prod varchar;

  _prod := product_id;

  select top 1 cast(product_cat_id as varchar), cast(product_format_id as varchar)
      into _cat, _format
    from oplweb2.oplweb.product p
    where p.product_id = _prod;

  _string := sprintf(
	'https://shop.openlinksw.com/?product_release_id=%s&product=%s&product_cat=%V&product_format=%V&os=%s&db=%s&buyme=yes',
	release_id, product_id, _cat, _format, opsys, dbms
	);

  return _string;
};

GRANT EXECUTE ON oplweb2.oplweb.LITRDF_to_shop TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.LITRDF_license_model_type (
		in _product_price_type_id integer
	)
returns varchar
{
  declare _string varchar; _string := '';

  select top 1 product_price_type_description into _string from oplweb2.oplweb.product_price_type
    where product_price_type_id = _product_price_type_id;

  return _string || ' License';
};

GRANT EXECUTE ON oplweb2.oplweb.LITRDF_license_model_type TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.LITRDF_license_model_explain (
		in _product_price_type_id integer
	)
returns varchar
{
  declare _string varchar; _string := '';

  select top 1 product_price_type_long_description into _string from oplweb2.oplweb.product_price_type
    where product_price_type_id = _product_price_type_id;

  return _string;
};

GRANT EXECUTE ON oplweb2.oplweb.LITRDF_license_model_explain TO "SPARQL", "SPARQL_UPDATE";


create function oplweb2.oplweb.LITRDF_shop_sample (
	in release_id varchar,
	in product_id varchar,
	in opsys varchar,
	in dbms varchar
	)
returns varchar
{
  declare _string varchar; _string := '';
  declare _cat, _format, _prod, _pricetype varchar;

  _prod := product_id;

  select top 1 cast(product_cat_id as varchar), cast(product_format_id as varchar), cast(product_price_type_id as varchar)
      into _cat, _format, _pricetype
    from oplweb2.DBA.license_model p, oplweb2.oplweb.opsys o, oplweb2.oplweb.dbms_engine e
    where p.product_id = _prod and product_release_id = release_id and o.opsys_name = opsys and e.dbms_name = dbms
      and p.dbms_family_id = e.dbms_family_id and o.opsys_family_id = p.opsys_family_id;

  _string := sprintf(
	'https://shop.openlinksw.com/price_calc.vsp?release=%s&cat=%V&format=%V&os=%s&db=%s&lictype=%V',
	release_id, _cat, _format, opsys, dbms, _pricetype
	);

  return http_client(_string);
};

GRANT EXECUTE ON oplweb2.oplweb.LITRDF_shop_sample TO "SPARQL", "SPARQL_UPDATE";


-- $Id$
-- Setup script for RDF view of OpenLink Product Portfolio version 2
--

--
-- This view is currently designed to SPECIFICALLY load on data.openlinksw.com.  The default URI macro has NOT
-- been used here because it makes no sense on the target box which is actually my.usnet.private:8891 or
-- something similar.  If you want to use this view on another box, a simple search-replace should do the trick,
-- but search-replace just`data.openlinksw.com' because http:// is sometimes encoded and you would miss it.
--
--



sparql drop quad map virtrdf:product_portfolio2 ;
sparql drop quad map virtrdf:product_portfolio ;

sparql

prefix opl: <http://www.openlinksw.com/schemas/oplweb#>

drop iri class opl:DownloadLocation .
drop iri class opl:ComponentCategory .
drop iri class opl:Component .
drop iri class opl:ComponentArchive .
drop iri class opl:ComponentArchiveType .
drop iri class opl:ComponentCategory .
drop iri class opl:ComponentMode .
drop iri class opl:ComponentType .
drop iri class opl:DbmsEngine .
drop iri class opl:DbmsFamily .
drop iri class opl:DownloadProtocol .
drop iri class opl:DownloadPartner .
drop iri class opl:FeatureBenefit .
drop iri class opl:Opsys .
drop iri class opl:OpsysFamily .
drop iri class opl:OpsysType .
drop iri class opl:Processor .
drop iri class opl:ProcessorFamily .
drop iri class opl:ProcessorMode .
drop iri class opl:ProductRelease .
drop iri class opl:Product .
drop iri class opl:ProductCategory .
drop iri class opl:ProductCategoryFeature .
drop iri class opl:ProductPortfolio .
drop iri class opl:ProductFamily .
drop iri class opl:ProductFamilyFeature .
drop iri class opl:ProductFeatureCategory .
drop iri class opl:ProductFeature .
drop iri class opl:ProductFormat .
drop iri class opl:ProductFormatCategory .
drop iri class opl:ProductFormatFeature .
drop iri class opl:ProductReleaseFeature .
drop iri class opl:ProductBenefit .
drop iri class opl:ProductBenefitCategory .
drop iri class opl:Vendor .
drop iri class opl:VendorCategory .
drop iri class opl:VendorCategoryFamily .
drop iri class opl:PriceType .
drop iri class opl:PriceUnitType .
drop iri class opl:PriceUnitIncrementalDiscount .
drop iri class opl:ProductPrice .
drop iri class opl:LicenseType .
drop iri class opl:LicenseModel .
drop iri class opl:LicenseClass .
drop iri class opl:Discount .
drop literal class opl:lit_product_release_label .
drop literal class opl:lit_format_cat_label .
drop literal class opl:lit_openlink_logo .
drop iri class opl:lit_openlink_logo .
drop literal class opl:lit_homepage .
drop iri class opl:lit_homepage .
drop literal class opl:lit_opsys_icon .
drop iri class opl:lit_opsys_icon .
drop literal class opl:lit_to_shop .
drop iri class opl:lit_to_shop .
drop literal class opl:lit_license_model_type .
drop literal class opl:lit_license_model_explain .
drop literal class opl:lit_shop_sample .
drop literal class opl:lit_wikipedia_to_dbpedia .
drop iri class opl:lit_wikipedia_to_dbpedia .
drop literal class opl:lit_to_string .
drop iri class opl:wwwsitefamily .
drop iri class opl:wwwsiteformat .
drop iri class opl:wwwsitecategory .
drop iri class opl:wwwsiteproduct .
;

DB.DBA.RDF_AUDIT_METADATA (1, '*');


sparql

prefix opl: <http://www.openlinksw.com/schemas/oplweb#>

create iri class opl:Component "http://data.openlinksw.com/oplweb/component/%s#this"
	(in component_name varchar not null) .

create iri class opl:ComponentArchive "http://data.openlinksw.com/oplweb/component_archive/%s#this"
	(in component_archive_name varchar not null) .

create iri class opl:ComponentArchiveType using
	function oplweb2.oplweb.COMPONENT_CATEGORY_URI (in _id integer not null)
		returns varchar,
	function oplweb2.oplweb.COMPONENT_CATEGORY_URI_INVERSE (in _iri varchar)
		returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/component_archive_type/%s#this' ).


create iri class opl:ComponentCategory using
	function oplweb2.oplweb.COMPONENT_CATEGORY_URI (in _id integer not null)
		returns varchar,
	function oplweb2.oplweb.COMPONENT_CATEGORY_URI_INVERSE (in _iri varchar)
		returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/component_category/%s#this' ).

create iri class opl:ComponentMode using
	function oplweb2.oplweb.COMPONENT_MODE_URI (in _id integer not null)
		returns varchar,
	function oplweb2.oplweb.COMPONENT_MODE_URI_INVERSE (in _iri varchar)
		returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/component_mode/%s#this' ).

create iri class opl:ComponentType using
	function oplweb2.oplweb.COMPONENT_TYPE_URI (in _id integer not null)
		returns varchar,
	function oplweb2.oplweb.COMPONENT_TYPE_URI_INVERSE (in _iri varchar)
		returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/component_type/%s#this' ).

create iri class opl:DbmsFamily using
	function oplweb2.oplweb.DBMS_FAMILY_URI (in _family_id integer not null)
		returns varchar,
	function oplweb2.oplweb.DBMS_FAMILY_URI_INVERSE (in _iri varchar)
		returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/dbms_family/%s#this' ).

create iri class opl:DbmsEngine "http://data.openlinksw.com/oplweb/dbms_engine/%s#this"
	(in dbms_name varchar not null) .

create iri class opl:DownloadLocation using
	function oplweb2.oplweb.DOWNLOAD_LOCATION_URI (in uri varchar not null)
		returns varchar,
	function oplweb2.oplweb.DOWNLOAD_LOCATION_URI_INVERSE (in dl_iri varchar)
		returns varchar
	option (bijection, returns 'http://data.openlinksw.com/oplweb/download_location/%s#this' ).

create iri class opl:DownloadProtocol "http://data.openlinksw.com/oplweb/download_protocol/%s#this"
	(in protocol_name varchar not null) .

create iri class opl:DownloadPartner "http://data.openlinksw.com/oplweb/download_partner/%s/%s#this"
	(
	  in host_name varchar not null,
	  in domain_name varchar not null
	) .

create iri class opl:FeatureBenefit using
  function oplweb2.oplweb.FEATURE_BENEFIT_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.FEATURE_BENEFIT_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/feature_benefit/%s#this' ).

create iri class opl:Opsys "http://data.openlinksw.com/oplweb/opsys/%s#this"
	(in opsys_name varchar not null) .

create iri class opl:OpsysFamily 	using
  function oplweb2.oplweb.OPSYS_FAMILY_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.OPSYS_FAMILY_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/opsys_family/%s#this' ).

create iri class opl:OpsysType 			using
  function oplweb2.oplweb.OPSYS_TYPE_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.OPSYS_TYPE_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/opsys_type/%s#this' ).

create iri class opl:Processor "http://data.openlinksw.com/oplweb/processor/%s/%d#this"
	(in processor_name varchar not null, in processor_mode_id integer not null) .

create iri class opl:ProcessorFamily 	using
  function oplweb2.oplweb.PROCESSOR_FAMILY_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.PROCESSOR_FAMILY_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/processor_family/%s#this' ).

create iri class opl:ProcessorMode 			using
  function oplweb2.oplweb.PROCESSOR_MODE_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.PROCESSOR_MODE_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/processor_mode/%s#this' ).

create iri class opl:Product "http://data.openlinksw.com/oplweb/product/%s#this"
	(in product_id varchar not null) .

create iri class opl:ProductCategory "http://data.openlinksw.com/oplweb/product_category/%s#this"
	(in product_cat_code varchar not null) .

create iri class opl:ProductCategoryFeature 	using
  function oplweb2.oplweb.PRODUCT_CATEGORY_FEATURE_URI (in _id integer not null) returns varchar,
		function oplweb2.oplweb.PRODUCT_CATEGORY_FEATURE_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/product_category_feature/%s#this' ).

create iri class opl:ProductPortfolio "http://data.openlinksw.com/oplweb/portfolio/%s#this"
	(in x varchar not null) .

create iri class opl:ProductFamily "http://data.openlinksw.com/oplweb/product_family/%s#this"
	(in product_family_code varchar not null) .

create iri class opl:ProductFamilyFeature 	using
  function oplweb2.oplweb.PRODUCT_FAMILY_FEATURE_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.PRODUCT_FAMILY_FEATURE_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/product_family_feature/%s#this' ).

create iri class opl:ProductFeatureCategory 			using
  function oplweb2.oplweb.PRODUCT_FEATURE_CATEGORY_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.PRODUCT_FEATURE_CATEGORY_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/product_feature_category/%s#this' ).

create iri class opl:ProductFeature 					using
  function oplweb2.oplweb.PRODUCT_FEATURE_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.PRODUCT_FEATURE_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/product_feature/%s#this' ).

create iri class opl:ProductFormat "http://data.openlinksw.com/oplweb/product_format/%s#this"
	(in product_format_code varchar not null) .

create iri class opl:ProductFormatCategory "http://data.openlinksw.com/oplweb/product_format_category/%s/%s#this"
	(in product_format_code varchar not null, in product_cat_code varchar not null) .

create iri class opl:ProductFormatFeature 	using
  function oplweb2.oplweb.PRODUCT_FORMAT_FEATURE_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.PRODUCT_FORMAT_FEATURE_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/product_format_feature/%s#this' ).

create iri class opl:ProductReleaseFeature 			using
  function oplweb2.oplweb.PRODUCT_RELEASE_FEATURE_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.PRODUCT_RELEASE_FEATURE_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/product_release_feature/%s#this' ).

create iri class opl:ProductBenefit 					using
  function oplweb2.oplweb.PRODUCT_BENEFIT_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.PRODUCT_BENEFIT_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/product_benefit/%s#this' ).

create iri class opl:ProductBenefitCategory 							using
  function oplweb2.oplweb.PRODUCT_BENEFIT_CATEGORY_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.PRODUCT_BENEFIT_CATEGORY_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/product_benefit_category/%s#this' ).

create iri class opl:ProductRelease "http://data.openlinksw.com/oplweb/product_release/%s/%s/%s/%s#this"
	(
	 in product_id varchar not null,
	 in product_release_id varchar not null,
	 in opsys_name varchar not null,
	 in dbms_name varchar not null
	) .

create iri class opl:Vendor 	using
  function oplweb2.oplweb.VENDOR_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.VENDOR_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/vendor/%s#this' ).

create iri class opl:VendorCategory 			using
  function oplweb2.oplweb.VENDOR_CATEGORY_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.VENDOR_CATEGORY_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/vendor_category/%s#this' ).

create iri class opl:VendorCategoryFamily 					using
  function oplweb2.oplweb.VENDOR_CATEGORY_FAMILY_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.VENDOR_CATEGORY_FAMILY_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/vendor_category_family/%s#this' ).

create iri class opl:PriceType "http://data.openlinksw.com/oplweb/price_type/%d#this"
    (in product_price_type_id integer not null) .

create iri class opl:LicenseType using
  function oplweb2.oplweb.LICENSE_MODEL_TYPE_URI (in _id integer not null) returns varchar,
  function oplweb2.oplweb.LICENSE_MODEL_TYPE_URI_INVERSE (in _iri varchar) returns integer
	option (bijection, returns 'http://data.openlinksw.com/oplweb/license_type/%s#this' ).

create iri class opl:PriceUnitType "http://data.openlinksw.com/oplweb/price_unit_type/%s_%s_%d_%d_%d_%s#this"
    (
    in product_release_id varchar not null,
    in product_id varchar not null,
    in opsys_family_id integer not null,
    in dbms_family_id integer not null,
    in product_price_type_id integer not null,
	in product_price_unit_type_id varchar not null) .

create iri class opl:PriceUnitIncrementalDiscount "http://data.openlinksw.com/oplweb/price_unit_discount/%s_%s_%d_%d_%d_%s#this"
    (
    in product_release_id varchar not null,
    in product_id varchar not null,
    in opsys_family_id integer not null,
    in dbms_family_id integer not null,
    in product_price_type_id integer not null,
	in product_price_unit_type_id varchar not null) .

create iri class opl:ProductPrice "http://data.openlinksw.com/oplweb/product_price/%d#this"
    (in product_price_id integer not null) .


create iri class opl:LicenseModel "http://data.openlinksw.com/oplweb/license_model/%s_%s_%d_%d_%d#this"
    (
      in product_release_id varchar not null,
      in product_id varchar not null,
      in opsys_family_id integer not null,
      in dbms_family_id integer not null,
	  in product_price_type_id integer not null
    ) .

create iri class opl:Discount "http://data.openlinksw.com/oplweb/discount/%s/%d/%s/%d/%d/%d#this"
    (
      in product_release_id varchar not null,
      in opsys_type_id integer not null,
      in product_id varchar not null,
      in opsys_family_id integer not null,
      in dbms_family_id integer not null,
      in product_price_type_id integer not null
    ) .

create iri class opl:wwwsitefamily "http://%s.openlinksw.com/"
    (
      in product_family_code varchar not null
    ) .

create iri class opl:wwwsitecategory "http://%s.openlinksw.com/%s/"
    (
      in product_family_code varchar not null,
      in product_category_code varchar not null
    ) .

create iri class opl:wwwsiteformat "http://%s.openlinksw.com/%s/%s/"
    (
      in product_family_code varchar not null,
      in product_category_code varchar not null,
      in product_format_code varchar not null
    ) .

create iri class opl:Uri "%s"
    ( in uri varchar not null
		) .

create literal class opl:lit_product_release_label using
	function oplweb2.oplweb.LIT_PRODUCT_RELEASE_LABEL(
		in _product_id varchar, in _id integer, in _opsys_name varchar, in _dbms_name varchar
		)
	returns varchar .

create literal class opl:lit_format_cat_label using
	function oplweb2.oplweb.LIT_FORMAT_CAT_LABEL(
		in _format integer, in _cat integer
		)
	returns varchar .

create iri class opl:lit_openlink_logo using
  function oplweb2.oplweb.LITRDF_openlink_logo(
    in _code varchar
  )
	returns varchar .

create iri class opl:lit_homepage using
  function oplweb2.oplweb.LITRDF_homepage(
    in _code varchar
  )
	returns varchar .

create iri class opl:lit_opsys_icon using
  function oplweb2.oplweb.LITRDF_opsys_icon(
    in _id integer
  )
	returns varchar .

create iri class opl:lit_to_shop using
  function oplweb2.oplweb.LITRDF_to_shop(
	in release_id varchar,
	in product_id varchar,
	in opsys varchar,
	in dbms varchar
  )
  returns varchar .

create literal class opl:lit_license_model_type using
	function oplweb2.oplweb.LITRDF_license_model_type (
		in _product_price_type_id integer
	)
	returns varchar .

create literal class opl:lit_license_model_explain using
	function oplweb2.oplweb.LITRDF_license_model_explain (
		in _product_price_type_id integer
	)
	returns varchar .

create literal class opl:lit_shop_sample using
	function oplweb2.oplweb.LITRDF_shop_sample (
	  in release_id varchar,
	  in product_id varchar,
	  in opsys varchar,
  	  in dbms varchar
	)
	returns varchar .

create iri class opl:lit_wikipedia_to_dbpedia using
	function oplweb2.oplweb.LITRDF_wikipedia_to_dbpedia (
	  in wikipedia_url varchar
	)
	returns varchar .

create literal class opl:lit_to_string using
	function oplweb2.oplweb.LITRDF_to_string (
	  in _s varchar
	)
	returns varchar .

create iri class opl:wwwsiteproduct using
  function oplweb2.oplweb.wwwsiteproduct_URI (in _id varchar not null) returns varchar,
  function oplweb2.oplweb.wwwsiteproduct_URI_INVERSE (in _iri varchar) returns varchar
  .


make opl:ProductCategory 	subclass of opl:ProductFamily .
make opl:Product 			subclass of opl:ProductCategory .
make opl:Product 			subclass of opl:ProductFormat .
make opl:ProductRelease		subclass of opl:Product .
make opl:Opsys		 		subclass of opl:OpsysFamily .
make opl:DbmsEngine		 	subclass of opl:DbmsFamily .

;



DB.DBA.RDF_AUDIT_METADATA (1, '*');


sparql
prefix opl: <http://www.openlinksw.com/schemas/oplweb#>
prefix dc: <http://purl.org/dc/terms#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix oplds: <http://www.openlinksw.com/dataspace/organization/openlink#>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix umbel: <http://umbel.org/umbel/sc/>
prefix gr: <http://purl.org/goodrelations/v1#>

alter quad storage virtrdf:DefaultQuadStorage
from oplweb2.oplweb.component_archive as component_archive_tbl
from oplweb2.oplweb.component_archive_type as component_archive_type_tbl
from oplweb2.oplweb.component_category as component_category_tbl text literal component_category_long_description
from oplweb2.oplweb.component_mode as component_mode_tbl
from oplweb2.oplweb.component_type as component_type_tbl
from oplweb2.oplweb.components_for_rdfs as components_tbl
from oplweb2.oplweb.dbms_engine as dbms_engine_tbl
from oplweb2.oplweb.dbms_family as dbms_family_tbl
from oplweb2.oplweb.download_location as download_location_tbl
from oplweb2.oplweb.download_protocol as download_protocol_tbl
from oplweb2.oplweb.download_partner as download_partner_tbl
from oplweb2.oplweb.opsys as opsys_tbl
from oplweb2.oplweb.opsys_family as opsys_family_tbl
from oplweb2.oplweb.opsys_type as opsys_type_tbl
from oplweb2.oplweb.processor_family as processor_family_tbl
from oplweb2.oplweb.processor_mode as processor_mode_tbl
from oplweb2.oplweb.processors as processors_tbl
from oplweb2.oplweb.product as product_tbl text literal long_description
from oplweb2.oplweb.product_benefits as product_benefits_tbl text literal product_benefit_explanation
from oplweb2.oplweb.product_benefits_category as product_benefits_category_tbl
from oplweb2.oplweb.product_category as product_category_tbl
from oplweb2.oplweb.product_category_features_with_code as product_category_features_tbl text literal long_description
from oplweb2.oplweb.product_family as product_family_tbl
from oplweb2.oplweb.product_family as product_family_tbl_2
from oplweb2.oplweb.product_family_features_with_code as product_family_features_tbl text literal long_description
from oplweb2.oplweb.product_features as product_features_tbl text literal long_description
from oplweb2.oplweb.product_feature_category as product_feature_category_tbl text literal description
from oplweb2.oplweb.product_format_features_with_code as product_format_features_tbl text literal long_description
from oplweb2.oplweb.product_release_features as product_release_features_tbl text literal long_description
from oplweb2.oplweb.product_release_with_family as product_release_tbl
from oplweb2.oplweb.vendor_category as vendor_category_tbl
from oplweb2.oplweb.vendor_category_family as vendor_category_family_tbl
from oplweb2.oplweb.vendors as vendors_tbl
from oplweb2.oplweb.product_formats_categories as product_formats_categories
from oplweb2.oplweb.product_with_code as product_with_code
from oplweb2.oplweb.product_category_with_code as product_category_with_code
from oplweb2.oplweb.product_format as product_format_with_code
from oplweb2.oplweb.product_price as pp
from oplweb2.oplweb.product_price_type as pt
from oplweb2.DBA.license_model_unit_type as put
from oplweb2.DBA.license_model_unit_type as put2
from oplweb2.DBA.license_model as lm
from oplweb2.DBA.license_model as lm2
from oplweb2.DBA.license_model_type as license_model_type_tbl
from oplweb2.DBA.product_price_varchar as ppv
from oplweb2.DBA.product_general_discount_vc as gd
from oplweb2.oplweb.archive_coverage_osdb as ac1
{
	create virtrdf:product_portfolio as
		graph <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>
	{
  opl:ProductPortfolio(product_family_tbl.product_family_code)
    a opl:ProductPortfolio
    as virtrdf:OplProductPortfolio .

  opl:ProductPortfolio(product_family_tbl.product_family_code) opl:hasProductFamilies
    opl:ProductFamily(product_family_tbl.product_family_code)
	as virtrdf:OplProductPortfolioProductFamily .

	  opl:ProductFamily(product_family_tbl.product_family_code)
	    a opl:ProductFamily
	    as virtrdf:OplProductFamily ;
	  rdfs:label product_family_tbl.product_family_description
	    as virtrdf:rdfsOplProductFamilyDescription ;
	  foaf:name 	product_family_tbl.product_family_description
		    as virtrdf:nameOplProductFamilyDescription ;
	  foaf:logo  opl:lit_openlink_logo(product_family_tbl.product_family_code)
	        as virtrdf:logoOpenLinkSoftware ;
	  foaf:homepage opl:lit_homepage(product_family_tbl.product_family_code)
	        as virtrdf:homepageProductFamily ;
	  foaf:homepage opl:wwwsitefamily(product_family_tbl.product_family_code)
#	    where (
#			^{product_family_tbl.}^.product_family_code = 'uda'
#		)
	        as virtrdf:homepageProductFamilyUda ;
	  foaf:maker oplds:this
	        as virtrdf:OplDataspaceOpenLinkUri ;
  	  owl:sameAs product_family_tbl.dbpedia_uri
        as virtrdf:OplFamilyOwlSameAsDBPediaUri ;
	  opl:ProductFamilyCode product_family_tbl.product_family_code
	    as virtrdf:OplProductFamilyCode ;
	  opl:ProductFamilyDescription product_family_tbl.product_family_description
	    as virtrdf:OplProductFamilyDescription ;
	  dc:description opl:lit_to_string(product_family_tbl.long_description)
	    as virtrdf:OplProductFamilyLongDescription 		;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy foaf: ;
      rdfs:isDefinedBy dc: ;
      rdfs:isDefinedBy owl: ;
      rdfs:isDefinedBy rdfs:
		.

	  opl:ProductCategory(product_category_with_code.product_cat_code)
	    a opl:ProductCategory
	    as virtrdf:OplProductCategory ;
	    a opl:ProductFamily
	    as virtrdf:OplProductCategorySubClassOfProductFamily ;
	  rdfs:label product_category_with_code.product_category_description
	    as virtrdf:rdfsOplProductCategoryDescription ;
	  foaf:homepage opl:wwwsitecategory(product_category_with_code.product_family_code, product_category_with_code.product_cat_code)
#	    where (
#			^{product_category_with_code.}^.product_family_code = 'uda'
#		)
	        as virtrdf:homepageProductFamilyCategoryUda ;
	  opl:ProductCategoryCode product_category_with_code.product_cat_code
	    as virtrdf:OplProductCategoryCode ;
  	  owl:sameAs product_category_with_code.dbpedia_uri
        as virtrdf:OplCategoryOwlSameAsDBPediaUri ;
	  opl:hasFamily opl:ProductFamily(product_category_with_code.product_family_code)
	    as virtrdf:OplProductCategoryIsOfFamily ;
	  opl:ProductCategoryDescription product_category_with_code.product_category_description
	    as virtrdf:OplProductCategoryDescription ;
	  dc:description opl:lit_to_string(product_category_with_code.long_description)
	    as virtrdf:OplProductCategoryLongDescription ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs: ;
      rdfs:isDefinedBy foaf: ;
      rdfs:isDefinedBy dc: ;
      rdfs:isDefinedBy owl:
		.

	  opl:ProductFormat(product_format_with_code.product_format_code)
	    a opl:ProductFormat
	    as virtrdf:OplProductFormat ;
	  opl:ProductFormatCode product_format_with_code.product_format_code
	    as virtrdf:OplProductFormatCode ;
	  rdfs:label product_format_with_code.product_format_description
	    as virtrdf:rdfsOplProductFormatDescription ;
	  dc:description product_format_with_code.product_format_description
	    as virtrdf:OplProductFormatDescription ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs: ;
      rdfs:isDefinedBy dc:
		.

	  opl:ProductFormatCategory(product_formats_categories.product_format_code, product_formats_categories.product_cat_code)
	    a opl:ProductFormatCategory
	    as virtrdf:OplProductFormatCategory ;
	    a opl:ProductFormat
	    as virtrdf:OplProductFormatCategoryProductFormat ;
	    a opl:ProductCategory
	    as virtrdf:OplProductFormatCategoryProductCategory ;
	  foaf:homepage opl:wwwsiteformat(product_category_with_code.product_family_code, product_formats_categories.product_cat_code, product_formats_categories.product_format_code)
	    where (
			^{product_category_with_code.}^.product_cat_code = ^{product_formats_categories.}^.product_cat_code
#			and
#			^{product_category_with_code.}^.product_family_code = 'uda'
		)
	        as virtrdf:homepageProductFamilyCategoryFormatUda ;
	  opl:ProductFormatCode product_formats_categories.product_format_code
	    as virtrdf:OplProductFormatCategoryFormatCode ;
	  opl:ProductCategoryCode product_formats_categories.product_cat_code
	    as virtrdf:OplProductFormatCategoryCategoryCode ;
      opl:isProductCategory opl:ProductCategory(product_formats_categories.product_cat_code)
        as virtrdf:OplProductFormatCategoryisCategory ;
      opl:isProductFormat opl:ProductFormat(product_formats_categories.product_format_code)
        as virtrdf:OplProductFormatCategoryisFormat ;
	  rdfs:label opl:lit_format_cat_label(product_formats_categories.product_format_id, product_formats_categories.product_cat_id)
	    as virtrdf:rdfsOplProductFormatCategoryDescription ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy foaf: ;
      rdfs:isDefinedBy rdfs:
		.


	  opl:ProductCategory(product_category_with_code.product_cat_code) opl:hasProduct
	    opl:Product(product_with_code.product_id)
	      where (^{product_with_code.}^.product_cat_id = ^{product_category_with_code.}^.product_cat_id)
	    as virtrdf:OplProductCategoryIsCategoryOfProduct .

	  opl:ProductFormat(product_format_with_code.product_format_code) opl:hasProduct
	    opl:Product(product_with_code.product_id)
	      where (^{product_with_code.}^.product_format_id = ^{product_format_with_code.}^.product_format_id)
	    as virtrdf:OplProductFormatIsFormatOfProduct .

	  opl:ProductFamily(product_family_tbl.product_family_code) opl:hasCategory
	    opl:ProductCategory(product_category_with_code.product_cat_code)
	      where (^{product_family_tbl.}^.product_family_id = ^{product_category_with_code.}^.product_family_id)
	    as virtrdf:OplProductFamilyIsFamilyOfProductCategory .

	  opl:ProductFamily(product_family_tbl.product_family_code) opl:hasFormat
	    opl:ProductFormat(product_formats_categories.product_format_code)
	      where (
		    ^{product_family_tbl.}^.product_family_id = ^{product_formats_categories.}^.product_family_id
		  )
	    as virtrdf:OplProductFamilyIsFamilyOfProductFormats .

	  opl:ProductFamily(product_family_tbl.product_family_code) opl:otherProductFamilies
	    opl:ProductFamily(product_family_tbl_2.product_family_code)
	      where (
		    ^{product_family_tbl.}^.product_family_id <> ^{product_family_tbl_2.}^.product_family_id
		  )
	    as virtrdf:OplProductFamilyHasOtherProductFamilies .

	  opl:ProductFormat(product_format_with_code.product_format_code) opl:hasCategory
	    opl:ProductFormatCategory(product_formats_categories.product_format_code, product_formats_categories.product_cat_code)
	      where (^{product_formats_categories.}^.product_format_id = ^{product_format_with_code.}^.product_format_id)
	    as virtrdf:OplProductFormatIsFormatOfProductFormatCategories .

	  opl:ProductFormatCategory(product_formats_categories.product_format_code, product_formats_categories.product_cat_code)
	    opl:hasProduct
	    opl:Product(product_with_code.product_id)
	      where (
		    ^{product_with_code.}^.product_cat_id = ^{product_formats_categories.}^.product_cat_id
		    and
		    ^{product_with_code.}^.product_format_id = ^{product_formats_categories.}^.product_format_id
		  )
	    as virtrdf:OplProductFormatCategoryIsFormatCategoryOfProduct .



	  opl:VendorCategoryFamily(vendor_category_family_tbl.vendor_category_family_id)
	    a opl:VendorCategoryFamily
	    as virtrdf:OplVendorCategoryFamily ;
	  opl:VendorCategoryFamilyDescription vendor_category_family_tbl.vendor_category_family_desc
	    as virtrdf:OplVendorCategoryFamilyDesc .


	  opl:VendorCategory(vendor_category_tbl.vendor_category_id)
	    a opl:VendorCategory
	    as virtrdf:OplVendorCategory ;
	    a opl:VendorCategoryFamily
	    as virtrdf:OplVendorCategorySubClassOfVendorCategoryFamily ;
	  rdfs:label vendor_category_tbl.vendor_category_description
	    as virtrdf:rdfsOplVendorCategoryDescription ;
	  opl:VendorCategoryDescription vendor_category_tbl.vendor_category_description
	    as virtrdf:OplVendorCategoryDescription ;
	  opl:isVendorCategoryOf opl:VendorCategoryFamily(vendor_category_tbl.vendor_category_family_id)
	    as virtrdf:OplVendorCategoryIsOfCategoryFamily ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.

	  opl:Vendor(vendors_tbl.vendor_id)
	    a opl:Vendor
	    as virtrdf:OplVendor ;
	    a opl:VendorCategory
	    as virtrdf:OplVendorSubClassOfVendorCategory ;
	  rdfs:label vendors_tbl.vendor_name
	    as virtrdf:rdfsOplVendorsName ;
	  opl:VendorName vendors_tbl.vendor_name
	    as virtrdf:OplVendorsName ;
	  opl:WikipediaPage opl:Uri(vendors_tbl.wikipedia_url)
	    as virtrdf:OplVendorsWikipediaUrl ;
	  owl:sameAs opl:lit_wikipedia_to_dbpedia(vendors_tbl.wikipedia_url)
	    as virtrdf:OplVendorsWikipediaUrlOwlSameAs ;
	  foaf:homepage opl:Uri(vendors_tbl.vendor_homepage)
	    as virtrdf:OplFoafVendorHomepage ;
	  opl:isOfVendorCategory opl:VendorCategory(vendors_tbl.vendor_category_id)
	    as virtrdf:OplVendorIsOfVendorCategory ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs: ;
      rdfs:isDefinedBy foaf: ;
      rdfs:isDefinedBy owl:
		.

	  opl:VendorCategoryFamily(vendor_category_family_tbl.vendor_category_family_id)
	    opl:hasVendorCategory
	    opl:VendorCategory(vendor_category_tbl.vendor_category_id)
	      where (
		    ^{vendor_category_family_tbl.}^.vendor_category_family_id = ^{vendor_category_tbl.}^.vendor_category_family_id
		  )
	    as virtrdf:OplVendorCategoryFamilyHasVendorCategory .

      opl:VendorCategory(vendor_category_tbl.vendor_category_id)
	    opl:hasVendorCategory
  	    opl:Vendor(vendors_tbl.vendor_id)
	      where (
		    ^{vendor_category_tbl.}^.vendor_category_id = ^{vendors_tbl.}^.vendor_category_id
		  )
	    as virtrdf:OplVendorCategoryHasVendors .

  	opl:OpsysFamily(opsys_family_tbl.opsys_family_id)
	    a opl:OpsysFamily
	    as virtrdf:OplOpsysFamily ;
	  rdfs:label opsys_family_tbl.opsys_family_name
  	  as virtrdf:rdfsOplOpsysFamilyName ;
	  opl:OpsysFamilyName opsys_family_tbl.opsys_family_name
  	  as virtrdf:OplOpsysFamilyName ;
  	opl:OpsysFamilyLicenseCode opsys_family_tbl.opsys_license_code
	    as virtrdf:OplOpsysFamilyLicenseCode ;
	  opl:OpsysFamilyVendor opl:Vendor(opsys_family_tbl.vendor_id)
  	  as virtrdf:OplOpsysFamilyVendor ;
  	opl:OpsysFamilyRating opsys_family_tbl.rating
	    as virtrdf:OplOpsysFamilyRating ;
	foaf:logo opl:lit_opsys_icon(opsys_family_tbl.opsys_family_id)
	  as virtrdf:OplLogoOpsysFamily ;
	foaf:homepage opl:Uri(opsys_family_tbl.wikipedia_url)
	  as virtrdf:FoafHomepageOpsysFamilyWikipediaUrl ;
	owl:sameAs opl:lit_wikipedia_to_dbpedia(opsys_family_tbl.wikipedia_url)
	  as virtrdf:FoafHomepageOpsysFamilyPediaUrlOwlSameAs ;
	opl:WikipediaPage opl:Uri(opsys_family_tbl.wikipedia_url)
	  as virtrdf:OplOpsysFamilyWikipediaUrl ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs: ;
      rdfs:isDefinedBy foaf: ;
      rdfs:isDefinedBy owl:
		.

	  opl:OpsysFamily(opsys_family_tbl.opsys_family_id) opl:hasOpsys
	    opl:Opsys(opsys_tbl.opsys_name)
	    where (^{opsys_tbl.}^.opsys_family_id = ^{opsys_family_tbl.}^.opsys_family_id)
	    as virtrdf:OplOpsysFamilyIsOpsysFamilyOfOpsys .


	  opl:DbmsFamily(dbms_family_tbl.dbms_family_id)
  	  a opl:DbmsFamily
	    as virtrdf:OplDbmsFamily ;
	  rdfs:label dbms_family_tbl.dbms_family_name
  	  as virtrdf:rdfsOplDbmsFamilyName ;
	  opl:DbmsFamilyName dbms_family_tbl.dbms_family_name
  	  as virtrdf:OplDbmsFamilyName ;
  	opl:DbmsFamilyVendor opl:Vendor(dbms_family_tbl.vendor_id)
      as virtrdf:OplDbmsFamilyVendor ;
	foaf:homepage opl:Uri(dbms_family_tbl.wikipedia_url)
 	  as virtrdf:FoafHomepageDbmsFamilyWikipediaUrl ;
	owl:sameAs opl:lit_wikipedia_to_dbpedia(dbms_family_tbl.wikipedia_url)
 	  as virtrdf:OwnSameAsDbmsFamilyPediaUrl ;
	opl:WikipediaPage opl:Uri(dbms_family_tbl.wikipedia_url)
	  as virtrdf:OplDbmsFamilyWikipediaUrl ;
	  opl:DbmsFamilyRating dbms_family_tbl.rating
  	  as virtrdf:OplDbmsFamilyRating ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs: ;
      rdfs:isDefinedBy foaf: ;
      rdfs:isDefinedBy owl:
		.

	  opl:DbmsEngine(dbms_engine_tbl.dbms_name)
  	  a opl:DbmsEngine
	    as virtrdf:OplDbmsEngine ;
  	  a opl:DbmsFamily
	    as virtrdf:DbmsEngineSubClassOfDbmsFamily ;
	    a umbel:RelationalDatabaseServerProgram
	    as virtrdf:DbmEngineSubClassOfUmbel ;
	  opl:isOfDbmsFamily opl:DbmsFamily(dbms_engine_tbl.dbms_family_id)
  	  as virtrdf:OplDbmsEngineisOfDbmsFamily ;
	  rdfs:label dbms_engine_tbl.dbms_name
  	  as virtrdf:rdfsOplLabelDbmsName ;
  	opl:DbmsEngineVersion dbms_engine_tbl.dbms_version
	    as virtrdf:OplDbmsEngineVersion ;
	  opl:DbmsEngineUpwardCompatible dbms_engine_tbl.upward_compatible
  	  as virtrdf:OplDbmsEngineUpwardCompatible ;
  	opl:DbmsEngineDownwardCompatible dbms_engine_tbl.downward_compatible
	    as virtrdf:OplDbmsEngineDownwardCompatible ;
	  opl:DbmsEngineRating dbms_engine_tbl.rating
  	  as virtrdf:OplDbmsEngineRating ;
  	opl:DbmsEngineOldArchiveCode dbms_engine_tbl.old_archive_code
	    as virtrdf:OplDbmsEngineOldArchiveCode ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.


  opl:DbmsFamily(dbms_family_tbl.dbms_family_id)
    opl:hasDatabaseVersions
    opl:DbmsEngine(dbms_engine_tbl.dbms_name)
    where (
        ^{dbms_family_tbl.}^.dbms_family_id = ^{dbms_engine_tbl.}^.dbms_family_id
    )
    as virtrdf:OplDbmsFamilyToDbms .


	  opl:OpsysType(opsys_type_tbl.opsys_type_id)
   	  a opl:OpsysType
	    as virtrdf:OplOpsysType ;
	  rdfs:label opsys_type_tbl.opsys_type_description
  	  as virtrdf:rdfsOplOpsysTypeDescription ;
	  opl:OpsysTypeDescription opsys_type_tbl.opsys_type_description
  	  as virtrdf:OplOpsysTypeDescription ;
  	opl:OpsysTypeShortDescription opsys_type_tbl.short_description
	    as virtrdf:OplOpsysTypeShortDescription ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.


	  opl:OpsysType(opsys_type_tbl.opsys_type_id) opl:hasOpsys
	    opl:Opsys(opsys_tbl.opsys_name)
	    where (^{opsys_tbl.}^.opsys_type_id = ^{opsys_type_tbl.}^.opsys_type_id)
	    as virtrdf:OplOpsysTypeIsOpsysTypeOfOpsys .


	  opl:ProcessorMode(processor_mode_tbl.processor_mode_id)
  	  a opl:ProcessorMode
	    as virtrdf:OplProcessorMode ;
	  opl:ProcessorModeName processor_mode_tbl.processor_mode_name
  	  as virtrdf:OplProcessorModeName .

  	opl:Processor(processors_tbl.processor_name, processors_tbl.processor_mode_id)
	    a opl:Processor
	    as virtrdf:OplProcessor ;
	  opl:ProcessorName processors_tbl.processor_name
  	  as virtrdf:OplProcessorName ;
  	opl:ProcessorVersion processors_tbl.processor_version
	    as virtrdf:OplProcessorVersion ;
	  rdfs:label processors_tbl.processor_description
  	  as virtrdf:rdfsOplProcessorDescription ;
	  opl:ProcessorDescription processors_tbl.processor_description
  	  as virtrdf:OplProcessorDescription ;
  	opl:ProcessorMode opl:ProcessorMode(processors_tbl.processor_mode_id)
	    as virtrdf:OplProcessorProcessorMode ;
	  opl:isOfProcessorFamily opl:ProcessorFamily(processors_tbl.processor_family_id)
  	  as virtrdf:OplProcessorIsOfProcessorFamily ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.

	opl:ProcessorFamily(processor_family_tbl.processor_family_id)
  	  a opl:ProcessorFamily
	    as virtrdf:OplProcessorFamily ;
    opl:ProcessorFamilyName processor_family_tbl.processor_family_name
  	  as virtrdf:OplProcessorFamilyName ;
    opl:ProcessorFamilyVendor opl:Vendor(processor_family_tbl.vendor_id)
	  as virtrdf:OplProcessorFamilyVendor ;
	foaf:homepage opl:Uri(processor_family_tbl.wikipedia_url)
	  as virtrdf:FoafHomepageProcessorFamilyWikipediaUrl ;
	owl:sameAs opl:lit_wikipedia_to_dbpedia(processor_family_tbl.wikipedia_url)
	  as virtrdf:OwlSameAsProcessorFamilyPediaUrl ;
    opl:WikipediaPage opl:Uri(processor_family_tbl.wikipedia_url)
	  as virtrdf:OplProcessorFamilyWikipediaUrl ;
	rdfs:label processor_family_tbl.processor_family_description
  	  as virtrdf:rdfsOplProcessorFamilyDescription ;
	opl:ProcessorFamilyDescription processor_family_tbl.processor_family_description
  	  as virtrdf:OplProcessorFamilyDescription ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy foaf: ;
      rdfs:isDefinedBy owl: ;
      rdfs:isDefinedBy rdfs:
		.

	  opl:Opsys(opsys_tbl.opsys_name)
  	  a opl:Opsys
	    as virtrdf:OplOpsys ;
  	  a opl:OpsysFamily
	    as virtrdf:OpsysSubClassOfOplOpsysFamily ;
  	  a umbel:OperatingSystem
	    as virtrdf:OpsysSubClassOfUmbelOpsys ;
	  opl:OpsysVersion opsys_tbl.opsys_version
  	  as virtrdf:OplOpsysVersion ;
  	opl:OpsysUpwardCompatible opsys_tbl.upward_compatible
	    as virtrdf:OplOpsysUpwardCompatible ;
	  opl:OpsysDownwardCompatible opsys_tbl.downward_compatible
  	  as virtrdf:OplOpsysDownwardCompatible ;
  	opl:OpsysSupported opsys_tbl.supported
	    as virtrdf:OplOpsysSupported ;
	  opl:OpsysLicenseCode opsys_tbl.opsys_license_code
  	  as virtrdf:OplOpsysLicenseCode ;
  	rdfs:label opsys_tbl.commercial_name
	    as virtrdf:rdfsOplOpsysCommercialName ;
  	opl:OpsysCommercialName opsys_tbl.commercial_name
	    as virtrdf:OplOpsysCommercialName ;
	  opl:OpsysEmulationMode opl:ProcessorMode(opsys_tbl.emulation_mode_id)
  	  as virtrdf:OplOpsysEmulationMode ;
  	opl:OpsysProcessor opl:Processor(opsys_tbl.processor_name, opsys_tbl.processor_mode_id)
	    as virtrdf:OplOpsysProcessor ;
	  opl:isOfOpsysFamily opl:OpsysFamily(opsys_tbl.opsys_family_id)
  	  as virtrdf:OplOpsysIsOfOpsysFamily ;
  	opl:isOfOpsysType opl:OpsysType(opsys_tbl.opsys_type_id)
	    as virtrdf:OplOpsysIsOfOpsysType ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.


	  opl:Product(product_with_code.product_id)
	    a opl:Product
	    as virtrdf:OplProduct ;
	    a opl:ProductFormat
	    as virtrdf:ProductSubClassOfProductFormat ;
	    a opl:ProductCategory
	    as virtrdf:ProductSubClassOfProductCategory ;
	    a opl:ProductFormatCategory
	    as virtrdf:OplProductProductFormatCategory ;
	  rdfs:label product_with_code.poduct_description
	    as virtrdf:rdfsOplProductDescription ;
	  foaf:homepage opl:wwwsiteproduct(product_with_code.product_id)
        as virtrdf:homepageProductFamilyCategoryFormatProductUda ;
	  opl:ProductDescription product_with_code.poduct_description
	    as virtrdf:OplProductDescription ;
	  dc:description opl:lit_to_string(product_with_code.long_description)
	    as virtrdf:OplProductLongDescription ;
	  opl:isOfCategory opl:ProductCategory(product_with_code.product_cat_code)
	    as virtrdf:OplProductIsOfCategory ;
	  opl:isOfFormat opl:ProductFormat(product_with_code.product_format_code)
	    as virtrdf:OplProductIsOfFormat ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy foaf: ;
      rdfs:isDefinedBy dc: ;
      rdfs:isDefinedBy rdfs:
		.


	  opl:Product(product_with_code.product_id) opl:hasProductRelease
	    opl:ProductRelease(
	      product_release_tbl.product_id,
	      product_release_tbl.product_release_id,
	      product_release_tbl.opsys_name,
	      product_release_tbl.dbms_name
	      )
	      where (^{product_with_code.}^.product_id = ^{product_release_tbl.}^.product_id)
	    as virtrdf:OplProductIsProductOfProductRelease .



	  opl:ProductRelease(
	      product_release_tbl.product_id,
	      product_release_tbl.product_release_id,
	      product_release_tbl.opsys_name,
	      product_release_tbl.dbms_name
	      )
	    a opl:ProductRelease
	    as virtrdf:OplProductRelease ;
	    a opl:Product
	    as virtrdf:OplProductReleaseSubClassProduct ;
		a gr:ProductOrService
		as virtrdf:OplProductReleaseAgrProductOrService ;
	  rdfs:label opl:lit_product_release_label(
	      product_release_tbl.product_id,
	      product_release_tbl.product_release_id,
	      product_release_tbl.opsys_name,
	      product_release_tbl.dbms_name
	  )
	    as virtrdf:rdfsOplProductReleaseProductReleaseId ;
	  opl:ProductReleaseProductReleaseId product_release_tbl.product_release_id
	    as virtrdf:OplProductReleaseProductReleaseId ;
	  opl:isOfProduct opl:Product(product_release_tbl.product_id)
	    as virtrdf:OplProductReleaseIsOfProduct ;
	  opl:isForOpsys opl:Opsys(product_release_tbl.opsys_name)
	    as virtrdf:OplProductReleaseIsForOpsys ;
	  opl:isForDbmsEngine opl:DbmsEngine(product_release_tbl.dbms_name)
	    as virtrdf:OplProductReleaseIsForDbmsEngine ;
  	  opl:UpwardCompatible product_release_tbl.upward_compatible
	    as virtrdf:OplProductReleaseUpwardCompatible ;
	  opl:DownwardCompatible product_release_tbl.downward_compatible
  	    as virtrdf:OplProductReleaseDownwardCompatible ;
      opl:PurchaseInShop opl:lit_to_shop (
	      product_release_tbl.product_release_id,
	      product_release_tbl.product_id,
	      product_release_tbl.opsys_name,
	      product_release_tbl.dbms_name
	 	)
   		as virtrdf:OplProductReleaseToShop ;
	  gr:hasBusinessFunction gr:Sell as virtrdf:grbusinessfunctionsell;
  	  opl:Supported product_release_tbl.supported
	    as virtrdf:OplProductReleaseSupported ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy gr:
		.

	  opl:ProductRelease(
	      product_release_tbl.product_id,
	      product_release_tbl.product_release_id,
	      product_release_tbl.opsys_name,
	      product_release_tbl.dbms_name
	      ) opl:hasComponentArchive
	  opl:ComponentArchive(component_archive_tbl.component_archive_name)
			where (
					^{product_release_tbl.}^.product_id = ^{component_archive_tbl.}^.product_id and
					^{product_release_tbl.}^.product_release_id = ^{component_archive_tbl.}^.product_release_id and
					^{product_release_tbl.}^.opsys_name = ^{component_archive_tbl.}^.opsys_name and
					^{product_release_tbl.}^.dbms_name = ^{component_archive_tbl.}^.dbms_name
			)
	    as virtrdf:OplProductReleaseIsProductReleaseOfComponentArchive .


	  opl:Component(components_tbl.component_name)
	    a opl:Component
	    as virtrdf:OplComponent ;
	  opl:isOfComponentCategory opl:ComponentCategory(components_tbl.component_category_id)
	    as virtrdf:OplComponentIsOfComponentCategory ;
	  opl:isOfComponentType opl:ComponentType(components_tbl.component_type_id)
	    as virtrdf:OplComponentIsOfComponentType ;
	  opl:isOfComponentMode opl:ComponentMode(components_tbl.component_mode_id)
	    as virtrdf:OplComponentIsOfComponentMode ;
	  opl:isForOpsys opl:Opsys(components_tbl.opsys_name)
	    as virtrdf:OplComponentIsForOpsys ;
	  opl:isForDbmsEngine opl:DbmsEngine(components_tbl.dbms_name)
	    as virtrdf:OplComponentIsForDbmsEngine ;
	  opl:ComponentCvsid components_tbl.component_cvsid
	    as virtrdf:OplComponentComponentCvsId ;
	  opl:ComponentBuildDate components_tbl.component_build_date
	    as virtrdf:OplComponentComponentBuildDate ;
	  opl:Notes components_tbl.notes
	    as virtrdf:OplComponentNotes ;
	  opl:BuildComments components_tbl.build_comments
	    as virtrdf:OplComponentBuildComments ;
	  opl:Filesize components_tbl.str_filesize
	    as virtrdf:OplComponentFilesize ;
      rdfs:isDefinedBy opl:
		.

    opl:DbmsEngine (dbms_engine_tbl.dbms_name) opl:hasComponents
      opl:Component(components_tbl.component_name)
      where (^{components_tbl.}^.dbms_name = ^{dbms_engine_tbl.}^.dbms_name)
      as virtrdf:OplDbmsEngineForComponents .

    opl:Opsys (opsys_tbl.opsys_name) opl:hasComponents
      opl:Component(components_tbl.component_name)
      where (^{components_tbl.}^.opsys_name = ^{opsys_tbl.}^.opsys_name)
      as virtrdf:OplOpsysForComponents .


	  opl:ComponentMode(component_mode_tbl.component_mode_id)
	    a opl:ComponentMode
	    as virtrdf:OplComponentMode ;
	  rdfs:label component_mode_tbl.component_mode_description
	    as virtrdf:rdfsOplComponentModeDescription ;
	  opl:ComponentModeDescription component_mode_tbl.component_mode_description
	    as virtrdf:OplComponentModeDescription ;
	  opl:ComponentModeShortDescription component_mode_tbl.short_description
	    as virtrdf:OplComponentModeShortDescription ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.

	  opl:ComponentType(component_type_tbl.component_type_id)
	    a opl:ComponentType
	    as virtrdf:OplComponentType ;
	  rdfs:label component_type_tbl.component_type_description
	    as virtrdf:rdfsOplComponentTypeDescription ;
	  opl:ComponentTypeDescription component_type_tbl.component_type_description
	    as virtrdf:OplComponentTypeDescription ;
	  opl:ComponentTypeShortDescription component_type_tbl.short_description
	    as virtrdf:OplComponentTypeShortDescription ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.

	  opl:ComponentCategory(component_category_tbl.component_category_id)
	    a opl:ComponentCategory
	    as virtrdf:OplComponentCategory ;
	  rdfs:label component_category_tbl.component_category_description
	    as virtrdf:rdfsOplComponentCategoryDescription ;
	  opl:ComponentCategoryDescription component_category_tbl.component_category_description
	    as virtrdf:OplComponentCategoryDescription ;
	  opl:ComponentCategoryShortDescription component_category_tbl.short_description
	    as virtrdf:OplComponentCateegoryShortDescription ;
	  dc:description opl:lit_to_string(component_category_tbl.component_category_long_description)
	    as virtrdf:OplComponentCategoryLongDescription ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.

	  opl:ComponentArchive(component_archive_tbl.component_archive_name)
	    a opl:ComponentArchive
	    as virtrdf:OplComponentArchive ;
	    a opl:Component
	    as virtrdf:ComponentArchiveSubClassOfComponent ;
	  opl:ComponentArchiveName component_archive_tbl.component_archive_name
	    as virtrdf:OplComponentArchiveComponentArchiveName ;
	  rdfs:label component_archive_tbl.component_archive_name
	    as virtrdf:rdfsComponentArchiveComponentArchiveName ;
  	opl:ComponentArchiveType opl:ComponentArchiveType(component_archive_tbl.component_archive_type_id)
	  	as virtrdf:ComponentArchiveComponentArchiveType ;
	  opl:isOfComponent opl:Component(component_archive_tbl.component_name)
	    as virtrdf:OplComponentArchiveIsOfComponent ;
	  opl:isOfProductRelease opl:ProductRelease(
	      component_archive_tbl.product_id,
	      component_archive_tbl.product_release_id,
	      component_archive_tbl.opsys_name,
	      component_archive_tbl.dbms_name
	      )
	    as virtrdf:OplComponentArchiveIsOfProductRelease ;
  	opl:AssemblyDate component_archive_tbl.assembly_date
	  	as virtrdf:OplComponentArchiveAssemblyDate ;
	  opl:FileUri component_archive_tbl.file_uri
  		as virtrdf:OplComponentArchiveFileUri ;
  	opl:LicenseCode component_archive_tbl.license_code
		  as virtrdf:OplComponentArchiveLicenseCode ;
	  opl:ResFullPath component_archive_tbl.res_full_path
  		as virtrdf:OplComponentArchiveResFullPath ;
  	opl:ResName component_archive_tbl.res_name
		  as virtrdf:OplComponentArchiveResName ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.


	opl:ComponentArchiveType(component_archive_type_tbl.component_archive_type_id)
	  a opl:ComponentArchiveType
		as virtrdf:OplComponentArchiveType ;
	opl:ComponentArchiveShortName component_archive_type_tbl.component_archive_short_name
		as virtrdf:OplComponentArchiveTypeComponentArchiveShortName ;
	rdfs:label component_archive_type_tbl.component_archive_type_name
		as virtrdf:rdfsOplComponentArchiveTypeComponentArchiveTypeName ;
	opl:ComponentArchiveTypeName component_archive_type_tbl.component_archive_type_name
		as virtrdf:OplComponentArchiveTypeComponentArchiveTypeName ;
	opl:Extension component_archive_type_tbl.extension
		as virtrdf:OplComponentArchiveTypeExtension ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.


	opl:DownloadLocation(download_location_tbl.uri)
	  a opl:DownloadLocation
		as virtrdf:OplDownloadLocation ;
	opl:isOfComponentArchive opl:ComponentArchive(download_location_tbl.component_archive_name)
		as virtrdf:OplDownloadLocationIsOfComponentArchive ;
	opl:hasDownloadProtocol opl:DownloadProtocol(download_location_tbl.protocol_name)
		as virtrdf:DownloadLocationHasProtocolName ;
	rdfs:label download_location_tbl.uri_old
		as virtrdf:rdfsOplDownloadLocationLabel ;
	opl:isOfProductRelease opl:ProductRelease(
		download_location_tbl.product_id,
		download_location_tbl.product_release_id,
		download_location_tbl.opsys_name,
		download_location_tbl.dbms_name
		)
		as virtrdf:OplDownloadLocationIsOfProductRelease ;
	opl:Uri download_location_tbl.uri
		as virtrdf:OplDownloadLocationUri ;
	opl:UriOld download_location_tbl.uri_old
		as virtrdf:OplDownloadLocationUriOld ;
    opl:hasDownloadPartner opl:DownloadPartner(
        download_location_tbl.host_name,
        download_location_tbl.domain_name
      )
        as virtrdf:OplDownloadLocationHasDownloadPartner ;
	opl:DomainName download_location_tbl.domain_name
		as virtrdf:OplDownloadLocationDomainName ;
	opl:HostName download_location_tbl.host_name
		as virtrdf:OplDownloadLocationHostName ;
	opl:ResName download_location_tbl.res_name
		as virtrdf:OplDownloadLocationResName ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.

	opl:DownloadProtocol(download_protocol_tbl.protocol_name)
	  a opl:DownloadProtocol
		as virtrdf:OplDownloadProtocolProtocolName ;
	opl:ProtocolDescription download_protocol_tbl.protocol_description
		as virtrdf:OplDownloadProtocolProtocolDescription .

	opl:DownloadPartner(
	  download_partner_tbl.host_name,
	  download_partner_tbl.domain_name
	  )
	  a opl:DownloadPartner
	  as virtrdf:OplDownloadPartner;
	rdfs:label download_partner_tbl.partner_name
	  as virtrdf:rdfsOplDownloadPartnerPartnerNamelabel ;
	opl:DownloadPartner download_partner_tbl.partner_name
	  as virtrdf:OplDownloadPartnerPartnerName ;
	opl:PortNumber download_partner_tbl.port_number
	  as virtrdf:OplDownloadPartnerPortNumber ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.

    opl:ComponentArchive(component_archive_tbl.component_archive_name)
      opl:hasDownloadLocation
      opl:DownloadLocation(download_location_tbl.uri)
		where (
				^{component_archive_tbl.}^.component_archive_name = ^{download_location_tbl.}^.component_archive_name
		)
      as virtrdf:OplComponentArchiveIsComponentArchiveOfDownloadLocation .

    opl:DownloadLocation(download_location_tbl.uri)
      opl:isDownloadLocationOf
      opl:ComponentArchive(component_archive_tbl.component_archive_name)
		where (
				 ^{download_location_tbl.}^.component_archive_name = ^{component_archive_tbl.}^.component_archive_name
		)
      as virtrdf:OplDownloadLocationIsDowloadLocationOfComponentArchive .


#
# Extra Peripheral family/cat/format/etc... to/from... dbfamily/opsysfamily/....
# ==================================================================================


# ---------------------> product_family

#  opl:ProductFamily(product_family_tbl.product_family_code)
#    opl:OperatingSystems
#    opl:Opsys(ac1.opsys_name)
#    where (
#        ^{product_family_tbl.}^.product_family_code = ^{ac1.}^.product_family_code
#    )
#    as virtrdf:OplProductFamilyToOpsys .

  opl:ProductFamily(product_family_tbl.product_family_code)
    opl:OperatingSystemsFamilies
    opl:OpsysFamily(ac1.opsys_family_id)
    where (
        ^{product_family_tbl.}^.product_family_code = ^{ac1.}^.product_family_code
    )
    as virtrdf:OplProductFamilyToOpsysFamily .

#  opl:ProductFamily(product_family_tbl.product_family_code)
#    opl:Databases
#    opl:DbmsEngine(ac1.dbms_name)
#    where (
#        ^{product_family_tbl.}^.product_family_code = ^{ac1.}^.product_family_code
#    )
#    as virtrdf:OplProductFamilyToDbms .

  opl:ProductFamily(product_family_tbl.product_family_code)
    opl:DatabaseFamilies
    opl:DbmsFamily(ac1.dbms_family_id)
    where (
        ^{product_family_tbl.}^.product_family_code = ^{ac1.}^.product_family_code
    )
    as virtrdf:OplProductFamilyToDbmsFamily .

#  opl:ProductFamily(product_family_tbl.product_family_code)
#    opl:Processors
#  	opl:Processor(ac1.processor_name, ac1.processor_mode_id)
#    where (
#        ^{product_family_tbl.}^.product_family_code = ^{ac1.}^.product_family_code
#    )
#    as virtrdf:OplProductFamilyToProcessor .

  opl:ProductFamily(product_family_tbl.product_family_code)
    opl:ProcessorFamilies
	opl:ProcessorFamily(ac1.processor_family_id)
    where (
        ^{product_family_tbl.}^.product_family_code = ^{ac1.}^.product_family_code
    )
    as virtrdf:OplProductFamilyToProcessorFamily .



# ---------------------> product_format

#  opl:ProductFormat(product_format_with_code.product_format_code)
#    opl:OperatingSystems
#    opl:Opsys(ac1.opsys_name)
#    where (
#        ^{product_format_with_code.}^.product_format_code = ^{ac1.}^.product_format_code
#    )
#    as virtrdf:OplProductFormatToOpsys .

  opl:ProductFormat(product_format_with_code.product_format_code)
    opl:OperatingSystemsFamilies
    opl:OpsysFamily(ac1.opsys_family_id)
    where (
        ^{product_format_with_code.}^.product_format_code = ^{ac1.}^.product_format_code
    )
    as virtrdf:OplProductFormatToOpsysFamily .

#  opl:ProductFormat(product_format_with_code.product_format_code)
#    opl:Databases
#    opl:DbmsEngine(ac1.dbms_name)
#    where (
#        ^{product_format_with_code.}^.product_format_code = ^{ac1.}^.product_format_code
#    )
#    as virtrdf:OplProductFormatToDbms .

  opl:ProductFormat(product_format_with_code.product_format_code)
    opl:DatabaseFamilies
    opl:DbmsFamily(ac1.dbms_family_id)
    where (
        ^{product_format_with_code.}^.product_format_code = ^{ac1.}^.product_format_code
    )
    as virtrdf:OplProductFormatToDbmsFamily .

  opl:ProductFormat(product_format_with_code.product_format_code)
    opl:Processors
  	opl:Processor(ac1.processor_name, ac1.processor_mode_id)
    where (
        ^{product_format_with_code.}^.product_format_code = ^{ac1.}^.product_format_code
    )
    as virtrdf:OplProductFormatToProcessor .

  opl:ProductFormat(product_format_with_code.product_format_code)
    opl:ProcessorFamilies
	opl:ProcessorFamily(ac1.processor_family_id)
    where (
        ^{product_format_with_code.}^.product_format_code = ^{ac1.}^.product_format_code
    )
    as virtrdf:OplProductFormatToProcessorFamily .



# ---------------------> product_category

#  opl:ProductCategory(product_category_with_code.product_cat_code)
#    opl:OperatingSystems
#    opl:Opsys(ac1.opsys_name)
#    where (
#        ^{product_category_with_code.}^.product_cat_code = ^{ac1.}^.product_cat_code
#    )
#    as virtrdf:OplProductCatToOpsys .

  opl:ProductCategory(product_category_with_code.product_cat_code)
    opl:OperatingSystemsFamilies
    opl:OpsysFamily(ac1.opsys_family_id)
    where (
        ^{product_category_with_code.}^.product_cat_code = ^{ac1.}^.product_cat_code
    )
    as virtrdf:OplProductCatToOpsysFamily .

#  opl:ProductCategory(product_category_with_code.product_cat_code)
#    opl:Databases
#    opl:DbmsEngine(ac1.dbms_name)
#    where (
#        ^{product_category_with_code.}^.product_cat_code = ^{ac1.}^.product_cat_code
#    )
#    as virtrdf:OplProductCatToDbms .

  opl:ProductCategory(product_category_with_code.product_cat_code)
    opl:DatabaseFamilies
    opl:DbmsFamily(ac1.dbms_family_id)
    where (
        ^{product_category_with_code.}^.product_cat_code = ^{ac1.}^.product_cat_code
    )
    as virtrdf:OplProductCatToDbmsFamily .

#  opl:ProductCategory(product_category_with_code.product_cat_code)
#    opl:Processors
#  	opl:Processor(ac1.processor_name, ac1.processor_mode_id)
#    where (
#        ^{product_category_with_code.}^.product_cat_code = ^{ac1.}^.product_cat_code
#    )
#    as virtrdf:OplProductCatToProcessor .

  opl:ProductCategory(product_category_with_code.product_cat_code)
    opl:ProcessorFamilies
	opl:ProcessorFamily(ac1.processor_family_id)
    where (
        ^{product_category_with_code.}^.product_cat_code = ^{ac1.}^.product_cat_code
    )
    as virtrdf:OplProductCatToProcessorFamily .




# ---------------------> product

  opl:Product(product_with_code.product_id)
    opl:OperatingSystems
    opl:Opsys(ac1.opsys_name)
    where (
        ^{product_with_code.}^.product_id = ^{ac1.}^.product_id
    )
    as virtrdf:OplProductToOpsys .

  opl:Product(product_with_code.product_id)
    opl:OperatingSystemsFamilies
    opl:OpsysFamily(ac1.opsys_family_id)
    where (
        ^{product_with_code.}^.product_id = ^{ac1.}^.product_id
    )
    as virtrdf:OplProductToOpsysFamily .

  opl:Product(product_with_code.product_id)
    opl:Databases
    opl:DbmsEngine(ac1.dbms_name)
    where (
        ^{product_with_code.}^.product_id = ^{ac1.}^.product_id
    )
    as virtrdf:OplProductToDbms .

  opl:Product(product_with_code.product_id)
    opl:DatabaseFamilies
    opl:DbmsFamily(ac1.dbms_family_id)
    where (
        ^{product_with_code.}^.product_id = ^{ac1.}^.product_id
    )
    as virtrdf:OplProductToDbmsFamily .

  opl:Product(product_with_code.product_id)
    opl:Processors
  	opl:Processor(ac1.processor_name, ac1.processor_mode_id)
    where (
        ^{product_with_code.}^.product_id = ^{ac1.}^.product_id
    )
    as virtrdf:OplProductToProcessor .

  opl:Product(product_with_code.product_id)
    opl:ProcessorFamilies
	opl:ProcessorFamily(ac1.processor_family_id)
    where (
        ^{product_with_code.}^.product_id = ^{ac1.}^.product_id
    )
    as virtrdf:OplProductToProcessorFamily .




# ---------------------> to product

  opl:Opsys(opsys_tbl.opsys_name)
    opl:hasProducts
    opl:Product(ac1.product_id)
    where (
        ^{opsys_tbl.}^.opsys_name = ^{ac1.}^.opsys_name
    )
    as virtrdf:OplOpsysToProduct .

  opl:OpsysFamily(opsys_family_tbl.opsys_family_id)
    opl:hasProducts
    opl:Product(ac1.product_id)
    where (
        ^{opsys_family_tbl.}^.opsys_family_id = ^{ac1.}^.opsys_family_id
    )
    as virtrdf:OplOpsysFamilyToProduct .

  opl:DbmsEngine(dbms_engine_tbl.dbms_name)
    opl:hasProducts
    opl:Product(ac1.product_id)
    where (
        ^{dbms_engine_tbl.}^.dbms_name = ^{ac1.}^.dbms_name
    )
    as virtrdf:OplDbmsToProduct .

  opl:DbmsFamily(dbms_family_tbl.dbms_family_id)
    opl:hasProducts
    opl:Product(ac1.product_id)
    where (
        ^{dbms_family_tbl.}^.dbms_family_id = ^{ac1.}^.dbms_family_id
    )
    as virtrdf:OplDbmsFamilyToProduct .

  opl:Processor(processors_tbl.processor_name, processors_tbl.processor_mode_id)
    opl:hasProducts
    opl:Product(ac1.product_id)
    where (
        ^{processors_tbl.}^.processor_name = ^{ac1.}^.processor_name
        and
        ^{processors_tbl.}^.processor_mode_id = ^{ac1.}^.processor_mode_id
    )
    as virtrdf:OplProcessorToProduct .

  opl:ProcessorFamily(processor_family_tbl.processor_family_id)
    opl:hasProducts
    opl:Product(ac1.product_id)
    where (
        ^{processor_family_tbl.}^.processor_family_id = ^{ac1.}^.processor_family_id
    )
    as virtrdf:OplProcessorFamilyProduct .




# ---------------------> to product_cat

#  opl:Opsys(opsys_tbl.opsys_name)
#    opl:hasProductCategory
#    opl:ProductCategory(ac1.product_cat_code)
#    where (
#        ^{opsys_tbl.}^.opsys_name = ^{ac1.}^.opsys_name
#    )
#    as virtrdf:OplOpsysToProductCategory .

  opl:OpsysFamily(opsys_family_tbl.opsys_family_id)
    opl:hasProductCategory
    opl:ProductCategory(ac1.product_cat_code)
    where (
        ^{opsys_family_tbl.}^.opsys_family_id = ^{ac1.}^.opsys_family_id
    )
    as virtrdf:OplOpsysFamilyToProductCategory .

#  opl:DbmsEngine(dbms_engine_tbl.dbms_name)
#    opl:hasProductCategory
#    opl:ProductCategory(ac1.product_cat_code)
#    where (
#        ^{dbms_engine_tbl.}^.dbms_name = ^{ac1.}^.dbms_name
#    )
#    as virtrdf:OplDbmsToProductCategory .

  opl:DbmsFamily(dbms_family_tbl.dbms_family_id)
    opl:hasProductCategory
    opl:ProductCategory(ac1.product_cat_code)
    where (
        ^{dbms_family_tbl.}^.dbms_family_id = ^{ac1.}^.dbms_family_id
    )
    as virtrdf:OplDbmsFamilyToProductCategory .

#  opl:Processor(processors_tbl.processor_name, processors_tbl.processor_mode_id)
#    opl:hasProductCategory
#    opl:ProductCategory(ac1.product_cat_code)
#    where (
#        ^{processors_tbl.}^.processor_name = ^{ac1.}^.processor_name
#        and
#        ^{processors_tbl.}^.processor_mode_id = ^{ac1.}^.processor_mode_id
#    )
#    as virtrdf:OplProcessorToProductCategory .

  opl:ProcessorFamily(processor_family_tbl.processor_family_id)
    opl:hasProductCategory
    opl:ProductCategory(ac1.product_cat_code)
    where (
        ^{processor_family_tbl.}^.processor_family_id = ^{ac1.}^.processor_family_id
    )
    as virtrdf:OplProcessorFamilyProductCategory .




# ---------------------> to product_format

#  opl:Opsys(opsys_tbl.opsys_name)
#    opl:hasProductFormat
#    opl:ProductFormat(ac1.product_format_code)
#    where (
#        ^{opsys_tbl.}^.opsys_name = ^{ac1.}^.opsys_name
#    )
#    as virtrdf:OplOpsysToProductFormat .

  opl:OpsysFamily(opsys_family_tbl.opsys_family_id)
    opl:hasProductFormat
    opl:ProductFormat(ac1.product_format_code)
    where (
        ^{opsys_family_tbl.}^.opsys_family_id = ^{ac1.}^.opsys_family_id
    )
    as virtrdf:OplOpsysFamilyToProductFormat .

#  opl:DbmsEngine(dbms_engine_tbl.dbms_name)
#    opl:hasProductFormat
#    opl:ProductFormat(ac1.product_format_code)
#    where (
#        ^{dbms_engine_tbl.}^.dbms_name = ^{ac1.}^.dbms_name
#    )
#    as virtrdf:OplDbmsToProductFormat .

  opl:DbmsFamily(dbms_family_tbl.dbms_family_id)
    opl:hasProductFormat
    opl:ProductFormat(ac1.product_format_code)
    where (
        ^{dbms_family_tbl.}^.dbms_family_id = ^{ac1.}^.dbms_family_id
    )
    as virtrdf:OplDbmsFamilyToProductFormat .

#  opl:Processor(processors_tbl.processor_name, processors_tbl.processor_mode_id)
#    opl:hasProductFormat
#    opl:ProductFormat(ac1.product_format_code)
#    where (
#        ^{processors_tbl.}^.processor_name = ^{ac1.}^.processor_name
#        and
#        ^{processors_tbl.}^.processor_mode_id = ^{ac1.}^.processor_mode_id
#    )
#    as virtrdf:OplProcessorToProductFormat .

  opl:ProcessorFamily(processor_family_tbl.processor_family_id)
    opl:hasProductFormat
    opl:ProductFormat(ac1.product_format_code)
    where (
        ^{processor_family_tbl.}^.processor_family_id = ^{ac1.}^.processor_family_id
    )
    as virtrdf:OplProcessorFamilyProductFormat .




# ---------------------> to product_family

#  opl:Opsys(opsys_tbl.opsys_name)
#    opl:hasProductFamily
#    opl:ProductFamily(ac1.product_family_code)
#    where (
#        ^{opsys_tbl.}^.opsys_name = ^{ac1.}^.opsys_name
#    )
#    as virtrdf:OplOpsysToProductFamily .

  opl:OpsysFamily(opsys_family_tbl.opsys_family_id)
    opl:hasProductFamily
    opl:ProductFamily(ac1.product_family_code)
    where (
        ^{opsys_family_tbl.}^.opsys_family_id = ^{ac1.}^.opsys_family_id
    )
    as virtrdf:OplOpsysFamilyToProductFamily .

#  opl:DbmsEngine(dbms_engine_tbl.dbms_name)
#    opl:hasProductFamily
#    opl:ProductFamily(ac1.product_family_code)
#    where (
#        ^{dbms_engine_tbl.}^.dbms_name = ^{ac1.}^.dbms_name
#    )
#    as virtrdf:OplDbmsToProductFamily .

  opl:DbmsFamily(dbms_family_tbl.dbms_family_id)
    opl:hasProductFamily
    opl:ProductFamily(ac1.product_family_code)
    where (
        ^{dbms_family_tbl.}^.dbms_family_id = ^{ac1.}^.dbms_family_id
    )
    as virtrdf:OplDbmsFamilyToProductFamily .

#  opl:Processor(processors_tbl.processor_name, processors_tbl.processor_mode_id)
#    opl:hasProductFamily
#    opl:ProductFamily(ac1.product_family_code)
#    where (
#        ^{processors_tbl.}^.processor_name = ^{ac1.}^.processor_name
#        and
#        ^{processors_tbl.}^.processor_mode_id = ^{ac1.}^.processor_mode_id
#    )
#    as virtrdf:OplProcessorToProductFamily .

  opl:ProcessorFamily(processor_family_tbl.processor_family_id)
    opl:hasProductFamily
    opl:ProductFamily(ac1.product_family_code)
    where (
        ^{processor_family_tbl.}^.processor_family_id = ^{ac1.}^.processor_family_id
    )
    as virtrdf:OplProcessorFamilyProductFamily .


#
# Product Benefits and things
# =========================================

	opl:ProductBenefit(product_benefits_tbl.product_benefit_id)
	  a opl:ProductBenefit
	  as virtrdf:OplProductBenefit ;
	rdfs:label product_benefits_tbl.product_benefit_desc
	  as virtrdf:rdfsLabelProductBenefitDescription ;
	opl:isOfProductBenefitCategory opl:ProductBenefitCategory(product_benefits_tbl.product_benefit_category_id)
	  as virtrdf:OplProductBenefitIsOfProductBenefitCategory ;
	opl:Description product_benefits_tbl.product_benefit_desc
	  as virtrdf:OplProductBenefitDescription ;
	opl:Acronym product_benefits_tbl.product_benefit_acronym
	  as virtrdf:OplProductBenefitAcronym ;
  opl:Explanation product_benefits_tbl.product_benefit_explanation
    as virtrdf:OplProductBenefitExplanation ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.

	opl:ProductBenefitCategory(product_benefits_category_tbl.product_benefit_category_id)
	  a opl:ProductBenefitCategory
	  as virtrdf:OplProductBenefitCategory ;
	rdfs:label product_benefits_category_tbl.description
	  as virtrdf:rdfsLabelProductBenefitCategoryDescription ;
	opl:Description product_benefits_category_tbl.description
	  as virtrdf:OplProductBenefitCategoryDescription ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.

	opl:ProductFeatureCategory(product_feature_category_tbl.product_feature_category_id)
	  a opl:ProductFeatureCategory
	  as virtrdf:OplProductFeatureCategory ;
	rdfs:label product_feature_category_tbl.short_desc
	  as virtrdf:rdfsLabelProductFeatureCategoryShortDescription ;
	opl:ShortDescription product_feature_category_tbl.short_desc
	  as virtrdf:OplProductFeatureCategoryShortDescription ;
	opl:Description product_feature_category_tbl.description
	  as virtrdf:OplProductFeatureCategoryDescription ;
	opl:StandardsId product_feature_category_tbl.standards_id
	  as virtrdf:OplProductFeatureCategoryStandardsId ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.

	opl:ProductFeature(product_features_tbl.product_feature_id)
	  a opl:ProductFeature
	  as virtrdf:OplProductFeature ;
	rdfs:label product_features_tbl.short_description
		as virtrdf:rdfsLabelProductFeaturesShortDescription ;
	opl:Description product_features_tbl.short_description
		as virtrdf:OplProductFeaturesShortDescription ;
	dc:description opl:lit_to_string(product_features_tbl.long_description)
		as virtrdf:OplProductFeaturesLongDescription ;
	opl:isOfProductBenefit opl:ProductBenefit(product_features_tbl.product_feature_benefit_id)
		as virtrdf:ProductFeaturesIsOfProductBenefit ;
	opl:isOfProductFeatureCategory opl:ProductFeatureCategory(product_features_tbl.product_feature_category_id)
		as virtrdf:ProductFeaturesIsOfProductFeatureCategory ;
	opl:isOfProduct opl:Product(product_features_tbl.product_id)
		as virtrdf:ProductFeaturesIsOfProduct ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy dc: ;
      rdfs:isDefinedBy rdfs:
		.

    opl:Product(product_with_code.product_id)
      opl:hasFeature
      opl:ProductFeature(product_features_tbl.product_feature_id)
      where (
	    ^{product_with_code.}^.product_id = ^{product_features_tbl.}^.product_id
	)
	as virtrdf:OplProductHasProductFeaturesProductFeatures .

    opl:ProductFeature(product_features_tbl.product_feature_id)
      opl:isFeatureOf
      opl:Product(product_with_code.product_id)
      where (
        ^{product_with_code.}^.product_id = ^{product_features_tbl.}^.product_id
    )
    as virtrdf:OplProductFeaturesAreProductFeaturesProduct .


	opl:ProductFamilyFeature(product_family_features_tbl.product_family_feature_id)
	  a opl:ProductFamilyFeature
		as virtrdf:OplProductFamilyFeature ;
	rdfs:label product_family_features_tbl.short_description
		as virtrdf:rdfsLabelProductFamilyFeaturesShortDescription ;
	opl:Description product_family_features_tbl.short_description
		as virtrdf:OplProductFamilyFeaturesShortDescription ;
	dc:description opl:lit_to_string(product_family_features_tbl.long_description)
		as virtrdf:OplProductFamilyFeaturesLongDescription ;
	opl:isOfProductBenefit opl:ProductBenefit(product_family_features_tbl.product_family_feature_benefit_id)
		as virtrdf:ProductFamilyFeaturesIsOfProductBenefit ;
	opl:isOfProductFeatureCategory opl:ProductFeatureCategory(product_family_features_tbl.product_family_feature_cat_id)
		as virtrdf:ProductFamilyFeaturesIsOfProductFeatureCategory ;
	opl:isOfProductFamily opl:ProductFamily(product_family_features_tbl.product_family_code)
		as virtrdf:ProductFamilyFeaturesIsOfProductFamily ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy dc: ;
      rdfs:isDefinedBy rdfs:
		.

    opl:ProductFamily(product_family_tbl.product_family_code)
      opl:hasFeature
      opl:ProductFamilyFeature(product_family_features_tbl.product_family_feature_id)
      where (
	    ^{product_family_tbl.}^.product_family_id = ^{product_family_features_tbl.}^.product_family_id
	)
	as virtrdf:OplProductFamilyHasProductFamilyFeaturesProductFamilyFeatures .

    opl:ProductFamilyFeature(product_family_features_tbl.product_family_feature_id)
      opl:isFeatureOf
      opl:Product(product_family_tbl.product_family_code)
      where (
        ^{product_family_tbl.}^.product_family_id = ^{product_family_features_tbl.}^.product_family_id
    )
    as virtrdf:OplProductFamilyFeaturesAreProductFamilyFeaturesProductFamily .


	opl:ProductFormatFeature(product_format_features_tbl.product_format_feature_id)
	  a opl:ProductFormatFeature
	  as virtrdf:OplProductFormatFeature ;
	rdfs:label product_format_features_tbl.short_description
		as virtrdf:rdfsLabelProductFormatFeaturesShortDescription ;
	opl:Description product_format_features_tbl.short_description
		as virtrdf:OplProductFormatFeaturesShortDescription ;
	dc:description opl:lit_to_string(product_format_features_tbl.long_description)
		as virtrdf:OplProductFormatFeaturesLongDescription ;
	opl:isOfProductBenefit opl:ProductBenefit(product_format_features_tbl.product_format_feature_benefit_id)
		as virtrdf:ProductFormatFeaturesIsOfProductBenefit ;
	opl:isOfProductFeatureCategory opl:ProductFeatureCategory(product_format_features_tbl.product_format_feature_cat_id)
		as virtrdf:ProductFormatFeaturesIsOfProductFeatureCategory ;
	opl:isOfProductFormat opl:ProductFormat(product_format_features_tbl.product_format_code)
		as virtrdf:ProductFormatFeaturesIsOfProductFormat ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy dc: ;
      rdfs:isDefinedBy rdfs:
		.

    opl:ProductFormat(product_format_with_code.product_format_code)
      opl:hasFeature
      opl:ProductFormatFeature(product_format_features_tbl.product_format_feature_id)
      where (
	    ^{product_format_with_code.}^.product_format_id = ^{product_format_features_tbl.}^.product_format_id
	)
	as virtrdf:OplProductFormatHasProductFormatFeaturesProductFormatFeatures .

    opl:ProductFormatFeature(product_format_features_tbl.product_format_feature_id)
      opl:isFeatureOf
      opl:ProductFormat(product_format_with_code.product_format_code)
      where (
        ^{product_format_with_code.}^.product_format_id = ^{product_format_features_tbl.}^.product_format_id
    )
    as virtrdf:OplProductFormatFeaturesAreProductFormatFeaturesProductFormat .



	opl:ProductCategoryFeature(product_category_features_tbl.product_category_feature_id)
	  a opl:ProductCategoryFeature
	  as virtrdf:OplProductCategoryFeature ;
	rdfs:label product_category_features_tbl.short_description
		as virtrdf:rdfsLabelProductCategoryFeaturesShortDescription ;
	opl:Description product_category_features_tbl.short_description
		as virtrdf:OplProductCategoryFeaturesShortDescription ;
	dc:description opl:lit_to_string(product_category_features_tbl.long_description)
		as virtrdf:OplProductCategoryFeaturesLongDescription ;
	opl:isOfProductBenefit opl:ProductBenefit(product_category_features_tbl.product_category_feature_benefit_id)
		as virtrdf:ProductCategoryFeaturesIsOfProductBenefit ;
	opl:isOfProductFeatureCategory opl:ProductFeatureCategory(product_category_features_tbl.product_category_feature_category_id)
		as virtrdf:ProductCategoryFeaturesIsOfProductFeatureCategory ;
	opl:isOfProductCategory opl:ProductCategory(product_category_features_tbl.product_cat_code)
		as virtrdf:ProductCategoryFeaturesIsOfProductCategory ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy dc: ;
      rdfs:isDefinedBy rdfs:
		.

    opl:ProductCategory(product_category_with_code.product_cat_code)
      opl:hasFeature
      opl:ProductCategoryFeature(product_category_features_tbl.product_category_feature_id)
      where (
	    ^{product_category_with_code.}^.product_cat_id = ^{product_category_features_tbl.}^.product_cat_id
	)
	as virtrdf:OplProductCategoryHasProductCategoryFeaturesProductCategoryFeatures .

    opl:ProductCategoryFeature(product_category_features_tbl.product_category_feature_id)
      opl:isFeatureOf
      opl:ProductCategory(product_category_with_code.product_cat_code)
      where (
        ^{product_category_with_code.}^.product_cat_id = ^{product_category_features_tbl.}^.product_cat_id
    )
    as virtrdf:OplProductCategoryFeaturesAreProductCategoryFeaturesProductCategory .


	opl:ProductReleaseFeature(product_release_features_tbl.product_release_feature_id)
	  a opl:ProductReleaseFeature
	  as virtrdf:OplProductReleaseFeature ;
	rdfs:label product_release_features_tbl.short_description
		as virtrdf:rdfsLabelProductReleaseFeaturesShortDescription ;
	opl:Description product_release_features_tbl.short_description
		as virtrdf:OplProductReleaseFeaturesShortDescription ;
	dc:description opl:lit_to_string(product_release_features_tbl.long_description)
		as virtrdf:OplProductReleaseFeaturesLongDescription ;
	opl:isOfProductBenefit opl:ProductBenefit(product_release_features_tbl.product_release_feature_benefit_id)
		as virtrdf:ProductReleaseFeaturesIsOfProductBenefit ;
	opl:isOfProductFeatureCategory opl:ProductFeatureCategory(product_release_features_tbl.product_release_feature_cat_id)
		as virtrdf:ProductReleaseFeaturesIsOfProductFeatureCategory ;
	opl:isOfProduct opl:Product(product_release_features_tbl.product_id)
		as virtrdf:ProductReleaseFeaturesIsOfProduct ;
	opl:ProductReleaseId product_release_features_tbl.product_release_id
		as virtrdf:ProductReleaseFeaturesProductRelease ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy dc: ;
      rdfs:isDefinedBy rdfs:
	.


	} .
} .
;




DB.DBA.RDF_AUDIT_METADATA (1, '*');


sparql
prefix opl: <http://www.openlinksw.com/schemas/oplweb#>
prefix dc: <http://purl.org/dc/terms#>
prefix oplsioc: <http://www.openlinksw.com/schemas/oplsioc#>
prefix sioc: <http://rdfs.org/sioc/ns#>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix wgs: <http://www.w3.org/2003/01/geo/wgs84_pos#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix oplds: <http://www.openlinksw.com/dataspace/organization/openlink#>
prefix owl: <http://www.w3.org/2002/07/owl#>
prefix umbel: <http://umbel.org/umbel/sc/>
prefix gr: <http://purl.org/goodrelations/v1#>

alter quad storage virtrdf:DefaultQuadStorage
from oplweb2.oplweb.component_archive as component_archive_tbl
from oplweb2.oplweb.component_archive_type as component_archive_type_tbl
from oplweb2.oplweb.component_category as component_category_tbl text literal component_category_long_description
from oplweb2.oplweb.component_mode as component_mode_tbl
from oplweb2.oplweb.component_type as component_type_tbl
from oplweb2.oplweb.components_for_rdfs as components_tbl
from oplweb2.oplweb.dbms_engine as dbms_engine_tbl
from oplweb2.oplweb.dbms_family as dbms_family_tbl
from oplweb2.oplweb.download_location as download_location_tbl
from oplweb2.oplweb.download_protocol as download_protocol_tbl
from oplweb2.oplweb.download_partner as download_partner_tbl
from oplweb2.oplweb.opsys as opsys_tbl
from oplweb2.oplweb.opsys_family as opsys_family_tbl
from oplweb2.oplweb.opsys_type as opsys_type_tbl
from oplweb2.oplweb.processor_family as processor_family_tbl
from oplweb2.oplweb.processor_mode as processor_mode_tbl
from oplweb2.oplweb.processors as processors_tbl
from oplweb2.oplweb.product as product_tbl text literal long_description
from oplweb2.oplweb.product_benefits as product_benefits_tbl text literal product_benefit_explanation
from oplweb2.oplweb.product_benefits_category as product_benefits_category_tbl
from oplweb2.oplweb.product_category as product_category_tbl
from oplweb2.oplweb.product_category_features_with_code as product_category_features_tbl text literal long_description
from oplweb2.oplweb.product_family as product_family_tbl
from oplweb2.oplweb.product_family as product_family_tbl_2
from oplweb2.oplweb.product_family_features_with_code as product_family_features_tbl text literal long_description
from oplweb2.oplweb.product_features as product_features_tbl text literal long_description
from oplweb2.oplweb.product_feature_category as product_feature_category_tbl text literal description
from oplweb2.oplweb.product_format_features_with_code as product_format_features_tbl text literal long_description
from oplweb2.oplweb.product_release_features as product_release_features_tbl text literal long_description
from oplweb2.oplweb.product_release_with_family as product_release_tbl
from oplweb2.oplweb.vendor_category as vendor_category_tbl
from oplweb2.oplweb.vendor_category_family as vendor_category_family_tbl
from oplweb2.oplweb.vendors as vendors_tbl
from oplweb2.oplweb.product_formats_categories as product_formats_categories
from oplweb2.oplweb.product_with_code as product_with_code
from oplweb2.oplweb.product_category_with_code as product_category_with_code
from oplweb2.oplweb.product_format as product_format_with_code
from oplweb2.oplweb.product_price as pp
from oplweb2.oplweb.product_price_type as pt
from oplweb2.DBA.license_model_unit_type as put
from oplweb2.DBA.license_model_unit_type as put2
from oplweb2.DBA.license_model as lm
from oplweb2.DBA.license_model as lm2
from oplweb2.DBA.license_model_type as license_model_type_tbl
from oplweb2.DBA.product_price_varchar as ppv
from oplweb2.DBA.product_general_discount_vc as gd
from oplweb2.oplweb.archive_coverage_osdb as ac1
{
	create virtrdf:product_portfolio2 as
		graph <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>
	  option (exclusive)
        {

  opl:ProcessorFamily(processor_family_tbl.processor_family_id)
    opl:hasProcessors
    opl:Processor(processors_tbl.processor_name, processors_tbl.processor_mode_id)
    where (
        ^{processor_family_tbl.}^.processor_family_id = ^{processors_tbl.}^.processor_family_id
    )
    as virtrdf:OplProcessorFamilyHasProcessors .


  opl:Processor(processors_tbl.processor_name, processors_tbl.processor_mode_id)
    opl:hasProductFamily
    opl:ProductFamily(ac1.product_family_code)
    where (
        ^{processors_tbl.}^.processor_name = ^{ac1.}^.processor_name
        and
        ^{processors_tbl.}^.processor_mode_id = ^{ac1.}^.processor_mode_id
    )
    as virtrdf:OplProcessorToProductFamily .



#
# Product Licensing and Shop stuff
# =========================================


	  opl:ProductRelease(
	      product_release_tbl.product_id,
	      product_release_tbl.product_release_id,
	      product_release_tbl.opsys_name,
	      product_release_tbl.dbms_name
	      )
      opl:hasLicenseModel
      opl:LicenseModel(
        lm.product_release_id,
        lm.product_id,
        lm.opsys_family_id,
        lm.dbms_family_id,
        lm.product_price_type_id
	  )
      where (
        ^{lm.}^.product_id = ^{product_release_tbl.}^.product_id and
        ^{lm.}^.product_release_id = ^{product_release_tbl.}^.product_release_id and
        ^{lm.}^.opsys_family_id = ^{product_release_tbl.}^.opsys_family_id and
        ^{lm.}^.dbms_family_id = ^{product_release_tbl.}^.dbms_family_id
    )
    as virtrdf:OplProductReleaseHasLicenseModel .

	  opl:ProductRelease(
	      product_release_tbl.product_id,
	      product_release_tbl.product_release_id,
	      product_release_tbl.opsys_name,
	      product_release_tbl.dbms_name
	      )
      opl:hasPriceSample
	  opl:lit_shop_sample (
	      product_release_tbl.product_release_id,
	      product_release_tbl.product_id,
	      product_release_tbl.opsys_name,
	      product_release_tbl.dbms_name
      	)
      as virtrdf:OplPriceSamples .


	opl:LicenseModel(
	    lm.product_release_id,
        lm.product_id,
        lm.opsys_family_id,
        lm.dbms_family_id,
		lm.product_price_type_id)
	a opl:LicenseModel
	as virtrdf:OplLicenseModel;
	a gr:Sell
	as virtrdf:OplLicenseModelAgrSell ;
	a gr:ActualProductOrServiceInstance
	as virtrdf:OplLicenseModelAgrProductOrServiceInstance ;
	rdfs:label opl:lit_license_model_type(
		lm.product_price_type_id
	) as virtrdf:OplLabelLicenseModel ;
	rdfs:description opl:lit_license_model_explain (
		lm.product_price_type_id
	) as virtrdf:OplLicenseModelExplain ;
	opl:ProductReleaseId
	  lm.product_release_id
	  as virtrdf:lm_shop_price_product_release;
	opl:isOfFormat
	  opl:ProductFormat(lm.product_format_code)
	  as virtrdf:lm_shop_price_product_format;
	opl:isOfCategory
	  opl:ProductCategory(lm.product_cat_code)
	  as virtrdf:lm_shop_price_product_cat;
	opl:OpsysFamily
	  opl:OpsysFamily(lm.opsys_family_id)
	  as virtrdf:lm_shop_price_opsys_family_oplweb;
	opl:OpsysType
	  opl:OpsysType(lm.opsys_type_id)
	  as virtrdf:lm_shop_price_opsys_type;
	opl:DbmsFamily
	  opl:DbmsFamily(lm.dbms_family_id)
	  as virtrdf:lm_shop_price_dbms_family	;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs: ;
      rdfs:isDefinedBy gr:
		.


	opl:LicenseModel(
	    lm.product_release_id,
        lm.product_id,
        lm.opsys_family_id,
        lm.dbms_family_id,
		lm.product_price_type_id)
	opl:hasPriceUnitType
	opl:PriceUnitType(
	    lm2.product_release_id,
        lm2.product_id,
        lm2.opsys_family_id,
        lm2.dbms_family_id,
		lm2.product_price_type_id,
		lm2.product_price_unit_type_id)
      where (
        ^{lm.}^.product_release_id = ^{lm2.}^.product_release_id AND
        ^{lm.}^.product_id = ^{lm2.}^.product_id AND
        ^{lm.}^.opsys_family_id = ^{lm2.}^.opsys_family_id AND
        ^{lm.}^.opsys_type_id = ^{lm2.}^.opsys_type_id AND
        ^{lm.}^.product_price_type_id = ^{lm2.}^.product_price_type_id AND
		^{lm2.}^.product_price_unit_type_id <> 'db_sessions'
        and
        (
          ^{lm.}^.dbms_family_id = ^{lm2.}^.dbms_family_id
    	  OR
          ^{lm2.}^.dbms_family_id = 15
        )
    )
    as virtrdf:OplLicenseModelPriceUnitTypes .



	opl:LicenseModel(
	    lm.product_release_id,
        lm.product_id,
        lm.opsys_family_id,
        lm.dbms_family_id,
		lm.product_price_type_id)
	gr:hasPriceSpecification
	opl:PriceUnitType(
	    lm2.product_release_id,
        lm2.product_id,
        lm2.opsys_family_id,
        lm2.dbms_family_id,
		lm2.product_price_type_id,
		lm2.product_price_unit_type_id)
      where (
        ^{lm.}^.product_release_id = ^{lm2.}^.product_release_id AND
        ^{lm.}^.product_id = ^{lm2.}^.product_id AND
        ^{lm.}^.opsys_family_id = ^{lm2.}^.opsys_family_id AND
        ^{lm.}^.opsys_type_id = ^{lm2.}^.opsys_type_id AND
        ^{lm.}^.product_price_type_id = ^{lm2.}^.product_price_type_id AND
		^{lm2.}^.product_price_unit_type_id = 'db_sessions'
        and
        (
          ^{lm.}^.dbms_family_id = ^{lm2.}^.dbms_family_id
    	  OR
          ^{lm2.}^.dbms_family_id = 15
        )
    )
    as virtrdf:OplLicenseModelBasePriceUnitTypes .


	opl:Discount(
	    gd.product_release_id,
	    gd.opsys_type_id,
	    gd.product_id,
	    gd.opsys_family_id,
	    gd.dbms_family_id,
	    gd.product_price_type_id)
	a opl:Discount
	as virtrdf:product_discount;
	rdfs:label gd.product_discount_description as virtrdf:OplLabelDiscount ;
	rdfs:description gd.product_discount_description as virtrdf:OplDiscountExplain ;
	opl:discount_description
	  gd.product_discount_description
	  as virtrdf:gd_discount_description;
	opl:discount_start
	  gd.discount_start
	  as virtrdf:gd_discount_start;
	opl:discount_end
	  gd.discount_end
	  as virtrdf:gd_discount_end;
	opl:ProductPriceType
	  opl:PriceType(gd.product_price_type_id)
	  as virtrdf:gd_shop_price_type;
	gr:hasUnitOfMeasurement
	  opl:PriceType(gd.product_price_type_id)
	  as virtrdf:gd_shop_price_type_grUnitOfMeasurement;
	opl:ProductReleaseId
	  gd.product_release_id
	  as virtrdf:gd_shop_price_product_release;
	opl:ProductFormat
	  opl:ProductFormat(gd.product_format_code)
	  as virtrdf:gd_shop_price_product_format;
	opl:ProductCategory
	  opl:ProductCategory(gd.product_cat_code)
	  as virtrdf:gd_shop_price_product_cat;
	opl:OpsysFamily
	  opl:OpsysFamily(gd.opsys_family_id)
	  as virtrdf:gd_shop_price_opsys_family_oplweb;
	opl:OpsysType
	  opl:OpsysType(gd.opsys_type_id)
	  as virtrdf:gd_shop_price_opsys_type;
	opl:DbmsFamily
	  opl:DbmsFamily(gd.dbms_family_id)
	  as virtrdf:gd_shop_price_dbms_family;
	opl:discount_token
	  gd.discount_token
	  as virtrdf:gd_discount_token ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.




	opl:PriceType(pt.product_price_type_id)
	  a opl:PriceType
	  as virtrdf:shop_product_price_type;
	rdfs:label pt.product_price_type_description as virtrdf:OplLabelPriceType ;
	rdfs:description pt.product_price_type_description as virtrdf:OplPriceTypeExplain ;
	opl:PriceTypeDescription
	  pt.product_price_type_description
	  as virtrdf:shop_product_price_type_description;
	dc:description
	  pt.product_price_type_long_description
	  as virtrdf:shop_product_price_type_long_description ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy dc: ;
      rdfs:isDefinedBy rdfs:
		.

	opl:PriceUnitType(
		put.product_release_id,
        put.product_id,
        put.opsys_family_id,
        put.dbms_family_id,
		put.product_price_type_id,
		put.product_price_unit_type_id)
	  a opl:PriceUnitType
	  as virtrdf:shop_product_price_unit_type;
	rdfs:label put.product_price_unit_description as virtrdf:OplLabelproductpriceunitdescription ;
	rdfs:description put.product_price_unit_description as virtrdf:OplproductpriceunitdescriptionExplain ;
	gr:hasUnitOfMeasurement
	  opl:PriceType(put.product_price_type_id)
	  as virtrdf:put_shop_price_type_grUnitOfMeasurement;
	opl:unitValue
	  put.unit_price
	  as virtrdf:unit_type_unit_price;
	gr:hasValue
	  put.unit_price
	  as virtrdf:unit_type_unit_price_grHasValue;
	opl:graceUnits
	  put.unit_grace
	  as virtrdf:unit_type_unit_grace;
	opl:minUnits
	  put.unit_low
	  as virtrdf:unit_type_unit_low;
	opl:maxUnits
	  put.unit_cap
	  as virtrdf:unit_type_unit_cap;
	opl:unit_type_description
	  put.product_price_unit_description
	  as virtrdf:unit_type_description ;
      rdfs:isDefinedBy opl: ;
      rdfs:isDefinedBy rdfs:
		.


    opl:PriceUnitType(
		put.product_release_id,
        put.product_id,
        put.opsys_family_id,
        put.dbms_family_id,
		put.product_price_type_id,
		put.product_price_unit_type_id
	  )
      opl:hasIncrementalDiscount
      opl:PriceUnitIncrementalDiscount(
		put2.product_release_id,
        put2.product_id,
        put2.opsys_family_id,
        put2.dbms_family_id,
		put2.product_price_type_id,
		put2.product_price_unit_type_id
	  )
      where (
		^{put.}^.product_release_id = ^{put2.}^.product_release_id and
        ^{put.}^.product_id = ^{put2.}^.product_id and
        ^{put.}^.opsys_family_id = ^{put2.}^.opsys_family_id and
        ^{put.}^.dbms_family_id = ^{put2.}^.dbms_family_id and
		^{put.}^.product_price_type_id = ^{put2.}^.product_price_type_id and
		^{put.}^.product_price_unit_type_id = ^{put2.}^.product_price_unit_type_id
    )
    as virtrdf:OplLicenseModelUnitsIncrementalDiscounts .


	opl:PriceUnitIncrementalDiscount(
		put.product_release_id,
        put.product_id,
        put.opsys_family_id,
        put.dbms_family_id,
		put.product_price_type_id,
		put.product_price_unit_type_id)
	  a opl:PriceUnitIncrementalDiscount
	  as virtrdf:shop_product_price_unit_type_incremental_discount;
	rdfs:label put.product_price_unit_description as virtrdf:OplLabelproductpriceunitIncDisdescription ;
	rdfs:description put.product_price_unit_description as virtrdf:OplproductpriceunitIncDisdescriptionExplain ;
	opl:percentageOfBase
	  put.unit_discount
	  as virtrdf:unit_type_unit_discount;
	opl:triggerPoint
	  put.quantity
	  as virtrdf:unit_type_unit_discount_quantity
	.


      opl:LicenseModel(
        lm.product_release_id,
        lm.product_id,
        lm.opsys_family_id,
        lm.dbms_family_id,
        lm.product_price_type_id
	  )
      opl:hasGeneralDiscounts
      opl:Discount(
	    gd.product_release_id,
	    gd.opsys_type_id,
	    gd.product_id,
	    gd.opsys_family_id,
	    gd.dbms_family_id,
	    gd.product_price_type_id
	  )
      where (
        ^{lm.}^.product_release_id = ^{gd.}^.product_release_id AND
        ^{lm.}^.product_id = ^{gd.}^.product_id AND
        ^{lm.}^.opsys_family_id = ^{gd.}^.opsys_family_id AND
        ^{lm.}^.dbms_family_id = ^{gd.}^.dbms_family_id AND
        ^{lm.}^.opsys_type_id = ^{gd.}^.opsys_type_id AND
        ^{lm.}^.product_price_type_id = ^{gd.}^.product_price_type_id
    )
    as virtrdf:OplLicenseModelGeneralDiscounts .



        } .
} .
;


DB.DBA.XML_SET_NS_DECL ('OpenLink', 'http://www.openlinksw.com/schemas/oplweb#', 2);
DB.DBA.XML_SET_NS_DECL ('OplProductCategory', 'http://data.openlinksw.com/oplweb/product_category/', 2);
DB.DBA.XML_SET_NS_DECL ('OplProductFamily', 'http://data.openlinksw.com/oplweb/product_family/', 2);
DB.DBA.XML_SET_NS_DECL ('OplProductFormat', 'http://data.openlinksw.com/oplweb/product_format/', 2);
DB.DBA.XML_SET_NS_DECL ('OplProduct', 'http://data.openlinksw.com/oplweb/product/', 2);
DB.DBA.XML_SET_NS_DECL ('OplProductRelease', 'http://data.openlinksw.com/oplweb/product_release/', 2);


DB.DBA.RDF_AUDIT_METADATA (1, '*');


commit work;
-- Clear the 'cache' for immediate effects
select hs_local_iri, exec ('sparql clear graph <'||hs_local_iri||'>')
  from sys_http_sponge
  where hs_local_iri like '%oplweb%';

select id_to_iri(G), exec ('sparql clear graph <'||id_to_iri(G)||'>')
  from rdf_quad
  where id_to_iri(G) like '%oplweb%';

sparql clear graph <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>;
commit work;


sparql CONSTRUCT { <http://data.openlinksw.com/oplweb/product_family/uda#this> ?p ?o }
  FROM <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>
  WHERE { <http://data.openlinksw.com/oplweb/product_family/uda#this> ?p ?o }
;

sparql select *
  FROM <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>
  WHERE { <http://data.openlinksw.com/oplweb/product_category/odbc#this> ?p ?o }
  limit 100
;

sparql define get:soft "soft" select *
  FROM <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>
  WHERE { <http://data.openlinksw.com/oplweb/product_category/odbc#this> ?p ?o }
  limit 100
;

sparql CONSTRUCT { <http://data.openlinksw.com/oplweb/product_category/jdbc#this> ?p ?o }
  FROM <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>
  WHERE { <http://data.openlinksw.com/oplweb/product_category/jdbc#this> ?p ?o }
  limit 100
;

sparql CONSTRUCT { <http://data.openlinksw.com/oplweb/product_format/mt#this> ?p ?o }
  FROM <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>
  WHERE { <http://data.openlinksw.com/oplweb/product_format/mt#this> ?p ?o }
  limit 1
;


sparql select  ?p ?o
  FROM <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>
  WHERE { <http://data.openlinksw.com/oplweb/product_family/uda#this> ?p ?o }
  limit 1
;

sparql
prefix opl: <http://www.openlinksw.com/schemas/oplweb#>
select  ?s ?o
  FROM <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>
  WHERE { ?s opl:hasProcessors ?o }
  limit 1
;

sparql
prefix opl: <http://www.openlinksw.com/schemas/oplweb#>
select distinct ?o
  FROM <http://www.openlinksw.com/dataspace/organization/openlink/oplweb/>
  WHERE { <http://data.openlinksw.com/oplweb/processor/i686_1#this> opl:hasProductFamily ?o }
  limit 10
;

-- curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/price_unit_type/6.1_odbc-sqlserver-st_1_2_1_db_sessions#this"
-- curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/price_unit_type/6.1_odbc-sqlserver-st_1_2_1_cpu#this"

--select top 10 * from oplweb2.DBA.license_model_unit_type where product_release_id = '6.1' and product_id = 'odbc-sqlserver-st'
--  and opsys_family_id = 1 and dbms_family_id = 15 and product_price_type_id = 1 and product_price_unit_type_id = 'cpu';

-- curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/rdfbrowser/index.html?uri=http%3A//data.openlinksw.com/oplweb/component_archive/6.1-odbc-oracle-st-i686-generic-win-32-ora10-odbclt-clnt-only_mv.msi"
-- curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/product_family/uda"
-- curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/product_category/odbc"
-- curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/dbms_family/MySQL"
-- curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/product_release/odbc-oracle-mt_6.1_i686-generic-win-32_ora9"
-- curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/license_model/6.1_odbc-sqlserver-st_1_2_1"




curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/rdfbrowser/index.html?uri=http%3A//data.openlinksw.com/oplweb/component_archive/6.1-odbc-oracle-st-i686-generic-win-32-ora10-odbclt-clnt-only_mv.msi"
curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/product_family/uda"
curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/product_release/odbc-oracle-mt_6.1_i686-generic-win-32_ora9"
curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/license_model/6.1_odbc-sqlserver-st_1_2_1"

--
-- XXX: note , the below would work only if www.openlinksw.com has the GRAPH <http://data.openlinksw.com/oplweb/>
-- if experimenting on other box, then www.openlinksw.com should be replaced with [URIQA] DefaultHost INI value
--



DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oplweb2_rule2',
    1,
    '/oplweb(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//data.openlinksw.com/oplweb%U%%23this%%3E+%%3Fp+%%3Fo+}+FROM+%%3Chttp%%3A//www.openlinksw.com/dataspace/organization/openlink/oplweb/%%3E+WHERE+{+%%3Chttp%%3A//data.openlinksw.com/oplweb%U%%23this%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oplweb2_rule1',
    1,
    '(/oplweb/[^#]*)',
    vector('path'),
    1,
    '/rdfbrowser/index.html?uri=http%%3A//data.openlinksw.com%U%',
--    '/DAV/RDF/rdfqry.vsp?uri=http%%3A//data.openlinksw.com%U%%23this',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'oplweb2_rule3',
    1,
    '(/[^#]*)/\x24',
    vector('path'),
    1,
    '%s',
    vector('path'),
    null,
    null,
    0,
    null
    );



create procedure DB.DBA.REDO_OPLWEB2_RDF_DET()
{
  declare colid int;
  colid := DAV_SEARCH_ID('/DAV/RDF/oplweb2/', 'C');
  if (colid < 0)
    return;
  update WS.WS.SYS_DAV_COL set COL_DET=null where COL_ID = colid;
}
;

DB.DBA.REDO_OPLWEB2_RDF_DET();

drop procedure DB.DBA.REDO_OPLWEB2_RDF_DET;

DB.DBA."RDFData_MAKE_DET_COL" ('/DAV/RDF/oplweb2/', 'http://data.openlinksw.com/oplweb', NULL);
VHOST_REMOVE (lpath=>'/oplweb/data/rdf');
DB.DBA.VHOST_DEFINE (lpath=>'/oplweb/data/rdf', ppath=>'/DAV/RDF/oplweb2/All/', is_dav=>1, vsp_user=>'dba');

-- procedure to convert path to DET resource name
create procedure DB.DBA.OPLWEB2_DET_REF (in par varchar, in fmt varchar, in val varchar)
{
  declare res, iri any;
  iri := 'http://data.openlinksw.com/oplweb' || val;
  res := sprintf ('iid (%d).rdf', iri_id_num (iri_to_id (iri)));
  return sprintf (fmt, res);
}
;

DB.DBA.URLREWRITE_CREATE_REGEX_RULE ('oplweb2_rdf', 1,
    '/oplweb/(.*)', vector('path'), 1,
    '/oplweb/data/rdf/%U', vector('path'),
    'DB.DBA.OPLWEB2_DET_REF',
    'application/rdf.xml',
    2,
    303);


DB.DBA.URLREWRITE_CREATE_RULELIST (
    'oplweb2_rule_list1',
    1,
    vector (
                'oplweb2_rule1',
                'oplweb2_rule2',
                'oplweb2_rule3',
                'oplweb2_rdf'
          ));


VHOST_REMOVE (vhost=>'data.openlinksw.com:80', lpath=>'/oplweb');
DB.DBA.VHOST_DEFINE (vhost=>'data.openlinksw.com:80', lpath=>'/oplweb', ppath=>'/DAV/RDF/oplweb2/',
  vsp_user=>'dba', is_dav=>1, def_page=>'sfront.vspx', is_brws=>0, opts=>vector ('url_rewrite', 'oplweb2_rule_list1'));


/*

DB.DBA.VHOST_DEFINE (vhost=>'data.openlinksw.com:80', lhost=>':80', lpath=>'/rdf_net', ppath=>'/rdf_net');
DB.DBA.VHOST_DEFINE (vhost=>'data.openlinksw.com:80', lhost=>':80', lpath=>'/sparql/',
  ppath => '/!sparql/', is_dav => 1, vsp_user => 'dba', opts => vector('noinherit', 1));

VHOST_REMOVE (vhost=>'data.openlinksw.com', lpath=>'/proxy');
DB.DBA.VHOST_DEFINE (vhost=>'data.openlinksw.com', lhost=>':80', lpath=>'/proxy',
  ppath=>'/SOAP/Http/ext_http_proxy', soap_user=>'PROXY');

DB.DBA.VHOST_DEFINE (vhost=>'data.openlinksw.com:80', lhost=>':80', lpath=>'/xml_a',
  ppath=>'/SOAP/',soap_user=>'XML_A');
DB.DBA.VHOST_DEFINE (vhost=>'data.openlinksw.com:80', lhost=>':80', lpath=>'/XMLA',
  ppath=>'/SOAP/', soap_user=>'XMLA', soap_opts => vector ('ServiceName', 'XMLAnalysis', 'elementFormDefault', 'qualified'))

GRANT EXECUTE ON DB.DBA.RDF_SPONGE_UP TO "SPARQL", "SPARQL_UPDATE";
GRANT EXECUTE ON DB.DBA.TTLP_EV_NEW_GRAPH TO "SPARQL", "SPARQL_UPDATE";
grant SPARQL_UPDATE to "SPARQL";

curl -H "Accept: application/rdf+xml" "http://data.openlinksw.com/oplweb/product_family/uda#this"

select hs_local_iri, exec ('sparql clear graph <'||hs_local_iri||'>') from sys_http_sponge;

*/



OWL based Ontology

--sparql construct { ?x ?y ?z } from --<http://www.openlinksw.com/dataspace/organization/openlink#this>
--	where { ?x ?y ?z }

DB.DBA.RDF_LOAD_RDFXML_MT (
'<?xml version="1.0"?>
<rdf:RDF
    xmlns="http://www.openlinksw.com/dataspace/organization/openlink/oplweb#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:owl="http://www.w3.org/2002/07/owl#"
    xmlns:foaf="http://xmlns.com/foaf/0.1/"
    xmlns:virtrdf="http://www.openlinksw.com/schemas/virtrdf#"
    xml:base="http://www.openlinksw.com/schemas/oplweb#">
  <owl:Ontology rdf:about="http://www.openlinksw.com/schemas/oplweb#">
        <rdfs:label>ProductPortfolio</rdfs:label>
        <rdfs:comment>OpenLink Product Portfolio</rdfs:comment>
        <virtrdf:catName>oplweb</virtrdf:catName>
        <virtrdf:version>1.00</virtrdf:version>
  </owl:Ontology>

	<!-- Family / Category / Format -->

	<rdfs:Class rdf:ID="ProductFamily">
		<rdfs:label>Product Family</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Family
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductCategory">
		<rdfs:label>Product Category</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Category
		</rdfs:comment>
    <rdfs:subPropertyOf rdf:resource="#ProductFamily"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductFormat">
		<rdfs:label>Product Format</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Format
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductFormatCategory">
		<rdfs:label>Product Format Category</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Format Category
		</rdfs:comment>
	</rdfs:Class>

	<rdf:Property rdf:ID="ProductFamilyDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:label>Product Family Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductFamilyLongDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:label>Product Family Long Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductFamilyCode">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:label>Product Family Long Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductFormatDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductFormat"/>
    <rdfs:label>Product Format Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductFormatLongDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductFormat"/>
    <rdfs:label>Product Format Long Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductFormatCode">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductFormat"/>
    <rdfs:domain rdf:resource="#ProductFormatCategory"/>
    <rdfs:label>Product Format Long Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductCategoryDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductCategory"/>
    <rdfs:label>Product Category Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductCategoryLongDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductCategory"/>
    <rdfs:label>Product Category Long Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductCategoryCode">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductCategory"/>
    <rdfs:domain rdf:resource="#ProductFormatCategory"/>
    <rdfs:label>Product Category Long Description</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="hasProduct">
    <rdfs:range rdf:resource="#Product"/>
    <rdfs:domain rdf:resource="#ProductCategory"/>
    <rdfs:domain rdf:resource="#ProductFormat"/>
    <rdfs:domain rdf:resource="#ProductFormatCategory"/>
    <rdfs:label>Product</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="hasCategory">
    <rdfs:range rdf:resource="#ProductCategory"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:label>Product</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="hasFormat">
    <rdfs:range rdf:resource="#ProductFormat"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:domain rdf:resource="#ProductFormat"/>
    <rdfs:label>Product</rdfs:label>
  </rdf:Property>


	<!-- Vendor -->

	<rdfs:Class rdf:ID="VendorCategoryFamily">
		<rdfs:label>vendor_category_family</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			vendor_category_family
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="VendorCategory">
		<rdfs:label>vendor_category</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			vendor_category
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="VendorCategoryFamily"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="Vendors">
		<rdfs:label>vendors</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			vendors
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="VendorCategory"/>
	</rdfs:Class>

	<rdf:Property rdf:ID="VendorName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Vendors"/>
    <rdfs:label>vendor name</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="VendorCategoryFamilyDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#VendorCategoryFamily"/>
    <rdfs:label>vendor_category_family_description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="VendorCategoryDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#VendorCategory"/>
    <rdfs:label>vendor_category_description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="isOfVendorCategory">
    <rdfs:range rdf:resource="#VendorCategory"/>
    <rdfs:domain rdf:resource="#Vendors"/>
    <rdfs:label>vendor_category_description</rdfs:label>
  </rdf:Property>

	<!-- Opsys / DBMS -->

	<rdfs:Class rdf:ID="OpsysFamily">
		<rdfs:label>Opsys Family</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Opsys Family
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="DbmsFamily">
		<rdfs:label>Dbms Family</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Dbms Family
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="DbmsEngine">
		<rdfs:label>Dbms Engine</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Dbms Engine
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="DbmsFamily"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="OpsysType">
		<rdfs:label>Opsys Type</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Opsys Type
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProcessorMode">
		<rdfs:label>Processor Mode</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Processor Mode
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="Processor">
		<rdfs:label>Processor</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Processor
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="ProcessorFamily"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProcessorFamily">
		<rdfs:label>Processor Family</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Processor Family
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="Opsys">
		<rdfs:label>Dbms Engine</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			opsys
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="OpsysFamily"/>
    <rdfs:subClassOf rdf:resource="OpsysType"/>
	</rdfs:Class>

	<rdf:Property rdf:ID="OpsysFamilyName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#OpsysFamily"/>
    <rdfs:label>Opsys Family Name</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysFamilyRating">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#OpsysFamily"/>
    <rdfs:label>Opsys Family Rating</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysFamilyLicenseCode">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#OpsysFamily"/>
    <rdfs:label>Opsys Family License Code</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysFamilyVendor">
    <rdfs:range rdf:resource="#Vendors"/>
    <rdfs:domain rdf:resource="#OpsysFamily"/>
    <rdfs:label>Opsys Family Vendor</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="DbmsFamilyName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DbmsFamily"/>
    <rdfs:label>DBMS Family Name</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="DbmsFamilyVendor">
    <rdfs:range rdf:resource="#Vendors"/>
    <rdfs:domain rdf:resource="#DbmsFamily"/>
    <rdfs:label>DBMS Family Vendor</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="DbmsName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DbmsEngine"/>
    <rdfs:label>DBMS Name</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="DbmsVersion">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DbmsEngine"/>
    <rdfs:label>DBMS Version</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="DbmsEngineRating">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DbmsEngine"/>
    <rdfs:label>DBMS Engine Rating</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="DbmsEngineOldArchiveCode">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DbmsEngine"/>
    <rdfs:label>DBMS Engine old Archive Code</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="DbmsUpwardCompatible">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DbmsEngine"/>
    <rdfs:label>DBMS Upward Compatible</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="DbmsDownwardCompatible">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DbmsEngine"/>
    <rdfs:label>DBMS Downward Compatible</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysTypeDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#OpsysType"/>
    <rdfs:label>Opsys Type Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysTypeShortDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#OpsysType"/>
    <rdfs:label>Opsys Type Short Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Opsys"/>
    <rdfs:label>Opsys Name</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysVersion">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Opsys"/>
    <rdfs:label>Opsys Version</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysUpwardCompatible">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Opsys"/>
    <rdfs:label>Opsys Compatible</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysDownwardCompatible">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Opsys"/>
    <rdfs:label>Opsys Downward Compatible</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysLicenseCode">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Opsys"/>
    <rdfs:label>Opsys License Code</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysCommercialName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Opsys"/>
    <rdfs:label>Opsys Commercial Name</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysProcessor">
    <rdfs:range rdf:resource="#Processor"/>
    <rdfs:domain rdf:resource="#Opsys"/>
    <rdfs:label>Opsys Processor</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="OpsysEmulation">
    <rdfs:range rdf:resource="#ProcessorMode"/>
    <rdfs:domain rdf:resource="#Opsys"/>
    <rdfs:label>Opsys Emulation Mode</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProcessorModeName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProcessorMode"/>
    <rdfs:label>Processor Mode Name</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProcessorName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Processor"/>
    <rdfs:label>Processor Name</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProcessorProcessorMode">
    <rdfs:range rdf:resource="#ProcessorMode"/>
    <rdfs:domain rdf:resource="#Processor"/>
    <rdfs:label>Processor Mode</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProcessorDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Processor"/>
    <rdfs:label>Processor Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProcessorFamilyName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProcessorFamily"/>
    <rdfs:label>Processor Family Name</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProcessorFamilyDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProcessorFamily"/>
    <rdfs:label>Processor Family Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProcessorFamilyVendor">
    <rdfs:range rdf:resource="#Vendors"/>
    <rdfs:domain rdf:resource="#ProcessorFamily"/>
    <rdfs:label>Processor Family Vendor</rdfs:label>
  </rdf:Property>


	<!-- Product / Product Release -->

	<rdfs:Class rdf:ID="Product">
		<rdfs:label>Product</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product
		</rdfs:comment>
    <rdfs:subPropertyOf rdf:resource="#ProductFormat"/>
    <rdfs:subPropertyOf rdf:resource="#ProductCategory"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductRelease">
		<rdfs:label>Product Release</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Release
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="#Product"/>
	</rdfs:Class>

	<rdf:Property rdf:ID="ProductId">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:label>Product ID</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="isOfCategory">
    <rdfs:range rdf:resource="#ProductCategory"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:label>Product Category</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="isOfFormat">
    <rdfs:range rdf:resource="#ProductFormat"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:label>Product Category</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductDescription">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:label>Product Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductLongDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:label>Product Long Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductReleaseId">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductRelease"/>
    <rdfs:label>Product Release ID</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductReleaseOpsys">
    <rdfs:range rdf:resource="#Opsys"/>
    <rdfs:domain rdf:resource="#ProductRelease"/>
    <rdfs:label>Product Release Opsys</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductReleaseDbms">
    <rdfs:range rdf:resource="#DbmsEngine"/>
    <rdfs:domain rdf:resource="#ProductRelease"/>
    <rdfs:label>Product Release DBMS</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductReleaseUpwardCompatible">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductRelease"/>
    <rdfs:label>Product Release upward compatible</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductReleaseDownwardCompatible">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductRelease"/>
    <rdfs:label>Product Release downward compatible</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ProductReleaseSupported">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductRelease"/>
    <rdfs:label>Product Release Supported</rdfs:label>
  </rdf:Property>

	<!-- Components -->

	<rdfs:Class rdf:ID="Component">
		<rdfs:label>Components</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Components
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ComponentMode">
		<rdfs:label>Component Mode</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Component
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ComponentType">
		<rdfs:label>Component</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Component Type
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ComponentCategory">
		<rdfs:label>Component Category</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Component
		</rdfs:comment>
	</rdfs:Class>

	<rdf:Property rdf:ID="ComponentModeDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentMode"/>
    <rdfs:label>Component Mode Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ComponentModeShortDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentMode"/>
    <rdfs:label>Component Mode Short Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ComponentTypeDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentType"/>
    <rdfs:label>Component Type Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ComponentTypeShortDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentType"/>
    <rdfs:label>Component Type Short Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ComponentCategoryDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentCategory"/>
    <rdfs:label>Component Category Description</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ComponentCategoryLongDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentCategory"/>
    <rdfs:label>Component Category Long Description</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentCategoryShortDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentCategory"/>
    <rdfs:label>Component Category Short Description</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components Name</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentCvsid">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components CVSID</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentBuildDate">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components Build Date</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="Notes">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components Notes</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="BuildComments">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components Build Comments</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="Filesize">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components Name</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ComponentComponentCategory">
    <rdfs:range rdf:resource="#ComponentCategory"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components Component Category</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentComponentType">
    <rdfs:range rdf:resource="#ComponentType"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components Component Type</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentComponentMode">
    <rdfs:range rdf:resource="#ComponentMode"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components Component Mode</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentOpsys">
    <rdfs:range rdf:resource="#Opsys"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components Opsys</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentDbmsEngine">
    <rdfs:range rdf:resource="#DbmsEngine"/>
    <rdfs:domain rdf:resource="#Component"/>
    <rdfs:label>Components DBMS</rdfs:label>
  </rdf:Property>

	<!-- Component Archives -->

	<rdfs:Class rdf:ID="ComponentArchive">
		<rdfs:label>Component Archive</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Component Archives
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="#ProductRelease"/>
    <rdfs:subClassOf rdf:resource="#Component"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ComponentArchiveType">
		<rdfs:label>Component Archive Type</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Component Archives Type
		</rdfs:comment>
	</rdfs:Class>

  <rdf:Property rdf:ID="ComponentArchiveTypeName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentArchiveType"/>
    <rdfs:label>Component Archive Type Name</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentArchiveTypeShortName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentArchiveType"/>
    <rdfs:label>Component Archive Type Name</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentArchiveTypeExtension">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentArchiveType"/>
    <rdfs:label>Component Archive Type Extension</rdfs:label>
  </rdf:Property>

	<rdf:Property rdf:ID="ComponentArchiveComponentArchiveType">
    <rdfs:range rdf:resource="#ComponentArchiveType"/>
    <rdfs:domain rdf:resource="#ComponentArchive"/>
    <rdfs:label>Component Archive Component Archive Type</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentArchiveName">
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentArchive"/>
    <rdfs:label>Component Archive Name</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentArchiveAssemblyDate">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentArchive"/>
    <rdfs:label>Component Archive Assembly Date</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentArchiveFileUri">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentArchive"/>
    <rdfs:label>Component Archive File URI</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentArchiveLicenseCode">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentArchive"/>
    <rdfs:label>Component Archive License Code</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentArchiveResName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentArchive"/>
    <rdfs:label>Component Archive DAV Resource Name</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentArchiveResFullPath">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentArchive"/>
    <rdfs:label>Component Archive DAV Full Path</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ComponentArchiveResFileSize">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ComponentArchive"/>
    <rdfs:label>Component Archive File Size in DAV</rdfs:label>
  </rdf:Property>

	<!-- Download locations -->

	<rdfs:Class rdf:ID="DownloadLocation">
		<rdfs:label>Download Location</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Download Location
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="#ComponentArchive"/>
    <rdfs:subClassOf rdf:resource="#DownloadPartner"/>
    <rdfs:subClassOf rdf:resource="#DownloadProtocol"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="DownloadProtocol">
		<rdfs:label>Download Protocol</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Download Protocol
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="DownloadPartner">
		<rdfs:label>Download Partner</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Download Partner
		</rdfs:comment>
	</rdfs:Class>

  <rdf:Property rdf:ID="ProtocolName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DownloadProtocol"/>
    <rdfs:label>Protocol Name</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ProtocolDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DownloadProtocol"/>
    <rdfs:label>Protocol Description</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ProtocolActive">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DownloadProtocol"/>
    <rdfs:label>Protocol Active</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="PartnerName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DownloadPartner"/>
    <rdfs:label>Download Partner Partner Name</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="HostName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DownloadPartner"/>
    <rdfs:label>Download Partner Hostname</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="DomainName">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DownloadPartner"/>
    <rdfs:label>Download Partner Domain Name</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="PortNumber">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DownloadPartner"/>
    <rdfs:label>Download Partner Port Number</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="Uri">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DownloadLocation"/>
    <rdfs:label>Download Location URI</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="UriOld">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#DownloadLocation"/>
    <rdfs:label>Download Location URI Old</rdfs:label>
  </rdf:Property>

	<!-- Features and Benefits -->

	<rdfs:Class rdf:ID="ProductBenefit">
		<rdfs:label>Product Benefit</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Benefit
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="#ProductBenefitCategory"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductBenefitCategory">
		<rdfs:label>Product Benefit</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Benefit
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductFeatureCategory">
		<rdfs:label>Product Feature Category</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Feature Category
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductFeature">
		<rdfs:label>Product Features</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Features
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="#ProductFeatureCategory"/>
    <rdfs:subClassOf rdf:resource="#ProductBenefit"/>
    <rdfs:subClassOf rdf:resource="#Product"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductFamilyFeature">
		<rdfs:label>Product Family Features</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Family Features
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="#ProductFeatureCategory"/>
    <rdfs:subClassOf rdf:resource="#ProductBenefit"/>
    <rdfs:subClassOf rdf:resource="#ProductFamily"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductFormatFeature">
		<rdfs:label>Product Format Features</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Format Features
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="#ProductFeatureCategory"/>
    <rdfs:subClassOf rdf:resource="#ProductBenefit"/>
    <rdfs:subClassOf rdf:resource="#ProductFormat"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductCategoryFeature">
		<rdfs:label>Product Category Features</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Category Features
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="#ProductFeatureCategory"/>
    <rdfs:subClassOf rdf:resource="#ProductBenefit"/>
    <rdfs:subClassOf rdf:resource="#ProductCategory"/>
	</rdfs:Class>

	<rdfs:Class rdf:ID="ProductReleaseFeature">
		<rdfs:label>Product Benefit</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Product Benefit
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="#ProductFeatureCategory"/>
    <rdfs:subClassOf rdf:resource="#ProductBenefit"/>
    <rdfs:subClassOf rdf:resource="#ProductRelease"/>
	</rdfs:Class>

  <rdf:Property rdf:ID="ProductBenefitsCategoryDescription">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductBenefitsCategory"/>
    <rdfs:label>product Benefits Category</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="Description">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductBenefit"/>
    <rdfs:domain rdf:resource="#ProductBenefitCategory"/>
    <rdfs:domain rdf:resource="#ProductFeatureCategory"/>
    <rdfs:domain rdf:resource="#ProductFeature"/>
    <rdfs:domain rdf:resource="#ProductFamilyFeature"/>
    <rdfs:domain rdf:resource="#ProductFormatFeature"/>
    <rdfs:domain rdf:resource="#ProductCategoryFeature"/>
    <rdfs:domain rdf:resource="#ProductReleaseFeature"/>
    <rdfs:label>Product Benefits Description</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="Details">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductFeature"/>
    <rdfs:domain rdf:resource="#ProductFamilyFeature"/>
    <rdfs:domain rdf:resource="#ProductFormatFeature"/>
    <rdfs:domain rdf:resource="#ProductCategoryFeature"/>
    <rdfs:domain rdf:resource="#ProductReleaseFeature"/>
    <rdfs:label>Product Benefits Description Details</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ProductBenefitsAcronym">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductBenefit"/>
    <rdfs:label>Product Benefits Acronym</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="ProductBenefitsExplanation">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductBenefit"/>
    <rdfs:label>Product Benefits Explanation</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="DemoUrl">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductCategoryFeature"/>
    <rdfs:domain rdf:resource="#ProductFormatFeature"/>
    <rdfs:domain rdf:resource="#ProductFamilyFeature"/>
    <rdfs:domain rdf:resource="#ProductReleaseFeature"/>
    <rdfs:label>The Features Demo URL</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="HypesPerSecond">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/>
    <rdfs:domain rdf:resource="#ProductCategoryFeature"/>
    <rdfs:domain rdf:resource="#ProductFormatFeature"/>
    <rdfs:domain rdf:resource="#ProductFamilyFeature"/>
    <rdfs:domain rdf:resource="#ProductreleaseFeature"/>
    <rdfs:label>The Features Number of Hypes per second</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="Implemented">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#ProductCategoryFeature"/>
    <rdfs:domain rdf:resource="#ProductFormatFeature"/>
    <rdfs:domain rdf:resource="#ProductFamilyFeature"/>
    <rdfs:domain rdf:resource="#ProductReleaseFeature"/>
    <rdfs:label>The Features Short Description</rdfs:label>
  </rdf:Property>

<!-- shop / pricing stuff -->

	<rdfs:Class rdf:ID="LicenseType">
		<rdfs:label>License Type</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			License Type
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="UnitType">
		<rdfs:label>Unit Type</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Unit Type
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="GeneralDiscount">
		<rdfs:label>General Discount</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			General Discount
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="IncrementalDiscount">
		<rdfs:label>Incremental Discount</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			Incremental Discount
		</rdfs:comment>
	</rdfs:Class>

	<rdfs:Class rdf:ID="License">
		<rdfs:label>License</rdfs:label>
    <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string">
			License
		</rdfs:comment>
    <rdfs:subClassOf rdf:resource="#LicenseType"/>
    <rdfs:subClassOf rdf:resource="#ProductRelease"/>
	</rdfs:Class>

  <rdf:Property rdf:ID="BaseCostUnit">
    <rdfs:range rdf:resource="#UnitType"/>
    <rdfs:domain rdf:resource="#License"/>
    <rdfs:label>Base Unit Cost</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="PriceUnit">
    <rdfs:range rdf:resource="#UnitType"/>
    <rdfs:domain rdf:resource="#License"/>
    <rdfs:label>Price Unit Cost</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="hasDiscount">
    <rdfs:range rdf:resource="#IncrementalDiscount"/>
    <rdfs:domain rdf:resource="#UnitType"/>
    <rdfs:label>Base Unit Cost</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="hasGeneralDiscount">
    <rdfs:range rdf:resource="#GeneralDiscount"/>
    <rdfs:domain rdf:resource="#License"/>
    <rdfs:label>General Discount</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="unitValue">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#UnitType"/>
    <rdfs:label>Unit Value</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="graceUnit">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#UnitType"/>
    <rdfs:label>Grace Unit</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="minUnits">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#UnitType"/>
    <rdfs:label>Minimum Units</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="maxUnits">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#UnitType"/>
    <rdfs:label>Maximum Units</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="codeWord">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#GeneralDiscount"/>
    <rdfs:label>Code Word needed to activate this discount</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="startDate">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#GeneralDiscount"/>
    <rdfs:label>Discount Start Date</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="endDate">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#GeneralDiscount"/>
    <rdfs:label>Discount End Date</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="percentageOfCost">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#GeneralDiscount"/>
    <rdfs:label>Percentage of cost attributing as discount</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="triggerPoint">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#IncrementalDiscount"/>
    <rdfs:label>Discount Trigger Point</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="percentageOfBase">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:domain rdf:resource="#IncrementalDiscount"/>
    <rdfs:label>Percentage of base cost attributing as discount</rdfs:label>
  </rdf:Property>

<!-- common properties -->

  <rdf:Property rdf:ID="label">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://www.w3.org/2001/XMLSchema#label"/>
    <rdfs:domain rdf:resource="#ProductCategory"/>
    <rdfs:domain rdf:resource="#ProductFormat"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:domain rdf:resource="#ProductRelease"/>
    <rdfs:domain rdf:resource="#VendorCategory"/>
    <rdfs:domain rdf:resource="#Vendor"/>
    <rdfs:domain rdf:resource="#OpsysFamily"/>
    <rdfs:domain rdf:resource="#DbmsFamily"/>
    <rdfs:domain rdf:resource="#DbmsEngine"/>
    <rdfs:domain rdf:resource="#OpsysType"/>
    <rdfs:domain rdf:resource="#Processor"/>
    <rdfs:domain rdf:resource="#ProcessorFamily"/>
    <rdfs:domain rdf:resource="#Opsys"/>
    <rdfs:domain rdf:resource="#Product"/>
    <rdfs:domain rdf:resource="#ComponentMode"/>
    <rdfs:domain rdf:resource="#ComponentType"/>
    <rdfs:domain rdf:resource="#ComponentCategory"/>
    <rdfs:domain rdf:resource="#ComponentArchive"/>
    <rdfs:domain rdf:resource="#ComponentArchiveType"/>
    <rdfs:domain rdf:resource="#DownloadLocation"/>
    <rdfs:domain rdf:resource="#ProductBenefit"/>
    <rdfs:domain rdf:resource="#ProductBenefitCategory"/>
    <rdfs:domain rdf:resource="#ProductFeatureCategory"/>
    <rdfs:domain rdf:resource="#ProductFeature"/>
    <rdfs:domain rdf:resource="#ProductFamilyFeature"/>
    <rdfs:domain rdf:resource="#ProductFormatFeature"/>
    <rdfs:domain rdf:resource="#ProductCategoryFeature"/>
    <rdfs:domain rdf:resource="#ProductReleaseFeature"/>
    <rdfs:domain rdf:resource="#LicenseModel"/>
    <rdfs:domain rdf:resource="#Discount"/>
    <rdfs:domain rdf:resource="#PriceType"/>
    <rdfs:domain rdf:resource="#PriceUnitType"/>
    <rdfs:label>Label</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="name">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/name"/>
    <rdfs:domain rdf:resource="#ProductCategory"/>
    <rdfs:domain rdf:resource="#ProductFormat"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:domain rdf:resource="#ProductRelease"/>
    <rdfs:label>Name</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="logo">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/logo"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:label>logo</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="homepage">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/homepage"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:domain rdf:resource="#ProcessorFamily"/>
    <rdfs:domain rdf:resource="#OpsysFamily"/>
    <rdfs:domain rdf:resource="#DbmsFamily"/>
    <rdfs:label>homepage</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="maker">
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/>
    <rdfs:subPropertyOf rdf:resource="http://xmlns.com/foaf/0.1/maker"/>
    <rdfs:domain rdf:resource="#ProductCategory"/>
    <rdfs:domain rdf:resource="#ProductFormat"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:domain rdf:resource="#ProductRelease"/>
    <rdfs:label>Maker</rdfs:label>
  </rdf:Property>

  <rdf:Property rdf:ID="sameAs">
    <rdfs:range rdf:resource="owl#sameAs"/>
    <rdfs:domain rdf:resource="#ProductCategory"/>
    <rdfs:domain rdf:resource="#ProductFormat"/>
    <rdfs:domain rdf:resource="#ProductFamily"/>
    <rdfs:domain rdf:resource="#ProductRelease"/>
    <rdfs:domain rdf:resource="#ProductFormatCategory"/>
    <rdfs:label>Name</rdfs:label>
  </rdf:Property>

</rdf:RDF>

',
'http://www.openlinksw.com/schemas/oplweb#',
'http://www.openlinksw.com/schemas/oplweb#')
--'http://www.openlinksw.com/dataspace/organization/openlink/ProductPortfolioOntology/1.0/')
;

rdfs_rule_set ('oplweb2_owlset', 'http://www.openlinksw.com/schemas/oplweb#', 1);

DB.DBA.XML_SET_NS_DECL ('opl', 'http://www.openlinksw.com/schemas/oplweb#', 2);
]]></programlisting>
    </sect3>
  </sect2>
</sect1>
<sect1 id="rdfsparqlrule"><title>RDF Inference in Virtuoso</title>
<sect2 id="rdfsparqlruleintro"><title>Introduction</title>
<para>Virtuoso SPARQL can use an inference context for inferring triples that are not physically stored.
This functionality applies to physically stored quads and not to virtual triples generated from relational data with RDF views.
Such an inference context can be built from one or more graphs containing RDF Schema triples. The supported
RDF Schema or OWL constraints are imported from these graphs and are grouped together into rule bases.
A rule base is a persistent entity that can be referenced by a SPARQL query or end point. Queries running
with a given rule base work as if the triples asserted by this rule base were included in the graph or graphs accessed by the query.
</para>
<para>As of version 5.0, Virtuoso recognizes <emphasis>rdfs:subClassOf</emphasis> and <emphasis>rdfs:subPropertyOf</emphasis>.
owl:sameAs is considered for arbitrary subjects and objects if specially enabled by a pragme in the query.
As of 5.00.3031, owl:sameAs, owl:equivalentClass and owl:equivalentProperty are also considered when determining subclass or subproperty relations.  If two  classes are equivalent, they share all instances, subclasses and superclasses directly or indirectly stated in the data for either class.
Other RDF Schema or OWL information is not taken into account.
</para>
</sect2>
<sect2 id="rdfsparqlrulemake"><title>Making Rule Sets</title>
<para>Since RDF Schema and OWL schemas are RDF graphs, these can be loaded into the triple store. Thus, in order to use
such a schema as query context, one first loads the corresponding document into the triple store using <emphasis>ttlp</emphasis> or
<emphasis>rdf_load_rdfxml</emphasis> or related functions. After the schema document is loaded, one can add the assertions therein
into an inference context with the <emphasis>rdfs_rule_set</emphasis> function. This function specifies a logical name for the rule
set plus a graph URI. It is possible to combine multiple schema graphs into a single rule set. A single schema
graph may also independently participate in multiple rule sets.
</para>
<programlisting>
rdfs_rule_set (in name varchar, in uri varchar, in remove int := 0)
</programlisting>
<para>This function adds the applicable facts of the graph into a rule set. The graph URI must correspond
to the graph IRI of a graph stored in the triple store of the Virtuoso instance. If the remove argument
is true, the specified graph is removed from the rule set instead.
</para>
</sect2>
<sect2 id="rdfsparqlrulechange"><title>Changing Rule Sets</title>
<para>Changing a rule set affects queries made after the change. Some queries may have been previously
compiled and will not be changed as a result of modifying the rule set. When a rule set is changed, i.e.
when <emphasis>rdfs_rule_set</emphasis> is called with the first argument set to a pre-existing rule set's name, all the graphs
associated with this name are read and the relevant facts are added to a new empty rule set. Thus, if
triples are deleted from or added to the graphs comprising the rule set, calling <emphasis>rdfs_rule_set</emphasis> will refresh
the rule set to correspond to the state of the stored graphs.
</para>
</sect2>
<sect2 id="rdfsparqlrulesubclassandsubprop"><title>Subclasses and Subproperties</title>
<para>Virtuoso SPARQL supports RDF Schema subclasses and subproperties.
</para>
<para>The predicates <emphasis>rdfs:subClassOf</emphasis> and <emphasis>rdfs:subPropertyOf</emphasis> are
recognized when they appear in graphs included in a rule set. When such a rule set is specified as a context
for a SPARQL query, the following extra triples are generated as needed.
</para>
<para>For every <emphasis>?s rdf:type ?class</emphasis>, a triple <emphasis>?s rdf:type ?superclass</emphasis> is considered to exist,
such that <emphasis>?superclass</emphasis> is a direct or indirect superclass of <emphasis>?class</emphasis>. Direct superclasses are
declared with the <emphasis>rdfs:subClassOf</emphasis> predicate in the rule set graph. Transitivity of superclasses
is automatically taken into account, meaning that if a is a superclass of b and b a superclass of c,
then a is a superclass of c also. Cyclic superclass relations are not allowed. If such occur in the rule set data,
the behavior is undefined but will not involve unterminating recursion.
</para>
<para>For every <emphasis>?s ?subpredicate ?o</emphasis>, a triple <emphasis>?s ?superpredicate ?o</emphasis>
is considered to exist if the rule context declares <emphasis>?superpredicate</emphasis> to be a superpredicate
of <emphasis>?predicate</emphasis>. This is done by having the triple <emphasis>?subpredicate rdfs:subPropertyOf ?superpredicate</emphasis>
as part of the graphs making up the rule context. Transitivity is observed, thus if a is a subpredicate of b and b
a subpredicate of c, then a is also a subpredicate of c.
</para>
</sect2>
<sect2 id="rdfsameas"><title>OWL sameAs Support</title>
<para>
Virtuoso has limited support for the OWL sameAs predicate.
</para>
<para>
In the following, the abbreviation owl:sameAs is used for  the IRI http://www.w3.org/2002/07/owl#sameAs .
</para>
<para>
If sameAs traversal is enabled and a triple pattern with a given
subject or object is being matched, all the synonyms of the S and O
will be tried and results generated for all the tried bindings of S
and O.  The set of synonyms is generated at run time by following all
owl:sameAs triples where the IRI in question is either the subject or
the object.  These are followed recursively from object to subject and
subject to object until the complete transitive closure is generated.
All sameAs triples from all the graphs applicable to instantiating
the triple pattern at hand are considered.
</para>
<para>
Thus, if we have
</para>
<programlisting><![CDATA[
<thing> <owl:sameAs> <gizmo> .
<thing> <label> "thingy" .
]]></programlisting>
<para>
and we instantiate <emphasis>?s &lt;label> "thingy"</emphasis>
we get <emphasis>?s</emphasis> bound to <emphasis>&lt;thing></emphasis>.
</para>
<para>
If we instantiate <emphasis>&lt;gizmo> &lt;label> ?l</emphasis>
we get <emphasis>?l</emphasis> bound to <emphasis>"thingy"</emphasis> because the subject was given and it was expanded to its synonyms.
</para>
<para>
If binding a variable in a pattern where the variable was free, we do not expand the value to the complete set of its synonyms.
</para>
<para>
Same-as expansion is enabled in a query by <emphasis>define input:same-as "yes"</emphasis> in the beginning of the SPARQL query.
This has a significant run time cost but is in some cases useful when joining data between sets which are mapped to each other with same-as.
</para>
<para>
We note that the number of same-as expansions will depend on the join order used for the SPARQL query.
The compiler does not know the number of synonyms and cannot set the join order accordingly.
Regardless of the join order we will however get at least one IRI of the each synonym set as answer.
Also when interactively navigating a graph with a browser, the same-as expansion will take all synonyms into account.
</para>
<para>
For getting the complete entailment of same-as, a forward
chaining approach should be used, effectively asserting all the
implied triples.
</para>
</sect2>
<sect2 id="rdfsparqlruleintro"><title>Implementation</title>
<para>Triples entailed by subclass or subproperty statements in an inference context are not physically stored.
Such triples are added to the result set by the query run time as needed. Also queries involving subclass or subproperty
rules are not rewritten into unions of all the possible triple patterns that might imply the pattern that is requested.
Instead, the SQL compiler adds special nodes that iterate over subclasses or subproperties at run time. The cost model
also takes subclasses and subproperties into account when determining the approximate cardinality of triple patterns.
</para>
<para>In essence, Virtuoso's support for subclasses and subproperties is backward chaining, i.e. it does not materialize
all implied triples but rather looks for the basic facts implying these triples at query evaluation time.
</para>
</sect2>
<sect2 id="rdfsparqlruleintro"><title>Enabling Inferencing</title>
<para>In a SPARQL query, the define input:inference clause is used to instruct the compiler to use the rules in the named rule set. For example:
</para>
<programlisting>
SQL> rdfs_rule_set ('sample', 'rule_graph');

SQL> sparql define input:inference "sample" select * from &lt;g&gt; where {?s ?p ?o};
</programlisting>
<para>will include all the implied triples in the result set, using the rules in the sample rule set.
</para>
<para>Inference can be enabled triple pattern by triple pattern. This is done with the option
(inference 'rule_set') clause after the triple pattern concerned. Specifying option (inference none)
will disable inference for the pattern concerned while the default inference context applies to the
rest of the patterns. Note that the keyword is input:inference in the query header and simply inference
in the option clause. See the examples section below for examples.
</para>
<para>In SQL, if RDF_QUAD occurs in a select from clause, inference can be added with the table option <emphasis>WITH</emphasis>, as follows:
</para>
<programlisting>
select * from rdf_quad table option (with 'sample') where g = iri_to_id ('xx', 0);
</programlisting>
<para>This is about the same as:
</para>
<programlisting>
define input:inference "sample" select * from &lt;xx&gt; where {?s ?p ?o}
</programlisting>
</sect2>
<sect2 id="rdfsparqlruleexamples"><title>Examples</title>
<programlisting><![CDATA[
ttlp ('
   <http://localhost:8890/dataspace>  	                        <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  <http://rdfs.org/sioc/ns#Space>.
   <http://localhost:8890/dataspace/test2/weblog/test2tWeblog>  <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  <http://rdfs.org/sioc/types#Weblog> .
   <http://localhost:8890/dataspace/discussion/oWiki-test1Wiki> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  <http://rdfs.org/sioc/types#MessageBoard>.
   <http://localhost:8890/dataspace>                            <http://rdfs.org/sioc/ns#link>                     <http://localhost:8890/ods> .
   <http://localhost:8890/dataspace/test2/weblog/test2tWeblog>  <http://rdfs.org/sioc/ns#link>                     <http://localhost:8890/dataspace/test2/weblog/test2tWeblog>.
   <http://localhost:8890/dataspace/discussion/oWiki-test1Wiki> <http://rdfs.org/sioc/ns#link>                     <http://localhost:8890/dataspace/discussion/oWiki-test1Wiki> .
   ', '', 'http://localhost:8890/test');
]]></programlisting>
<para>This loads data space instance data Triples into a Named Graph: &lt;http://localhost:8890/test&gt;
</para>
<programlisting><![CDATA[
ttlp (' @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
  <http://rdfs.org/sioc/ns#Space> rdfs:subClassOf <http://www.w3.org/2000/01/rdf-schema#Resource> .
  <http://rdfs.org/sioc/ns#Container> rdfs:subClassOf <http://rdfs.org/sioc/ns#Space> .
  <http://rdfs.org/sioc/ns#Forum> rdfs:subClassOf <http://rdfs.org/sioc/ns#Container> .
  <http://rdfs.org/sioc/types#Weblog> rdfs:subClassOf <http://rdfs.org/sioc/ns#Forum> .
  <http://rdfs.org/sioc/types#MessageBoard> rdfs:subClassOf <http://rdfs.org/sioc/ns#Forum> .
  <http://rdfs.org/sioc/ns#link> rdfs:subPropertyOf <http://rdfs.org/sioc/ns> .
  ', '', 'http://localhost:8890/schema/test');
]]></programlisting>
<para>This loads a Triples into a Named Graph for schema/ontology data called:
&lt;http://localhost:8890/schema/test&gt; that expresses assertions
about subclasses and subproperties.
</para>
<programlisting>
rdfs_rule_set ('http://localhost:8890/schema/property_rules1', 'http://localhost:8890/schema/test');
</programlisting>
<para>This defines the rule context http://localhost:8890/schema/property_rules1 that is initialized from the contents of graph http://localhost:8890/schema/test.
</para>
<programlisting><![CDATA[
SQL>sparql define input:inference 'http://localhost:8890/schema/property_rules1' select ?s from <http://localhost:8890/test> where {?s <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  <http://rdfs.org/sioc/ns#Space> };
s
VARCHAR
_______________________________________________________________________________

http://localhost:8890/dataspace/test2/weblog/test2tWeblog
http://localhost:8890/dataspace/discussion/oWiki-test1Wiki
http://localhost:8890/dataspace

3 Rows. -- 0 msec.
]]></programlisting>
<para>This returns the instances of http://rdfs.org/sioc/ns#Space. Since http://rdfs.org/sioc/types#Weblog
and http://rdfs.org/sioc/types#MessageBoard are subclasses of http://rdfs.org/sioc/ns#Space,
instances of http://rdfs.org/sioc/ns#Space, http://rdfs.org/sioc/types#Weblog and
http://rdfs.org/sioc/types#MessageBoard are all returned. This results in the subjects
http://localhost:8890/dataspace, http://localhost:8890/dataspace/test2/weblog/test2tWeblog and
http://localhost:8890/dataspace/discussion/oWiki-test1Wiki.
</para>
<programlisting><![CDATA[
SQL>select id_to_iri (s)
from rdf_quad table option (with 'http://localhost:8890/schema/property_rules1')
where g = iri_to_id ('http://localhost:8890/test',0)
  and p = iri_to_id ('http://www.w3.org/1999/02/22-rdf-syntax-ns#type', 0)
  and o = iri_to_id ('http://rdfs.org/sioc/ns#Space', 0);
callret
VARCHAR
_______________________________________________________________________________

http://localhost:8890/dataspace/test2/weblog/test2tWeblog
http://localhost:8890/dataspace/discussion/oWiki-test1Wiki
http://localhost:8890/dataspace

3 Rows. -- 10 msec.
]]></programlisting>
<para>This is the corresponding SQL query, internally generated by the SPARQL query.</para>
<para>Below we first look for all instances of http://rdfs.org/sioc/ns#Space with some
property set to http://localhost:8890/dataspace/test2/weblog/test2tWeblog.
We get the subject http://localhost:8890/dataspace/test2/weblog/test2tWeblog and the
properties http://rdfs.org/sioc/ns#link and http://rdfs.org/sioc/ns.
The join involves both subclass and subproperty inference. Then we turn off the inference
for the second pattern and only get the property http://rdfs.org/sioc/ns#link. Then we do
the same but now specify that inference should apply only to the first triple pattern.
</para>
<programlisting><![CDATA[

SQL>sparql define input:inference  'http://localhost:8890/schema/property_rules1' select * from <http://localhost:8890/test>
where { ?s ?p <http://rdfs.org/sioc/ns#Space> . ?s ?p1 <http://localhost:8890/dataspace/test2/weblog/test2tWeblog> . };


s             p              p1
VARCHAR       VARCHAR       VARCHAR
_______________________________________________________________________________

http://localhost:8890/dataspace/test2/weblog/test2tWeblog  http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://rdfs.org/sioc/ns#link
http://localhost:8890/dataspace/test2/weblog/test2tWeblog  http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://rdfs.org/sioc/ns

2 Rows. -- 0 msec.


SQL>sparql  select * from <http://localhost:8890/test>
where { ?s ?p <http://rdfs.org/sioc/ns#Space> option (inference 'http://localhost:8890/schema/property_rules1') . ?s ?p1 <http://localhost:8890/dataspace/test2/weblog/test2tWeblog> . };

s             p              p1
VARCHAR       VARCHAR        VARCHAR
_______________________________________________________________________________

http://localhost:8890/dataspace/test2/weblog/test2tWeblog  http://www.w3.org/1999/02/22-rdf-syntax-ns#type http://rdfs.org/sioc/ns#link

1 Rows. -- 10 msec.

]]></programlisting>
<emphasis>DBpedia example</emphasis>
<programlisting><![CDATA[
ttlp ('
 prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
 <http://dbpedia.org/property/birthcity> rdfs:subPropertyOf <http://dbpedia.org/property/birthPlace> .
 <http://dbpedia.org/property/birthcountry> rdfs:subPropertyOf  <http://dbpedia.org/property/birthPlace> .
 <http://dbpedia.org/property/cityofbirth> rdfs:subPropertyOf <http://dbpedia.org/property/birthPlace> .
 <http://dbpedia.org/property/countryofbirth> rdfs:subPropertyOf <http://dbpedia.org/property/birthPlace> .
 <http://dbpedia.org/property/countyofbirth> rdfs:subPropertyOf <http://dbpedia.org/property/birthPlace> .
 <http://dbpedia.org/property/cityofdeath> rdfs:subPropertyOf <http://dbpedia.org/property/deathPlace> .
 <http://dbpedia.org/property/countryofdeath> rdfs:subPropertyOf <http://dbpedia.org/property/deathPlace> . ', '',
 'http://dbpedia.org/inference/rules#') ;

rdfs_rule_set ('http://dbpedia.org/schema/property_rules1', 'http://dbpedia.org/inference/rules#');
]]></programlisting>
<programlisting><![CDATA[
sparql
define input:inference 'http://dbpedia.org/schema/property_rules1'
prefix p: <http://dbpedia.org/property/>
select ?s from <http://dbpedia.org> where {?s p:birthcity ?o }
limit 50
s
VARCHAR
_______________________________________________________________________________

http://dbpedia.org/resource/Britt_Janyk
http://dbpedia.org/resource/Chiara_Costazza
http://dbpedia.org/resource/Christoph_Gruber
http://dbpedia.org/resource/Daron_Rahlves
http://dbpedia.org/resource/Finlay_Mickel
http://dbpedia.org/resource/Genevi%C3%A8ve_Simard
http://dbpedia.org/resource/Johann_Grugger
http://dbpedia.org/resource/Kalle_Palander
http://dbpedia.org/resource/Marc_Gini
http://dbpedia.org/resource/Mario_Scheiber
http://dbpedia.org/resource/Prince_Hubertus_of_Hohenlohe-Langenburg
http://dbpedia.org/resource/Resi_Stiegler
http://dbpedia.org/resource/Steven_Nyman
http://dbpedia.org/resource/Hannes_Reichelt
http://dbpedia.org/resource/Jeremy_Transue

15 Rows. -- 167 msec.

sparql
define input:inference 'http://dbpedia.org/schema/property_rules1'
prefix p: <http://dbpedia.org/property/>
select ?s from <http://dbpedia.org> where {?s p:countryofbirth ?o }
limit 50
s
VARCHAR
_______________________________________________________________________________

http://dbpedia.org/resource/A._J._Wood
http://dbpedia.org/resource/A._J._Godbolt
http://dbpedia.org/resource/Ac%C3%A1cio_Casimiro
http://dbpedia.org/resource/Adam_Fry
http://dbpedia.org/resource/Adam_Gilchrist
http://dbpedia.org/resource/Adam_Griffin
http://dbpedia.org/resource/Adam_Gross
...

50 Rows. -- 324 msec.

sparql
define input:inference 'http://dbpedia.org/schema/property_rules1'
prefix p: <http://dbpedia.org/property/>
select ?s from <http://dbpedia.org> where {?s p:countyofbirth ?o }
limit 50

s
VARCHAR
_______________________________________________________________________________

http://dbpedia.org/resource/Eddie_Colman

1 Rows. -- 163 msec.

sparql
define input:inference 'http://dbpedia.org/schema/property_rules1'
prefix p: <http://dbpedia.org/property/>
select ?s from <http://dbpedia.org> where {?s p:birthPlace ?o }

s
VARCHAR
_______________________________________________________________________________

http://dbpedia.org/resource/Eddie_Colman
http://dbpedia.org/resource/Jeremy_Transue
http://dbpedia.org/resource/Finlay_Mickel
http://dbpedia.org/resource/Prince_Hubertus_of_Hohenlohe-Langenburg
http://dbpedia.org/resource/Hannes_Reichelt
http://dbpedia.org/resource/Johann_Grugger
http://dbpedia.org/resource/Chiara_Costazza
...
155287 Rows. -- 342179 msec.

]]></programlisting>
<emphasis>Loading script of the Yago Class hierarchy as inference rules example</emphasis>
<programlisting><![CDATA[
--- Load Class Hierarchy into a Named Graph
select ttlp_mt (file_to_string_output ('yago-class-hierarchy_en.nt'),
'', 'http://dbpedia.org/resource/classes/yago#');

-- Create an  Inference Rule that references the Yago Class Hierarchy
Named Graph

SQL>rdfs_rule_set ('http://dbpedia.org/resource/inference/rules/yago#',
'http://dbpedia.org/resource/classes/yago#');

-- Query for the "The Lord of the Rings" which is a "Book" as
-- explicitly claimed in the DBpedia data set (instance data)

SQL>SPARQL
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX dbpedia: <http://dbpedia.org/property/>
PREFIX yago: <http://dbpedia.org/class/yago/>

SELECT ?s
FROM <http://dbpedia.org>
WHERE {
?s a yago:Book106410904 .
?s dbpedia:name "The Lord of the Rings"@en .
};

s
VARCHAR
_______________________________________________________________________________

http://dbpedia.org/resource/The_Lord_of_the_Rings

1 Rows. -- 321 msec.

-- Query aimed at Books via query scoped to the "Publication" class
-- of which it is a subclass in the Yago Hierarchy
SQL>SPARQL
define input:inference
'http://dbpedia.org/resource/inference/rules/yago#'
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX dbpedia: <http://dbpedia.org/property/>
PREFIX yago: <http://dbpedia.org/class/yago/>

SELECT ?s
FROM <http://dbpedia.org>
WHERE {
?s a yago:Publication106589574 .
?s dbpedia:name "The Lord of the Rings"@en .
};

s
VARCHAR
_______________________________________________________________________________

http://dbpedia.org/resource/The_Lord_of_the_Rings


-- # Variant of query with Virtuoso's Full Text Index extension: bif:contains
SQL>SPARQL
define input:inference
'http://dbpedia.org/resource/inference/rules/yago#'
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX dbpedia: <http://dbpedia.org/property/>
PREFIX yago: <http://dbpedia.org/class/yago/>

SELECT ?s ?n
FROM <http://dbpedia.org>
WHERE {
?s a yago:Publication106589574 .
?s dbpedia:name ?n .
?n bif:contains 'Lord and Rings'
};

s                                                                                 n
VARCHAR                                                                           VARCHAR
_______________________________________________________________________________

http://dbpedia.org/resource/The_Lord_of_the_Rings                                 The Lord of the Rings
http://dbpedia.org/resource/Journeys_of_Frodo                                     Journeys of Frodo: An Atlas of J. R. R. Tolkien's The Lord of the Ri
ngs
http://dbpedia.org/resource/The_Lord_of_the_Rings:_A_Reader%27s_Companion         The Lord of the Rings: A Reader's Companion
http://dbpedia.org/resource/Tolkien:_A_Look_Behind_%22The_Lord_of_the_Rings%22    A Look Behind "The Lord of the Rings""

4 Rows. -- 29573 msec.

-- Retrieve all individuals instances of the Book Class
SQL>SPARQL
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX dbpedia: <http://dbpedia.org/property/>
PREFIX yago: <http://dbpedia.org/class/yago/>

SELECT ?s ?n
FROM <http://dbpedia.org>
WHERE {
?s a yago:Book106410904 .
?s dbpedia:name ?n .
}
limit 10;
s                                                                                 n
VARCHAR                                                                           VARCHAR
_______________________________________________________________________________

http://dbpedia.org/resource/.hack//AI_buster                                      .hack// AI buster
http://dbpedia.org/resource/1000_Love_and_Sex_Quiz                                1000 Love and Sex Quiz
http://dbpedia.org/resource/1491:_New_Revelations_of_the_Americas_Before_Columbus  1491: New Revelations of the Americas Before Columbus
http://dbpedia.org/resource/.hack//AI_buster_2                                    .hack// AI buster 2
http://dbpedia.org/resource/100_Books_by_August_Derleth                           100 Books by August Derleth
http://dbpedia.org/resource/1634:_The_Baltic_War                                  1634: The Baltic War
http://dbpedia.org/resource/003%C2%BD:_The_Adventures_of_James_Bond_Junior        003-+: The Adventures of James Bond Junior"
http://dbpedia.org/resource/1001_Movies_You_Must_See_Before_You_Die               1001 Movies You Must See Before You Die
http://dbpedia.org/resource/1066_and_All_That                                     1066 and All That
http://dbpedia.org/resource/14%2C000_Things_to_be_Happy_About                     14,000 Things to be Happy About

10 Rows. -- 1422 msec.

-- Retrieve all individuals instances of Publication Class which
-- should include all Books.
SQL>SPARQL
define input:inference
'http://dbpedia.org/resource/inference/rules/yago#'
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX dbpedia: <http://dbpedia.org/property/>
PREFIX yago: <http://dbpedia.org/class/yago/>

SELECT ?s ?n
FROM <http://dbpedia.org>
WHERE {
?s a yago:Publication106589574 .
?s dbpedia:name ?n .
};
s                                                                                 n
VARCHAR                                                                           VARCHAR
_______________________________________________________________________________

http://dbpedia.org/resource/461_Ocean_Boulevard                                   461 Ocean Boulevard
http://dbpedia.org/resource/A_Love_Supreme                                        A Love Supreme
http://dbpedia.org/resource/A_Night_at_Red_Rocks_with_the_Colorado_Symphony_Orchestra  A Night at Red Rocks with the Colorado Symphony Orchestra
http://dbpedia.org/resource/At_Fillmore_East                                      At Fillmore East
http://dbpedia.org/resource/August_and_Everything_After                           August and Everything After
...
]]></programlisting>
<emphasis>Equivalence between classes</emphasis>
<para>The example below is based on <ulink url="http://umbel.org/documentation.html">UMBEL</ulink> and DBpedia integraion:</para>
<programlisting><![CDATA[
-- Load UMBEL & DBpedia Instance Level Cross-Links (owl:sameAs) Triples
select ttlp_mt (file_to_string_output ('umbel_dbpedia_linkage_v071.n3'), '', 'http://dbpedia.org');

-- Load UMBEL and DBpedia Type (rdf:type) association Triples
select ttlp_mt (file_to_string_output ('umbel_dbpedia_types_v071.n3'), '', 'http://dbpedia.org');

--- Load UMBEL Subject Concept Class Hierarchy into a Named Graph
select ttlp_mt (file_to_string_output ('umbel_class_hierarchy_v071.n3'), '', 'http://dbpedia.org/resource/classes/umbel#');

--- load UMBEL Subject Concepts Instance Data
select ttlp_mt (file_to_string_output ('umbel_subject_concepts.n3'), '', 'http://dbpedia.org/resource/classes/umbel#');

--- Load UMBEL Abstract Concepts Instance Data
select ttlp_mt (file_to_string_output ('umbel_abstract_concepts.n3'), '', 'http://dbpedia.org/resource/classes/umbel#');


-- Load UMBEL External Ontology Mapping into a Named Graph
select ttlp_mt (file_to_string_output ('umbel_external_ontologies_linkage.n3'), '', 'http://dbpedia.org/resource/classes/umbel#');

-- Create UMBEL Inference Rules

rdfs_rule_set ('http://dbpedia.org/resource/inference/rules/umbel#', 'http://dbpedia.org/resource/classes/umbel#');
]]></programlisting>
<para>Now let's execute the following queries:</para>
<programlisting><![CDATA[
SQL>sparql define input:inference 'http://dbpedia.org/resource/inference/rules/umbel#'
prefix umbel: <http://umbel.org/umbel/sc/>
PREFIX dbpedia: <http://dbpedia.org/property/>
prefix opencyc: <http://sw.opencyc.org/2008/06/10/concept/en/>
select ?s
where
{
 ?s a opencyc:Motorcycle.
 ?s dbpedia:name ?n.
 ?n bif:contains "BMW".
};

s
____________________________________________
http://dbpedia.org/resource/BMW_K1200GT
http://dbpedia.org/resource/BMW_F650CS
http://dbpedia.org/resource/BMW_C1
http://dbpedia.org/resource/BMW_R75
4 Rows. -- 26 msec.
]]></programlisting>
<programlisting><![CDATA[
SQL>sparql define input:inference 'http://dbpedia.org/resource/inference/rules/umbel#'
prefix umbel: <http://umbel.org/umbel/sc/>
PREFIX dbpedia: <http://dbpedia.org/property/>
prefix opencyc: <http://sw.opencyc.org/2008/06/10/concept/en/>
select ?s
where
{
 ?s a umbel:Motorcycle.
 ?s dbpedia:name ?n.
 ?n bif:contains "BMW".
};

s
____________________________________________
http://dbpedia.org/resource/BMW_K1200GT
http://dbpedia.org/resource/BMW_F650CS
http://dbpedia.org/resource/BMW_C1
http://dbpedia.org/resource/BMW_R75
4 Rows. -- 26 msec.
]]></programlisting>
</sect2>
</sect1>
<sect1 id="rdfsparqlrulefulltext"><title>Using Full Text Search in SPARQL</title>
<para>Virtuoso's triple store supports optional full text indexing of RDF object values since version 5.0.
It is possible to declare that objects of triples with a given predicate or graph get indexed.
The graphs and triples may be enumerated or a wildcard may be used.
</para>
<para>The triples for which a full text index entry exists can be found using the <emphasis>bif:contains</emphasis>
or related filters and predicates.
</para>
<para>For example, the query:
</para>
<programlisting>
select *
  from &lt;people&gt;
 where {?s foaf:Name ?name . ?name bif:contains "rich*" .}
</programlisting>
<para>would match all subjects whose <emphasis>foaf:Name</emphasis> contained a word starting with Rich.
This would match Richard, Richie etc.
</para>
<para>If the <emphasis>bif:contains</emphasis> or related predicate is applied to an object that is not
a string or is not the object of an indexed triple, no match will be found.
</para>
<para>The syntax for text patterns is identical to the syntax for the SQL contains predicate.
</para>
<para>The SPARQL/SQL optimizer determines whether the text pattern will be used to drive the query or whether it
will filter results after other conditions are applied first. As opposed to <emphasis>bif:contains</emphasis>,
regexp matching never drives the query or makes us of an index, thus regexps are in practice checked after other conditions.
</para>
<sect2 id="rdfsparqlrulespecifywhatindex"><title>Specifying What to Index</title>
<para>Whether the object of a given triple is indexed in the text index depends on indexing rules. If at least one
indexing rule matches the triple, the object gets indexed if the object is a string. An indexing rule specifies
a graph and a predicate. Either may be an IRI or NULL, in which case it matches all IRI's.
</para>
<para>Rules also have a 'reason', which can be used to group rules into application-specific sets. A triple will stop
being indexed only after all rules mandating its indexing are removed. When an application requires indexing a
certain set of triples, rules are added to for the purpose. These rules are tagged with the name of the application
as their reason. When an application no longer requires indexing, the rules belonging to this application can be
removed. This will not turn off indexing if another application still needs certain triples to stay indexed.
</para>
<para>Indexing is enabled/disable for specific graph/predicate combinations with:
</para>
<programlisting>
create function DB.DBA.RDF_OBJ_FT_RULE_ADD
  (in rule_g varchar, in rule_p varchar, in reason varchar) returns integer
</programlisting>
<programlisting>
create function DB.DBA.RDF_OBJ_FT_RULE_DEL
  (in rule_g varchar, in rule_p varchar, in reason varchar) returns integer
</programlisting>
<para>The first function adds a rule. The two first arguments are the text representation of the IRI's for the graph
and predicate. If NULL is given then all graph's or predicates match. Specifying both as NULL means that all
string valued objects will be added to a text index.
</para>
<para>The second function reverses the effect of the first. Only a rule that actually has been added can be deleted.
Thus one cannot say that all except a certain enumerated set should be indexed.
</para>
<para>The reason argument is an arbitrary string identifying the application that needs this rule.
Two applications can add the same rule.
Removing one of them will still keep the rule in effect.
If an object is indexed due to more than one rule the index data remain free from duplicates, neither index size nor speed is affected.
</para>
<para>
If <emphasis>DB.DBA.RDF_OBJ_FT_RULE_ADD</emphasis> detects that the <emphasis>DB.DBA.RDF_QUAD</emphasis> contains quads whose graphs and/or predicates match to the new rule but not indexed before due to other rules then these quads are indexed automatically.
However the function <emphasis>DB.DBA.RDF_OBJ_FT_RULE_DEL</emphasis> does not remove indexing data about related objects.
Thus the presence of indexing data about an object does not imply that it is necessarily used in some quad that matches to some rule.
</para>
<para>Functions return one if the rule is added or deleted and zero if the call was redundant (the rule has been added before or there's no rule to delete).
</para>
<programlisting><![CDATA[

-- We load Tim Berners-Lee's FOAF file into a graph called people.

DB.DBA.RDF_LOAD_RDFXML (http_get ('http://www.w3.org/People/Berners-Lee/card#i'), 'no', 'http://www.w3.org/people#');

-- We check how many triples we got.

select count (*) from (sparql select * from <people> where {?s ?p ?o})f;

-- We specify that all string objects in the graph people should be text indexed.

DB.DBA.RDF_OBJ_FT_RULE_ADD ('http://www.w3.org/people/rules/ftindex/people#', null, 'http://www.w3.org/people#');

-- We update the text index.

DB.DBA.VT_INC_INDEX_DB_DBA_RDF_OBJ ();

-- See impact of the index  by querying the subjects and predicates of all triples in the GRAPH: <http://www.w3.org/people#>,  where the object is a string which contains a word beginning with "TIM".

sparql select * from <http://www.w3.org/people#> where { ?s ?p ?o . ?o bif:contains '"TIM*"' .};

s                p                o
VARCHAR          VARCHAR          VARCHAR
_______________________________________________________________________________

http://no        http://purl.org/dc/elements/1.1/title  Tim Berners-Lee's FOAF file
http://www.w3.org/People/Berners-Lee/card#i  http://xmlns.com/foaf/0.1/name  Timothy Berners-Lee
http://www.w3.org/People/Berners-Lee/card#i  http://www.w3.org/2000/01/rdf-schema#label  Tim Berners-Lee
http://www.w3.org/People/Berners-Lee/card#i  http://xmlns.com/foaf/0.1/givenname  Timothy
http://www.w3.org/People/Berners-Lee/card#i  http://xmlns.com/foaf/0.1/nick  TimBL
http://www.w3.org/People/Berners-Lee/card#i  http://xmlns.com/foaf/0.1/nick  timbl
http://dig.csail.mit.edu/breadcrumbs/blog/4  http://purl.org/dc/elements/1.1/title  timbl's blog

7 Rows. -- 2 msec.
]]></programlisting>
<para>
The below query is identical with the above but uses a different syntax.
The filter syntax is more flexible in that it allows passing extra options to the contains predicate. These may be useful in the future.
</para>
<programlisting><![CDATA[
sparql select * from <people> where { ?s ?p ?o . filter (bif:contains(?o,  '"TIM*"')) };
]]></programlisting>
<note><title>Note:</title><para>It is better to upgrade to the latest version of Virtuoso before adding free-text rules for the first time.
The upgrade is especially advised in case of big amounts of texts to be indexed.
The reason is that the free-text index on RDF may be changed in future versions and automatic upgrade of an existing index data into new format may take much more time than indexing from scratch.</para></note>
<para>The table <emphasis>DB.DBA.RDF_OBJ_FT_RULES</emphasis> stores list of free-text index configuration rules.
</para>
<programlisting><![CDATA[
create table DB.DBA.RDF_OBJ_FT_RULES (
  ROFR_G varchar not null,       -- specific graph IRI or NULL for "all graphs"
  ROFR_P varchar not null,       -- specific predicate IRI or NULL for "all predicates"
  ROFR_REASON varchar not null,  -- identification string of a creator, preferably human-readable
  primary key (ROFR_G, ROFR_P, ROFR_REASON) );
]]></programlisting>
<para>
Applications may read from this table but they should not write directly.
Numerous duplicates in rules does not affect speed of free-text index operations because the content of the table is cached in memory in a special way,
Unlike the use of configuration functions, direct write to the table will not update that cache.
</para>
<para>
The table is convenient to search for rules added by a given application.
If a unique identification string is used during installation of an application when rules are added then it's easy to remove that rules by an uninstall.
</para>
</sect2>
<sect2 id="rdfsparqlruletimeindexing"><title>Time of Indexing</title>
<para>The triple store's text index is by default in manual batch mode. This means that changes in triples are periodically
reflected in the text index but are not maintained in strict synchrony. This is much more efficient than keeping the
indices in constant synchrony. This setting may be altered with the <emphasis>db.dba.vt_batch_update</emphasis> stored procedure.
</para>
<para>To force synchronization of the RDF text index, use:
</para>
<programlisting>
DB.DBA.VT_INC_INDEX_DB_DBA_RDF_OBJ ();
</programlisting>
<para>To set the text index to follow the triples in real time, use:
</para>
<programlisting>
DB.DBA.VT_BATCH_UPDATE ('DB.DBA.RDF_OBJ', 'ON', null);
</programlisting>
<para>To set the text index to be updated every 10 minutes, use:
</para>
<programlisting>
DB.DBA.VT_BATCH_UPDATE ('DB.DBA.RDF_OBJ', 'ON', 10);
</programlisting>
<para>To make the update always manual, specify NULL as the last argument above.
</para>
<para>
Additional problem related to free-text index of <emphasis>DB.DBA.RDF_QUAD</emphasis> is that some applications (e.g. import of billions of triples) may set triggers off.
This will make free-text index data incomplete.
Call of procedure <emphasis>DB.DBA.RDF_OBJ_FT_RECOVER ()</emphasis> will insert all missing free-text index items by drop and re-insert every existing free-text index rule.
</para>
</sect2>
<sect2 id="rdfviewsandfreetext"><title>Free-Text Indexes on RDF Views</title>
<para>
If an <emphasis>O</emphasis> field of a quad map pattern gets its value from a database column that have a free text index then this index can be used in SPARQL for efficient text search.
As a variant, the free-text index of an additional table may be used.
</para>
<para>
If a statement of quad map pattern declaration starts with declaration of table aliases, declaration of table alias may include name of table column that should have a text index.
Consider possible use of free-text index on content of DAV resources stored in DAV system tables of Virtuoso:
</para>
<programlisting><![CDATA[
prefix mydav: <...>
create quad storage mydav:metadata
from WS.WS.SYS_DAV_RES as dav_resource text literal RES_CONTENT
...
  {
    ...
    mydav:resource-iri (dav_resource.RES_FULL_PATH)
        a mydav:resource ;
        mydav:resource-content dav_resource.RES_CONTENT ;
        mydav:resource-mime-type dav_resource.RESTYPE ;
    ...
  }
]]></programlisting>
<para>
The clause <emphasis>text literal RES_CONTENT</emphasis> grants the SPARQL compiler permission to use free-text index for objects that are literals composed from column <emphasis>dav_resource.RES_CONTENT</emphasis>; this clause also choose between <emphasis>text literal</emphasis> (supports <emphasis>contains()</emphasis> predicate only) and <emphasis>text xml literal</emphasis> (supports both <emphasis>contains()</emphasis> and <emphasis>xcontains()</emphasis>) text indexes.
It is important to understand that free-text index will produce results using raw relational data.
If a literal class transformation changes the text stored in the column then these changes are ignored by free-text search.
E.g., a transformation concatenates a word to the value of the column, but the free-text search will not find this word.
</para>
<para>
The free-text index may be used in a more sophisticated way. Consider a built-in table <emphasis>DB.DBA.RDF_QUAD</emphasis> that does not have a free-text index.
Moreover, the table does not contain full values of all objects; the <emphasis>O</emphasis> column contains &quot;short enough&quot; values inlined, but long and special values are represented by links to <emphasis>DB.DBA.RDF_OBJ</emphasis> table.
The RDF_OBJ table, however, has free-text index that can be used.
The full declaration of built-in default mapping for default storage could be written this way:
</para>
<programlisting><![CDATA[
-- Important! Do not try to execute on live system
-- without prior changing names of storage and quad map pattern!

sparql
create virtrdf:DefaultQuadMap as
graph rdfdf:default-iid-nonblank (DB.DBA.RDF_QUAD.G)
subject rdfdf:default-iid (DB.DBA.RDF_QUAD.S)
predicate rdfdf:default-iid-nonblank (DB.DBA.RDF_QUAD.P)
object rdfdf:default (DB.DBA.RDF_QUAD.O)

create quad storage virtrdf:DefaultQuadStorage
from DB.DBA.RDF_QUAD as physical_quad
from DB.DBA.RDF_OBJ as physical_obj text xml literal RO_DIGEST of (physical_quad.O)
where (^{physical_quad.}^.O = ^{physical_obj.}^.RO_DIGEST)
  {
    create virtrdf:DefaultQuadMap as
      graph rdfdf:default-iid-nonblank (physical_quad.G)
      subject rdfdf:default-iid (physical_quad.S)
      predicate rdfdf:default-iid-nonblank (physical_quad.P)
      object rdfdf:default (physical_quad.O) .
  }
;
]]></programlisting>
<para>
The reference to the free-text index is extended by clause <emphasis> of (physical_quad.O)</emphasis>.
This means that the free-text on <emphasis>DB.DBA.RDF_OBJ.RO_DIGEST</emphasis> will be used when the object value comes from <emphasis>physical_quad.O</emphasis> as if <emphasis>physical_quad.O</emphasis> were indexed itself.
If a SPARQL query invokes <emphasis>virtrdf:DefaultQuadMap</emphasis> but contains no free-text criteria then only <emphasis>DB.DBA.RDF_QUAD</emphasis> appears in the final SQL statement and no join with <emphasis>DB.DBA.RDF_OBJ</emphasis> is made.
Adding a free-text predicate will add <emphasis>DB.DBA.RDF_OBJ</emphasis> to the list of source tables and a join condition for <emphasis>DB.DBA.RDF_QUAD.O</emphasis> and <emphasis>DB.DBA.RDF_OBJ.RO_DIGEST</emphasis>; and it will add <emphasis>contains (RO_DIGEST, ...)</emphasis> predicate, not <emphasis>contains (O, ...)</emphasis>.
As a result, &quot;you pay only for what you use&quot;: adding free-text index to the declaration does not add tables to the query unless the index is actually used.
</para>
<para>
Boolean functions <function>bif:contains</function> and <function>bif:xcontains</function> are used for objects that come from RDF Views as well as for regular &quot;physical&quot; triples.
Every function gets two arguments and returns a boolean value.
The first argument is an local variable.
The argument variable should be used as an object field in the group pattern where the filter condition is placed.
Moreover, the occurrence of variable in object field should be placed <emphasis>before</emphasis> the filter.
If there are many occurrences of the variable in object fields then the free-text search is associated with the rightmost occurrence that is still to the left from the filter.
The triple pattern that contains the rightmost occurrence is called &quot;intake&quot; of free-text search.
When SPARQL compiler chooses appropriate quad map patterns that may generate data matching intake triple pattern it skips quad map patterns that have no declared free-text indexes, because nothing can be found by free-text search in data that have no free-text index.
Every quad map pattern that has free-text pattern will finally produce an invocation of SQL <link linkend="containspredicate">contains</link> or <link linkend="xcontainspredicate">xcontains</link> predicate, so the whole result of free-text search may be a union of free-text searches from different quad map patterns.
</para>
<para>
The described logic is important only in really complicated cases whereas simple queries are self-evident:
</para>
<programlisting><![CDATA[
select * from <my-dav-graph>
where {
    ?resource a mydav:resource ;
        mydav:resource-content ?text .
    filter (bif:contains (?text, "hello and world")) }
]]></programlisting>
<para>
or, more compact,
</para>
<programlisting><![CDATA[
select * from <my-dav-graph>
where {
    ?resource a mydav:resource ;
        mydav:resource-content ?text .
    ?text bif:contains "hello and world" . }
]]></programlisting>
</sect2>
</sect1>
<sect1 id="rdfsparqlprotocolendpoint"><title>Virtuoso SPARQL Query Service</title>
<sect2 id="rdfsparqlprotocolendpointintro"><title>Introduction</title>
<para>The Virtuoso SPARQL query service implements the <ulink url="http://www.w3.org/TR/rdf-sparql-protocol/">SPARQL Protocol for RDF</ulink>
(W3C Working Draft 25 January 2006) providing SPARQL query processing for RDF data available on the open internet.</para>
<para>The query processor extends the standard protocol to provide support for multiple output formats.
At present this uses additional query parameters.</para>
<para>Supported features include</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem>GET and POST requests;</listitem>
<listitem>variety of transfer MIME-types, including RDF /XML and TURTLE;</listitem>
<listitem>default-graph-uri environment parameter;</listitem>
<listitem>all sorts of queries including CONSTRUCT and DESCRIBE.</listitem>
</itemizedlist>
</sect2>

<sect2 id="rdfsupportedprotocolendpointuri"><title>Service Endpoint</title>
<para>Virtuoso reserves the path '/sparql/' and a synonym path '/SPARQL/' for SPARQL service.</para>
<para>In the current implementation, Virtuoso defines virtual directories for HTTP requests that come to the port
specified as 'ServerPort' in the '[HTTPServer]' section of Virtuoso configuration file and refer to one of these
two path strings. So if the Virtuoso installation on host example.com listens for HTTP requests on
port 8080 then client applications should use the 'service endpoint' string equal to 'http://example.com:8080/sparql/'.</para>
<para>Both GET and POST requests are supported by both server and client. The server recognizes the 'Accept: ...' line of request header
to find MIME types preferred by the connected client and adjust the output mode of the response.</para>
<para>The client chooses between GET and POST automatically, using the length of query text as a criterion.</para>
<para>If the SPARQL endpoint is accessed without any URL and query entered, will be shown page with interactive query form.</para>
</sect2>


<sect2 id="rdfsupportedprotocolendpointuri"><title>Service Endpoint with authenticated SPARUL option</title>
<para>Virtuoso reserves the path '/sparql-auth/' for SPARQL service with authenticated SPARUL option.</para>
<para>This endpoint allows specific SQL accounts to perform SPARUL over the SPARQL protocol.</para>
<para>"SPARQL_UPDATE" is needed to be granted on a user to perform all operations on physical triples and
the user to be able allowed to perform SQL/ODBC logins:</para>
<itemizedlist>
  <listitem>Go to the Virtuoso Administration Conductor i.e. http://host:port/conductor</listitem>
  <listitem>Login as dba user</listitem>
  <listitem>Go to System Admin->User Accounts->Users
    <figure id="rdf1" float="1">
      <title>Conductor UI</title>
      <graphic fileref="ui/usr1.png"/>
    </figure>
  </listitem>
  <listitem>Click the link "Edit"</listitem>
  <listitem>In the shown form check the "Allow SQL/ODBC Logins" check-box.</listitem>
  <listitem>Select from the list of available Account Roles "SPARQL_UPDATE" role and
click the ">>" button so to add it to the right-positioned list.</listitem>
    <figure id="rdf2" float="1">
      <title>Conductor UI</title>
      <graphic fileref="ui/usr2.png"/>
    </figure>
  <listitem>Click the "Save" button.</listitem>
</itemizedlist>
<para>Note that if there is a table used in a RDF view, and this table is not granted to SPARQL_SELECT
( SPARQL_UPDATE inherits it ), then select on all graph will return access violation error as the user
account has no permissions to read it. Thus the account need to have privileges on all tables included
in any rdf view in order to be able to select on *all* graphs.</para>
</sect2>

<sect2 id="rdfsupportedrequestmethodsofprotocol"><title>Request Methods</title>
<table colsep="1" frame="all" rowsep="0" shortentry="0" tocentry="1" tabstyle="decimalstyle" orient="land" pgwide="0">
    <title>Methods List</title>
    <tgroup align="char" charoff="50" char="." cols="3">
    <colspec align="left" colnum="1" colsep="0" colwidth="20pc"/>
    <thead>
      <row>
        <entry>Method</entry>
        <entry>Supported?</entry>
        <entry>Notes</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry>GET</entry>
        <entry>Yes</entry>
        <entry>short queries are sent in GET mode</entry>
      </row>
      <row>
        <entry>POST</entry>
        <entry>Yes</entry>
        <entry>Queries longer than 1900 bytes are POST-ed.</entry>
      </row>
      <row>
        <entry>DELETE</entry>
        <entry>No</entry>
        <entry></entry>
      </row>
      <row>
        <entry>PUT</entry>
        <entry>No</entry>
        <entry></entry>
      </row>
    </tbody>
  </tgroup>
</table>
</sect2>

<sect2 id="rdfsparqlclientfunctions"><title>Functions</title>
<para>The SPARQL client can be invoked by three similar functions:</para>

<table colsep="1" frame="all" rowsep="0" shortentry="0" tocentry="1" tabstyle="decimalstyle" orient="land" pgwide="0">
    <title>Functions List</title>
    <tgroup align="char" charoff="50" char="." cols="3">
    <colspec align="left" colnum="1" colsep="0" colwidth="20pc"/>
    <thead>
      <row>
        <entry>Function</entry>
        <entry>Notes</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry>DB.DBA.SPARQL_REXEC</entry>
        <entry>behaves like DBA.SPARQL_EVAL, but executes the query on the specified server. The procedure does not return anything. Instead, it creates a result set. </entry>
      </row>
      <row>
        <entry>DB.DBA.SPARQL_REXEC_TO_ARRAY</entry>
        <entry>behaves like DBA.SPARQL_EXEC_TO_ARRAY (), but executes the query on the specified server. The function return a vector of rows, where every row is represented by a vector of values of fields.</entry>
      </row>
      <row>
        <entry>DB.DBA.SPARQL_REXEC_WITH_META</entry>
        <entry>has no local 'SPARQL_EVAL' analog. It produces not only an array of result rows but also array of metadata about result set in a format used by the exec () function. This function can be used when the result should be passed later to exec_result_names () and exec_result () built-in functions. To process local query in similar style, an application can use plain SQL built-in function exec (): an SPARQL query (with 'SPARQL' keyword in front) can be passed to exec () instead of text of plain SQL SELECT statement.</entry>
      </row>
    </tbody>
  </tgroup>
</table>

<programlisting>
create procedure DB.DBA.SPARQL_REXEC (
    in service varchar, in query varchar, in dflt_graph varchar, in named_graphs any,
    in req_hdr any, in maxrows integer, in bnode_dict any );
</programlisting>

<programlisting>
create function DB.DBA.SPARQL_REXEC_TO_ARRAY (
    in service varchar, in query varchar, in dflt_graph varchar, in named_graphs any,
    in req_hdr any, in maxrows integer, in bnode_dict any )
    returns any;
</programlisting>

<programlisting>
create procedure DB.DBA.SPARQL_REXEC_WITH_META (
    in service varchar, in query varchar, in dflt_graph varchar, in named_graphs any,
    in req_hdr any, in maxrows integer, in bnode_dict any,
    out metadata any,  -- metadata like exec () returns.
    out resultset any) -- results as 'long valmode' values.
</programlisting>

</sect2>

<sect2 id="rdfrequestparamsofunctions"><title>Request Parameters</title>
<table colsep="1" frame="all" rowsep="0" shortentry="0" tocentry="1" tabstyle="decimalstyle" orient="land" pgwide="0">
    <title>Request Parameters List</title>
    <tgroup align="char" charoff="50" char="." cols="3">
    <colspec align="left" colnum="1" colsep="0" colwidth="20pc"/>
    <thead>
      <row>
        <entry>Parameter</entry>
        <entry>Notes</entry>
        <entry>Required?</entry>
        <entry>Occurrence</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry>service</entry>
        <entry>service URI such as 'http://example.com/sparql/'</entry>
        <entry>Yes</entry>
        <entry></entry>
      </row>
      <row>
        <entry>query</entry>
        <entry>text of the query</entry>
        <entry>Yes</entry>
        <entry></entry>
      </row>
      <row>
        <entry>dflt_graph</entry>
        <entry>default graph URI (string or NULL)</entry>
        <entry>No</entry>
        <entry></entry>
      </row>
      <row>
        <entry>named_graphs</entry>
        <entry>vector of named graphs (or NULL to not override what's specified in the query</entry>
        <entry>Yes</entry>
        <entry></entry>
      </row>
      <row>
        <entry>req_hdr</entry>
        <entry>additional HTTP header lines that should be passed to the service; 'Host: ...' is most popular</entry>
        <entry>No</entry>
        <entry></entry>
      </row>
      <row>
        <entry>maxrows</entry>
        <entry>limit on numbers of rows that should be returned (actual size of result set may differ)</entry>
        <entry>No</entry>
        <entry></entry>
      </row>
      <row>
        <entry>bnode_dict</entry>
        <entry>dictionary of known blank node names, or NULL for usual loading</entry>
        <entry>No</entry>
        <entry></entry>
      </row>
    </tbody>
  </tgroup>
</table>
</sect2>

<sect2 id="rdfresponsecodeofprotocol"><title>Response Codes</title>
<para>If the query is a CONSTRUCT or DESCRIBE then the result set
consists of a single row and a single column, the value inside is a
dictionary of triples in 'long valmode'. Note that the dictionary
object can not be sent to SQL client, say, via ODBC. The client can
loose database connection trying to fetch a result set row that
contain a dictionary object. This disconnect will be safe for server,
so the client can re-connect to the server, but the disconnected
transaction will be rolled back.</para>
</sect2>

<sect2 id="rdfsupportedmimesofprotocol"><title>Response Format</title>
<para>All standard MIME types of SPARQL Protocol are supported:</para>
<table colsep="1" frame="all" rowsep="0" shortentry="0" tocentry="1" tabstyle="decimalstyle" orient="land" pgwide="0">
    <title>Supported MIME Types list</title>
    <tgroup align="char" charoff="50" char="." cols="3">
    <colspec align="left" colnum="1" colsep="0" colwidth="20pc"/>
    <thead>
      <row>
        <entry>Mimetype</entry>
        <entry>Supported for result of Query</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry>'application/sparql-results+xml'</entry>
        <entry>SELECT</entry>
      </row>
      <row>
        <entry>'application/sparql-results+xml'</entry>
        <entry>ASK</entry>
      </row>
      <row>
        <entry>'application/rdf+xml'</entry>
        <entry>CONSTRUCT</entry>
      </row>
      <row>
        <entry>'application/rdf+xml'</entry>
        <entry>DESCRIBE</entry>
      </row>
      <row>
        <entry>'text/rdf+n3'</entry>
        <entry>CONSTRUCT</entry>
      </row>
      <row>
        <entry>'text/rdf+n3'</entry>
        <entry>DESCRIBE</entry>
      </row>
    </tbody>
  </tgroup>
</table>
<para>If the HTTP header returned by the remote server does not contain 'Content-Type' line, the MIME type may be guessed from the text of the returned body. </para>
<para>The current implementation does not support results of SELECT returned in RDF /XML, TURTLE or 'sparql-results-2'.</para>
<para>Error messages returned from the service are returned as XML documents, using the mime type application/xml. The documents consist of a single element containing an error message.</para>
</sect2>

<sect2 id="rdfsupportedmimesaddofprotocol"><title>Additional Response Formats -- SELECT</title>
<para>Use the format parameter to select one of the following alternate output formats:</para>

<table colsep="1" frame="all" rowsep="0" shortentry="0" tocentry="1" tabstyle="decimalstyle" orient="land" pgwide="0">
    <title>Additional Response formats list</title>
    <tgroup align="char" charoff="50" char="." cols="3">
    <colspec align="left" colnum="1" colsep="0" colwidth="20pc"/>
    <thead>
      <row>
        <entry>Format Value</entry>
        <entry>Description</entry>
        <entry>Mimetype</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry>HTML</entry>
        <entry>HTML document containing query summary and tabular results</entry>
        <entry>text/html</entry>
      </row>
      <row>
        <entry>json</entry>
        <entry>JSON serialization of results. Conforms to the draft specification Serializing SPARQL Query Results in JSON</entry>
        <entry>application/sparql-results+json</entry>
      </row>
      <row>
        <entry>js</entry>
        <entry>Javascript serialization of results. Generates an HTML table with the CSS class sparql. The table contains a column indicating row number and additional columns for each query variable. Each query solution contributes one row of the table. Unbound variables are indicated with a non-breaking space in the appropriate table cells.</entry>
        <entry>application/javascript</entry>
      </row>
      <row>
        <entry>table</entry>
        <entry></entry>
        <entry>text/html</entry>
      </row>
      <row>
        <entry>XML</entry>
        <entry></entry>
        <entry>text/html</entry>
      </row>
      <row>
        <entry>TURTLE</entry>
        <entry></entry>
        <entry>text/html</entry>
      </row>
    </tbody>
  </tgroup>
</table>
</sect2>

<sect2 id="rdfsparqlendpointexamples"><title>Examples</title>
<para>Virtuoso's SPARQL Implementation Demo offers a live demonstration of Virtuoso's implementation of
<ulink url="http://www.w3.org/TR/rdf-dawg-uc/">DAWG's SPARQL test-suite</ulink>;
a collection of SPARQL query language use-cases that enable interactive and simplified testing of a Triple Store's implementation.
Can be found at 'http://example.com:8080/sparql_demo/' depending on the local Virtuoso Server Configuration, or live at <ulink url="http://demo.openlinksw.com/sparql_demo">Virtuoso Demo Server</ulink>.
</para>
<para><emphasis>Simple example with CONSTRUCT:</emphasis></para>
<para>Go to the sparql endpoint UI: i.e. go to http://host:port/sparql</para>
<para>Enter for Default Graph URI: http://www.w3.org/2001/sw/DataAccess/proto-tests/data/construct/simple-data.rdf</para>
<para>Select "Retrieve remote RDF data for all missing source graphs".</para>
<para>Enter as Query:</para>
<programlisting>
SELECT * WHERE {?s ?p ?o}
</programlisting>
<para>Click the "Run Query" button.</para>
<para>As result will be shown the save in the graph http://www.w3.org/2001/sw/DataAccess/proto-tests/data/construct/simple-data.rdf retrieved triples</para>
<programlisting>
s  	                                  p  	                                           o
http://www.example/jose/foaf.rdf#jose 	  http://www.w3.org/1999/02/22-rdf-syntax-ns#type  http://xmlns.com/foaf/0.1/Person
http://www.example/jose/foaf.rdf#jose 	  http://xmlns.com/foaf/0.1/nick 	           Jo
http://www.example/jose/foaf.rdf#jose 	  http://xmlns.com/foaf/0.1/name 	           Jose Jimen~ez
http://www.example/jose/foaf.rdf#jose 	  http://xmlns.com/foaf/0.1/knows 	           http://www.example/jose/foaf.rdf#juan
http://www.example/jose/foaf.rdf#jose 	  http://xmlns.com/foaf/0.1/homepage 	           http://www.example/jose/
http://www.example/jose/foaf.rdf#jose 	  http://xmlns.com/foaf/0.1/workplaceHomepage 	   http://www.corp.example/
http://www.example/jose/foaf.rdf#kendall  http://xmlns.com/foaf/0.1/knows                  http://www.example/jose/foaf.rdf#edd
http://www.example/jose/foaf.rdf#julia 	  http://www.w3.org/1999/02/22-rdf-syntax-ns#type  http://xmlns.com/foaf/0.1/Person
http://www.example/jose/foaf.rdf#julia 	  http://xmlns.com/foaf/0.1/mbox 	           mailto:julia@mail.example
http://www.example/jose/foaf.rdf#juan 	  http://www.w3.org/1999/02/22-rdf-syntax-ns#type  http://xmlns.com/foaf/0.1/Person
http://www.example/jose/foaf.rdf#juan 	  http://xmlns.com/foaf/0.1/mbox 	           mailto:juan@mail.example
</programlisting>
<para>Now let's take the CONSTRUCT query:</para>
<programlisting><![CDATA[
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX myfoaf: <http://www.example/jose/foaf.rdf#>
CONSTRUCT
  { myfoaf:jose foaf:depiction <http://www.example/jose/jose.jpg>.
    myfoaf:jose foaf:schoolHomepage <http://www.edu.example/>.
    ?s ?p ?o.
  }
FROM <http://www.w3.org/2001/sw/DataAccess/proto-tests/data/construct/simple-data.rdf>
WHERE
  {
    ?s ?p ?o. myfoaf:jose foaf:nick "Jo".
    FILTER ( ! (?s = myfoaf:kendall && ?p = foaf:knows && ?o = myfoaf:edd )
    && ! ( ?s = myfoaf:julia && ?p = foaf:mbox && ?o = <mailto:julia@mail.example> )
    && ! ( ?s = myfoaf:julia && ?p = rdf:type && ?o = foaf:Person))
  }
]]></programlisting>
<para>Execute the GET command with the above query added as parameter with encoded value:</para>
<programlisting><![CDATA[
GET -e -s http://host:port/sparql/?query=PREFIX+rdf%3A+%3Chttp%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%3E%0D%0APREFIX+foaf%3A+%3Chttp%3A%2F%2Fxmlns.com%2Ffoaf%2F0.1%2F%3E%0D%0APREFIX+myfoaf%3A+%3Chttp%3A%2F%2Fwww.example%2Fjose%2Ffoaf.rdf%23%3E%0D%0A%0D%0ACONSTRUCT+%7B+myfoaf%3Ajose+foaf%3Adepiction+%3Chttp%3A%2F%2Fwww.example%2Fjose%2Fjose.jpg%3E.%0D%0A++++++++++++myfoaf%3Ajose+foaf%3AschoolHomepage+%3Chttp%3A%2F%2Fwww.edu.example%2F%3E.%0D%0A++++++++++++%3Fs+%3Fp+%3Fo.%7D%0D%0AFROM+%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2Fsw%2FDataAccess%2Fproto-tests%2Fdata%2Fconstruct%2Fsimple-data.rdf%3E%0D%0AWHERE+%7B+%3Fs+%3Fp+%3Fo.+myfoaf%3Ajose+foaf%3Anick+%22Jo%22.%0D%0A+++++++FILTER+%28+%21+%28%3Fs+%3D+myfoaf%3Akendall+%26%26+%3Fp+%3D+foaf%3Aknows+%26%26+%3Fo+%3D+myfoaf%3Aedd+%29%0D%0A++++++++++++++%26%26+%21+%28+%3Fs+%3D+myfoaf%3Ajulia+%26%26+%3Fp+%3D+foaf%3Ambox+%26%26+%3Fo+%3D+%3Cmailto%3Ajulia%40mail.example%3E+%29%0D%0A++++++++++%26%26+%21+%28+%3Fs+%3D+myfoaf%3Ajulia+%26%26+%3Fp+%3D+rdf%3Atype+%26%26+%3Fo+%3D+foaf%3APerson%29%29%0D%0A%7D%0D%0A&format=application%2Frdf%2Bxml
]]></programlisting>
<para>As result the response will be:</para>
<programlisting><![CDATA[
200 OK
Connection: close
Date: Fri, 28 Dec 2007 10:06:14 GMT
Accept-Ranges: bytes
Server: Virtuoso/05.00.3023 (Win32) i686-generic-win-32  VDB
Content-Length: 2073
Content-Type: application/rdf+xml; charset=UTF-8
Client-Date: Fri, 28 Dec 2007 10:06:14 GMT
Client-Peer: 83.176.40.177:port
Client-Response-Num: 1

<?xml version="1.0" encoding="utf-8" ?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">
<rdf:Description rdf:about="http://www.example/jose/foaf.rdf#juan"><ns0pred:mbox xmlns:ns0pred="http://xmlns.com/foaf/0.1/" rdf:resource="mailto:juan@mail.example"/></rdf:Description>
<rdf:Description rdf:about="http://www.example/jose/foaf.rdf#jose"><ns0pred:schoolHomepage xmlns:ns0pred="http://xmlns.com/foaf/0.1/" rdf:resource="http://www.edu.example/"/></rdf:Description>
<rdf:Description rdf:about="http://www.example/jose/foaf.rdf#jose"><ns0pred:type xmlns:ns0pred="http://www.w3.org/1999/02/22-rdf-syntax-ns#" rdf:resource="http://xmlns.com/foaf/0.1/Person"/></rdf:Description>
<rdf:Description rdf:about="http://www.example/jose/foaf.rdf#jose"><ns0pred:homepage xmlns:ns0pred="http://xmlns.com/foaf/0.1/" rdf:resource="http://www.example/jose/"/></rdf:Description>
<rdf:Description rdf:about="http://www.example/jose/foaf.rdf#juan"><ns0pred:type xmlns:ns0pred="http://www.w3.org/1999/02/22-rdf-syntax-ns#" rdf:resource="http://xmlns.com/foaf/0.1/Person"/></rdf:Description>
<rdf:Description rdf:about="http://www.example/jose/foaf.rdf#jose"><ns0pred:workplaceHomepage xmlns:ns0pred="http://xmlns.com/foaf/0.1/" rdf:resource="http://www.corp.example/"/></rdf:Description>
<rdf:Description rdf:about="http://www.example/jose/foaf.rdf#jose"><ns0pred:nick xmlns:ns0pred="http://xmlns.com/foaf/0.1/">Jo</ns0pred:nick></rdf:Description>
<rdf:Description rdf:about="http://www.example/jose/foaf.rdf#jose"><ns0pred:depiction xmlns:ns0pred="http://xmlns.com/foaf/0.1/" rdf:resource="http://www.example/jose/jose.jpg"/></rdf:Description>
<rdf:Description rdf:about="http://www.example/jose/foaf.rdf#jose"><ns0pred:name xmlns:ns0pred="http://xmlns.com/foaf/0.1/">Jose Jime?+ez</ns0pred:name></rdf:Description>
<rdf:Description rdf:about="http://www.example/jose/foaf.rdf#jose"><ns0pred:knows xmlns:ns0pred="http://xmlns.com/foaf/0.1/" rdf:resource="http://www.example/jose/foaf.rdf#juan"/></rdf:Description>
</rdf:RDF>
Done
]]></programlisting>

</sect2>

<sect2 id="rdfsparqlendpointimplnotes"><title>Implementation Notes</title>
<para>This service has been implemented using <ulink url="http://docs.openlinksw.com/virtuoso">Virtuoso Server</ulink>.</para>
</sect2>

<sect2 id="rdftables"><title>Virtuoso Semantic Bank end point</title>
    <para>
	<emphasis>What is Piggy Bank?</emphasis>
    </para>
    <para>
	Piggy Bank is an extension to the Firefox Web browser that turns it into a Semantic Web browser, letting you make use of existing information on the Web in more useful and flexible ways not offered by the original Web sites.
    </para>
    <para></para>
    <para>
	<emphasis>What is Semantic Bank?</emphasis>
    </para>
    <para>
	Semantic Bank is the server companion of Piggy Bank that lets you persist, share and publish data collected by individuals, groups or communities. Here is a screen shot of one in action:
    </para>
    <para></para>
    <para></para>
    <para>
	<emphasis>What can I do with this?</emphasis>
    </para>
    <para>
	A Semantic Bank allows you to:
    </para>
    <para></para>
    <para>
	persist your information remotely on a server. This is useful, for example, if you want to share data between two of your computers or to avoid losing it due to mistakes or failure.
    </para>
    <para></para>
    <para>
	share information with other people. The ability to tag resources creates a powerful serendipitous categorization (as proven by things like del.icio.us or Flickr).
    </para>
    <para></para>
    <para>
	lets you publish your information, both in the "pure" RDF form (for those who know how to make use of it) or to regular web pages, with the usual Longwell faceted browsing view of it
    </para>
    <para></para>
    <para></para>
    <para>
	<emphasis>How can I help?</emphasis>
    </para>
    <para>
	Semantic Bank is an open source software and built around the spirit of open participation and collaboration.
    </para>
    <para>
	There are several ways you can help:
    </para>
    <itemizedlist mark="bullet" spacing="compact">
      <listitem>Install a Semantic Bank and lets us know about it, so that we can update the list of available Semantic Banks.</listitem>
      <listitem>Subscribe to our mailing lists to show your interest and give us feedback</listitem>
      <listitem>Report problems and ask for new features through our issue tracking system.</listitem>
      <listitem>Send us patches or fixes to the code</listitem>
    </itemizedlist>
    <para>
	<emphasis>Licensing and Legal Issues</emphasis>
    </para>
    <para>
	Semantic Bank is open source software and is licensed under the BSD license.
    </para>
    <para>
	<emphasis>Note</emphasis>, however, that this software ships with libraries that are not released under the same license; that we interpret their licensing terms to be compatible with ours and that we are redistributing them unmodified. For more information on the licensing terms of the libraries Semantic Bank depends on, please refer to the source code.
    </para>
    <para>
	<emphasis>Download location:</emphasis>
    </para>
    <para>
	<ulink url="http://simile.mit.edu/dist/semantic-bank/">"http://simile.mit.edu/dist/semantic-bank/</ulink>
    </para>
    <para>
	<emphasis>The Virtuoso Semantic Bank end point.</emphasis>
    </para>
    <para>
	Before you can publish, you must register with one or more Semantic Banks:
    </para>
    <itemizedlist mark="bullet" spacing="compact">
      <listitem>Invoke the menu command Tools  Piggy Bank  My Semantic Bank Accounts....</listitem>
      <listitem>Click Add... in the Semantic Bank Accounts dialog box.</listitem>
      <listitem>In the popup dialog box, type in the URL to the Virtuoso Semantic Bank you want to register with. Example: http://server_name:server_port/bank</listitem>
      <listitem>Enter an account a valid Virtuoso DAV user. (Note: currently we do not use encryption during authentication; do not use your precious password here.)</listitem>
      <listitem>Click OK, wait for the account to get registered, and then dismiss the Semantic Bank Accounts dialog box.</listitem>
      <listitem>To publish an item, just click the corresponding Publish button (much like how you save the item). To publish all the items being viewed, click the Publish All button.</listitem>
    </itemizedlist>
    <para>
	<emphasis>What is the Graph Name used by Virtuoso for the Triples from PiggyBank?</emphasis>
    </para>
    <para>
	http://simile.org/piggybank/&lt;piggybank-generated-name&gt;
    </para>
    <para>
	The piggybank-generated-name is Virtuoso DAV user.
    </para>
</sect2>
<sect2 id="rdfsparqlexnpointnorthwindexample"><title>Making RDF View Dereferenceable -- Northwind example</title>
<para>Consider an application that makes some relational data available for SPARQL requests, as described in <link linkend="rdfviewnorthwindexample1">first part of Northwind RDF View example</link>. This may be sufficient for some clients but IRIs of described subjects are not dereferenceable. This means that external SPARQL processors can not retrieve that data using Virtuoso Sponger or the like. This also means that if some external resource refer to IRI of some Northwind subject and a user browses that resource then he can not look at application's data by clicking on the subject link.</para>
<para>To make RDF access complete, application can do the following:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem>create a virtual directory;</listitem>
<listitem>instruct the server how to prepare RDF resources on demand;</listitem>
<listitem>configure rendering of RDF resources for non-RDF clients (including web search engines);</listitem>
<listitem>make the used ontology available;</listitem>
<listitem>provide an index or sitemap page to help users that try to browe published data but do not know proper URLs</listitem>
</itemizedlist>
<para>The following sequence of operations demonstrate how to implement the listed features without writing any special web pages.
All requests (except the application-specific index/sitemap) will be handled by existing web service endpoints.</para>
<para>As a precaution, we erase url rewrite rule list that may be in the database after previous run of the script:</para>
<programlisting><![CDATA[
DB.DBA.URLREWRITE_DROP_RULELIST ('demo_nw_rule_list1', 1)
;
]]></programlisting>
<para>Same for individual rewrite rules:</para>
<programlisting><![CDATA[
DB.DBA.URLREWRITE_DROP_RULE ('demo_nw_rule1', 1)
;
DB.DBA.URLREWRITE_DROP_RULE ('demo_nw_rule2', 1)
;
DB.DBA.URLREWRITE_DROP_RULE ('demo_nw_rule3', 1)
;
DB.DBA.URLREWRITE_DROP_RULE ('demo_nw_rule4', 1)
;
]]></programlisting>
<para>As a sanity check we ensure that there are no more rules named like our rules</para>
<programlisting><![CDATA[
select signal ('WEIRD', sprintf ('Rewrite rule "%s" found', URR_RULE))
from DB.DBA.URL_REWRITE_RULE where URR_RULE like 'demo_nw%'
;

]]></programlisting>
<para>Now we create URI rewrite rules based on regular expressions by calling <link linkend="fn_urlrewrite_create_regex_rule"><function>DB.DBA.URLREWRITE_CREATE_REGEX_RULE</function></link>, so same path will be redirected to different places depending on MIME types the client can accept.</para>
<para>This rule is to construct TURTLE or RDF/XML output of CONSTRUCT. Note dots in regexp for MIME type (<emphasis>rdf.n3</emphasis> and <emphasis>rdf.xml</emphasis> instead of fixed chars) because there exist SPARQL web clients published before the related W3C recommendation, they will produce slightly incorrect &quot;Accept:&quot; string.</para>
<programlisting><![CDATA[
DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'demo_nw_rule2',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/sparql?query=CONSTRUCT+{+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Fp+%%3Fo+}+FROM+%%3Chttp%%3A//^{URIQADefaultHost}^/Northwind%%3E+WHERE+{+%%3Chttp%%3A//^{URIQADefaultHost}^%U%%23this%%3E+%%3Fp+%%3Fo+}&format=%U',
    vector('path', 'path', '*accept*'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );
]]></programlisting>
<note><para>The request URL for SPARQL web service looks terrible due to encoding, the sprintf format string for it is even worse. The easiest way of composing strings of that sort is to open the endpoint page, type desired CONSTRUCT or DESCRIBE statement in the form (using some sample IRI), execute, cut the URL of the page with results from the address line of browser window, paste it to the script and then replace the host name with <emphasis>^{URIQADefaultHost}^</emphasis>, every percent with double percent, some parts of sample IRI with <emphasis>%U</emphasis> and value after <emphasis>&amp;format=</emphasis> with <emphasis>%U</emphasis>; adjust the vector of replacement parameters so that its length is equal to the number of <emphasis>%U</emphasis> or other format specifiers in the template.</para></note>
<para>Next rule is to redirect to the RDF browser that will show the subject description and let the user to explore related subjects.</para>
<programlisting><![CDATA[
DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'demo_nw_rule1',
    1,
    '(/[^#]*)',
    vector('path'),
    1,
    '/rdfbrowser/index.html?uri=http%%3A//^{URIQADefaultHost}^%U%%23this',
    vector('path'),
    null,
    '(text/html)|(\\*/\\*)',
    0,
    303
    );
]]></programlisting>
<para>This rule is to remove trailing slash from path. Note that <emphasis>\x24</emphasis> is <emphasis>$</emphasis> for end of line regex pattern, it is written escaped because dollar sign indicates the beginning of macro for ISQL.</para>
<programlisting><![CDATA[
DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'demo_nw_rule3',
    1,
    '(/[^#]*)/\x24',
    vector('path'),
    1,
    '%s',
    vector('path'),
    null,
    null,
    0,
    null
    );
]]></programlisting>
<para>This allow the server to describe proper ontology even when the requested IRI contain wrong host name and even if the ontology for <emphasis>http://demo.openlinksw.com/schemas/northwind#</emphasis> is actualy loaded in the database in graph with different IRI (<emphasis>http://demo.openlinksw.com/schemas/NorthwindOntology/1.0/</emphasis>) and the URI of downloadable ontology file differs from both (the file is <emphasis>/DAV/VAD/demo/sql/nw.owl</emphasis>) .</para>
<programlisting><![CDATA[
create procedure DB.DBA.LOAD_NW_ONTOLOGY_FROM_DAV()
{
  declare content1, urihost varchar;
  select cast (RES_CONTENT as varchar) into content1 from WS.WS.SYS_DAV_RES where RES_FULL_PATH = '/DAV/VAD/demo/sql/nw.owl';
  DB.DBA.RDF_LOAD_RDFXML (content1, 'http://demo.openlinksw.com/schemas/northwind#', 'http://demo.openlinksw.com/schemas/NorthwindOntology/1.0/');
  urihost := cfg_item_value(virtuoso_ini_path(), 'URIQA','DefaultHost');
  if (urihost = 'demo.openlinksw.com')
  {
    DB.DBA.VHOST_REMOVE (lpath=>'/schemas/northwind');
    DB.DBA.VHOST_DEFINE (lpath=>'/schemas/northwind', ppath=>'/DAV/VAD/demo/sql/nw.owl', vsp_user=>'dba', is_dav=>1, is_brws=>0);
    DB.DBA.VHOST_REMOVE (lpath=>'/schemas/northwind#');
    DB.DBA.VHOST_DEFINE (lpath=>'/schemas/northwind#', ppath=>'/DAV/VAD/demo/sql/nw.owl', vsp_user=>'dba', is_dav=>1, is_brws=>0);
  }
};

DB.DBA.LOAD_NW_ONTOLOGY_FROM_DAV();

drop procedure DB.DBA.LOAD_NW_ONTOLOGY_FROM_DAV;

DB.DBA.URLREWRITE_CREATE_REGEX_RULE (
    'demo_nw_rule4',
    1,
    '/schemas/northwind#(.*)',
    vector('path'),
    1,
    '/sparql?query=DESCRIBE%20%3Chttp%3A//demo.openlinksw.com/schemas/northwind%23%U%3E%20FROM%20%3Chttp%3A//demo.openlinksw.com/schemas/NorthwindOntology/1.0/%3E',
    vector('path'),
    null,
    '(text/rdf.n3)|(application/rdf.xml)',
    0,
    null
    );
]]></programlisting>
<para>Then we create the rulelist and define virtual directory <emphasis>/Northwind</emphasis>. Requests that match rewriting rules will be properly redirected and produce the requested data, access to the root will execute default page of the application, namely <emphasis>sfront.vspx</emphasis>.</para>
<programlisting><![CDATA[
DB.DBA.URLREWRITE_CREATE_RULELIST (
    'demo_nw_rule_list1',
    1,
    vector (
                'demo_nw_rule1',
                'demo_nw_rule2',
                'demo_nw_rule3',
                'demo_nw_rule4'
          ));

VHOST_REMOVE (lpath=>'/Northwind');
DB.DBA.VHOST_DEFINE (lpath=>'/Northwind', ppath=>'/DAV/home/demo/', vsp_user=>'dba', is_dav=>1, def_page=>'sfront.vspx',
          is_brws=>0, opts=>vector ('url_rewrite', 'demo_nw_rule_list1'));
]]></programlisting>
<para>Finally, to register the namespace prefix <emphasis>northwind</emphasis> as persistent we execute:</para>
<programlisting><![CDATA[
DB.DBA.XML_SET_NS_DECL ('northwind', 'http://demo.openlinksw.com/schemas/northwind#', 2);
]]></programlisting>
</sect2>
<sect2 id="rdfproxyservice"><title>RDF proxy service</title>
    <para>
	In certain cases like for Ajax applications, it's prohibited to issue HTTP requests to another server that origin server.
	In other cases it is needed to transform the content of target to an RDF format. To this purpose the Virtuoso Server provide a RDF proxy service. This service takes as argument target URL and may return content as-is or will try to transform with SPARQL sponger and return RDF data representing the target. In case of transformation to RDF the serialization of the output can be forced by a URL parameter of by content negotiation.
    </para>
    <para>
	When the rdf_mappers package is installed, Virtuoso reserves the path '/about/[rdf|html]/' for RDF
proxy service. In the current implementation, Virtuoso defines virtual directories for HTTP requests that
come to the port specified as 'ServerPort' in the '[HTTPServer]' section of Virtuoso configuration file
and refer to the above path string. So if the Virtuoso installation on host example.com listens for HTTP
requests on port 8080 then client applications should use the 'service endpoint' string equal to
'http://example.com:8080/about/[rdf|html]/'.
    </para>
    <para>
	If the rdf_mappers package is not installed, then the path '/proxy/rdf/' is used for
RDF proxy service.
    </para>
    <para>
	The old pattern '/proxy/' for RDF proxy service is deprecated.
    </para>
    <para><emphasis>Note: </emphasis>In order the RDF proxy service to work correctly, in case you do
not have the rdf_mappers package installed, you need to enable SPARQL_UPDATE and grant RDF_SPONGE_UP
for SPARQL user:
    </para>
    <para>
       enable SPARQL_UPDATE using Conductor UI:
    </para>
<itemizedlist>
  <listitem>Go to the Virtuoso Administration Conductor i.e. http://host:port/conductor</listitem>
  <listitem>Login as dba user</listitem>
  <listitem>Go to System Admin->User Accounts->Roles</listitem>
    <figure id="rl1" float="1">
      <title>Conductor UI</title>
      <graphic fileref="ui/cn1.png"/>
    </figure>
  <listitem>Click the link "Edit" for "SPARQL_UPDATE</listitem>
  <listitem>Select from the list of available user/groups "SPARQL" and click the ">>" button so to add it to the right-positioned list.</listitem>
    <figure id="rl2" float="1">
      <title>Conductor UI</title>
      <graphic fileref="ui/cn2.png"/>
    </figure>
  <listitem>Click the button "Update".</listitem>
</itemizedlist>
    <para>
       grant RDF_SPONGE_UP:
    </para>
<programlisting><![CDATA[
grant execute on DB.DBA.RDF_SPONGE_UP to "SPARQL";
]]></programlisting>
    <para>
	The RDF proxy service takes following URL parameters when using the style: http://host:port/proxy?..:
    </para>
    <itemizedlist mark="bullet" spacing="compact">
	<listitem><emphasis>force</emphasis> if 'rdf' is specified will try to extract RDF data from target and return it</listitem>
	<listitem><emphasis>header</emphasis> HTTP headers to be sent to the target</listitem>
	<listitem><emphasis>output-format</emphasis> if 'force=rdf' is given, designate the output MIME type of the RDF data, the default is 'rdf+xml', can be also 'n3' or 'turtle' or 'ttl'.</listitem>
    </itemizedlist>
    <para>
	When no 'output-format' is given and RDF data is asked, the result will be serialized with MIME type depending of 'Accept' header i.e. the proxy service will do content negotiation.
    </para>
    <para>Example: rdf file with URL: http://www.w3.org/People/Berners-Lee/card</para>
<programlisting><![CDATA[
-- Access the url in order to view the result in html format:
http://host:port/about/html/http://www.w3.org/People/Berners-Lee/card
-- Access the url in order to view the result in rdf:
http://host:port/about/rdf/http://www.w3.org/People/Berners-Lee/card
-- or use the style:
http://host:port/proxy/rdf/http://www.w3.org/People/Berners-Lee/card
-- or use the style:
http://host:port/proxy?url=http://www.w3.org/People/Berners-Lee/card&force=rdf
]]></programlisting>
	<para>Note: It is not allowed when using the style http://host:port/proxy/rdf to pass url parameters to the proxy. </para>
<para>Now go to the sparql endpoint, i.e. http://host:port/sparql</para>
<para>Enter for Default Graph URI the url of the rdf file:  http://www.w3.org/People/Berners-Lee/card</para>
<para>Enter for Query:</para>
<programlisting><![CDATA[
SELECT * WHERE {?s ?p ?o}
]]></programlisting>
<para>As result will be shown the saved triples:</para>
<programlisting><![CDATA[
s  	                                        p  	                                           o
http://www.w3.org/People/Berners-Lee/card 	http://www.w3.org/1999/02/22-rdf-syntax-ns#type    http://xmlns.com/foaf/0.1/PersonalProfileDocument
http://www.w3.org/People/Berners-Lee/card 	http://purl.org/dc/elements/1.1/title 	           Tim Berners-Lee's FOAF file
http://www.w3.org/People/Berners-Lee/card 	http://creativecommons.org/ns#license 	           http://creativecommons.org/licenses/by-nc/3.0/
http://www.w3.org/People/Berners-Lee/card 	http://xmlns.com/foaf/0.1/maker 	           http://www.w3.org/People/Berners-Lee/card#i
etc ...
]]></programlisting>
</sect2>
<sect2 id="sparqliniservice"><title>SPARQL ini service</title>
    <para>
	The SPARQL INI section values can be get as RDF via http://cname/sparql?ini
    </para>
    <para>Example: http://demo.openlinksw.com/sparql?ini</para>
<programlisting><![CDATA[
<?xml version="1.0" encoding="utf-8" ?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">
<rdf:Description rdf:about="http://www.openlinksw.com/schemas/virtini#SPARQL"><ns0pred:MaxQueryCostEstimationTime xmlns:ns0pred="http://www.openlinksw.com/schemas/virtini#">1000</ns0pred:MaxQueryCostEstimationTime></rdf:Description>
<rdf:Description rdf:about="http://www.openlinksw.com/schemas/virtini#SPARQL"><ns0pred:ExternalXsltSource xmlns:ns0pred="http://www.openlinksw.com/schemas/virtini#">1</ns0pred:ExternalXsltSource></rdf:Description>
<rdf:Description rdf:about="http://www.openlinksw.com/schemas/virtini#SPARQL"><ns0pred:DefaultQuery xmlns:ns0pred="http://www.openlinksw.com/schemas/virtini#">select ?Subject ?Concept where {?Subject a ?Concept}</ns0pred:DefaultQuery></rdf:Description>
<rdf:Description rdf:about="http://www.openlinksw.com/schemas/virtini#SPARQL"><ns0pred:ResultSetMaxRows xmlns:ns0pred="http://www.openlinksw.com/schemas/virtini#">100000</ns0pred:ResultSetMaxRows></rdf:Description>
<rdf:Description rdf:about="http://www.openlinksw.com/schemas/virtini#SPARQL"><ns0pred:MaxQueryExecutionTime xmlns:ns0pred="http://www.openlinksw.com/schemas/virtini#">30</ns0pred:MaxQueryExecutionTime></rdf:Description>
<rdf:Description rdf:about="http://www.openlinksw.com/schemas/virtini#SPARQL"><ns0pred:ExternalQuerySource xmlns:ns0pred="http://www.openlinksw.com/schemas/virtini#">1</ns0pred:ExternalQuerySource></rdf:Description>
<rdf:Description rdf:about="http://www.openlinksw.com/schemas/virtini#SPARQL"><ns0pred:DefaultGraph xmlns:ns0pred="http://www.openlinksw.com/schemas/virtini#">http://demo.openlinksw.com/dataspace/person/demo</ns0pred:DefaultGraph></rdf:Description>
<rdf:Description rdf:about="http://www.openlinksw.com/schemas/virtini#SPARQL"><ns0pred:PingService xmlns:ns0pred="http://www.openlinksw.com/schemas/virtini#">http://rpc.pingthesemanticweb.com/</ns0pred:PingService></rdf:Description>
</rdf:RDF>
]]></programlisting>
</sect2>
<sect2 id="sparqloauthendpoint"><title>SPARQL OAuth Endpoint</title>
<para>OAuth provides a secure data transmmission level mechanism for your SPARQL endpoint.
It enables you to securely interact with your RDF database from a variety of locations. It also
allows you to provide controlled access to private data to select user profiles.</para>
<para>Virtuoso OAuth server can be installed by installing the oauth_dav.vad package and
the OAuth UI is accessible from the URL http://cname:port/oauth</para>
<para>The user must have SQL privileges in order to run secured SPARQL statements.</para>
<para>Here is a sample scenario:</para>
<orderedlist>
<listitem>Install the conductor_dav.vad and oauth_dav.vad packages. </listitem>
<listitem>From the Conductor UI create user test1 by setting SQL and DAV login enable. Also set SPARQL_UPDATE role to it:
<orderedlist>
<listitem>Go to http://cname:port/conductor </listitem>
<listitem>Log in as dba user</listitem>
<listitem>Go to System Admin->User Account and click the "Create New Account" link
<figure id="sparqloauthendpoint1" float="1">
      <title>Conductor UI</title>
      <graphic fileref="ui/SparqlOAuth1.png"/>
    </figure>
</listitem>
<listitem>In the shown form:
<orderedlist>
<listitem>Enter user name for ex. test1, password and confirm password </listitem>
<listitem>Check "Allow DAV Logins" </listitem>
<listitem>Check "Allow SQL/ODBC Logins" </listitem>
<listitem>Add Role "SPARQL_UPDATE" from the list of available Roles to the "Selected" box.
<figure id="sparqloauthendpoint2" float="1">
      <title>Conductor UI</title>
      <graphic fileref="ui/SparqlOAuth2.png"/>
    </figure>
</listitem>
</orderedlist>
</listitem>
<listitem>Click the "Save" button. </listitem>
<listitem>As result the user test1 will be created.
<figure id="sparqloauthendpoint3" float="1">
      <title>Conductor UI</title>
      <graphic fileref="ui/SparqlOAuth3.png"/>
    </figure>
</listitem>
</orderedlist>
</listitem>
<listitem>Go to http://cname:port/oauth/
<figure id="sparqloauthendpoint4" float="1">
      <title>OAuth UI</title>
      <graphic fileref="ui/SparqlOAuth4.png"/>
    </figure>
</listitem>
<listitem>Click the "OAuth keys" link</listitem>
<listitem>Log in as user test1
<figure id="sparqloauthendpoint5" float="1">
      <title>OAuth UI</title>
      <graphic fileref="ui/SparqlOAuth5.png"/>
    </figure>
</listitem>
<listitem>As result will be shown the OAuth application registration form.
<figure id="sparqloauthendpoint6" float="1">
      <title>OAuth UI</title>
      <graphic fileref="ui/SparqlOAuth6.png"/>
    </figure>
</listitem>
<listitem>Generate key for SPARQL by selecting it from the list of "Application name" and click the "Generate Keys" button.</listitem>
<listitem>As result for SPARQL will be generated Consumer Key for ex.:
<programlisting><![CDATA[
cf92411e17f59960a4189451bfb5bf6b92c856e3
]]></programlisting>
<figure id="sparqloauthendpoint7" float="1">
      <title>OAuth UI</title>
      <graphic fileref="ui/SparqlOAuth7.png"/>
    </figure>
</listitem>
<listitem>Click the "Back to main menu" link.</listitem>
<listitem>Click the "Protected SPARQL Endpoint" link.</listitem>
<listitem>As result will be shown the OpenLink Virtuoso SPARQL Query form.
<figure id="sparqloauthendpoint8" float="1">
      <title>OAuth UI</title>
      <graphic fileref="ui/SparqlOAuth8.png"/>
    </figure>
</listitem>
<listitem>Enter for Default Graph URI this:
<programlisting><![CDATA[
http://myopenlink.net/dataspace/person/kidehen#this
]]></programlisting>
</listitem>
<listitem>Enter for "OAuth token" field the value:
<programlisting><![CDATA[
cf92411e17f59960a4189451bfb5bf6b92c856e3
]]></programlisting>
<figure id="sparqloauthendpoint9" float="1">
      <title>OAuth UI</title>
      <graphic fileref="ui/SparqlOAuth9.png"/>
    </figure>
</listitem>
<listitem>Click the "Run Query" button.</listitem>
<listitem>In the shown OAuth Authorization Service form enter the password for user test1 and click the "Login" button.
<figure id="sparqloauthendpoint10" float="1">
      <title>OAuth UI</title>
      <graphic fileref="ui/SparqlOAuth10.png"/>
    </figure>
</listitem>
<listitem>In the shown form click the "Authorize" button.
<figure id="sparqloauthendpoint11" float="1">
      <title>OAuth UI</title>
      <graphic fileref="ui/SparqlOAuth11.png"/>
    </figure>
</listitem>
<listitem>As results will be shown the found results:
<figure id="sparqloauthendpoint12" float="1">
      <title>OAuth UI</title>
      <graphic fileref="ui/SparqlOAuth12.png"/>
    </figure>
</listitem>
</orderedlist>
</sect2>
<sect2 id="sparqlexcel"><title>SPARQL Endpoint with Excel mime-type output option</title>
<para>The SPARQL Endpoint offers an Excel mime-type output option.</para>
<para>From http://cname:host/sparql select for "Display Results As:" Spreadsheet and click the "Run Query" button.</para>
<figure id="sparqlexcel1" float="1">
      <title>SPARQL Endpoint with Excel mime-type output</title>
      <graphic fileref="ui/Excel1.png"/>
    </figure>
<para>As result URL containg as parameter the format application/vnd.ms-excel
for ex. <ulink url="http://demo.openlinksw.com/sparql?default-graph-uri=http%3A%2F%2Fdemo.openlinksw.com%2Fdataspace%2Fperson%2Fdemo&amp;should-sponge=&amp;query=select+*%0D%0Awhere+%7B%3Fs+%3Fp+%3Fo%7D%0D%0Alimit+10&amp;format=application%2Fvnd.ms-excel&amp;debug=on">this one</ulink> will be generated, and can be opened directly with Excel.</para>
<figure id="sparqlexcel2" float="1">
      <title>SPARQL Endpoint with Excel mime-type output</title>
      <graphic fileref="ui/Excel2.png"/>
    </figure>
</sect2>
<sect2 id="sparqljson"><title>SPARQL Endpoint with JSON+RDF</title>
<para>The SPARQL Endpoint offers JSON+RDF output option.</para>
<para>From http://cname:host/sparql select for "Display Results As:" JSON and click the "Run Query" button.</para>
<figure id="sparqljson1" float="1">
      <title>SPARQL Endpoint with JSON+RDF output</title>
      <graphic fileref="ui/JSON1.png"/>
    </figure>
<para>As result URL containg as parameter the format application/sparql-results+json will be generated and the content should look like:</para>
<figure id="sparqljson2" float="1">
      <title>SPARQL Endpoint with JSON+RDF</title>
      <graphic fileref="ui/JSON2.png"/>
    </figure>
</sect2>
</sect1>
<sect1 id="sparqlbi"><title>Business Intelligence Extensions for SPARQL</title>
<para>
Virtuoso extends SPARQL with expressions in results, subqueries, aggregates and grouping.
These extensions allow a straightforward translation of arbitrary SQL queries to SPARQL.
This extension is called  "SPARQL BI", because the primary objective is to match needs of Business Intelligence.
The extended features apply equally to querying physical quads or relational tables mapped through RDF views.
</para>
<note><para>In this section, many examples use TPC-H namespace. You may test them on your local demo database.
They use data from TPC-H dataset that is mapped into graph with IRI like
http://example.com/tpch , but you should replace fake host name &quot;example.com&quot; with host name of your own installation,
<strong>verbatim</strong>, that is specified as &quot;DefaultHost&quot; parameter in [URIQA] section of Virtuoso configuration file.</para></note>
<sect2 id="rdfsparqlaggregate"><title>Aggregates in SPARQL</title>
<para>Virtuoso extends SPARQL with SQL like aggregate and group by functionality. This functionality is
also available through embedding SPARQL text inside SQL but the SPARQL extension syntax has the benefit
of working also over the SPARQL protocol and of looking more SPARQL-like.
</para>
<para>The supported aggregates are <emphasis>count</emphasis>, <emphasis>min</emphasis>, <emphasis>max</emphasis>,
<emphasis>avg</emphasis> and <emphasis>sum</emphasis>. These can take an optional <emphasis>distinct</emphasis>
keyword. These are permitted only in the selection part of a select query. If a selection list consists
of a mix of variables and aggregates, the non-aggregate selected items are considered to be grouping
columns and a group by over them is implicitly added at the end of the generated SQL query. There is
no explicit syntax for group by or having in Virtuoso SPARQL.
</para>
<para>If a selection consists of aggregates exclusively, the result set has one row with the values
of the aggregates. If there are aggregates and variables in the selection, the result set as has many
rows as there are distinct combinations of the variables and the aggregates are calculated over each
such distinct combination, as if there were a SQL group by over all non-aggregates.
</para>
<para>With the count aggregate the argument may be either <emphasis>*</emphasis>, meaning counting all rows or a variable
name, meaning counting all the rows where this variable is bound. If there is no implicit <emphasis>group by</emphasis>,
there can be an optional <emphasis>distinct</emphasis> keyword before the variable that is the argument of an aggregate.
</para>
<para>There is a special syntax for counting distinct combinations of selected variables. This is:</para>
<programlisting><![CDATA[
select count distinct ?v1 ... ?vn
  from ....
]]></programlisting>
<para>User-defined aggregate functions are not supported in current version of SPARQL compiler.</para>
<sect3 id="rdfsparqlaggregateexamples"><title>Examples</title>
<programlisting><![CDATA[
sparql
select count (*)
  from <http://mygraph.com>
 where {?s ?p ?o}

-- Returns the count of physical triples in http://mygraph.com.
]]></programlisting>

<programlisting><![CDATA[
sparql define input:inference 'http://mygraph.com'
select ?p count (?o)
  from <http://mygraph.com>
 where {?s ?p ?o};

-- Returns the count of O's for each distinct P.
]]></programlisting>

<programlisting><![CDATA[
sparql define input:inference 'http://mygraph.com'
select count (?p) count (?o) count (distinct ?o)
 from <http://mygraph.com>
where {?s ?p ?o};

-- returns the count of triples, including inferred triples and the count of distinct O values.
]]></programlisting>

<programlisting><![CDATA[
sparql define input:inference 'http://mygraph.com'
select count distinct ?s ?p ?o
  from <http://mygraph.com>
 where {?s ?p ?o};

-- Returns the number of distinct bindings of ?s ?p ?o.
]]></programlisting>
<programlisting><![CDATA[
sparql
prefix tpch: <http://www.openlinksw.com/schemas/tpch#>
select ?status count(*) sum(?extendedprice)
from <http://localhost.localdomain:8310/tpch>
where {
    ?l a tpch:lineitem ;
      tpch:lineextendedprice ?extendedprice ;
      tpch:linestatus ?status .
  };

-- Get counts and total prices of ordered items, grouped by item status.
]]></programlisting>
   <para><emphasis>Example with dataset of people, some duplicated:</emphasis></para>
   <para>Suppose there is a dataset with many people, some of them duplicated. To list execute the query:
   </para>
<programlisting><![CDATA[
sparql
SELECT DISTINCT
 (?name) ?person ?mail
 WHERE {
   ?person rdf:type foaf:Person .
   ?person foaf:name ?name .
   ?person foaf:mbox_sha1sum ?mail
 };
]]></programlisting>
   <para>Note the newline after DISTINCT to read the query.</para>
   <para>SELECT DISTINCT is as in plain SPARQL, return values are expression ?name and two variables
?person and ?mail. Unfortunately, there's no such thing as DISTINCT for a part of the result set row.
If there's a regular need in such feature and duplicates are seldom then we may introduce an aggregate
called, say, SPECIMEN, that will return the very first of aggregated values, unchanged:
   </para>
<programlisting><![CDATA[
sparql
SELECT ?name (specimen(?person)) (specimen(?mail))
WHERE
  {
    ?person rdf:type foaf:Person .
    ?person foaf:name ?name .
    ?person foaf:mbox_sha1sum ?mail
  };
]]></programlisting>
   <para>If duplicates are seldom and there's no requirement that ?person should correspond to ?mail
(so the result should contains some person node and some mail but they don't have to be connected by
foaf:mbox_sha1sum), then MIN aggregate will work:
   </para>
<programlisting><![CDATA[
sparql
SELECT ?name (min(?person)) (min(?mail))
WHERE
  {
    ?person rdf:type foaf:Person .
    ?person foaf:name ?name .
    ?person foaf:mbox_sha1sum ?mail
  };
]]></programlisting>
   <para>Otherwise, a complicated query is needed:</para>
<programlisting><![CDATA[
sparql
SELECT
 ?name
 ((select (min (?person3))
     where {
         ?person3 rdf:type foaf:Person .
         ?person3 foaf:name ?name .
         ?person3 foaf:mbox_sha1sum ?mail } )) as ?person
 ?mail
 WHERE {
     { select distinct ?name
       where {
           ?person1 rdf:type foaf:Person .
           ?person1 foaf:name ?name .
           ?person1 foaf:mbox_sha1sum ?mail1 } }
     { select ?name (min(?mail2)) as ?mail
       where {
           ?person2 rdf:type foaf:Person .
           ?person2 foaf:name ?name .
           ?person2 foaf:mbox_sha1sum ?mail2 } }
 };
]]></programlisting>
</sect3>
</sect2>
<sect2 id="rdfsparqlaggregatenote"><title>Note on Aggregates and Inference</title>
<para>Inference is added to a SPARQL query only for the variables whose value is actually used. Thus,
</para>
<programlisting><![CDATA[
select count (*)
 from <http://mygraph.com>
where {?s ?p ?o}
]]></programlisting>
<para>will not make inferred values since s, p, and o are actually not used. Instead,
</para>
<programlisting><![CDATA[
sparql
select count (?s) count (?p) count (?o)
 from <http://mygraph.com>
where {?s ?p ?o};
]]></programlisting>
<para>will get all the inferred triples also.
</para>
<para>
This may be confusing and will likely be corrected in the future.
</para>
</sect2>
<!--
<para>We introduce the <emphasis>sum</emphasis>, <emphasis>count</emphasis>, <emphasis>avg</emphasis>, <emphasis>min</emphasis> and <emphasis>max</emphasis> aggregate functions from SQL.</para>
<para>
Semantics of aggregate functions with respect to unbound variables is inherited from semantics for <emphasis>NULL</emphasis> from SQL.
To count result rows without regard to any value being defined, <emphasis>count (*)</emphasis> can be used.</para>
<para>
If grouping is desired, aggregate expressions can be combined with non-aggregate expressions in a selection list.
The non-aggregate expressions will function as grouping columns, i.e. the aggregates are calculated for each distinct combination of the grouping columns. This makes GROUP BY clauses redundant.
</para> -->
<sect2 id="rdfsparqlarrowop"><title>Pointer Operator (<emphasis>+&gt;</emphasis> and <emphasis>*&gt;</emphasis>)</title>
<para>
When expressions occur in result sets, many variables are introduced only to pass a value from triple pattern to the result expression.
This is inconvenient because many triple patterns are trivial. Big number of variable names masquerade &quot;interesting&quot; variables that are used more than one in pattern part of the query and establish logical relationshops between parts of the query.
As a solution we introduce pointer operators.</para>
<para>
The <emphasis>+&gt;</emphasis> (pointer) operator allows referring to a property value without naming it as a variable and explicit writing triple pattern. We can shorten the example above as</para>
<programlisting><![CDATA[sparql
prefix tpch: <http://www.openlinksw.com/schemas/tpch#>
select ?l+>tpch:linestatus count(*) sum(?l+>tpch:lineextendedprice)
from <http://localhost.localdomain:8310/tpch>
where { ?l a tpch:lineitem }]]></programlisting>
<para>
The <emphasis>?subject+&gt;propertyname</emphasis> notation is exactly equivalent to having a triple pattern <emphasis>?subject propertyname ?aux_var</emphasis> binding an auxiliary variable to the mentioned property of the subject within the group pattern enclosing the reference.
For a SELECT, the enclosing group pattern is considered to be the top level pattern of the where clause or in the event of a union, the top level of each term of the union.
Each distinct pointer adds exactly one triple pattern to the enclosing group pattern, thus multiple uses of <emphasis>+&gt;</emphasis> with same arguments do not each add a triple pattern.
Having multiple copies of an identical pattern might lead to changes in cardinality if multiple input graphs were being considered.
If a lineitem had multiple discounts or extended prices, then we would get the cartesian product of both.
</para>
<para>
If a property referenced via <emphasis>+&gt;</emphasis> is absent, the variable at left side of the operator is not bound in the enclosing group pattern because it should be bound in all triple patterns where it appears as a field, including implicitly added patterns.
The <emphasis>?subject*&gt;propertyname</emphasis> notation is introduced in order to access optional property values. It adds an OPTIONAL group <emphasis>OPTIONAL { ?subject propertyname ?aux_var }</emphasis>, not plain triple pattern, so the binding of ?subject is not changed even if the object variable is not bound. If the property is set for all subjects in question then the results of <emphasis>*&gt;</emphasis> and <emphasis>+&gt;</emphasis> are the same. All other equal, <emphasis>+&gt;</emphasis> operator produces better SQL code than <emphasis>*&gt;</emphasis> so use <emphasis>*&gt;</emphasis> only when it is really needed.</para>
</sect2>
<sect2 id="rdfsparqlnesting"><title>Subqueries in SPARQL</title>
<para>
Pure SPARQL does not allow binding a value that is not retrieved through a triple pattern.
We lift this restriction by allowing expressions in the result set and providing names for result columns.
We also let a sparql SELECT statement to appear in other sparql statement in any place where a group pattern may appear,
so names of result columns become names of variables bound using values from returned rows.
This resembles derived tables in SQL.</para>
<para>
For instance, the following statement finds prices of 1000 order lines with biggest discounts.</para>

<programlisting><![CDATA[sparql
define sql:signal-void-variables 1
prefix tpch: <http://www.openlinksw.com/schemas/tpch#>
select ?line ?discount (?extendedprice * (1 - ?discount)) as ?finalprice
from <http://localhost.localdomain:8310/tpch>
where {
  ?line a tpch:lineitem ;
    tpch:lineextendedprice ?extendedprice ;
    tpch:linediscount ?discount . }
order by desc (?extendedprice * ?discount)
limit 1000;]]></programlisting>

<para>
As soon as we ensure that the query works fine, we can use it in answering more complex question.
Imagine that we want to find how big are customers who has got biggest discounts ever made by company.</para>

<programlisting><![CDATA[sparql
define sql:signal-void-variables 1
prefix tpch: <http://www.openlinksw.com/schemas/tpch#>
select ?cust sum(?extendedprice2 * (1 - ?discount2)) max (?bigdiscount)
from <http://localhost.localdomain:8310/tpch>
where
  {
    {
      select ?line (?extendedprice * ?discount) as ?bigdiscount
      where {
        ?line a tpch:lineitem ;
          tpch:lineextendedprice ?extendedprice ;
          tpch:linediscount ?discount . }
      order by desc (?extendedprice * ?discount)
      limit 1000
    }
    ?line tpch:has_order ?order .
    ?order tpch:has_customer ?cust .
    ?cust tpch:customer_of ?order2 .
    ?order2 tpch:order_of ?line2 .
    ?line2 tpch:lineextendedprice ?extendedprice2 ;
      tpch:linediscount ?discount2 .
  }
order by (sum(?extendedprice2 * (1 - ?discount2)) / max (?bigdiscount));]]></programlisting>

<para>
Looking at the result we can see that customers in question are really big so even big 10% discounts on individual items looks like additional 0.5% to 1.5% discounts from sums of total purchases.</para>
<para>
The inner select finds 1000 biggest (in absolute value) discounts and their order lines. For each line we find order of that line and the customer. For every found customers we find all orders he made and all lines of that orders (variable ?line2). The rest is trivial.</para>
<para>
Note that the inner select does not contains FROM clauses. It is not required because inner select inherits access permissions of all outer queries. It is also important that internal variable bindings of subquery are not visible in outer query, only result set variables are bound, similarly, variables bound in outer query are not accessible inside.</para>
<para>
Note also the declaration <emphasis>define sql:signal-void-variables 1</emphasis> that forces SPARQL compiler to signal errors if some variables can not be bound due to typos in names or attempts of making joins of disjoint domains. This diagnostics is especially important when the query is long.</para>
</sect2>
<sect2 id="rdfsparqlbackq"><title>Expressions in Triple Patterns</title>
<para>In addition to expressions in filters and result sets, Virtuoso allows the use of expressions in triples of
CONSTRUCT pattern or WHERE pattern: an expression can be used instead
of constant or variable name for subject, predicate or object. In this
case, an expression is surrounded by backquotes.</para>

<para><emphasis>Example with WHERE Clause:</emphasis></para>
<para>The following return all distinct 'fragment' parts of all subjects in all graphs that have some predicate whose value is equal to 2+2.</para>
<programlisting><![CDATA[
SQL>sparql select distinct (bif:subseq (?s, bif:strchr (?s, '#')))
   where {
     graph ?g {
       ?s ?p `2+2` .
       filter (! bif:isnull (bif:strchr (?s, '#') ) )
     } };

callret
VARCHAR
----------
#four
]]></programlisting>
<para>Inside WHERE part, every expression in a triple pattern is replaced with new variable, a filter expression is added to the enclosing group. The new filter is an equality of new variable and the expression. Hence the sample above is identical to</para>
<programlisting><![CDATA[
sparql
select distinct (bif:subseq (?s, bif:strchr (?s, '#')))
   where {
     graph ?g {
       ?s ?p ?newvariable .
       filter (! bif:isnull (bif:strchr (?s, '#') ) )
       filter (?newvariable = (2+2)) .
     } };
]]></programlisting>
<para><emphasis>Example with CONSTRUCT:</emphasis></para>
<programlisting><![CDATA[
CONSTRUCT {
  <http://bio2rdf.org/interpro:IPR000181>
<http://bio2rdf.org/ns/bio2rdf#hasLinkCount>
`(select (count(?s)) as ?countS
   where { ?s ?p <http://bio2rdf.org/interpro:IPR000181> })` }
where { ?s1 ?p1 ?o1 } limit 1
]]></programlisting>
<para>The result should be:</para>
<programlisting><![CDATA[
<http://bio2rdf.org/interpro:IPR000181> <http://bio2rdf.org/ns/bio2rdf#hasLinkCount> "0"^^<http://www.w3.org/2001/XMLSchema#integer> .
]]></programlisting>
<para><emphasis>Example create graph:</emphasis></para>
<programlisting><![CDATA[
SQL>sparql insert into graph <http://MyNewGraph.com/> {
<http://bio2rdf.org/interpro:IPR000181>
<http://bio2rdf.org/ns/bio2rdf#hasLinkCount>
  `(select (count(?s)) as ?countS
    where { ?s ?p <http://bio2rdf.org/interpro:IPR000181> })` }
 where { ?s1 ?p1 ?o1 } limit 1  ;

callret-0
VARCHAR
_______________________________________________________________________________

Insert into <http://MyNewGraph.com/>, 1 triples -- done

1 Rows. -- 30 msec.
]]></programlisting>
</sect2>	
</sect1>
<sect1 id="sparqldebug"><title>Debugging SPARQL queries</title>

<para>A short SPARQL query can be compiled into a long SQL statement,
especially if data comes from many quad map petterns. Middle-size
application with 50 tables and 10 columns per table may create
thousand of quad map patterns for subjects of hundred different
types. An attempt to &quot;select everything&quot; from RDF view of
that complexity may easily create 5000 lines of SQL code. Thus it is
known in advance that some queries will be rejected even if same
queries work fine on default storage of &quot;physical
quads&quot;.</para>

<para>In addition, an SQL compiler signals an error if table or column
name is unknown, efficiently catching typos. SPARQL uses IRIs that are
long and sometimes unreadable, but there is no &quot;closed
world&quot; schema of the data so a typo in an IRI is not an error, it
is simply some other IRI. So typo in a IRI or in a namespace prefix
cause missing bindings of some triple patterns of the query and
incomplete result, but no errors are usually reported. Typo in graph
or predicate IRI may cause the SPARQL compiler to generate code that
access deafult storage instead of relational source or to generate
empty code that accesses nothing.</para>

<para>The SQL compiler does not signal casting errors when it runs the
statement generated from SPARQL, because the generated SQL code
contains <emphasis>option (QUIETCAST)</emphasis>. This means that
mismatches between expected and actual datatypes of values stay
invisible and may cause rounding errors (say, integer division instead
of floating-point) and even empty joins (due to join conditions that
silently return NULL instead of return comparison error).</para>

<para>In two words, SPARQL queries are so laconic that there is no
room for details that let the compiler distinguish between intention
and a bug. This masquerades query complexity, misuse of names and
mismatches in types. One may make debugging easier by making queries
longer.</para>

<para>Two most helpful debugging tools are automatic void variable
recognition and plain old code inspection. &quot;Automatic&quot; means
&quot;cheap&quot; so the very first step of debugging is to ensure
that every triple pattern of the query may in principle return
something.  This helps in finding typos when the query gets data from
RDF views, this also helps when a query tries to join two disjoint
sorts of subjects.  If <emphasis>define sql:signal-void-variables
1</emphasis> directive is placed at the preambl e of the SPARQL query,
compiler will signal an error if if finds any triple pattern that can
not bind variables or any variable that is proved to be always
unbound. This is especially useful when data are supposed to come from
<emphasis>option (exclusive)</emphasis> or <emphasis>option (soft
exclusive)</emphasis> quad map. Without one of that options SPARQL
compiler will usually bind variables using &quot;physical quad&quot;;
the table of physical quads may contain any rows that match any given
triple pattern; thus many errors will remain undiscovered. If the name
of quad map pattern is known then it is possible to force the SPARQL
compiler to use only that quad map for a whole query or for a
part. This is possible by using the following syntax:</para>

<programlisting><![CDATA[
QUAD MAP quad-map-name { group-pattern }
]]></programlisting>
<para>If some triple pattern inside <emphasis>group-pattern</emphasis> can not be bound using <emphasis>quad-map-name</emphasis> or one of its descendants then <emphasis>define sql:signal-void-variables 1</emphasis> will force the compiler to signal the error.</para>

<note><para>It is technically possible to use <emphasis>QUAD
MAP</emphasis> to improve the performance of query that tries to
access redundant RDF Views but it is much better to achieve the same
effect by providing a more restrictive query or by changing/extending
the RDF View. If an application needs this trick then interoperable SPARQL
clients will experience problems -- they can not use Virtuoso-specific
extensions.</para></note>

<para>
If the automated query checking gives nothing, function <function>sparql_to_sql_text</function> can be used in order to get the SQL text generated from the given query. Its only argument is the text of SPARQL query to compile, without leading SPARQL keyword and semicolon at the end; the returned value is the SQL text. The output may be long but that is the most authoritative source of diagnostic data.
</para>
<para>
When called from ISQL or other ODBC client, return value of <function>sparql_to_sql_text</function> may be transferred as a BLOB so ISQL needs &quot;set blobs on&quot; instruction to avoid data truncation. Even better, the SQL text can be saved into a file:
</para>
<programlisting><![CDATA[
string_to_file ('debug.sql', sparql_to_sql_text ('select * where { graph ?g { ?s a ?type }}'), -2);
]]></programlisting>
<para>(-2 is to overwrite the previous version of the file, as there will be probably many runs of the statement).</para>
<note><para>It is inconvenient to edit query text in order to replace every single quote with two single quotes to make it string constant for <function>sparql_to_sql_text</function>. It is much more convenient to use double quotes in SPARQL queries and replace nothing.</para></note>
<para>As an example, let's find out why the query</para>
<programlisting><![CDATA[
sparql 
prefix northwind: <http://demo.openlinksw.com/schemas/northwind#>
select distinct ?emp
from <http://myhost.example.com/Northwind>
where {
    ?order1 northwind:has_salesrep ?emp ; northwind:shipCountry ?country1 .
    ?order2 northwind:has_salesrep ?emp ; northwind:shipCountry ?country2 .
    filter (?country1 != ?country2) }
]]></programlisting>
<para>is much slower than similar SQL statement. The call of <function>sparql_to_sql_text</function> returns equivalent SQL statement:</para>
<programlisting><![CDATA[
SELECT DISTINCT sprintf_iri ( 'http://myhost.example.com/Northwind/Employee/%U%U%d#this' ,
    /*retval[*/ "s-6-1-t0"."b067b7d~FirstName~0" /* emp */ /*]retval*/ ,
    /*retval[*/  "s-6-1-t0"."b067b7d~FirstName~1" /*]retval*/ ,
    /*retval[*/  "s-6-1-t0"."b067b7d~FirstName~2" /*]retval*/ ) AS /*tmpl*/ "emp"
FROM (SELECT "s-6-1-t0-int~orders"."OrderID" AS /*tmpl*/ "20ffecc~OrderID",
         "s-6-1-t0-int~employees"."FirstName" AS /*as-name-N*/ "b067b7d~FirstName~0",
         "s-6-1-t0-int~employees"."LastName" AS /*as-name-N*/ "b067b7d~FirstName~1",
         "s-6-1-t0-int~employees"."EmployeeID" AS /*as-name-N*/ "b067b7d~FirstName~2"
         FROM Demo.demo.Employees AS "s-6-1-t0-int~employees", Demo.demo.Orders AS "s-6-1-t0-int~orders"
         WHERE /* inter-alias join cond */ 
       "s-6-1-t0-int~orders".EmployeeID = "s-6-1-t0-int~employees".EmployeeID) AS "s-6-1-t0",
    (SELECT "s-6-1-t1-int~orders"."OrderID" AS /*tmpl*/ "20ffecc~OrderID",
        "s-6-1-t1-int~orders"."ShipCountry" AS /*tmpl*/ "e45a7f~ShipCountry"
        FROM Demo.demo.Orders AS "s-6-1-t1-int~orders") AS "s-6-1-t1",
    (SELECT "s-6-1-t2-int~orders"."OrderID" AS /*tmpl*/ "20ffecc~OrderID",
        "s-6-1-t2-int~employees"."FirstName" AS /*as-name-N*/ "b067b7d~FirstName~0",
	"s-6-1-t2-int~employees"."LastName" AS /*as-name-N*/ "b067b7d~FirstName~1",
	"s-6-1-t2-int~employees"."EmployeeID" AS /*as-name-N*/ "b067b7d~FirstName~2"
	FROM Demo.demo.Employees AS "s-6-1-t2-int~employees", Demo.demo.Orders AS "s-6-1-t2-int~orders"
    WHERE /* inter-alias join cond */ 
       "s-6-1-t2-int~orders".EmployeeID = "s-6-1-t2-int~employees".EmployeeID) AS "s-6-1-t2",
    (SELECT "s-6-1-t3-int~orders"."OrderID" AS /*tmpl*/ "20ffecc~OrderID",
        "s-6-1-t3-int~orders"."ShipCountry" AS /*tmpl*/ "e45a7f~ShipCountry"
    FROM Demo.demo.Orders AS "s-6-1-t3-int~orders") AS "s-6-1-t3"
WHERE /* two fields belong to same equiv */ 
    /*retval[*/  "s-6-1-t0"."20ffecc~OrderID" /* order1 */ /*]retval*/  =
    /*retval[*/  "s-6-1-t1"."20ffecc~OrderID" /* order1 */ /*]retval*/ 
    AND /* two fields belong to same equiv */ 
    sprintf_iri ( 'http://myhost.example.com/Northwind/Employee/%U%U%d#this' ,
        /*retval[*/  "s-6-1-t0"."b067b7d~FirstName~0" /* emp */ /*]retval*/ ,
	/*retval[*/  "s-6-1-t0"."b067b7d~FirstName~1" /*]retval*/ ,
	/*retval[*/  "s-6-1-t0"."b067b7d~FirstName~2" /*]retval*/ ) =
    sprintf_iri ( 'http://myhost.example.com/Northwind/Employee/%U%U%d#this' ,
        /*retval[*/  "s-6-1-t2"."b067b7d~FirstName~0" /* emp */ /*]retval*/ ,
	/*retval[*/  "s-6-1-t2"."b067b7d~FirstName~1" /*]retval*/ ,
	/*retval[*/  "s-6-1-t2"."b067b7d~FirstName~2" /*]retval*/ )
    AND /* two fields belong to same equiv */ 
    /*retval[*/  "s-6-1-t2"."20ffecc~OrderID" /* order2 */ /*]retval*/  =
    /*retval[*/  "s-6-1-t3"."20ffecc~OrderID" /* order2 */ /*]retval*/ 
    AND /* filter */ 
   ( /*retval[*/  "s-6-1-t1"."e45a7f~ShipCountry" /* country1 */ /*]retval*/  <>
        /*retval[*/  "s-6-1-t3"."e45a7f~ShipCountry" /* country2 */ /*]retval*/ )
OPTION (QUIETCAST)
]]></programlisting>
<para>The query is next to unreadable but some comments split it into meaningful expressions. Every triple (or list of similar triples) become a subquery that return fields needed to build values of bound variables. That fields are printed outside with comments like

<emphasis>/*retval[*/ expression /* original variable name */
/*]retval*/</emphasis>. Names like<emphasis>"s-6-1-t0"</emphasis>
contain source line number where a group pattern begin (6) and serial
number of triple (0). Comment <emphasis>/* inter-alias join cond
*/</emphasis> means that the expression after that is the condition as
it is written in the declaration of quad map pattern. Comment
<emphasis>/* filter */</emphasis> is before expressions for FILTER
expressions in the source SPARQL. The word &quot;equiv&quot; means
&quot;equivalence class&quot;, i.e. group of occurencies of variables
in the source query that all occurencies are bound to same
value. E.g. when name repeates in many triples of a group, all its
occurencies form an equivalence class. In sone cases compiler can
prove that two variables are always equal even if names differ -- that
variables are also placed into one &quot;equiv&quot;.</para>

<para>Looking at this query, one may notice equality like
<emphasis>sprintf_iri (...) = sprintf_iri (...)</emphasis>. That is
bad because it means that no index will be used to optimize the join
and that there will be one function call per row. When variable
<emphasis>?emp</emphasis> appears in two different triples it means
that the value of the variable is same in both triples. The query
compares IRIs instead of comparing arguments of <link
linkend="fn_sprintf_iri"><function>sprintf_iri</function></link>
because the format string is not proven to be a bijection. Indeed it
can not be bjection for arbitrary strings, but the database is about
real world. If it is known that real names of persons never start with
digit so digits of <emphasis>%d%U</emphasis> fragment will always
be distinguishable from name then the IRI class can be declared as a
bijection even if it is not true for arbitrary strings; the script
can include &quot;suspicious&quot; <emphasis>option (bijection)</emphasis> as
follows:</para>
<programlisting><![CDATA[
create iri class sample:Employee "http://example.com/Employee/%d%U#this"
  (in employee_id integer not null, in employee_lastname varchar not null)
  option (bijection) .
]]></programlisting>
<para>Unfortunately, the attempt of making same trick with the declaration from Northwind example will fail:</para>
<programlisting><![CDATA[
create iri class northwind:Employee "http://^{URIQADefaultHost}^/Northwind/Employee/%U%U%d#this"
  (in employee_firstname varchar not null, in employee_lastname varchar not null, in employee_id integer not null)
  option (bijection) .
]]></programlisting>
<para>Bijection will allow the parsing but it will never give proper result, because first <emphasis>%U</emphasis> will read the whole concatenation of <emphasis>%U%U%d</emphasis>, leave nothing before <emphasis>#this</emphasis> for second <emphasis>%U</emphasis> (that is wrong) and leave nothing for <emphasis>%d</emphasis> (that is explicit parse error, as integer notation can not be empty)</para>.
<para>The string parser will process the string from left to right so it will be unable to parse the string.
The compiler might sometimes report an error if it can prove that the format string is not appropriate for bijection.</para>
<para>The proper way of improving the Northwind example is to make true and reliable bijection by adding strong delimiters:</para>
<programlisting><![CDATA[
create iri class northwind:Employee "http://^{URIQADefaultHost}^/Northwind/Employee/%U/%U/%d#this"
  (in employee_firstname varchar not null, in employee_lastname varchar not null, in employee_id integer not null)
  option (bijection) .
]]></programlisting>
<para>After running the updated script, the query contains three comparisons of fields that were arguments of <function>sprintf_iri</function> in the previous version.</para>
<para><emphasis>Example for casting string as IRI type</emphasis></para>
<programlisting><![CDATA[
create function DB.DBA.RDF_DF_GRANTEE_ID_URI (in id integer)
{
  declare isrole integer;
  isrole := coalesce ((select top 1 U_IS_ROLE from DB.DBA.SYS_USERS where U_ID = id));
  if (isrole is null)
    return NULL;
  else if (isrole)
    return sprintf ('http://%s/sys/group?id=%d', registry_get ('URIQADefaultHost'), id);
  else
    return sprintf ('http://%s/sys/user?id=%d', registry_get ('URIQADefaultHost'), id);
}
;

grant execute on DB.DBA.RDF_DF_GRANTEE_ID_URI to SPARQL_SELECT
;

create function DB.DBA.RDF_DF_GRANTEE_ID_URI_INVERSE (in id_iri varchar)
{
  declare parts any;
  parts := sprintf_inverse (id_iri, sprintf ('http://%s/sys/user?id=%%d', registry_get ('URIQADefaultHost')), 1);
  if (parts is not null)
    {
      if (exists (select top 1 1 from DB.DBA.SYS_USERS where U_ID = parts[0] and not U_IS_ROLE))
        return parts[0];
    }
  parts := sprintf_inverse (id_iri, sprintf ('http://%s/sys/group?id=%%d', registry_get ('URIQADefaultHost')), 1);
  if (parts is not null)
    {
      if (exists (select top 1 1 from DB.DBA.SYS_USERS where U_ID = parts[0] and U_IS_ROLE))
        return parts[0];
    }
  return NULL;
}
;

grant execute on DB.DBA.RDF_DF_GRANTEE_ID_URI_INVERSE to SPARQL_SELECT
;


create iri class oplsioc:grantee_iri using
  function DB.DBA.RDF_DF_GRANTEE_ID_URI (in id integer) returns varchar ,
  function DB.DBA.RDF_DF_GRANTEE_ID_URI_INVERSE (in id_iri varchar) returns integer
  option ( bijection ,
    returns	"http://^{URIQADefaultHost}^/sys/group?id=%d"
    union	"http://^{URIQADefaultHost}^/sys/user?id=%d" ) .

]]></programlisting>
</sect1>
<sect1 id="rdfperformancetuning"><title>Virtuoso RDF Performance Tuning</title>
<para>For RDF query performance, we have the following possible questions:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem>Is the Virtuoso process properly configured to handle big data sets?</listitem>
<listitem>Is the graph always specified?</listitem>
<listitem>Are public web service endpoints protected against bad queries?</listitem>
<listitem>Are there patterns where only a predicate is given?</listitem>
<listitem>Is there a bad query plan because of cost model error?</listitem>
</itemizedlist>
<sect2 id="rdfperfgeneral"><title>General</title>
	<para>For running with large data sets, one should configure the Virtuoso process to use between 2/3 to  3/5 of system RAM and to stripe storage on all available disks.  See <link linkend="VIRTINI">NumberOfBuffers</link> and <link linkend="VIRTINI">Striping</link> ini parameters.</para>
<para> Also, if running with a large database, setting <link linkend="VIRTINI">MaxCheckpointRemap</link> to 1/4th of
 the database size is recommended.  This is in pages, 8K per page.</para>
    </sect2>
    <sect2 id="rdfperfindexes"><title>Index Scheme Selection</title>
<para>If the graph is always given, as one or more <emphasis>FROM</emphasis> or <emphasis>FROM NAMED</emphasis>, and there are no patterns where only graph and predicate are given, then the default indices should be appropriate.
If the predicate and graph are given but subject is not, then it is sometimes useful to add</para>

<programlisting><![CDATA[
create bitmap index RDF_QUAD_PGOS on DB.DBA.RDF_QUAD (G, P, O, S) partition (O varchar (-1, 0hexffff));
]]></programlisting>

<note><para>If the server is pre 5.0.7, leave out the partitioning clause.</para></note>

<para>Making the PGOS index can help in some cases even if it is not readily apparent from the queries that one is needed.  This is so for example if the predicate by itself is selective, i.e. there is a predicate that occurs in only a few triples.</para>
<para>If the graph itself is not given in the queries, then the default index scheme will be unworkable.
For this, the appropriate scheme is:</para>

<programlisting><![CDATA[
create table RDF_QUAD (G iri_id_8, S iri_id_8, P iri_id_8, O any, primary key (S, P, O, G))
alter index RDF_QUAD on RDF_QUAD partition (S int (0hexffff00));
create bitmap index RDF_QUAD_OPGS on DB.DBA.RDF_QUAD (O, P, G, S) partition (O varchar (-1, 0hexffff));
create bitmap index RDF_QUAD_POGS on DB.DBA.RDF_QUAD (P, O, G, S) partition (O varchar (-1, 0hexffff));
create bitmap index RDF_QUAD_GPOS on DB.DBA.RDF_QUAD (G, P, O, S) partition (O varchar (-1, 0hexffff));
]]></programlisting>

<note><para>For a pre 5.0.7 server, leave the partition clauses and the alter index statement out.</para></note>

<para>If there are existing triples and one does not wish to reload them, then the following sequence will convert the data:</para>

<programlisting><![CDATA[
log_enable (2);
drop index RDF_QUAD_OGPS;
checkpoint;
create table R2 (G iri_id_8, S iri_id_8, P iri_id_8, O any, primary key (S, P, O, G))
alter index R2 on R2 partition (S int (0hexffff00));

insert into r2 (g, s, p, o) select g, s, p, o from rdf_quad;

drop table RDF_QUAD;
checkpoint;
alter table r2 rename RDF_QUAD;
create bitmap index RDF_QUAD_OPGS on DB.DBA.RDF_QUAD (O, P, G, S) partition (O varchar (-1, 0hexffff));
create bitmap index RDF_QUAD_POGS on RDF_QUAD (P, O, G, S) partition (O varchar (-1, 0hexffff));
create bitmap index RDF_QUAD_GPOS on RDF_QUAD (G, P, O, S) partition (O varchar (-1, 0hexffff));
checkpoint;
log_enable (1);
]]></programlisting>

<para>First drop the OGPS index to make space.  Then, in row autocommit mode
and without logging, copy the quads into a new primary key layout.
Drop the old and rename the new over the old.  Make the additional
indices.  Do a checkpoint after the drops so as to actually free the
space also in the checkpointed state.  Finish with a checkpoint so as
to finalize the changes, since logging was turned off.  Even if
logging had been on, one would not wish to have to replay the
reindexing if the server terminated abnormally.
Finally turn logging back on for the session.</para>

<note><para>This is all meant to be done with a SQL client like isql and not through a web interface.
The web interface has no real session and the log_enables do nothing there.</para></note>

<para>Other indexing schemes may be tried.  We note however that in all
cases, one or other of the indices should begin with G.  This is
because for schema operations it is necessary to read through a
graph. If no index begins with G, this becomes a full table scan and
is unworkable, leading to an extremely slow server start and making
operations like drop graph as good as unusable.</para>

<para>Public web service endpoints are proven to be sources of especially bad queries. While local application develpers can obtain instructions from database administrator and use ISQL access to the database in order to tune execution plans, &quot;external&quot; clients do not know details of configuration and/or lacks appropriate skills. The most common problem is that public endpoints usually get requests that does not mention the required graph, because that queries were initially written for use with triple stores. If the web service provides access to a single graph (or to a short list of graphs) then it is strongly recommended to configure it by adding a row into <emphasis>DB.DBA.SYS_SPARQL_HOST</emphasis>. The idea is that if the client specifies default graph in the request or uses named graphs and group graph patterns then he is probably smarter than average and will provide meaningful queries. If no graph names are specified then the query will benefit from preset graph because this will give the compiler some more indexes to choose from -- indexes taht begin with G.</para>
<para>Sometimes web service endpoint is used to access data of only one application, not all data in the system. In that case one may wish to declare a separate storage that consists of only RDF Views made by that application and define <emphasis>input:storage</emphasis> in appropriate row of <emphasis>DB.DBA.SYS_SPARQL_HOST</emphasis>.</para>
</sect2>
<sect2 id="rdfperfcost"><title>Erroneous Cost Estimates and Explicit Join Order</title>

	<para>The selectivity of triple patterns is determined at query compile time from sampling the data.
It is possible that misleading data is produced.
To see if the cardinality guesses are generally valid, look at the query plan with <link linkend="fn_explain"><function>explain</function> ()</link>.</para>
<para>Below is a sample from the LUBM qualification data set in the Virtuoso distribution.
After running <emphasis>make test</emphasis> in <emphasis>binsrc/tets/lubm</emphasis>, there is a loaded database with the data.
Start a server in the same directory to see the data.</para>

<programlisting><![CDATA[
SQL> explain ('sparql prefix ub: <http://www.lehigh.edu/~zhp2/2004/0401/univ-bench.owl#>
select * from <lubm>
where { ?x rdf:type ub:GraduateStudent }');

REPORT
VARCHAR
_______________________________________________________________________________

{ 
 
Precode:
      0: $25 "callret" := Call __BOX_FLAGS_TWEAK (<constant (lubm)>, <constant (1)>)
      5: $26 "lubm" := Call DB.DBA.RDF_MAKE_IID_OF_QNAME_SAFE ($25 "callret")
      12: $27 "callret" := Call __BOX_FLAGS_TWEAK (<constant (http://www.w3.org/1999/02/22-rdf-syntax-ns#type)>, <constant (1)>)
      17: $28 "-ns#type" := Call DB.DBA.RDF_MAKE_IID_OF_QNAME_SAFE ($27 "callret")
      24: $29 "callret" := Call __BOX_FLAGS_TWEAK (<constant (http://www.lehigh.edu/~zhp2/2004/0401/univ-bench.owl#GraduateStudent)>, <constant (1)>)
      29: $30 "owl#GraduateStudent" := Call DB.DBA.RDF_MAKE_IID_OF_QNAME_SAFE ($29 "callret")
      36: BReturn 0
from DB.DBA.RDF_QUAD by RDF_QUAD_OGPS    1.9e+03 rows
Key RDF_QUAD_OGPS  ASC ($32 "s-3-1-t0.S")
<col=415 O = $30 "owl#GraduateStudent"> , <col=412 G = $26 "lubm"> , <col=414 P = $28 "-ns#type">
row specs: <col=415 O LIKE <constant (T)>>
 
Current of: <$34 "<DB.DBA.RDF_QUAD s-3-1-t0>" spec 5>
 
After code:
      0: $35 "x" := Call ID_TO_IRI ($32 "s-3-1-t0.S")
      5: BReturn 0
Select ($35 "x", <$34 "<DB.DBA.RDF_QUAD s-3-1-t0>" spec 5>)
}

22 Rows. -- 1 msec.
]]></programlisting>
<para>
This finds the graduate student instances in the lubm graph.  First
the query converts the IRI literals to id's.  Then, using a match of
OG on OGPS it finds the IRI's of the graduate students.  Then it
converts the IRI id to return to the string form.</para>
<para>The cardinality estimate of 1.9e+03 rows is on the FROM line.</para>
<para>Doing an explain on the queries will show the cardinality estimates.  To drill down further, one can split the query into smaller chunks and see the estimates for these, up to doing it at the triple pattern level.  
To indicate a variable that is bound but whose value is not a literal known at compile time, one can use the parameter marker <emphasis>??</emphasis>.</para>

<programlisting><![CDATA[
explain ('sparql define sql:table-option "order"  prefix ub: <http://www.lehigh.edu/~zhp2/2004/0401/univ-bench.owl#>
select * from <lubm>
where { ?x rdf:type ?? }');
]]></programlisting>

<para>This will not know the type but will know that a type will be
provided.  So instead of guessing 1900 matches, this will guess a
smaller number, which is obviously less precise.  Thus literals are generally better.</para>
<para>In some cases, generally to work around an optimization error, one can specify an explicit join order. 
This is done with the sql:select-option "order"  clause in the SPARQL query prefix.</para>

<programlisting><![CDATA[
select sparql_to_sql_text (' define sql:select-option "order" prefix ub: <http://www.lehigh.edu/~zhp2/2004/0401/univ-bench.owl#>
select * from <lubm>
where { ?x rdf:type ub:GraduateStudent . ?x ub:takesCourse <http://www.Department0.University0.edu/GraduateCourse0> }');
]]></programlisting>

<para>shows the SQL text with the order option at the end.</para>
<para>If an estimate is radically wrong then this should be reported as a bug.</para>
<para>If there is a FROM with a KEY on the next line and no column specs then this is a full table scan. The more columns are specified the less rows will be passed to the next operation in the chain. In the example above, there are three columns whose values are known before  reading the table and these columns are leading columns of the index in use so column specs are</para>
<programlisting><![CDATA[
<col=415 O = $30 "owl#GraduateStudent"> , <col=412 G = $26 "lubm"> , <col=414 P = $28 "-ns#type">
]]></programlisting>
<note><para>A KEY with only a row spec is a full table scan with the row spec applied as a filter.
This is usually not good unless this is specifically intended.</para></note>
<para>If queries are compiled to make full table scans when this is not specifically intended, this should be reported as a bug.
The explain output and the query text should be included in the report.</para>
<para>An explicit join order is specified by the <emphasis>define sql:select-option "order"</emphasis> clause in the SPARQL query prefix:
Consider:</para>

<programlisting><![CDATA[
explain ('sparql define sql:select-option "order, loop" prefix ub: <http://www.lehigh.edu/~zhp2/2004/0401/univ-bench.owl#>
select * from <lubm>
where { ?x ub:takesCourse ?c . ?x rdf:type ub:GraduateStudent   }');
]]></programlisting>

<para>One will see in the output that the first table access is to retrieve
all in the lubm graph which take some course and then later to check
if this is a graduate student.  This is obviously not the preferred
order but the <emphasis>sql:select-option "order"</emphasis> forces the optimizer to join
from left to right.</para>
<para>It is very easy to end up with completely unworkable query plans in
this manner but if the optimizer really is in error, then this is the
only way of overriding its prefrences.  The effect of <emphasis>sql:select-option</emphasis> is pervasive, extending inside unions, optionals, subqueries etc within the statement.</para>
<para>We note that if, in the above query, both the course taken by the
student and the type of the student are given, the query compilation
will be, at least for all non-cluster cases, an index intersection.
This is not overridden by the sql:select-option clause since an index
intersection is always a safe guess, regardless of the correctness of
the cardinality guesses of the patterns involved.</para>
</sect2>
    <sect2 id="rdfperfloading"><title>Loading</title>
	<para>There are many functions for loading RDF text, in RDF/XML and Turtle.</para>
	<para>For loading RDF/XML, the best way is to ssplit the data to be loaded into multiple streams and load these in parallel using <link linkend="fn_rdf_load_rdfxml"><function>rdf_load_rdfxml ()</function></link>. To avoid running out of rollback space for large files and in order to have multiple concurrent loads not interfere with each other, the row autocommit mode should be enabled.</para>
	<para>For example, </para>
<programlisting><![CDATA[
log_enable (2);
-- switch row-by-row autocommit on and logging off for this session
db..rdf_load_rdfxml (file_to_string_output ('file.xml'), 'base_uri', 'target_graph');
-- more files here ...
checkpoint;
]]></programlisting>
<para>Loading a file with text like the above with isql will load the data.  Since the transaction logging is off, make a manual checkpoint at the end to ensure that data is persisted upon server restart since there is no roll forward log.</para>
<para>If large amounts of data are to be loaded, run multiple such streams in parallel. One may have for example 6 streams for 4 cores. This
means that if up to two threads wait for disk, there is still work
for all cores.</para>
<para>Having substantially more threads than processors or disks is not particularly useful.</para>
<para>There exist multithreaded load functions which will load one file on multiple threads.  Experience shows that loading multiple files on one thread per file is better.</para>
<para>For loading Turtle, some platforms may have a non-reentrant Turtle parser.  This means that only one load may run at a time.  One can try this by calling <link linkend="rdfapidataimport"><function>ttlp ()</function></link> from two sessions at the same time. If these do not execute concurrently, then the best way may be to try <link linkend="rdfapidataimport"><function>ttlp_mt</function></link> and see if this runs faster than a single threaded ttlp call.</para>
       <sect3 id="rdfperfloadingunitpro"><title>Loading UniProt RDF data</title>
<para>To load the uniprot data, create a function for example such as:</para>
<programlisting><![CDATA[
create function DB.DBA.UNIPROT_LOAD (in log_mode integer := 1)
{
  DB.DBA.RDF_LOAD_RDFXML_MT (file_to_string_output('filename1'),'http://base_uri_1', 'destination_graph_1', log_mode, 3);
  DB.DBA.RDF_LOAD_RDFXML_MT (file_to_string_output('filename2'),'http://base_uri_2', 'destination_graph_2', log_mode, 3);
  ...
  DB.DBA.RDF_LOAD_RDFXML_MT (file_to_string_output('filename9'),'http://base_uri_9', 'destination_graph_9', log_mode, 3);
}
]]></programlisting>
<para>If you are starting from blank database and you can drop it and re-create in case of error signaled, use it this way:</para>
<programlisting><![CDATA[
checkpoint;
checkpoint_interval(6000);
DB.DBA.UNIPROT_LOAD (0),
checkpoint;
checkpoint_interval(60);
]]></programlisting>
<para>If the database contains important data already and there's no way to stop it and backup before the load then use:</para>
<programlisting><![CDATA[
checkpoint;
checkpoint_interval(6000);
DB.DBA.UNIPROT_LOAD (),
checkpoint;
checkpoint_interval(60);
]]></programlisting>
<para>Note that the 'number of threads' parameter of DB.DBA.RDF_LOAD_RDFXML() mentions threads
used to process data from file, an extra thread will read the text and parse it,
so for 4 CPU cores there's no need in parameter value greater than 3. Three processing
threads per one parsing tread is usually good ratio because parsing is usually three
times faster than the rest of loading so CPU loading is well balanced.
If for example you are using 2 x Quad Xeon, then you can choose between 8
single-threaded parsers or 2 parsers with 3 processing threads each. With 4 cores you may simply load
file after file with 3 processing threads. The most important performance tuning is to set the
[Parameters] section of virtuoso configuration file:</para>
<programlisting><![CDATA[
NumberOfBuffers = 1000000
MaxDirtyBuffers = 800000
MaxCheckpointRemap = 1000000
DefaultIsolation = 2
]]></programlisting>
<para>Note: these numbers are reasonable for 16 GB RAM Linux box. Usually when there are no such massive operations as loading huge database, you can set up the values as:</para>
<programlisting><![CDATA[
NumberOfBuffers = 1500000
MaxDirtyBuffers = 1200000
MaxCheckpointRemap = 1500000
DefaultIsolation = 2
]]></programlisting>
<para>Tip: Thus after loading all data you may wish to shutdown, tweak and start server again.
If you have ext2fs or ext3fs filesystem, then it's better to have enough free space on disk not to
make it more than 80% full.  When it's almost full it may allocate database file badly, resulting
in measurable loss of disk access speed. That is not Virtuoso-specific fact, but a common hint
for all database-like applications with random access to big files.</para>
<para>Here is an example of using awk file for splitting big file smaller ones:</para>
<programlisting><![CDATA[
BEGIN {
	file_part=1000
	e_line = "</rdf:RDF>"
        cur=0
        cur_o=0
	file=0
	part=file_part
      }
	{
	    res_file_i="res/"FILENAME
	    line=$0
	    s=$1
	    res_file=res_file_i"_"file".rdf"

	    if (index (s, "</rdf:Description>") == 1)
	    {
		cur=cur+1
		part=part-1
	    }

	    if (part > 0)
	    {
	    	print line >> res_file
	    }

	    if (part == 0)
	    {
#		print "===================== " cur
	    	print line >> res_file
		print e_line >> res_file
		close (res_file)
		file=file+1
		part=file_part
	    	res_file=res_file_i"_"file".rdf"
		system ("cp beg.txt " res_file)
	    }
        }
END { }
]]></programlisting>
       </sect3>
       <sect3 id="rdfperfloadingdbpedia"><title>Loading DBPedia RDF data</title>
<para>You can use the following script as an example for loading DBPedia RDF data in Virtuoso:</para>
<programlisting><![CDATA[
#!/bin/sh

PORT=$1
USER=$2
PASS=$3
file=$4
g=$5
LOGF=`basename $0`.log

if [ -z "$PORT" -o -z "$USER" -o -z "$PASS" -o -z "$file" -o -z "$g" ]
then
  echo "Usage: `basename $0` [DSN] [user] [password] [ttl-file] [graph-iri]"
  exit
fi

if [ ! -f "$file" -a ! -d "$file" ]
then
    echo "$file does not exists"
    exit 1
fi

mkdir READY 2>/dev/null
rm -f $LOGF $LOGF.*

echo "Starting..."
echo "Logging into: $LOGF"

DOSQL ()
{
    isql $PORT $USER $PASS verbose=on banner=off prompt=off echo=ON errors=stdout exec="$1" > $LOGF
}

LOAD_FILE ()
{
    f=$1
    g=$2
    echo "Loading $f (`cat $f | wc -l` lines) `date \"+%H:%M:%S\"`" | tee -a $LOG

    DOSQL "ttlp_mt (file_to_string_output ('$f'), '', '$g', 17); checkpoint;" > $LOGF

    if [ $? != 0 ]
    then
	echo "An error occured, please check $LOGF"
	exit 1
    fi

    line_no=`grep Error $LOGF | awk '{ match ($0, /line [0-9]+/, x) ; match (x[0], /[0-9]+/, y); print y[0] }'`
    newf=$f.part
    inx=1
    while [ ! -z "$line_no" ]
    do
	cat $f |  awk "BEGIN { i = 1 } { if (i==$line_no) { print \$0; exit; } i = i + 1 }"  >> bad.nt
	line_no=`expr $line_no + 1`
	echo "Retryng from line $line_no"
	echo "@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> ." > tmp.nt
	cat $f |  awk "BEGIN { i = 1 } { if (i>=$line_no) print \$0; i = i + 1 }"  >> tmp.nt
	mv tmp.nt $newf
	f=$newf
	mv $LOGF $LOGF.$inx
	DOSQL "ttlp_mt (file_to_string_output ('$f'), '', '$g', 17); checkpoint;" > $LOGF

	if [ $? != 0 ]
    then
	    echo "An error occured, please check $LOGF"
	    exit 1
    fi
	line_no=`grep Error $LOGF | awk '{ match ($0, /line [0-9]+/, x) ; match (x[0], /[0-9]+/, y); print y[0] }'`
	inx=`expr $inx + 1`
    done
    rm -f $newf 2>/dev/null
    echo "Loaded.  "
}

echo "======================================="
echo "Loading started."
echo "======================================="

if [ -f "$file" ]
then
    LOAD_FILE $file $g
    mv $file READY 2>> /dev/null
elif [ -d "$file" ]
then
    for ff in `find $file -name '*.nt'`
    do
	LOAD_FILE $ff $g
	mv $ff READY 2>> /dev/null
    done
else
   echo "The input is not file or directory"
fi
echo "======================================="
echo "Final checkpoint."
DOSQL "checkpoint;" > temp.res
echo "======================================="
echo "Check bad.nt file for skipped triples."
echo "======================================="

exit 0

]]></programlisting>
       </sect3>
       <sect3 id="rdfperfloadingbio2rdf"><title>Loading Bio2RDF data</title>
<para>The shell script below was used to import files in n3 notation into OpenLink Virtuoso RDF storage.</para>
<para>When an syntax error it will cut content from next line and will retry. This was used on ubuntu linux to import bio2rdf and freebase dumps.</para>
<para>Note it uses gawk, so it must be available on system where is tried. Also for recovery additional disk space is needed at max the size of original file.</para>
<programlisting><![CDATA[
#!/bin/bash

PASS=$1
f=$2
g=$3

# Usage
if [ -z "$PASS" -o -z "$f" -o -z "$g" ]
then
  echo "Usage: $0 [password] [ttl-file] [graph-iri]"
  exit
fi

if [ ! -f "$f" ]
then
    echo "$f does not exists"
    exit
fi

# Your port here
PORT=1111  #`inifile -f dbpedia.ini -s Parameters -k ServerPort`
if test -z "$PORT"
then
    echo "Cannot find INI and inifile command"
    exit
fi

# Initial run
isql $PORT dba $PASS verbose=on banner=off prompt=off echo=ON errors=stdout exec="ttlp_mt (file_to_string_output ('$f'), '', '$g'); checkpoint;" > $0.log

# If disconnect etc.
if [ $? != 0 ]
then
    echo "An error occured, please check $0.log"
    exit
fi

# Check for error
line_no=`grep Error $0.log | awk '{ match ($0, /line [0-9]+/, x) ; match (x[0], /[0-9]+/, y); print y[0] }'`
newf=$f.part
inx=1

# Error recovery
while [ ! -z "$line_no" ]
do
    cat $f |  awk "BEGIN { i = 0 } { if (i==$line_no) { print \$0; exit; } i = i + 1 }"  >> bad.nt
    line_no=`expr $line_no + 1`
    echo "Retryng from line $line_no"
    cat $f |  awk "BEGIN { i = 0 } { if (i>=$line_no) print \$0; i = i + 1 }"  > tmp.nt
    mv tmp.nt $newf
    f=$newf
    mv $0.log $0.log.$inx
    # Run the recovered part
    isql $PORT dba $PASS verbose=on banner=off prompt=off echo=ON errors=stdout exec="ttlp_mt (file_to_string_output ('$f'), '', '$g'); checkpoint;" > $0.log

    if [ $? != 0 ]
    then
	echo "An error occured, please check $0.log"
	exit
    fi
   line_no=`grep Error $0.log | awk '{ match ($0, /line [0-9]+/, x) ; match (x[0], /[0-9]+/, y); print y[0] }'`
   inx=`expr $inx + 1`
done
]]></programlisting>

       </sect3>
    </sect2>
    <sect2 id="rdfperfsparul"><title>Using SPARUL</title>
	<para>Since SPARUL updates are generally not ment to be transactional, it is
	    best to run these in <link linkend="fn_log_enable"><function>log_enable (2)</function></link> mode,
	    which commits every operation as it is done.  This prevents one from running out of rollback space.  Also for bulk updates, transaction logging can be turned off.  If so, one should do a manual checkpoint after the operation to ensure persistence across server restart since there is no roll forward log.</para>
<para>To have a roll forward log and row by row autocommit, one may use <link linkend="fn_log_enable"><function>log_enable (3)</function></link>.  This will write constantly into the log which takes extra time.  Having no logging and doing a checkpoint when the whole work is finished is faster.</para>
<para>Many SPARUL operations can be run in parallel in this way.  If they are independent with respect to their input and output, they can run in parallel and row by row autocommit will ensure they do not end up waiting for each others' locks.</para>
    </sect2>
    <sect2 id="rdfperfgeneraldbpedia"><title>DBpedia Benchmark</title>
<para>We ran the DBpedia benchmark queries again with different configurations of Virtuoso.
Comparing numbers given by different parties is a constant problem. In the case reported here,
we loaded the full DBpedia 3, all languages, with about 198M triples, onto Virtuoso v5 and Virtuoso Cluster
v6, all on the same 4 core 2GHz Xeon with 8G RAM. All databases were striped on 6 disks. The Cluster
configuration was with 4 processes in the same box.
We ran the queries in two variants:
</para>
<itemizedlist>
  <listitem>With graph specified in the SPARQL FROM clause, using the default indices.</listitem>
  <listitem>With no graph specified anywhere, using an alternate indexing scheme.</listitem>
</itemizedlist>
<para>The times below are for the sequence of 5 queries.
As there is a query in the set that specifies no condition on S or O and only P,
thus cannot be done with the default indices With Virtuoso v5. With Virtuoso Cluster v6 it can,
because v6 is more space efficient. So we added the index:</para>
<programlisting><![CDATA[
create bitmap index rdf_quad_pogs on rdf_quad (p, o, g, s);
]]></programlisting>
<table>
<tgroup cols="4">
<thead>
<row>
  <entry></entry>
  <entry>Virtuoso v5 with  gspo, ogps, pogs</entry>
  <entry>Virtuoso Cluster v6 with gspo, ogps</entry>
  <entry>Virtuoso Cluster v6 with gspo, ogps, pogs</entry>
</row>
</thead>
<tbody>
<row><entry>cold</entry><entry>210 s</entry><entry>136 s</entry><entry>33.4 s</entry></row>
<row><entry>warm</entry><entry>0.600 s</entry><entry>4.01 s</entry><entry>0.628 s</entry></row>
</tbody>
</tgroup>
</table>
<para>Now let us do it without a graph being specified. Note that alter index is valid for v6 or higher.
For all platforms, we drop any existing indices, and:</para>
<programlisting><![CDATA[
create table r2 (g iri_id_8, s, iri_id_8, p iri_id_8, o any, primary key (s, p, o, g))
alter index R2 on R2 partition (s int (0hexffff00));

log_enable (2);
insert into r2 (g, s, p, o) select g, s, p, o from rdf_quad;

drop table rdf_quad;
alter table r2 rename RDF_QUAD;
create bitmap index rdf_quad_opgs on rdf_quad (o, p, g, s) partition (o varchar (-1, 0hexffff));
create bitmap index rdf_quad_pogs on rdf_quad (p, o, g, s) partition (o varchar (-1, 0hexffff));
create bitmap index rdf_quad_gpos on rdf_quad (g, p, o, s) partition (o varchar (-1, 0hexffff));
]]></programlisting>
<para>The code is identical for v5 and v6, except that with v5 we use iri_id (32 bit) for
the type, not iri_id_8 (64 bit). We note that we run out of IDs with v5 around a few billion
triples, so with v6 we have double the ID length and still manage to be vastly more space efficient.</para>
<para>With the above 4 indices, we can query the data pretty much in any combination without hitting
a full scan of any index. We note that all indices that do not begin with s end with s as a bitmap.
This takes about 60% of the space of a non-bitmap index for data such as DBpedia.</para>
<para>If you intend to do completely arbitrary RDF queries in Virtuoso, then chances are
you are best off with the above index scheme.</para>
<table>
<tgroup cols="3">
<thead>
<row>
  <entry></entry>
  <entry>Virtuoso v5 with  gspo, ogps, pogs</entry>
  <entry>Virtuoso Cluster v6 with gspo, ogps, pogs</entry>
</row>
</thead>
<tbody>
<row><entry>warm</entry><entry>0.595 s</entry><entry>0.617 s</entry></row>
</tbody>
</tgroup>
</table>
<para>The cold times were about the same as above, so not reproduced.</para>
<para>It is in the SPARQL spirit to specify a graph and for pretty much any application,
there are entirely sensible ways of keeping the data in graphs and specifying which ones are
concerned by queries. This is why Virtuoso is set up for this by default.</para>
<para>On the other hand, for the open web scenario, dealing with an unknown large number of graphs,
enumerating graphs is not possible and questions like which graph of which source asserts x become
relevant. We have two distinct use cases which warrant different setups of the database, simple as that.</para>
<para>The latter use case is not really within the SPARQL spec, so implementations may or may not
support this.</para>
<para>Once the indices are right, there is no difference between specifying a graph and not specifying a
graph with the queries considered. With more complex queries, specifying a graph or set of graphs does
allow some optimizations that cannot be done with no graph specified. For example, bitmap intersections
are possible only when all leading key parts are given.</para>
<para>The best warm cache time is with v5; the five queries run under 600 ms after the first go.
This is noted to show that all-in-memory with a single thread of execution is hard to beat.</para>
<para>Cluster v6 performs the same queries in 623 ms. What is gained in parallelism is lost in latency
if all operations complete in microseconds. On the other hand, Cluster v6 leaves v5 in the dust in any
situation that has less than 100% hit rate. This is due to actual benefit from parallelism if operations
take longer than a few microseconds, such as in the case of disk reads. Cluster v6 has substantially
better data layout on disk, as well as fewer pages to load for the same content.</para>
<para>This makes it possible to run the queries without the pogs index on Cluster v6 even when v5 takes prohibitively long.</para>
<para>The purpose is to have a lot of RAM and space-efficient data representation.</para>
<para>For reference, the query texts specifying the graph are below. To run without specifying
the graph, just drop the FROM &lt;http://dbpedia.org&gt; from each query. The returned row counts are
indicated below each query's text.</para>
<programlisting><![CDATA[
sparql SELECT ?p ?o FROM <http://dbpedia.org> WHERE {
  <http://dbpedia.org/resource/Metropolitan_Museum_of_Art> ?p ?o };

-- 1337 rows

sparql PREFIX p: <http://dbpedia.org/property/>
SELECT ?film1 ?actor1 ?film2 ?actor2
FROM <http://dbpedia.org> WHERE {
  ?film1 p:starring <http://dbpedia.org/resource/Kevin_Bacon> .
  ?film1 p:starring ?actor1 .
  ?film2 p:starring ?actor1 .
  ?film2 p:starring ?actor2 . };

--  23910 rows

sparql PREFIX p: <http://dbpedia.org/property/>
SELECT ?artist ?artwork ?museum ?director FROM <http://dbpedia.org>
WHERE {
  ?artwork p:artist ?artist .
  ?artwork p:museum ?museum .
  ?museum p:director ?director };

-- 303 rows

sparql PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?s ?homepage FROM <http://dbpedia.org>  WHERE {
   <http://dbpedia.org/resource/Berlin> geo:lat ?berlinLat .
   <http://dbpedia.org/resource/Berlin> geo:long ?berlinLong .
   ?s geo:lat ?lat .
   ?s geo:long ?long .
   ?s foaf:homepage ?homepage .
   FILTER (
     ?lat        <=     ?berlinLat + 0.03190235436 &&
     ?long       >=     ?berlinLong - 0.08679199218 &&
     ?lat        >=     ?berlinLat - 0.03190235436 &&
     ?long       <=     ?berlinLong + 0.08679199218) };

-- 56 rows

sparql PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX p: <http://dbpedia.org/property/>
SELECT ?s ?a ?homepage FROM <http://dbpedia.org>  WHERE {
   <http://dbpedia.org/resource/New_York_City> geo:lat ?nyLat .
   <http://dbpedia.org/resource/New_York_City> geo:long ?nyLong .
   ?s geo:lat ?lat .
   ?s geo:long ?long .
   ?s p:architect ?a .
   ?a foaf:homepage ?homepage .
   FILTER (
     ?lat        <=     ?nyLat + 0.3190235436 &&
     ?long       >=     ?nyLong - 0.8679199218 &&
     ?lat        >=     ?nyLat - 0.3190235436 &&
     ?long       <=     ?nyLong + 0.8679199218) };

-- 13 rows
]]></programlisting>
<para></para>
<para></para>
<para></para>
<para></para>
    </sect2>
</sect1>
<sect1 id="rdfstorebenchmarks"><title>RDF Store Benchmarks</title>
    <sect2 id="rdfstorebenchmarksintroduction"><title>Introduction</title>
       <para>In a particular RDF Store Benchmarks there is difference if the queries are
executed with specified graph or with specified multiple graphs. As Virtuoso is quad store,
not triple store with many tables, it runs queries inefficiently if graphs are specified
and there are no additional indexes except pre-set GSPO and OGPS. Proper use of the FROM clause
or adding indexes with graph column will contribute for better results.
       </para>
    </sect2>
    <sect2 id="rdfstorebenchmarksindexusage"><title>Using bitmap indexes</title>
    <para>If is known in advance for the current RDF Store Benchmarks that some
users will not indicate specific graphs then should be done: </para>
    <itemizedlist>
       <listitem>either create indexes with graph in last position</listitem>
       <listitem>or load everything into single graph and specify it somewhere in querying application.</listitem>
    </itemizedlist>
    <para>Both methods do not require any changes in query texts</para>
    <para>Strongly recommended is the usage of additional bitmap indexes:</para>
<programlisting><![CDATA[
SQL> create bitmap index RDF_QUAD_POGS on DB.DBA.RDF_QUAD (P,O,G,S);
SQL> create bitmap index RDF_QUAD_PSOG on DB.DBA.RDF_QUAD (P,S,O,G);
]]></programlisting>
    <para>You can create other indexes as well. Bitmap indexes are preferable, but
if O is the last column, then the index can not be bitmap, so it could be, for e.g.:</para>
<programlisting><![CDATA[
create index RDF_QUAD_PSGO on DB.DBA.RDF_QUAD (P, S, G, O);
]]></programlisting>
    <para>but cannot be:</para>
<programlisting><![CDATA[
create bitmap index RDF_QUAD_PSGO on DB.DBA.RDF_QUAD (P, S, G, O);
]]></programlisting>
    </sect2>
</sect1>
<sect1 id="rdfsparqlimplementationextent"><title>SPARQL Implementation Details</title>
<para>Virtuoso's RDF support includes in-built support for the SPARQL query language. It also includes a number of powerful extensions that cover path traversal and business intelligence features. In addition, there is in-built security based on Virtuoso's support for Row Level policy based security, custom authentication, and Named Graphs.</para>
<para>The current implementation does not support some SPARQL features.</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem>Unicode characters in names are not supported.</listitem>
<listitem>Comments inside SPARQL query are not supported when the query is inlined in SQL code.</listitem>
</itemizedlist>
<para>On the other hand, Virtuoso implements some extensions to SPARQL:</para>
<itemizedlist mark="bullet" spacing="compact">
<listitem>SPARUL statements are supported, like <emphasis>insert</emphasis>, <emphasis>modify</emphasis>, <emphasis>load</emphasis> and so on.</listitem>
<listitem>The SPARQL compiler can be configured using <emphasis>define ...</emphasis> clauses, e.g., <emphasis>define output:valmode "LONG"</emphasis>.</listitem>
<listitem>Expressions are allowed in triple patterns both in <emphasis>where</emphasis> and in constructor patterns, that expressions are delimited by backquotes.</listitem>
<listitem>Expressions are allowed in result lists of select statements.</listitem>
<listitem>Parameters can be passed to the query from outside, using <emphasis>?:variablename</emphasis> syntax.</listitem>
<listitem>Aggregate functions are supported.</listitem>
<listitem>Subqueries may appear where group patterns are allowed.</listitem>
<listitem>A set of operators is added in order to configure the mapping of relational data to RDF.</listitem>
</itemizedlist>
<para>The following dump is BNF grammar of SPARQL with all Virtuoso extensions, but without rules for syntax of lexems.
Rule numbers in square brackets are from W3C normative SPARQL grammar,
asterisk means that the rule differs from W3C grammar due to Virtuoso extensions,
<emphasis>[Virt]</emphasis> means that the rule is Virtuoso-specific.
<emphasis>[DML]</emphasis> stands for data manipulation language extensions from SPARUL.
</para>
<programlisting><![CDATA[
[1]*	Query		 ::=  Prolog ( QueryBody | SparulAction* | ( QmStmt ('.' QmStmt)* '.'? ) )
[1]	QueryBody	 ::=  SelectQuery | ConstructQuery | DescribeQuery | AskQuery
[2]*	Prolog		 ::=  Define* BaseDecl? PrefixDecl*
[Virt]	Define		 ::=  'DEFINE' QNAME (QNAME | Q_IRI_REF | String )
[3]	BaseDecl	 ::=  'BASE' Q_IRI_REF
[4]	PrefixDecl	 ::=  'PREFIX' QNAME_NS Q_IRI_REF
[5]*	SelectQuery	 ::=  'SELECT' 'DISTINCT'? ( ( Retcol ( ','? Retcol )* ) | '*' )
			DatasetClause* WhereClause SolutionModifier
[6]	ConstructQuery	 ::=  'CONSTRUCT' ConstructTemplate DatasetClause* WhereClause SolutionModifier
			DatasetClause* WhereClause? SolutionModifier
[8]	AskQuery	 ::=  'ASK' DatasetClause* WhereClause
[9]	DatasetClause	 ::=  'FROM' ( DefaultGraphClause | NamedGraphClause )
[10]*	DefaultGraphClause	 ::=  SourceSelector SpongeOptionList?
[11]*	NamedGraphClause	 ::=  'NAMED' SourceSelector SpongeOptionList?
[Virt]	SpongeOptionList	 ::=  'OPTION' '(' ( SpongeOption ( ',' SpongeOption )* )? ')'
[Virt]	SpongeOption	 ::=  QNAME PrecodeExpn
[Virt]	PrecodeExpn	 ::=  Expn	(* Only global variables can occur in Expn, local can not *)
[13]	WhereClause	 ::=  'WHERE'? GroupGraphPattern
[14]	SolutionModifier	 ::=  OrderClause?
			((LimitClause OffsetClause?) | (OffsetClause LimitClause?))?
[15]	OrderClause	 ::=  'ORDER' 'BY' OrderCondition+
[16]*	OrderCondition	 ::=  ( 'ASC' | 'DESC' )?
			( FunctionCall | Var | ( '(' Expn ')' ) | ( '[' Expn ']' ) )
[17]	LimitClause	 ::=  'LIMIT' INTEGER
[17]	LimitClause	 ::=  'LIMIT' INTEGER
[18]	OffsetClause	 ::=  'OFFSET' INTEGER
[18]	OffsetClause	 ::=  'OFFSET' INTEGER
[19]*	GroupGraphPattern	 ::=  '{' ( GraphPattern | SelectQuery ) '}'
[20]	GraphPattern	 ::=  Triples? ( GraphPatternNotTriples '.'? GraphPattern )?
[21]*	GraphPatternNotTriples	 ::=
			QuadMapGraphPattern
			| OptionalGraphPattern
			| GroupOrUnionGraphPattern
			| GraphGraphPattern
			| Constraint
[22]	OptionalGraphPattern	 ::=  'OPTIONAL' GroupGraphPattern
[Virt]	QuadMapGraphPattern	 ::=  'QUAD' 'MAP' ( IRIref | '*' ) GroupGraphPattern
[23]	GraphGraphPattern	 ::=  'GRAPH' VarOrBlankNodeOrIRIref GroupGraphPattern
[24]	GroupOrUnionGraphPattern	 ::=  GroupGraphPattern ( 'UNION' GroupGraphPattern )*
[25]*	Constraint	 ::=  'FILTER' ( ( '(' Expn ')' ) | BuiltInCall | FunctionCall )
[26]*	ConstructTemplate	 ::=  '{' ConstructTriples '}'
[27]	ConstructTriples	 ::=  ( Triples1 ( '.' ConstructTriples )? )?
[28]	Triples		 ::=  Triples1 ( '.' Triples? )?
[29]	Triples1	 ::=  VarOrTerm PropertyListNotEmpty | TriplesNode PropertyList
[30]	PropertyList	 ::=  PropertyListNotEmpty?
[31]	PropertyListNotEmpty	 ::=  Verb ObjectList ( ';' PropertyList )?
[32]*	ObjectList	 ::=  ObjGraphNode ( ',' ObjectList )?
[Virt]	ObjGraphNode	 ::=  GraphNode TripleOptions?
[Virt]	TripleOptions	 ::=  'OPTION' '(' TripleOption ( ',' TripleOption )? ')'
[Virt]	TripleOption	 ::=  'INFERENCE' ( QNAME | Q_IRI_REF | SPARQL_STRING )
[33]	Verb		 ::=  VarOrBlankNodeOrIRIref | 'a'
[34]	TriplesNode	 ::=  Collection | BlankNodePropertyList
[35]	BlankNodePropertyList	 ::=  '[' PropertyListNotEmpty ']'
[36]	Collection	 ::=  '(' GraphNode* ')'
[37]	GraphNode	 ::=  VarOrTerm | TriplesNode
[38]	VarOrTerm	 ::=  Var | GraphTerm
[39]*	VarOrIRIrefOrBackquoted	 ::=  Var | IRIref | Backquoted
[40]*	VarOrBlankNodeOrIRIrefOrBackquoted	 ::=  Var | BlankNode | IRIref | Backquoted
[Virt]	Retcol	 ::=  ( Var | ( '(' Expn ')' ) | RetAggCall ) ( 'AS' ( VAR1 | VAR2 ) )?
[Virt]	RetAggCall	 ::=  AggName '(', ( '*' | ( 'DISTINCT'? Var ) ) ')'
[Virt]	AggName	 ::=  'COUNT' | 'AVG' | 'MIN' | 'MAX' | 'SUM'
[41]*	Var	 ::=  VAR1 | VAR2 | GlobalVar | ( Var ( '+>' | '*>' ) IRIref )
[Virt]	GlobalVar	 ::=  QUEST_COLON_PARAMNAME | DOLLAR_COLON_PARAMNAME
			| QUEST_COLON_PARAMNUM | DOLLAR_COLON_PARAMNUM
[42]*	GraphTerm	 ::=  IRIref | RDFLiteral | ( '-' | '+' )? NumericLiteral
			| BooleanLiteral | BlankNode | NIL | Backquoted
[Virt]	Backquoted	 ::=  '`' Expn '`'
[43]	Expn		 ::=  ConditionalOrExpn
[44]	ConditionalOrExpn	 ::=  ConditionalAndExpn ( '||' ConditionalAndExpn )*
[45]	ConditionalAndExpn	 ::=  ValueLogical ( '&&' ValueLogical )*
[46]	ValueLogical	 ::=  RelationalExpn
[47]*	RelationalExpn	 ::=  NumericExpn
			( ( ('='|'!='|'<'|'>'|'<='|'>='|'LIKE') NumericExpn )
			| ( 'IN' '(' Expns ')' ) )?
[49]	AdditiveExpn	 ::=  MultiplicativeExpn ( ('+'|'-') MultiplicativeExpn )*
[50]	MultiplicativeExpn	 ::=  UnaryExpn ( ('*'|'/') UnaryExpn )*
[51]	UnaryExpn	 ::=   ('!'|'+'|'-')? PrimaryExpn
[58]	PrimaryExpn	 ::=
			BracketedExpn | BuiltInCall | IRIrefOrFunction
			| RDFLiteral | NumericLiteral | BooleanLiteral | BlankNode | Var
[55]	IRIrefOrFunction	 ::=  IRIref ArgList?
[52]*	BuiltInCall	 ::=
			( 'STR' '(' Expn ')' )
			| ( 'IRI' '(' Expn ')' )
			| ( 'LANG' '(' Expn ')' )
			| ( 'LANGMATCHES' '(' Expn ',' Expn ')' )
			| ( 'DATATYPE' '(' Expn ')' )
			| ( 'BOUND' '(' Var ')' )
			| ( 'sameTERM' '(' Expn ',' Expn ')' )
			| ( 'isIRI' '(' Expn ')' )
			| ( 'isURI' '(' Expn ')' )
			| ( 'isBLANK' '(' Expn ')' )
			| ( 'isLITERAL' '(' Expn ')' )
			| RegexExpn
[53]	RegexExpn	 ::=  'REGEX' '(' Expn ',' Expn ( ',' Expn )? ')'
[54]	FunctionCall	 ::=  IRIref ArgList
[56]*	ArgList	 ::=  ( NIL | '(' Expns ')' )
[Virt]	Expns	 ::=  Expn ( ',' Expn )*
[59]	NumericLiteral	 ::=  INTEGER | DECIMAL | DOUBLE
[60]	RDFLiteral	 ::=  String ( LANGTAG | ( '^^' IRIref ) )?
[61]	BooleanLiteral	 ::=  'true' | 'false'
[63]	IRIref		 ::=  Q_IRI_REF | QName
[64]	QName		 ::=  QNAME | QNAME_NS
[65]*	BlankNode	 ::=  BLANK_NODE_LABEL | ( '[' ']' )
[DML]	SparulAction	 ::=
			CreateAction | DropAction | LoadAction
			| InsertAction | InsertDataAction | DeleteAction | DeleteDataAction
			| ModifyAction | ClearAction
[DML]*	InsertAction	 ::=
			'INSERT' ( ( 'IN' | 'INTO ) 'GRAPH' ( 'IDENTIFIED' 'BY' )? )? PrecodeExpn
			ConstructTemplate ( DatasetClause* WhereClause SolutionModifier )?
[DML]*	InsertDataAction	 ::=
			'INSERT' 'DATA' ( ( 'IN' | 'INTO ) 'GRAPH' ( 'IDENTIFIED' 'BY' )? )?
			PrecodeExpn ConstructTemplate
[DML]*	DeleteAction	 ::=
			'DELETE' ( 'FROM' 'GRAPH' ( 'IDENTIFIED' 'BY' )? )? PrecodeExpn
			ConstructTemplate ( DatasetClause* WhereClause SolutionModifier )?
[DML]*	DeleteDataAction	 ::=
			'DELETE' 'DATA' ( 'FROM' 'GRAPH' ( 'IDENTIFIED' 'BY' )? )?
			PrecodeExpn ConstructTemplate
[DML]*	ModifyAction	 ::=
			'MODIFY' ( 'GRAPH' ( 'IDENTIFIED' 'BY' )? PrecodeExpn?
			'DELETE' ConstructTemplate 'INSERT' ConstructTemplate
			( DatasetClause* WhereClause SolutionModifier )?
[DML]*	ClearAction	 ::=  'CLEAR' ( 'GRAPH' ( 'IDENTIFIED' 'BY' )? PrecodeExpn )?
[DML]*	LoadAction	 ::=  'LOAD' PrecodeExpn
			( ( 'IN' | 'INTO' ) 'GRAPH' ( 'IDENTIFIED' 'BY' )? PrecodeExpn )?
[DML]*	CreateAction	 ::=  'CREATE' 'SILENT'? 'GRAPH' ( 'IDENTIFIED' 'BY' )? PrecodeExpn
[DML]*	DropAction	 ::=  'DROP' 'SILENT'? 'GRAPH' ( 'IDENTIFIED' 'BY' )? PrecodeExpn
[Virt]	QmStmt		 ::=  QmSimpleStmt | QmCreateStorage | QmAlterStorage
[Virt]	QmSimpleStmt	 ::=
			QmCreateIRIClass | QmCreateLiteralClass | QmDropIRIClass | QmDropLiteralClass
			| QmCreateIRISubclass | QmDropQuadStorage | QmDropQuadMap
[Virt]	QmCreateIRIClass	 ::=  'CREATE' 'IRI' 'CLASS' QmIRIrefConst
			( ( String QmSqlfuncArglist )
			| ( 'USING' QmSqlfuncHeader ',' QmSqlfuncHeader ) )
[Virt]	QmCreateLiteralClass	 ::=  'CREATE' 'LITERAL' 'CLASS' QmIRIrefConst
			'USING' QmSqlfuncHeader ',' QmSqlfuncHeader QmLiteralClassOptions?
[Virt]	QmDropIRIClass	 ::=  'DROP' 'IRI' 'CLASS' QmIRIrefConst
[Virt]	QmDropLiteralClass	 ::=  'DROP' 'LITERAL' 'CLASS' QmIRIrefConst
[Virt]	QmCreateIRISubclass	 ::=  'IRI' 'CLASS' QmIRIrefConst 'SUBCLASS' 'OF' QmIRIrefConst
[Virt]	QmIRIClassOptions	 ::=  'OPTION' '(' QmIRIClassOption (',' QmIRIClassOption)* ')'
[Virt]	QmIRIClassOption	 ::=
			'BIJECTION'
			| 'DEREF'
			| 'RETURNS' STRING ('UNION' STRING)*
[Virt]	QmLiteralClassOptions	 ::=  'OPTION' '(' QmLiteralClassOption (',' QmLiteralClassOption)* ')'
[Virt]	QmLiteralClassOption	 ::=
			( 'DATATYPE' QmIRIrefConst )
			| ( 'LANG' STRING )
			| ( 'LANG' STRING )
			| 'BIJECTION'
			| 'DEREF'
			| 'RETURNS' STRING ('UNION' STRING)*
[Virt]	QmCreateStorage	 ::=  'CREATE' 'QUAD' 'STORAGE' QmIRIrefConst QmSourceDecl* QmMapTopGroup
[Virt]	QmAlterStorage	 ::=  'ALTER' 'QUAD' 'STORAGE' QmIRIrefConst QmSourceDecl* QmMapTopGroup
[Virt]	QmDropStorage	 ::=  'DROP' 'QUAD' 'STORAGE' QmIRIrefConst
[Virt]	QmDropQuadMap	 ::=  'DROP' 'QUAD' 'MAP' 'GRAPH'? QmIRIrefConst
[Virt]	QmDrop	 ::=  'DROP' 'GRAPH'? QmIRIrefConst
[Virt]	QmSourceDecl	 ::=
			( 'FROM' QTABLE 'AS' PLAIN_ID QmTextLiteral* )
			| ( 'FROM' PLAIN_ID 'AS' PLAIN_ID QmTextLiteral* )
			| QmCondition
[Virt]	QmTextLiteral	 ::=  'TEXT' 'XML'? 'LITERAL' QmSqlCol ( 'OF' QmSqlCol )? QmTextLiteralOptions?
[Virt]	QmTextLiteralOptions	 ::=  'OPTION' '(' QmTextLiteralOption ( ',' QmTextLiteralOption )* ')'
[Virt]	QmMapTopGroup	 ::=  '{' QmMapTopOp ( '.' QmMapTopOp )* '.'? '}'
[Virt]	QmMapTopOp	 ::=  QmMapOp | QmDropQuadMap | QmDrop
[Virt]	QmMapGroup	 ::=  '{' QmMapOp ( '.' QmMapOp )* '.'? '}'
[Virt]	QmMapOp		 ::=
			( 'CREATE' QmIRIrefConst 'AS' QmMapIdDef )
			| ( 'CREATE' 'GRAPH'? QmIRIrefConst 'USING' 'STORAGE' QmIRIrefConst QmOptions? )
			| ( QmNamedField+ QmOptions? QmMapGroup )
			| QmTriples1
[Virt]	QmMapIdDef	 ::=  QmMapTriple | ( QmNamedField+ QmOptions? QmMapGroup )
[Virt]	QmMapTriple	 ::=  QmFieldOrBlank QmVerb QmObjField
[Virt]	QmTriples1	 ::=  QmFieldOrBlank QmProps
[Virt]	QmNamedField	 ::=  ('GRAPH'|'SUBJECT'|'PREDICATE'|'OBJECT') QmField
[Virt]	QmProps		 ::=  QmProp ( ';' QmProp )?
[Virt]	QmProp		 ::=  QmVerb QmObjField ( ',' QmObjField )*
[Virt]	QmObjField	 ::=  QmFieldOrBlank QmCondition* QmOptions?
[Virt]	QmIdSuffix	 ::=  'AS' QmIRIrefConst
[Virt]	QmVerb		 ::=  QmField | ( '[' ']' ) | 'a'
[Virt]	QmFieldOrBlank	 ::=  QmField | ( '[' ']' )
[Virt]	QmField		 ::=
			NumericLiteral
			| RdfLiteral
			| ( QmIRIrefConst ( '(' ( QmSqlCol ( ',' QmSqlCol )* )? ')' )? )
			| QmSqlCol
[Virt]	QmCondition	 ::=  'WHERE' ( ( '(' SQLTEXT ')' ) | String )
[Virt]	QmOptions	 ::=  'OPTION' '(' QmOption ( ',' QmOption )* ')'
[Virt]	QmOption	 ::=  ( 'SOFT'? 'EXCLUSIVE' ) | ( 'ORDER' INTEGER ) | ( 'USING' PLAIN_ID )
[Virt]	QmSqlfuncHeader	 ::=  'FUNCTION' SQL_QTABLECOLNAME QmSqlfuncArglist 'RETURNS' QmSqltype
[Virt]	QmSqlfuncArglist	 ::=  '(' ( QmSqlfuncArg ( ',' QmSqlfuncArg )* )? ')'
[Virt]	QmSqlfuncArg	 ::=  ('IN' | QmSqlId) QmSqlId QmSqltype
[Virt]	QmSqltype	 ::=  QmSqlId ( 'NOT' 'NULL' )?
[Virt]	QmSqlCol	 ::=  QmSqlId | spar_qm_sql_id
[Virt]	QmSqlId		 ::=  PLAIN_ID | 'TEXT' | 'XML'
[Virt]	QmIRIrefConst	 ::=  IRIref | ( 'IRI' '(' String ')' )
]]></programlisting>
<para><emphasis>Example using OFFSET and LIMIT:</emphasis></para>
<para>Virtuoso uses a zero index in the OFFSET. Thus in the example below, will be taken position at
record 9000 in the result set, and will get the next 1000 rows starting from 9001 record. Note that the
MaxSortedTopRows in parameters Virtuoso ini section needs to be encreased (default is 10000).</para>
<programlisting><![CDATA[
select ?name
ORDER BY ?name
OFFSET 9000
LIMIT 1000
]]></programlisting>
<sect2 id="rdfsparqlandxquery"><title>SPARQL and XQuery Core Function Library</title>
<para>In the current implementation, the XQuery Core Function Library is not available from SPARQL.</para>
<para>As a temporary workaround, string parsing functions are made available, because they are widely used in W3C DAWG examples and the like. They are:</para>
<programlisting>
xsd:boolean (in strg any) returns integer
xsd:dateTime (in strg any) returns datetime
xsd:double (in strg varchar) returns double precision
xsd:float (in strg varchar) returns float
xsd:integer (in strg varchar) returns integer
</programlisting>
<para>(assuming that the query contains declaration 'PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;')</para>
</sect2>
</sect1>
<sect1 id="rdfnativestorageproviders"><title>Native RDF Storage Providers</title>
  <sect2 id="rdfnativestorageprovidersjena"><title>Virtuoso Jena Provider</title>
    <sect3 id="rdfnativestorageprovidersjenawhatis"><title>What is Jena</title>
    <para>Jena is an open source Semantic Web framework for Java. It provides an API to
extract data from and write to RDF graphs. The graphs are represented as an abstract "model".
A model can be sourced with data from files, databases, URIs or a combination of these. A Model
can also be queried through SPARQL and updated through SPARUL.
    </para>
    </sect3>
    <sect3 id="rdfnativestorageprovidersjenawhatisv"><title>What is the Virtuoso Jena Provider</title>
    <para>The Virtuoso Jena RDF Data Provider is a fully operational Native Graph Model Storage
Provider for the Jena Framework, enables Semantic Web applications written using the Jena RDF
Frameworks to query the Virtuoso RDF Quad store directly. The Provider has been tested against
the <ulink url="http://jena.sourceforge.net/">Jena 2.5.5</ulink> version currently available.
    </para>
    <figure id="rdfnativestorageprovidersjena1" float="1">
      <title>Virtuoso Jena RDF Data Provider</title>
      <graphic fileref="ui/VirtJenaProvider.png"/>
    </figure>
    </sect3>
    <sect3 id="rdfnativestorageprovidersjenasetup"><title>Setup</title>
    <sect4 id="rdfnativestorageprovidersjenareqfiles"><title>Required Files</title>
    <itemizedlist mark="bullet">
      <listitem>Virtuoso Jena Provider JAR file, <ulink url="http://virtuoso.openlinksw.com/wiki/main/Main/VirtJenaProvider/virt_jena.jar">virt_jena.jar</ulink></listitem>
      <listitem>Virtuoso JDBC Driver JAR file, <ulink url="http://virtuoso.openlinksw.com/wiki/main/Main/VirtJenaProvider/virtjdbc3.jar">virtjdbc3.jar</ulink></listitem>
      <listitem>Jena Framework and associated classes, <ulink url="http://virtuoso.openlinksw.com/wiki/main/Main/VirtJenaProvider/jenajars.zip">jenajars.zip</ulink></listitem>
      <listitem>Sample programs, <ulink url="http://virtuoso.openlinksw.com/wiki/main/Main/VirtJenaProvider/virtjenasamples.zip">virtjenasamples.zip</ulink></listitem>
    </itemizedlist>
    </sect4>
    <sect4 id="rdfnativestorageprovidersjenacmsmpr"><title>Compiling Jena Sample Programs</title>
    <orderedlist>
      <listitem>Edit the sample programs VirtuosoSPARQLExampleX.java, where X = 1 to 9. Set the JDBC connection strings within to point to a valid Virtuoso Server instance of the form:
<programlisting><![CDATA[
"jdbc:virtuoso://localhost:1111/charset=UTF-8/log_enable=2", "dba", "dba"
]]></programlisting>
      <itemizedlist>
         <listitem>charset=UTF-8: to work correctly with different encodings such as cirilic, etc.
         </listitem>
         <listitem>log_enable=2: to use row auto commit
         </listitem>
         <listitem>use these settings to process large rdf data.
         </listitem>
      </itemizedlist>
      </listitem>
      <listitem>Ensure that full paths to <emphasis>jena.jar, arq.jar,</emphasis> and
<emphasis>virtjdbc3.jar</emphasis> are included in the active CLASSPATH setting.
      </listitem>
      <listitem>Compile the Jena Sample applications using the following command:
<programlisting><![CDATA[
javac -cp "jena.jar:arq.jar:virtjdbc3.jar:virt_jena.jar:." VirtuosoSPARQLExample1.java
VirtuosoSPARQLExample2.java VirtuosoSPARQLExample3.java VirtuosoSPARQLExample4.java
VirtuosoSPARQLExample5.java VirtuosoSPARQLExample6.java VirtuosoSPARQLExample7.java
VirtuosoSPARQLExample8.java VirtuosoSPARQLExample9.java
]]></programlisting>
      </listitem>
    </orderedlist>
    </sect4>
    <sect4 id="rdfnativestorageprovidersjenatesting"><title>Testing</title>
    <para>Once the Provider classes and sample program have been successfully compiled,
the Provider can be tested using the sample programs included. Ensure your active CLASSPATH
includes full paths to all of the following files, before executing the example commands:
    </para>
    <itemizedlist mark="bullet">
      <listitem>icu4j_3_4.jar</listitem>
      <listitem>iri.jar</listitem>
      <listitem>xercesImpl.jar</listitem>
      <listitem>axis.jar</listitem>
      <listitem>commons-logging-1.1.1.jar</listitem>
      <listitem>jena.jar</listitem>
      <listitem>arq.jar</listitem>
      <listitem>virtjdbc3.jar</listitem>
      <listitem>virt_jena.jar</listitem>
    </itemizedlist>
    <orderedlist>
      <listitem><link linkend="rdfnativestorageprovidersjenaexamples1">VirtuosoSPARQLExample1</link> returns the contents of the RDF Quad store of the targeted Virtuoso instance, with the following command:
<programlisting><![CDATA[
java VirtuosoSPARQLExample1
]]></programlisting>
      </listitem>
      <listitem><link linkend="rdfnativestorageprovidersjenaexamples2">VirtuosoSPARQLExample2</link> reads in the contents of the following FOAF URIs --
<programlisting><![CDATA[
http://kidehen.idehen.net/dataspace/person/kidehen#this
http://www.w3.org/People/Berners-Lee/card#i
http://demo.openlinksw.com/dataspace/person/demo#this
]]></programlisting>
      <para>-- and returns the RDF data stored, with the following command:</para>
<programlisting><![CDATA[
java VirtuosoSPARQLExample2
]]></programlisting>
      </listitem>
      <listitem><link linkend="rdfnativestorageprovidersjenaexamples3">VirtuosoSPARQLExample3</link> performs simple addition and deletion operation on
the content of the triple store, with the following command:
<programlisting><![CDATA[
java VirtuosoSPARQLExample3
]]></programlisting>
      </listitem>
      <listitem><link linkend="rdfnativestorageprovidersjenaexamples4">VirtuosoSPARQLExample4</link> demonstrates the use of the <emphasis>graph.contains</emphasis> method for searching triples, with the following command:
<programlisting><![CDATA[
java VirtuosoSPARQLExample4
]]></programlisting>
</listitem>
      <listitem><link linkend="rdfnativestorageprovidersjenaexamples5">VirtuosoSPARQLExample5</link> demonstrates the use of the <emphasis>graph.find</emphasis> method for searching triples, with the following command:
<programlisting><![CDATA[
java VirtuosoSPARQLExample5
]]></programlisting>
      </listitem>
      <listitem><link linkend="rdfnativestorageprovidersjenaexamples6">VirtuosoSPARQLExample6</link> demonstrates the use of the <emphasis>graph.getTransactionHandler</emphasis> method, with the following command:
<programlisting><![CDATA[
java VirtuosoSPARQLExample6
]]></programlisting>
      </listitem>
      <listitem><link linkend="rdfnativestorageprovidersjenaexamples7">VirtuosoSPARQLExample7</link> demonstrates the use of the graph.getBulkUpdateHandler method, with the following command:
<programlisting><![CDATA[
java VirtuosoSPARQLExample7
]]></programlisting>
      </listitem>
      <listitem><link linkend="rdfnativestorageprovidersjenaexamples8">VirtuosoSPARQLExample8</link> demonstrates how to insert triples into a graph, with the following command:
<programlisting><![CDATA[
java VirtuosoSPARQLExample8
]]></programlisting>
      </listitem>
      <listitem><link linkend="rdfnativestorageprovidersjenaexamples9">VirtuosoSPARQLExample9</link> demonstrates the use of the <emphasis>CONSTRUCT, DESCRIBE,</emphasis> and <emphasis>ASK</emphasis> SPARQL query forms, with the following command:
<programlisting><![CDATA[
java VirtuosoSPARQLExample9
]]></programlisting>
      </listitem>
    </orderedlist>
    </sect4>
    </sect3>
    <sect3 id="rdfnativestorageprovidersjenaexamples"><title>Examples</title>
    <sect4 id="rdfnativestorageprovidersjenaexamples1"><title>VirtJenaSPARQLExample1</title>
<programlisting><![CDATA[
import com.hp.hpl.jena.query.*;
import com.hp.hpl.jena.rdf.model.RDFNode;

import virtuoso.jena.driver.*;

public class VirtuosoSPARQLExample1 {

	/**
	 * Executes a SPARQL query against a virtuoso url and prints results.
	 */
	public static void main(String[] args) {

		String url;
		if(args.length == 0)
		    url = "jdbc:virtuoso://localhost:1111";
		else
		    url = args[0];

/*			STEP 1			*/
		VirtGraph set = new VirtGraph (url, "dba", "dba");

/*			STEP 2			*/


/*			STEP 3			*/
/*		Select all data in virtuoso	*/
		Query sparql = QueryFactory.create("SELECT * WHERE { GRAPH ?graph { ?s ?p ?o } } limit 100");

/*			STEP 4			*/
		VirtuosoQueryExecution vqe = VirtuosoQueryExecutionFactory.create (sparql, set);

		ResultSet results = vqe.execSelect();
		while (results.hasNext()) {
			QuerySolution result = results.nextSolution();
		    RDFNode graph = result.get("graph");
		    RDFNode s = result.get("s");
		    RDFNode p = result.get("p");
		    RDFNode o = result.get("o");
		    System.out.println(graph + " { " + s + " " + p + " " + o + " . }");
		}
	}
}

]]></programlisting>
    </sect4>
    <sect4 id="rdfnativestorageprovidersjenaexamples2"><title>VirtJenaSPARQLExample2</title>
<programlisting><![CDATA[
import com.hp.hpl.jena.query.*;
import com.hp.hpl.jena.rdf.model.RDFNode;

import virtuoso.jena.driver.*;

public class VirtuosoSPARQLExample2 {

	/**
	 * Executes a SPARQL query against a virtuoso url and prints results.
	 */
	public static void main(String[] args) {

		String url;
		if(args.length == 0)
		    url = "jdbc:virtuoso://localhost:1111";
		else
		    url = args[0];

/*			STEP 1			*/
		VirtGraph graph = new VirtGraph ("Example2", url, "dba", "dba");

/*			STEP 2			*/
/*		Load data to Virtuoso		*/
		graph.clear ();

		System.out.print ("Begin read from 'http://www.w3.org/People/Berners-Lee/card#i'  ");
		graph.read("http://www.w3.org/People/Berners-Lee/card#i", "RDF/XML");
		System.out.println ("\t\t\t Done.");

		System.out.print ("Begin read from 'http://demo.openlinksw.com/dataspace/person/demo#this'  ");
		graph.read("http://demo.openlinksw.com/dataspace/person/demo#this", "RDF/XML");
		System.out.println ("\t Done.");

		System.out.print ("Begin read from 'http://kidehen.idehen.net/dataspace/person/kidehen#this'  ");
		graph.read("http://kidehen.idehen.net/dataspace/person/kidehen#this", "RDF/XML");
		System.out.println ("\t Done.");


/*			STEP 3			*/
/*		Select only from VirtGraph	*/
		Query sparql = QueryFactory.create("SELECT ?s ?p ?o WHERE { ?s ?p ?o }");

/*			STEP 4			*/
		VirtuosoQueryExecution vqe = VirtuosoQueryExecutionFactory.create (sparql, graph);

		ResultSet results = vqe.execSelect();
		while (results.hasNext()) {
			QuerySolution result = results.nextSolution();
		    RDFNode graph_name = result.get("graph");
		    RDFNode s = result.get("s");
		    RDFNode p = result.get("p");
		    RDFNode o = result.get("o");
		    System.out.println(graph_name + " { " + s + " " + p + " " + o + " . }");
		}

		System.out.println("graph.getCount() = " + graph.getCount());
	}
}
]]></programlisting>
    </sect4>
    <sect4 id="rdfnativestorageprovidersjenaexamples3"><title>VirtJenaSPARQLExample3</title>
<programlisting><![CDATA[
import java.util.*;

import com.hp.hpl.jena.query.*;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;

import virtuoso.jena.driver.*;

public class VirtuosoSPARQLExample3
{
    public static void main(String[] args)
    {
	String url;

	if(args.length == 0)
	    url = "jdbc:virtuoso://localhost:1111";
	else
	    url = args[0];

	Node foo1 = Node.createURI("http://example.org/#foo1");
	Node bar1 = Node.createURI("http://example.org/#bar1");
	Node baz1 = Node.createURI("http://example.org/#baz1");

	Node foo2 = Node.createURI("http://example.org/#foo2");
	Node bar2 = Node.createURI("http://example.org/#bar2");
	Node baz2 = Node.createURI("http://example.org/#baz2");

	Node foo3 = Node.createURI("http://example.org/#foo3");
	Node bar3 = Node.createURI("http://example.org/#bar3");
	Node baz3 = Node.createURI("http://example.org/#baz3");

	List <Triple> triples = new ArrayList <Triple> ();

	VirtGraph graph = new VirtGraph ("Example3", url, "dba", "dba");

	graph.clear ();

	System.out.println("graph.isEmpty() = " + graph.isEmpty());
	System.out.println("Add 3 triples to graph <Example3>.");

	graph.add(new Triple(foo1, bar1, baz1));
	graph.add(new Triple(foo2, bar2, baz2));
	graph.add(new Triple(foo3, bar3, baz3));

	System.out.println("graph.isEmpty() = " + graph.isEmpty());
	System.out.println("graph.getCount() = " + graph.getCount());

	triples.add(new Triple(foo1, bar1, baz1));
	triples.add(new Triple(foo2, bar2, baz2));

	graph.isEmpty();

	System.out.println("Remove 2 triples from graph <Example3>");
	graph.remove(triples);
	System.out.println("graph.getCount() = " + graph.getCount());
	System.out.println("Please check result with isql tool.");

	/* EXPECTED RESULT:

SQL> sparql select ?s ?p ?o from <Example3> where {?s ?p ?o};
s                                                    p                                                             o
VARCHAR                                    VARCHAR                                              VARCHAR
_______________________________________________________________________________

http://example.org/#foo3              http://example.org/#bar3                         http://example.org/#baz3

1 Rows. -- 26 msec.
SQL>

*/

	}
}
]]></programlisting>
    </sect4>
    <sect4 id="rdfnativestorageprovidersjenaexamples4"><title>VirtJenaSPARQLExample4</title>
<programlisting><![CDATA[
import java.util.*;

import com.hp.hpl.jena.query.*;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;

import virtuoso.jena.driver.*;

public class VirtuosoSPARQLExample4
{

    public static void main(String[] args)
    {
	String url;
	if(args.length == 0)
	    url = "jdbc:virtuoso://localhost:1111";
	else
	    url = args[0];

	Node foo1 = Node.createURI("http://example.org/#foo1");
	Node bar1 = Node.createURI("http://example.org/#bar1");
	Node baz1 = Node.createURI("http://example.org/#baz1");

	Node foo2 = Node.createURI("http://example.org/#foo2");
	Node bar2 = Node.createURI("http://example.org/#bar2");
	Node baz2 = Node.createURI("http://example.org/#baz2");

	Node foo3 = Node.createURI("http://example.org/#foo3");
	Node bar3 = Node.createURI("http://example.org/#bar3");
	Node baz3 = Node.createURI("http://example.org/#baz3");

	VirtGraph graph = new VirtGraph ("Example4", url, "dba", "dba");

	graph.clear ();

	System.out.println("graph.isEmpty() = " + graph.isEmpty());

	System.out.println("Add 3 triples to graph <Example4>.");

	graph.add(new Triple(foo1, bar1, baz1));
	graph.add(new Triple(foo2, bar2, baz2));
	graph.add(new Triple(foo3, bar3, baz3));

	System.out.println("graph.isEmpty() = " + graph.isEmpty());
	System.out.println("graph.getCount() = " + graph.getCount());

	System.out.println ("graph.contains(new Triple(foo2, bar2, baz2) - " + graph.contains(new Triple(foo2, bar2, baz2)));
	System.out.println ("graph.contains(new Triple(foo2, bar2, baz3) - " + graph.contains(new Triple(foo2, bar2, baz3)));

	graph.clear ();

    }
}
]]></programlisting>
    </sect4>
    <sect4 id="rdfnativestorageprovidersjenaexamples5"><title>VirtJenaSPARQLExample5</title>
<programlisting><![CDATA[
import java.util.*;

import com.hp.hpl.jena.query.*;
import com.hp.hpl.jena.util.iterator.ExtendedIterator;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;

import virtuoso.jena.driver.*;

public class VirtuosoSPARQLExample5
{

    public static void main(String[] args)
    {
	String url;
	if(args.length == 0)
	    url = "jdbc:virtuoso://localhost:1111";
	else
	    url = args[0];

	Node foo1 = Node.createURI("http://example.org/#foo1");
	Node bar1 = Node.createURI("http://example.org/#bar1");
	Node baz1 = Node.createURI("http://example.org/#baz1");

	Node foo2 = Node.createURI("http://example.org/#foo2");
	Node bar2 = Node.createURI("http://example.org/#bar2");
	Node baz2 = Node.createURI("http://example.org/#baz2");

	Node foo3 = Node.createURI("http://example.org/#foo3");
	Node bar3 = Node.createURI("http://example.org/#bar3");
	Node baz3 = Node.createURI("http://example.org/#baz3");

	VirtGraph graph = new VirtGraph ("Example5", url, "dba", "dba");

	graph.clear ();

	System.out.println("graph.isEmpty() = " + graph.isEmpty());

	System.out.println("Add 3 triples to graph <Example5>.");

	graph.add(new Triple(foo1, bar1, baz1));
	graph.add(new Triple(foo2, bar2, baz2));
	graph.add(new Triple(foo3, bar3, baz3));
	graph.add(new Triple(foo1, bar2, baz2));
	graph.add(new Triple(foo1, bar3, baz3));

	System.out.println("graph.isEmpty() = " + graph.isEmpty());
	System.out.println("graph.getCount() = " + graph.getCount());

	ExtendedIterator iter = graph.find(foo1, Node.ANY, Node.ANY);
	System.out.println ("\ngraph.find(foo1, Node.ANY, Node.ANY) \nResult:");
	for ( ; iter.hasNext() ; )
	    System.out.println ((Triple) iter.next());

	iter = graph.find(Node.ANY, Node.ANY, baz3);
	System.out.println ("\ngraph.find(Node.ANY, Node.ANY, baz3) \nResult:");
	for ( ; iter.hasNext() ; )
	    System.out.println ((Triple) iter.next());

	iter = graph.find(foo1, Node.ANY, baz3);
	System.out.println ("\ngraph.find(foo1, Node.ANY, baz3) \nResult:");
	for ( ; iter.hasNext() ; )
	    System.out.println ((Triple) iter.next());

	graph.clear ();

    }
}
]]></programlisting>
    </sect4>
    <sect4 id="rdfnativestorageprovidersjenaexamples6"><title>VirtJenaSPARQLExample6</title>
<programlisting><![CDATA[
import java.util.*;

import com.hp.hpl.jena.query.*;
import com.hp.hpl.jena.util.iterator.ExtendedIterator;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;

import virtuoso.jena.driver.*;

public class VirtuosoSPARQLExample6
{

    public static void main(String[] args)
    {
	String url;
	if(args.length == 0)
	    url = "jdbc:virtuoso://localhost:1111";
	else
	    url = args[0];

	Node foo1 = Node.createURI("http://example.org/#foo1");
	Node bar1 = Node.createURI("http://example.org/#bar1");
	Node baz1 = Node.createURI("http://example.org/#baz1");

	Node foo2 = Node.createURI("http://example.org/#foo2");
	Node bar2 = Node.createURI("http://example.org/#bar2");
	Node baz2 = Node.createURI("http://example.org/#baz2");

	Node foo3 = Node.createURI("http://example.org/#foo3");
	Node bar3 = Node.createURI("http://example.org/#bar3");
	Node baz3 = Node.createURI("http://example.org/#baz3");

	VirtGraph graph = new VirtGraph ("Example6", url, "dba", "dba");

	graph.clear ();

	System.out.println("graph.isEmpty() = " + graph.isEmpty());

	System.out.println("test Transaction Commit.");
	graph.getTransactionHandler().begin();
	System.out.println("begin Transaction.");
	System.out.println("Add 3 triples to graph <Example6>.");

	graph.add(new Triple(foo1, bar1, baz1));
	graph.add(new Triple(foo2, bar2, baz2));
	graph.add(new Triple(foo3, bar3, baz3));

	graph.getTransactionHandler().commit();
	System.out.println("commit Transaction.");
	System.out.println("graph.isEmpty() = " + graph.isEmpty());
	System.out.println("graph.getCount() = " + graph.getCount());

	ExtendedIterator iter = graph.find(Node.ANY, Node.ANY, Node.ANY);
	System.out.println ("\ngraph.find(Node.ANY, Node.ANY, Node.ANY) \nResult:");
	for ( ; iter.hasNext() ; )
	    System.out.println ((Triple) iter.next());

	graph.clear ();
	System.out.println("\nCLEAR graph <Example6>");
	System.out.println("graph.isEmpty() = " + graph.isEmpty());

	System.out.println("Add 1 triples to graph <Example6>.");
	graph.add(new Triple(foo1, bar1, baz1));

	System.out.println("test Transaction Abort.");
	graph.getTransactionHandler().begin();
	System.out.println("begin Transaction.");
	System.out.println("Add 2 triples to graph <Example6>.");

	graph.add(new Triple(foo2, bar2, baz2));
	graph.add(new Triple(foo3, bar3, baz3));

	graph.getTransactionHandler().abort();
	System.out.println("abort Transaction.");
	System.out.println("graph.isEmpty() = " + graph.isEmpty());
	System.out.println("graph.getCount() = " + graph.getCount());

	iter = graph.find(Node.ANY, Node.ANY, Node.ANY);
	System.out.println ("\ngraph.find(Node.ANY, Node.ANY, Node.ANY) \nResult:");
	for ( ; iter.hasNext() ; )
	    System.out.println ((Triple) iter.next());

	graph.clear ();
	System.out.println("\nCLEAR graph <Example6>");

    }
}


]]></programlisting>
    </sect4>
    <sect4 id="rdfnativestorageprovidersjenaexamples7"><title>VirtJenaSPARQLExample7</title>
<programlisting><![CDATA[
import java.util.*;

import com.hp.hpl.jena.query.*;
import com.hp.hpl.jena.util.iterator.ExtendedIterator;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;

import virtuoso.jena.driver.*;

public class VirtuosoSPARQLExample7
{

    public static void main(String[] args)
    {
	String url;
	if(args.length == 0)
	    url = "jdbc:virtuoso://localhost:1111";
	else
	    url = args[0];

	Node foo1 = Node.createURI("http://example.org/#foo1");
	Node bar1 = Node.createURI("http://example.org/#bar1");
	Node baz1 = Node.createURI("http://example.org/#baz1");

	Node foo2 = Node.createURI("http://example.org/#foo2");
	Node bar2 = Node.createURI("http://example.org/#bar2");
	Node baz2 = Node.createURI("http://example.org/#baz2");

	Node foo3 = Node.createURI("http://example.org/#foo3");
	Node bar3 = Node.createURI("http://example.org/#bar3");
	Node baz3 = Node.createURI("http://example.org/#baz3");

	List triples1 = new ArrayList();
	triples1.add(new Triple(foo1, bar1, baz1));
	triples1.add(new Triple(foo2, bar2, baz2));
	triples1.add(new Triple(foo3, bar3, baz3));

	List triples2 = new ArrayList();
	triples2.add(new Triple(foo1, bar1, baz1));
	triples2.add(new Triple(foo2, bar2, baz2));

	VirtGraph graph = new VirtGraph ("Example7", url, "dba", "dba");

	graph.clear ();

	System.out.println("graph.isEmpty() = " + graph.isEmpty());
	System.out.println("Add List with 3 triples to graph <Example7> via BulkUpdateHandler.");

	graph.getBulkUpdateHandler().add(triples1);

	System.out.println("graph.isEmpty() = " + graph.isEmpty());
	System.out.println("graph.getCount() = " + graph.getCount());

	ExtendedIterator iter = graph.find(Node.ANY, Node.ANY, Node.ANY);
	System.out.println ("\ngraph.find(Node.ANY, Node.ANY, Node.ANY) \nResult:");
	for ( ; iter.hasNext() ; )
	    System.out.println ((Triple) iter.next());


	System.out.println("\n\nDelete List of 2 triples from graph <Example7> via BulkUpdateHandler.");

	graph.getBulkUpdateHandler().delete(triples2);

	System.out.println("graph.isEmpty() = " + graph.isEmpty());
	System.out.println("graph.getCount() = " + graph.getCount());

	iter = graph.find(Node.ANY, Node.ANY, Node.ANY);
	System.out.println ("\ngraph.find(Node.ANY, Node.ANY, Node.ANY) \nResult:");
	for ( ; iter.hasNext() ; )
	    System.out.println ((Triple) iter.next());

	graph.clear ();
	System.out.println("\nCLEAR graph <Example7>");

    }
}
]]></programlisting>
    </sect4>
    <sect4 id="rdfnativestorageprovidersjenaexamples8"><title>VirtJenaSPARQLExample8</title>
<programlisting><![CDATA[
import com.hp.hpl.jena.query.*;
import com.hp.hpl.jena.rdf.model.RDFNode;

import virtuoso.jena.driver.*;

public class VirtuosoSPARQLExample8 {

	/**
	 * Executes a SPARQL query against a virtuoso url and prints results.
	 */
	public static void main(String[] args) {

		String url;
		if(args.length == 0)
		    url = "jdbc:virtuoso://localhost:1111";
		else
		    url = args[0];

/*			STEP 1			*/
		VirtGraph set = new VirtGraph (url, "dba", "dba");

/*			STEP 2			*/
System.out.println("\nexecute: CLEAR GRAPH <http://test1>");
                String str = "CLEAR GRAPH <http://test1>";
                VirtuosoUpdateRequest vur = VirtuosoUpdateFactory.create(str, set);
                vur.exec();

System.out.println("\nexecute: INSERT INTO GRAPH <http://test1> { <aa> <bb> 'cc' . <aa1> <bb1> 123. }");
                str = "INSERT INTO GRAPH <http://test1> { <aa> <bb> 'cc' . <aa1> <bb1> 123. }";
                vur = VirtuosoUpdateFactory.create(str, set);
                vur.exec();

/*			STEP 3			*/
/*		Select all data in virtuoso	*/
System.out.println("\nexecute: SELECT * FROM <http://test1> WHERE { ?s ?p ?o }");
		Query sparql = QueryFactory.create("SELECT * FROM <http://test1> WHERE { ?s ?p ?o }");

/*			STEP 4			*/
		VirtuosoQueryExecution vqe = VirtuosoQueryExecutionFactory.create (sparql, set);

		ResultSet results = vqe.execSelect();
		while (results.hasNext()) {
			QuerySolution rs = results.nextSolution();
		    RDFNode s = rs.get("s");
		    RDFNode p = rs.get("p");
		    RDFNode o = rs.get("o");
		    System.out.println(" { " + s + " " + p + " " + o + " . }");
		}


System.out.println("\nexecute: DELETE FROM GRAPH <http://test1> { <aa> <bb> 'cc' }");
                str = "DELETE FROM GRAPH <http://test1> { <aa> <bb> 'cc' }";
                vur = VirtuosoUpdateFactory.create(str, set);
                vur.exec();

System.out.println("\nexecute: SELECT * FROM <http://test1> WHERE { ?s ?p ?o }");
		vqe = VirtuosoQueryExecutionFactory.create (sparql, set);
                results = vqe.execSelect();
		while (results.hasNext()) {
			QuerySolution rs = results.nextSolution();
		    RDFNode s = rs.get("s");
		    RDFNode p = rs.get("p");
		    RDFNode o = rs.get("o");
		    System.out.println(" { " + s + " " + p + " " + o + " . }");
		}


	}
}
]]></programlisting>
    </sect4>
    <sect4 id="rdfnativestorageprovidersjenaexamples9"><title>VirtJenaSPARQLExample9</title>
<programlisting><![CDATA[
import com.hp.hpl.jena.query.*;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Graph;
import com.hp.hpl.jena.rdf.model.*;
import java.util.Iterator;

import virtuoso.jena.driver.*;

public class VirtuosoSPARQLExample9 {

	/**
	 * Executes a SPARQL query against a virtuoso url and prints results.
	 */
	public static void main(String[] args) {

		String url;
		if(args.length == 0)
		    url = "jdbc:virtuoso://localhost:1111";
		else
		    url = args[0];

/*			STEP 1			*/
		VirtGraph set = new VirtGraph (url, "dba", "dba");

/*			STEP 2			*/
                String str = "CLEAR GRAPH <http://test1>";
                VirtuosoUpdateRequest vur = VirtuosoUpdateFactory.create(str, set);
                vur.exec();

                str = "INSERT INTO GRAPH <http://test1> { <http://aa> <http://bb> 'cc' . <http://aa1> <http://bb> 123. }";
                vur = VirtuosoUpdateFactory.create(str, set);
                vur.exec();


/*		Select all data in virtuoso	*/
		Query sparql = QueryFactory.create("SELECT * FROM <http://test1> WHERE { ?s ?p ?o }");
		VirtuosoQueryExecution vqe = VirtuosoQueryExecutionFactory.create (sparql, set);
		ResultSet results = vqe.execSelect();
                System.out.println("\nSELECT results:");
		while (results.hasNext()) {
			QuerySolution rs = results.nextSolution();
		    RDFNode s = rs.get("s");
		    RDFNode p = rs.get("p");
		    RDFNode o = rs.get("o");
		    System.out.println(" { " + s + " " + p + " " + o + " . }");
		}

		sparql = QueryFactory.create("DESCRIBE <http://aa> FROM <http://test1>");
		vqe = VirtuosoQueryExecutionFactory.create (sparql, set);

		Model model = vqe.execDescribe();
 	        Graph g = model.getGraph();
                System.out.println("\nDESCRIBE results:");
	        for (Iterator i = g.find(Node.ANY, Node.ANY, Node.ANY); i.hasNext();)
	           {
	              Triple t = (Triple)i.next();
		      System.out.println(" { " + t.getSubject() + " " +
		      				 t.getPredicate() + " " +
		      				 t.getObject() + " . }");
	        }



		sparql = QueryFactory.create("CONSTRUCT { ?x <http://test> ?y } FROM <http://test1> WHERE { ?x <http://bb> ?y }");
		vqe = VirtuosoQueryExecutionFactory.create (sparql, set);

		model = vqe.execConstruct();
 	        g = model.getGraph();
                System.out.println("\nCONSTRUCT results:");
	        for (Iterator i = g.find(Node.ANY, Node.ANY, Node.ANY); i.hasNext();)
	           {
	              Triple t = (Triple)i.next();
		      System.out.println(" { " + t.getSubject() + " " +
		      				 t.getPredicate() + " " +
		      				 t.getObject() + " . }");
	        }


		sparql = QueryFactory.create("ASK FROM <http://test1> WHERE { <http://aa> <http://bb> ?y }");
		vqe = VirtuosoQueryExecutionFactory.create (sparql, set);

		boolean res = vqe.execAsk();
                System.out.println("\nASK results: "+res);


	}
}
]]></programlisting>
    </sect4>
    </sect3>
    <sect3 id="rdfnativestorageprovidersjenajavadoc"><title>Javadoc API Documentation</title>
    <para><ulink url="http://docs.openlinksw.com/jena/">Jena Provider Javadoc API Documentation</ulink> is available enabling the complete set of classes, interfaces and methods implemented for the provider to be viewed.
    </para>
    </sect3>
  </sect2>
  <sect2 id="rdfnativestorageproviderssesame"><title>Virtuoso Sesame Provider</title>
    <sect3 id="rdfnativestorageproviderssesamewhatis"><title>What is Sesame</title>
      <para>Sesame is an open source Java framework for storing, querying and reasoning
with RDF and RDF Schema. It can be used as a database for RDF and RDF Schema, or as a Java
library for applications that need to work with RDF internally. For example, suppose you need
to read a big RDF file, find the relevant information for your application, and use that information.
Sesame provides you with the necessary tools to parse, interpret, query and store all this information,
embedded in your own application if you want, or, if you prefer, in a separate database or even on a remote
server. More generally: Sesame provides an application developer a toolbox that contains useful hammers
screwdrivers etc. for doing 'Do-It-Yourself' with RDF.
      </para>
    </sect3>
    <sect3 id="rdfnativestorageproviderssesamewhatisvirtuososesameprovider"><title>What is the Virtuoso Sesame Provider</title>
    <para>The Virtuoso Sesame Provider is a fully oprerational Native Graph Model Storage Providers
for the Sesame Framework, allowing users of Virtuoso to leverage the Sesame framework for modifying,
querying, and reasoning with the Virtuoso quad store using the Java language. The Sesame Repository
API offers a central access point for connecting to the Virtuoso quad store. Its purpose is to
provides a java-friendly access point to Virtuoso. It offers various methods for querying and
updating the data, while abstracting the details of the underlying machinery. The Provider has
been tested against the <ulink url="http://sourceforge.net/project/showfiles.php?group_id=46509&amp;package_id=168413">Sesame 2.1.2</ulink> version currently available.
    </para>
    <figure id="rdfnativestorageproviderssesame1" float="1">
      <title>Fig. 1 Sesame Component Stack</title>
      <graphic fileref="ui/VirtSesame2Provider.png"/>
    </figure>
    <para>If you need more information about how to set up your environment for working with the
Sesame APIs, take a look at Chapter 4 of the Sesame User Guide, <ulink url="http://www.openrdf.org/doc/sesame2/users/RDF">Setting up to use the Sesame libraries</ulink>.
    </para>
    </sect3>
    <sect3 id="rdfnativestorageproviderssesamesetup"><title>Setup</title>
    <sect4 id="rdfnativestorageproviderssesamereqfiles"><title>Required Files</title>
    <para>This tutorial assumes you have Virtuoso server installed and that the database
is accessible at "localhost:1111". In addition, you will need the latest version of the
Virtuoso Sesame Provider, and Sesame 2 or greater installed.
    </para>
    <itemizedlist mark="bullet">
      <listitem>Virtuoso Sesame 2 Provider JAR file, <ulink url="http://virtuoso.openlinksw.com/wiki/main/Main/VirtSesame2Provider/virt_sesame2.jar">virt_sesame2.jar</ulink></listitem>
      <listitem>The Virtuoso JDBC Driver JAR file, <ulink url="http://virtuoso.openlinksw.com/wiki/main/Main/VirtSesame2Provider/virtjdbc3.jar">virtjdbc3.jar</ulink></listitem>
      <listitem>Sesame Framework and associated classes, <ulink url="http://virtuoso.openlinksw.com/wiki/main/Main/VirtSesame2Provider/sesame2jars.zip">sesame2jars.zip</ulink></listitem>
      <listitem>Sample programs, <ulink url="http://virtuoso.openlinksw.com/wiki/main/Main/VirtSesame2Provider/virtsesame2samples.zip">virtsesame2samples.zip</ulink></listitem>
    </itemizedlist>
    </sect4>
    <sect4 id="rdfnativestorageproviderssesamecmppr"><title>Compiling Jena Sample Programs</title>
    <orderedlist>
      <listitem>Ensure that full paths to the following files are all included in the active CLASSPATH setting --
    <itemizedlist mark="bullet">
      <listitem>openrdf-sesame-2.1.2-onejar.jar</listitem>
      <listitem>slf4j-api-1.5.0.jar</listitem>
      <listitem>slf4j-jdk14-1.5.0.jar</listitem>
      <listitem>virtjdbc3.jar</listitem>
      <listitem>virt_sesame2.jar</listitem>
   </itemizedlist>
      </listitem>
      <listitem>Execute the following command --
<programlisting><![CDATA[
javac VirtuosoTest.java
]]></programlisting>
      <para>Note: to use utf-8 and to use row auto commit is recommended
to add the following to the connect string:
      </para>
<programlisting><![CDATA[
"/charset=UTF-8/log_enable=2"
-- i.e. in VirtuosoTest.java the line:
Repository repository = new VirtuosoRepository("jdbc:virtuoso://" + sa[0] + ":" + sa[1], sa[2], sa[3]);
-- should become:
Repository repository = new VirtuosoRepository("jdbc:virtuoso://" + sa[0] + ":" + sa[1]+ "/charset=UTF-8/log_enable=2", sa[2], sa[3]);
]]></programlisting>
      </listitem>
    </orderedlist>
    </sect4>
    <sect4 id="rdfnativestorageproviderssesametesting"><title>Testing</title>
    <orderedlist>
      <listitem>Ensure that full paths to the following files are all included in the active CLASSPATH setting --
    <itemizedlist mark="bullet">
      <listitem>openrdf-sesame-2.1.2-onejar.jar</listitem>
      <listitem>slf4j-api-1.5.0.jar</listitem>
      <listitem>slf4j-jdk14-1.5.0.jar</listitem>
      <listitem>virtjdbc3.jar</listitem>
      <listitem>virt_sesame2.jar</listitem>
      <listitem>virtuoso_driver</listitem>
    </itemizedlist>
      </listitem>
      <listitem>Test the Sesame 2 Provider with the following command
<programlisting><![CDATA[
java VirtuosoTest <hostname> <port> <uid> <pwd>
]]></programlisting>
      </listitem>
      <listitem>The test run should look like this --
<programlisting><![CDATA[
$ java VirtuosoTest localhost 1111 dba dba

== TEST 1:  : Start
   Loading data from URL: http://www.openlinksw.com/dataspace/person/kidehen@openlinksw.com/foaf.rdf
== TEST 1:  : End
PASSED: TEST 1

== TEST 2:  : Start
   Clearing triple store
== TEST 2:  : End
PASSED: TEST 2

== TEST 3:  : Start
   Loading data from file: virtuoso_driver/data.nt
== TEST 3:  : End
PASSED: TEST 3

== TEST 4:  : Start
   Loading UNICODE single triple
== TEST 4:  : End
PASSED: TEST 4

== TEST 5:  : Start
   Loading single triple
== TEST 5:  : End
PASSED: TEST 5

== TEST 6:  : Start
   Casted value type
== TEST 6:  : End
PASSED: TEST 6

== TEST 7:  : Start
   Selecting property
== TEST 7:  : End
PASSED: TEST 7

== TEST 8:  : Start
   Statement does not exists
== TEST 8:  : End
PASSED: TEST 8

== TEST 9:  : Start
   Statement exists (by resultset size)
== TEST 9:  : End
PASSED: TEST 9

== TEST 10:  : Start
   Statement exists (by hasStatement())
== TEST 10:  : End
PASSED: TEST 10

== TEST 11:  : Start
   Retrieving namespaces
== TEST 11:  : End
PASSED: TEST 11

== TEST 12:  : Start
   Retrieving statement (http://myopenlink.net/dataspace/person/kidehen http://myopenlink.net/foaf/name null)
== TEST 12:  : End
PASSED: TEST 12

== TEST 13:  : Start
   Writing the statements to file: (/Users/hughwilliams/src/virtuoso-opensource/binsrc/sesame2/results.n3.txt)
== TEST 13:  : End
PASSED: TEST 13

== TEST 14:  : Start
   Retrieving graph ids
== TEST 14:  : End
PASSED: TEST 14

== TEST 15:  : Start
   Retrieving triple store size
== TEST 15:  : End
PASSED: TEST 15

== TEST 16:  : Start
   Sending ask query
== TEST 16:  : End
PASSED: TEST 16

== TEST 17:  : Start
   Sending construct query
== TEST 17:  : End
PASSED: TEST 17

== TEST 18:  : Start
   Sending describe query
== TEST 18:  : End
PASSED: TEST 18

============================
PASSED:18 FAILED:0
]]></programlisting>
      </listitem>
    </orderedlist>
    </sect4>
    </sect3>
    <sect3 id="rdfnativestorageproviderssesamegettingstarted"><title>Getting Started</title>
    <para>This section covers the essentials for connecting to and manipulating data stored in
a Virtuoso repository using the Sesame API. More information on the Sesame Framework, including
extended examples on how to use the API, can be found in Chapter 8 of the Sesame Users guide,
<ulink url="http://www.openrdf.org/doc/sesame2/2.1.2/users/ch08.html#d0e833">the RepositoryConnection API</ulink>.
    </para>
    <para>The interfaces for the Repository API can be found in packages virtuoso.sesame2.driver
and org.openrdf.repository. Several implementations for these interface exist in the
Virtuoso Provider download package.
The <ulink url="http://www.openrdf.org/doc/sesame2/2.1.2/apidocs/">Javadoc reference for the Sesame API</ulink>
is available online and can also be found in the doc directory of the download.
    </para>
    <sect4 id="rdfnativestorageproviderssesamegettingstartedcrrep"><title>Creating a VirtuosoRepositoryRDF object</title>
      <para>The first step to connecting to Virtuoso through the Sesame API is to create a
Repository for it. The Repository object operates on (stacks of) Sail object(s) for storage
and retrieval of RDF data.
      </para>
      <para>One of the simplest configurations is a repository that just stores RDF data in main
memory without applying any inference or whatsoever. This is also by far the fastest type of
repository that can be used. The following code creates and initialize a non-inferencing main-memory
repository:
      </para>
<programlisting><![CDATA[
import virtuoso.sesame2.driver.VirtuosoRepository;

Repository myRepository = VirtuosoRepositoryRDF?("jdbc:virtuoso://localhost:1111,dba,dba);

myRepository.initialize();
]]></programlisting>
      <para>The constructor of the VirtuosoRepositoryRDF class accepts the JDBC URL of the Virtuoso
engine (the default port is 1111), the username and password of an authorized user. Following this
example, the repository needs to be initialized to prepare the Sail(s) that it operates on, which
includes operations such as restoring previously stored data, setting up connections to a relational
database, etc.
      </para>
      <para>The repository that is created by the above code is volatile: its contents are lost
when the object is garbage collected or when the program is shut down. This is fine for cases where,
for example, the repository is used as a means for manipulating an RDF model in memory. Using the
Virtuoso repository with RepositoryConnecton.
      </para>
      <para>Now that we have created a VirtuosoRepositoryRDF, we want to do something with it.
This is achieved through the use of the VirtuosoRepositoryConnection, which can be created by
the VirtuosoRepositoryRDF.
      </para>
      <para>A VirtuosoRepositoryConnection represents - as the name suggests - a connection
to the actual Virtuoso quad store. We can issue operations over this connection, and close it
when we are done to make sure we are not keeping resources unnecessarily occupied.
      </para>
      <para>In the following sections, we will show some examples of basic operations
using the Northwind dataset.
      </para>
    </sect4>
    <sect4 id="rdfnativestorageproviderssesamegettingstartedrdfvirt"><title>Adding RDF to Virtuoso</title>
      <para>The Repository implements the Sesame Repository API offers various methods for adding
data to a repository. Data can be added pro grammatically by specifying the location of a file
that contains RDF data, and statements can be added individually or in collections.
      </para>
      <para>We perform operations on the repository by requesting a RepositoryConnection from
the repository, which returns a VirtuosoRepositoryConnection object. On this VirtuosoRepositoryConnection
object we can perform the various operations, such as query evaluation, getting, adding, or removing
statements, etc.
      </para>
      <para>The following example code adds two files, one local and one located on the WWW, to a repository:
      </para>
<programlisting><![CDATA[
import org.openrdf.repository.RepositoryException;

import org.openrdf.repository.Repository;

import org.openrdf.repository.RepositoryConnection;

import org.openrdf.rio.RDFFormat;

import java.io.File;

import java.net.URL;

File file = new File("/path/to/example.rdf");

String baseURI = "http://example.org/example/localRDF";

?

try {

   RepositoryConnection con = myRepository.getConnection();

   try {

      con.add(file, baseURI, RDFFormat.RDFXML);

      URL url = new URL("http://example.org/example/remoteRDF");

      con.add(url, url.toString(), RDFFormat.RDFXML);

   }

   finally {

      con.close();

   }

}

catch (RepositoryException rex) {

   // handle exception

}

catch (java.io.IOEXception e) {

   // handle io exception

}
]]></programlisting>
      <para>More information on other available methods can be found in the javadoc
reference of the RepositoryConnection interface.
      </para>
    </sect4>
    <sect4 id="rdfnativestorageproviderssesamegettingstartedqr"><title>Querying Virtuoso</title>
      <para>The Repository API has a number of methods for creating and evaluating queries.
Three types of queries are distinguished: tuple queries, graph queries and boolean queries.
The query types differ in the type of results that they produce.
      </para>
      <para><emphasis>Select Query:</emphasis> The result of a select query is a set of tuples
(or variable bindings), where each tuple represents a solution of a query. This type of query
is commonly used to get specific values (URIs, blank nodes, literals) from the stored RDF data.
The method QueryFactory.executeQuery() returns a Value[][] for sparql "SELECT" queries.
The method QueryFactory.executeQuery() also calls the QueryFactory.setResult() which populates
a set of tuples for SPARQL "SELECT" queries. The graph can be retrieved using
QueryFactory.getBooleanResult().
      </para>
      <para><emphasis>Graph Query:</emphasis> The result of graph queries is an RDF graph
(or set of statements). This type of query is very useful for extracting sub-graphs from
the stored RDF data, which can then be queried further, serialized to an RDF document,
etc. The method QueryFactory.executeQuery() calls the QueryFactory.setGraphResult()
which populates a graph for SPARQL "DESCRIBE" and "CONSTRUCT" queries. The graph can
be retrieved using QueryFactory.getGraphResult().
      </para>
      <para><emphasis>Boolean Query:</emphasis> The result of boolean queries is a simple
boolean value, i.e. true of false. This type of query can be used to check if a repository
contains specific information. The method QueryFactory.executeQuery() calls the
QueryFactory.setBooleanResult() which sets a boolean value for sparql "ASK" queries.
The value can be retrieved using QueryFactory.getBooleanResult().
      </para>
      <para>Note: Although Sesame 2 currently supports two query languages: SeRQL and SPARQL,
the Virtuoso provider only supports the W3C SPARQL specification.
      </para>
    </sect4>
    <sect4 id="rdfnativestorageproviderssesamegettingstartevq"><title>Evaluating a SELECT Query</title>
      <para>To evaluate a tuple query we simply do the following:
      </para>
<programlisting><![CDATA[
import java.util.List;

import org.openrdf.OpenRDFException;

import org.openrdf.repository.RepositoryConnection;

import org.openrdf.query.TupleQuery;

import org.openrdf.query.TupleQueryResult;

import org.openrdf.query.BindingSet;

import org.openrdf.query.QueryLanguage;

?

try {

   RepositoryConnection? con = myRepository.getConnection();

   try {

      String queryString = "SELECT x, y FROM  WHERE {x} p {y}";

      TupleQuery? tupleQuery = con.prepareTupleQuery(QueryLanguage.SPARQL, queryString);

      TupleQueryResult? result = tupleQuery.evaluate();

      try {

         ? // do something with the result

      }

      finally {

         result.close();

      }

   }

   finally {

      con.close();

   }

}

catch (RepositoryException? e) {

   // handle exception

}
]]></programlisting>
      <para>This evaluates a SPARQL query and returns a TupleQueryResult, which consists of a
sequence of BindingSet objects. Each BindingSet contains a set of pairs called Binding objects.
A Binding object represents a name/value pair for each variable in the querys projection.
      </para>
      <para>We can use the TupleQueryResult to iterate over all results and get each individual
result for x and y:
      </para>
<programlisting><![CDATA[
while (result.hasNext()) {

   BindingSet bindingSet = result.next();

   Value valueOfX = bindingSet.getValue("x");

   Value valueOfY = bindingSet.getValue("y");

   // do something interesting with the query variable values here?

}
]]></programlisting>
      <para>As you can see, we retrieve values by name rather than by an index. The names used
should be the names of variables as specified in your query. The TupleQueryResult.getBindingNames()
method returns a list of binding names, in the order in which they were specified in the query.
To process the bindings in each binding set in the order specified by the projection, you can do
the following:
      </para>
<programlisting><![CDATA[
List bindingNames = result.getBindingNames();

while (result.hasNext()) {

   BindingSet bindingSet = result.next();

   Value firstValue = bindingSet.getValue(bindingNames.get(0));

   Value secondValue = bindingSet.getValue(bindingNames.get(1));

   // do something interesting with the values here?

}
]]></programlisting>
      <para>It is important to invoke the close() operation on the TupleQueryResult, after we are
done with it. A TupleQueryResult evaluates lazily and keeps resources (such as connections to
the underlying database) open. Closing the TupleQueryResult frees up these resources. Do not
forget that iterating over a result may cause exceptions! The best way to make sure no connections
are kept open unnecessarily is to invoke close() in the finally clause.
      </para>
      <para>An alternative to producing a TupleQueryResult is to supply an object that implements
the TupleQueryResultHandler interface to the query's evaluate() method. The main difference is that
when using a return object, the caller has control over when the next answer is retrieved, whereas
with the use of a handler, the connection simply pushes answers to the handler object as soon as it
has them available.
      </para>
      <para>As an example we will use SPARQLResultsXMLWriter, which is a TupleQueryResultHandler
implementation that writes SPARQL Results XML documents to an output stream or to a writer:
      </para>
<programlisting><![CDATA[
import org.openrdf.query.resultio.sparqlxml.SPARQLResultsXMLWriter;

?

FileOutputStream out = new FileOutputStream("/path/to/result.srx");

try {

   SPARQLResultsXMLWriter sparqlWriter = new SPARQLResultsXMLWriter(out);

   RepositoryConnection con = myRepository.getConnection();

   try {

      String queryString = "SELECT * FROM  WHERE {x} p {y}";

      TupleQuery tupleQuery = con.prepareTupleQuery(QueryLanguage.SPARQL, queryString);

      tupleQuery.evaluate(sparqlWriter);

   }

   finally {

      con.close();

   }

}

finally {

   out.close();

}
]]></programlisting>
      <para>You can just as easily supply your own application-specific implementation of
TupleQueryResultHandler though.
      </para>
      <para>Lastly, an important warning: as soon as you are done with the RepositoryConnection
object, you should close it. Notice that during processing of the TupleQueryResult object
(for example, when iterating over its contents), the RepositoryConnection should still be open.
We can invoke con.close() after we have finished with the result.
      </para>
    </sect4>
    <sect4 id="rdfnativestorageproviderssesamegettingstartevcnq"><title>Evaluating a CONSTRUCT query</title>
      <para>The following code evaluates a graph query on a repository:
      </para>
<programlisting><![CDATA[
import org.openrdf.query.GraphQueryResult;

GraphQueryResult graphResult = con.prepareGraphQuery(

      QueryLanguage.SPARQL, "CONSTRUCT * FROM {x} p {y}").evaluate();
]]></programlisting>
      <para>A GraphQueryResult is similar to TupleQueryResult in that is an object that iterates
over the query results. However, for graph queries the query results are RDF statements, so a
GraphQueryResult iterates over Statement objects:
      </para>
<programlisting><![CDATA[
while (graphResult.hasNext()) {

   Statement st = graphResult.next();

   // ? do something with the resulting statement here.


}
]]></programlisting>
      <para>The TupleQueryResultHandler equivalent for graph queries is org.openrdf.rio.RDFHandler.
Again, this is a generic interface, each object implementing it can process the reported RDF statements
in any way it wants.
      </para>
      <para>All writers from Rio (such as the RDFXMLWriter, TurtleWriter, TriXWriter, etc.) implement
the RDFHandler interface. This allows them to be used in combination with querying quite easily. In
the following example, we use a TurtleWriter to write the result of a SPARQL graph query to standard
output in Turtle format:
      </para>
<programlisting><![CDATA[
import org.openrdf.rio.turtle.TurtleWriter;

?

RepositoryConnection con = myRepository.getConnection();

try {

   TurtleWriter turtleWriter = new TurtleWriter(System.out);

   con.prepareGraphQuery(QueryLanguage.SPARQL, "CONSTRUCT * FROM  WHERE {x} p {y}").evaluate(turtleWriter);

}

finally {

   con.close();

}
]]></programlisting>
      <para>Again, note that as soon as we are done with the result of the query (either after iterating over the contents of the GraphQueryResult or after invoking the RDFHandler),
we invoke con.close() to close the connection and free resources.
      </para>
    </sect4>
    </sect3>
    <sect3 id="rdfnativestorageproviderssesamejavadoc"><title>Javadoc API Documentation</title>
    <para><ulink url="http://docs.openlinksw.com/sesame/">Sesame Provider Javadoc API Documentation</ulink>
is available enabling the complete set of classes, interfaces and methods implemented for the provider to be viewed.
    </para>
    </sect3>
  </sect2>
  <sect2 id="rdfnativestorageproviderredland"><title>Virtuoso Redland Provider</title>
     <sect3 id="rdfnativestorageproviderredlandwhatis"><title>What is Redland</title>
     <para><ulink url="http://librdf.org/">Redland</ulink> is a set of free software 'C' libraries that
provide support for the Resource Description Framework (RDF), providing modular, object based libraries
and APIs for manipulating the RDF graph, triples, URIs and Literals. Redland includes several high-level
language APIs providing RDF manipulation and storage and requires the
<ulink url="http://librdf.org/raptor/">Raptor</ulink> RDF parser and <ulink url="http://librdf.org/rasqal/">Rasqal</ulink>
RDF syntax and query library
for its use.
    </para>
    </sect3>
    <sect3 id="rdfnativestorageproviderredlandwhatisv"><title>What is the Virtuoso Redland Provider</title>
    <para>The Virtuoso Redland RDF Provider is an implementation of the Storage API, Model and Query
interfaces of the Redland framework for RDF. This provider enables the execution of queries via the
Redland Rasqal query engine or via Virtuoso query engine directly against the Virtuoso Quad store.
The Virtuoso Redland Provider uses ODBC as the data access mechanism for communicating the Virtuoso
Quad Store and requires the Virtuoso ODBC Driver be installed on the Redland client and a suitable
ODBC DSN be configured for connecting to the target Virtuoso Quad Store instance. The provider has
been tested against the <ulink url="http://download.librdf.org/source/">Redland 1.0.8</ulink> version currently available for download.
    </para>
    <figure id="rdfnativestorageproviderredland1" float="1">
      <title>Redland Component Stack</title>
      <graphic fileref="ui/VirtRedLand.png"/>
    </figure>
    <para>As indicated in the above diagram the Virtuoso Provider can be used to execute RDF queries either
directly against the Virtuoso graph storage module supporting the <ulink url="http://dbpedia.org/resource/SPARQL">SPARQL</ulink>,
<ulink url="http://dbpedia.org/resource/SPARUL">SPARQL</ulink>SPARUL, <ulink url="http://virtuoso.openlinksw.com/dataspace/dav/wiki/Main/VOSArticleBISPARQL2">SPARQL-BI</ulink>
query languages or via the Rasqal query engine built into Redland which supports the SPARQL query language.
This is done by simply changing the syntax of the query using the "vsparql" rather then default "sparql"
construct when executing a query as indicated in the sample queries below:
    </para>
<programlisting><![CDATA[
rdfproc -r xml -t "user='dba',password='dba',dsn='Demo'" gr query sparql - "SELECT * WHERE { ?s ?p ?o }"   ;; via Redland Rasqal engine

rdfproc -r xml -t "user='dba',password='dba',dsn='Demo'" gr query vsparql - "SELECT * WHERE { ?s ?p ?o }"  ;; direct to Virtuoso storage module
]]></programlisting>
    <para>The Virtuoso Provider uses the <ulink url="http://virtuoso.openlinksw.com/dataspace/dav/wiki/Main/VOSSQL2RDF">SPASQL</ulink> query language for querying the remote Virtuoso QUAD store.
    </para>
    </sect3>
    <sect3 id="rdfnativestorageproviderredlandsetup"><title>Setup</title>
      <sect4 id="rdfnativestorageproviderredlandreqfiles"><title>Required Files</title>
      <para>The Virtuoso Redland Provider has been integrated into the Redland RDF Framework and submitted to
the open source project to become part of the standard distribution available for
<ulink url="http://librdf.org/INSTALL.html">download</ulink>. Until this
submission has been accepted and committed into the available Redland release a tar ball created by
OpenLink Software and a diff for application to a Redland 1.0.8 tree can be obtained from:
      </para>
      <itemizedlist mark="bullet">
        <listitem><ulink url="ftp://download.openlinksw.com/support/vos/redland-vos-1.0.8.tar.gz"></ulink>Redland 1.0.8 tar ball with Virtuoso storage support</listitem>
        <listitem><ulink url="ftp://download.openlinksw.com/support/vos/redland-vos.diff">Redland 1.0.8 Diff file of changes made for Virtuoso storage support</ulink></listitem>
      </itemizedlist>
      </sect4>
      <sect4 id="rdfnativestorageprovidersredlandcmsmpr"><title>Compling Redland with Virtuoso storage support</title>
        <itemizedlist mark="bullet">
          <listitem><ulink url="http://svn.librdf.org/">Download Redland</ulink>, extract and apply diff
above or download the tar ball above with diff already applied and extract to a location of choice.</listitem>
          <listitem>The following additional configure options are available for enabling the Virtuoso
storage support:
<programlisting><![CDATA[
  --with-virtuoso(=yes|no) Enable Virtuoso RDF store (default=auto)
  --with-iodbc(=DIR)        Select iODBC support
                            DIR is the iODBC base install directory
                            (default=/usr/local)
  --with-unixodbc(=DIR)   Select UnixODBC support
                            DIR is the UnixODBC base install directory
                            (default=/usr/local)
  --with-datadirect(=DIR) Select DataDirect support
                            DIR is the DataDirect base install directory
                            (default=/usr/local)
  --with-odbc-inc=DIR     Specify custom ODBC include directory
                            (default=/usr/local/include)
  --with-odbc-lib=DIR     Specify custom ODBC lib directory
                            (default=/usr/local/lib)
]]></programlisting>
          </listitem>
          <listitem>The "--with-virtuoso" option default to being auto enable if a valid ODBC Driver Manager
(iODBC, UnixODBC? or DataDirect?) or include and lib directories for required ODBC header files and libraries
are located with the suitable setting for one or more of the other ODBC related options above. Assuming
iODBC is installed the following option can be used to enable Virtuoso storage support to be configured
for compilation into your Redland build:
<programlisting><![CDATA[
./configure --with-iodbc=/usr/local/iODBC
]]></programlisting>
          </listitem>
          <listitem>Run "make" to compile the Redland libraries and "sudo make install" to install in
the default "/usr/local" location</listitem>
          <listitem>Test compilation with test utility utils/rdfproc:
<programlisting><![CDATA[

rdfproc test parse http://planetrdf.com/guide/rss.rdf
rdfproc test print
rdfproc test serialize ntriples
]]></programlisting>
          <para>This test will use the default 'hashes' storage.</para>
          </listitem>
          <listitem>Ensure you have the Virtuoso ODBC Driver installed and a valid ODBC DSN called
"Local Virtuoso" configured for your target Virtuoso Server</listitem>
          <listitem>Set the following environment variable:
<programlisting><![CDATA[
export RDFPROC_STORAGE_TYPE=virtuoso                                   ;; Enable Virtuoso Storage
export ODBCINI=<path_to_odbcini_directory>/odbc.ini                      ;; Enable ODBC DSN to be located
export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH                     ;; May be required to enable Redland libraries to be located

]]></programlisting>
          </listitem>
          <listitem>Test Virtuoso storage with the provided test program utils/vtest:
<programlisting><![CDATA[
$ utils/vtest
  1: Remove all triples in <http://red> context
**PASSED**: removed context triples from the graph
  2: Add triples to <http://red> context
**PASSED**: add triple to context
  3: Print all triples in <http://red> context
[[
  {[aa], [bb], [cc]} with context [http://red]
  {[aa], [bb1], [cc]} with context [http://red]
  {[aa], [a2], "cc"} with context [http://red]
  {[aa], [a2], (cc)} with context [http://red]
  {[mm], [nn], "Some long literal with language@en"} with context [http://red]
  {[oo], [pp], "12345^^<http://www.w3.org/2001/XMLSchema#int>"} with context [http://red]
]]
**PASSED**:
  4: Count of triples in <http://red> context
**PASSED**: graph has 6 triples
  5: Exec:  ARC  aa bb
Matched node: [cc]
**PASSED**:
  6: Exec:  ARCS  aa cc
Matched node: [bb] with context [http://red]
Matched node: [bb1] with context [http://red]
: matching nodes: 2
**PASSED**:
  7: Exec:  ARCS-IN  cc
Matched arc: [bb] with context [http://red]
Matched arc: [bb1] with context [http://red]
**PASSED**: matching arcs: 2
  8: Exec:  ARCS-OUT  aa
Matched arc: [bb] with context [http://red]
Matched arc: [bb1] with context [http://red]
Matched arc: [a2] with context [http://red]
Matched arc: [a2] with context [http://red]
**PASSED**: matching arcs: 4
  9: Exec:  CONTAINS aa bb1 cc
**PASSED**: the graph contains the triple
 10: Exec:  FIND aa - -
Matched triple: {[aa], [bb], [cc]} with context [http://red]
Matched triple: {[aa], [bb1], [cc]} with context [http://red]
Matched triple: {[aa], [a2], "cc"} with context [http://red]
Matched triple: {[aa], [a2], (cc)} with context [http://red]
**PASSED**: matching triples: 4
 11: Exec:  HAS-ARC-IN cc bb
**PASSED**: the graph contains the arc
 12: Exec:  HAS-ARC-OUT aa bb
**PASSED**: the graph contains the arc
 13: Exec:  SOURCE  aa cc
Matched node: [aa]
**PASSED**:
 14: Exec:  SOURCES  bb cc
Matched node: [aa] with context [http://red]
: matching nodes: 1
**PASSED**:
 15: Exec:  TARGET  aa bb
Matched node: [cc]
**PASSED**:
 16: Exec:  TARGETS  aa bb
Matched node: [cc] with context [http://red]
: matching nodes: 1
**PASSED**:
 17: Exec:  REMOVE aa bb1 cc
**PASSED**: removed triple from the graph
 18: Exec:  QUERY "CONSTRUCT {?s ?p ?o} FROM <http://red> WHERE {?s ?p ?o}"
Matched triple: {[aa], [a2], "cc"}
Matched triple: {[oo], [pp], "12345^^<http://www.w3.org/2001/XMLSchema#int>"}
Matched triple: {[aa], [a2], (cc)}
Matched triple: {[aa], [bb], [cc]}
Matched triple: {[mm], [nn], "Some long literal with language@en"}
**PASSED**: matching triples: 5
 19: Exec1:  QUERY_AS_BINDINGS "SELECT * WHERE {graph <http://red> { ?s ?p ?o }}"
**: Formatting query result as 'xml':
<?xml version="1.0" encoding="utf-8"?>
<sparql xmlns="http://www.w3.org/2005/sparql-results#">
  <head>
    <variable name="s"/>
    <variable name="p"/>
    <variable name="o"/>
  </head>
  <results>
    <result>
      <binding name="s"><uri>aa</uri></binding>
      <binding name="p"><uri>bb</uri></binding>
      <binding name="o"><uri>cc</uri></binding>
    </result>
    <result>
      <binding name="s"><uri>aa</uri></binding>
      <binding name="p"><uri>a2</uri></binding>
      <binding name="o"><literal>cc</literal></binding>
    </result>
    <result>
      <binding name="s"><uri>aa</uri></binding>
      <binding name="p"><uri>a2</uri></binding>
      <binding name="o"><bnode>cc</bnode></binding>
    </result>
    <result>
      <binding name="s"><uri>mm</uri></binding>
      <binding name="p"><uri>nn</uri></binding>
      <binding name="o"><literal>Some long literal with language@en</literal></binding>
    </result>
    <result>
      <binding name="s"><uri>oo</uri></binding>
      <binding name="p"><uri>pp</uri></binding>
      <binding name="o"><literal>12345^^<http://www.w3.org/2001/XMLSchema#int></literal></binding>
    </result>
  </results>
</sparql>
**PASSED**:
 20: Exec2:  QUERY_AS_BINDINGS "SELECT * WHERE {graph <http://red> { ?s ?p ?o }}"
: Query returned bindings results:
result: [s=[aa], p=[bb], o=[cc]]
result: [s=[aa], p=[a2], o=cc]
result: [s=[aa], p=[a2], o=(cc)]
result: [s=[mm], p=[nn], o=Some long literal with language@en]
result: [s=[oo], p=[pp], o=12345^^<http://www.w3.org/2001/XMLSchema#int>]
: Query returned 5 results
**PASSED**:
=============================================
PASSED: 20  FAILED:  0
]]></programlisting>
          </listitem>
        </itemizedlist>
      </sect4>
      <sect4 id="rdfnativestorageprovidersredlandcp"><title>Connection Parameters</title>
        <para>The Virtuoso provider has the following connection parameters available fro use:</para>
        <itemizedlist mark="bullet">
          <listitem><emphasis>dsn</emphasis> - ODBC datasource name</listitem>
          <listitem><emphasis>user</emphasis> - user name of database server</listitem>
          <listitem><emphasis>password</emphasis> - password of database server</listitem>
          <listitem><emphasis>host</emphasis> - hostname:portno of the database server</listitem>
          <listitem><emphasis>charset</emphasis> - database charset to use</listitem>
        </itemizedlist>
        <para>NOTE: Take care exposing the password as for example, program arguments or environment
variables. The rdfproc utility can help this by reading the password from standard input. Inside programs,
one way to prevent storing the password in a string is to construct a Redland hash of the storage options
such as via librdf hash_from_string and use librdf_new_storage_with_options to create a storage. The
rdfproc utility source code demonstrates this.
        </para>
        <para>The storage name parameter given to the storage constructor librdf new_storage is used
inside the virtuoso store to allow multiple stores inside one Virtuoso database instance as parameterised
with the above options.
        </para>
        <para>This store always provides contexts; the boolean storage option contexts is not checked.</para>
        <para>Examples:</para>
<programlisting><![CDATA[
  /* A new Virtuoso store */
  storage=librdf_new_storage(world, "virtuoso", "db1",
      "dsn='Local Virtuoso',user='demo',password='demo'");

  /* A different, existing Virtuoso store in the same database as above */
  storage=librdf_new_storage(world, "virtuoso", "db2",
      "dsn='Local Virtuoso',user='demo',password='demo'");

  /* An existing Virtuoso store on a different database server */
  storage=librdf_new_storage(world, "virtuoso", "http://red3",
      "dsn='Remote Virtuoso',user='demo',password='demo'");

  /* Opening with an options hash */
  options=librdf_new_hash(world, NULL);
  librdf_hash_from_string(options,
      "dsn='Local Virtuoso',user='demo'");
  librdf_hash_put_strings(options, "password", user_password);
  storage=librdf_new_storage_with_options(world, "virtuoso", "http://red3", options);
]]></programlisting>
      </sect4>
    </sect3>
    <sect3 id="rdfnativestorageprovidersredlandref"><title>References</title>
      <itemizedlist mark="bullet">
        <listitem><ulink url="http://librdf.org/docs/api/redland-storage.html">RedLand Triple Store</ulink></listitem>
        <listitem><ulink url="http://librdf.org/docs/api/redland-storage-modules.html">RedLand Storage Modules</ulink></listitem>
      </itemizedlist>
    </sect3>
  </sect2>
</sect1>
<sect1 id="rdfpredicatessparql"><title>SPARQL predicates usage</title>
  <para>Since version 5.0 Virtuoso supports declaring RDF objects triples by given predicate.</para>
  <sect2 id="rdfpredicatessparqlexamples"><title>Examples</title>
    <para>The boolean functions bif:contains and bif:xcontains are used for objects that come from RDF Views as well
as for regular "physical" triples. Every function gets two arguments and returns a boolean value.
The first argument is an local variable. The argument variable should be used as an object field in
the group pattern where the filter condition is placed.
    </para>
    <para>In order to execute the examples below please run these commands:</para>
<programlisting><![CDATA[
sparql clear graph <http://MyTest.com>;
DB.DBA.RDF_QUAD_URI_L ('http://MyTest.com', 'sxml1', 'p_all1', xtree_doc ('<Hello>world</Hello>'));
DB.DBA.RDF_QUAD_URI_L ('http://MyTest.com', 'sxml2', 'p_all2', xtree_doc ('<Hello2>world</Hello2>'));
DB.DBA.RDF_QUAD_URI_L ('http://MyTest.com', 'nonxml1', 'p_all3', 'Hello world');
VT_INC_INDEX_DB_DBA_RDF_OBJ();
DB.DBA.RDF_OBJ_FT_RULE_ADD ('http://MyTest.com', null, 'My test RDF Data');
]]></programlisting>
    <para><emphasis>bif:contains</emphasis></para>
<programlisting><![CDATA[
SQL>sparql
select *
from <http://MyTest.com>
where { ?s ?p ?o . ?o bif:contains "world" };

s             p         o
VARCHAR       VARCHAR   VARCHAR
_______________________________________________________________________________

sxml1         p_all1    <Hello>world</Hello>
nonxml1       p_all3    Hello world
sxml2         p_all2    <Hello2>world</Hello2>

3 Rows. -- 20 msec.
]]></programlisting>
<para><emphasis>bif:xcontains</emphasis></para>
<programlisting><![CDATA[
SQL>sparql
select *
from <http://MyTest.com>
where { ?s ?p ?o . ?o bif:xcontains "//Hello[text-contains (., 'world')]" };
s                  p          o
VARCHAR            VARCHAR    VARCHAR
_______________________________________________________________________________

sxml1              p_all      <Hello>world</Hello>

1 Rows. -- 10 msec.
]]></programlisting>
<para><emphasis>bif:xpath_contains</emphasis></para>
<programlisting><![CDATA[
SQL>sparql
select *
from <http://MyTest.com>
where { ?s ?p ?o . ?o bif:xpath_contains "//*" };

s             p         o
VARCHAR       VARCHAR   VARCHAR
_______________________________________________________________________________

sxml1         p_all1    <Hello>world</Hello>
sxml2         p_all2    <Hello2>world</Hello2>

2 Rows. -- 20 msec.
]]></programlisting>
<para><emphasis>bif:xquery_contains</emphasis></para>
<programlisting><![CDATA[
SQL>sparql
select *
from <http://MyTest.com>
where { ?s ?p ?o . ?o bif:xquery_contains "//Hello2 , world" };

s             p         o
VARCHAR       VARCHAR   VARCHAR
_______________________________________________________________________________

sxml2         p_all2    <Hello2>world</Hello2>

1 Rows. -- 20 msec.
]]></programlisting>
  </sect2>
</sect1>
</chapter>
