<!--
 -  
 -  This file is part of the OpenLink Software Virtuoso Open-Source (VOS)
 -  project.
 -  
 -  Copyright (C) 1998-2019 OpenLink Software
 -  
 -  This project is free software; you can redistribute it and/or modify it
 -  under the terms of the GNU General Public License as published by the
 -  Free Software Foundation; only version 2 of the License, dated June 1991.
 -  
 -  This program is distributed in the hope that it will be useful, but
 -  WITHOUT ANY WARRANTY; without even the implied warranty of
 -  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 -  General Public License for more details.
 -  
 -  You should have received a copy of the GNU General Public License along
 -  with this program; if not, write to the Free Software Foundation, Inc.,
 -  51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 -  
 -  
-->
<?xml version="1.0" encoding="ISO-8859-1" ?>
<cases>

<case id="1.1.9.1">
<descr>List books published by Addison-Wesley after 1991, including their year and title.</descr>
<xquery><![CDATA[
<bib>
   {
   for $b in document("bib.xml")/bib/book
   where $b/publisher = "Addison-Wesley" and $b/@year > 1991
   return
      <book year = {$b/@year}>
	 {$b/title}
      </book>
   }
</bib>
]]></xquery>
<etalon>
<bib>
    <book year="1994">
	<title>TCP/IP Illustrated</title>
    </book>
    <book year="1992">
	<title>Advanced Programming in the Unix environment</title>
    </book>
</bib>
</etalon>
</case>

<case id="1.1.9.1a">
<descr>List books, including their year and title.</descr>
<xquery><![CDATA[
<bib>
   {
   for $b in document("bib.xml")/bib/book
   return
      <book year = {$b/@year}>
	 {$b/title}
      </book>
   }
</bib>
]]></xquery>
<etalon>
<bib>
  <book year="1994">
    <title>TCP/IP Illustrated</title>
  </book>
  <book year="1992">
    <title>Advanced Programming in the Unix environment</title>
  </book>
  <book year="2000">
    <title>Data on the Web</title>
  </book>
  <book year="1999">
    <title>The Economics of Technology and Content for Digital TV</title>
  </book>
</bib>
</etalon>
</case>

<case id="1.1.9.1b">
<descr>List books, including their title.</descr>
<xquery><![CDATA[
<bib>
   {
   for $b in document("bib.xml")/bib/book
   return
      <book>
	 {$b/title}
      </book>
   }
</bib>
]]></xquery>
<etalon>
<bib>
  <book>
    <title>TCP/IP Illustrated</title>
  </book>
  <book>
    <title>Advanced Programming in the Unix environment</title>
  </book>
  <book>
    <title>Data on the Web</title>
  </book>
  <book>
    <title>The Economics of Technology and Content for Digital TV</title>
  </book>
</bib>
</etalon>
</case>

<case id="1.1.9.2">
<descr>Create a flat list of all the title-author pairs, with each pair enclosed in a "result" element.</descr>
<xquery><![CDATA[
<results>
   {
   for $b in document("bib.xml")/bib/book,
       $t in $b/title,
       $a in $b/author
   return
      <result>
	 { $t }
	 { $a }
      </result>
   }
</results>
]]></xquery>
<etalon>
<results>
	<result>
	       <title>TCP/IP Illustrated</title>
	       <author><last>Stevens</last><first>W.</first></author>
	</result>
	<result>
	       <title>Advanced Programming in the Unix environment</title>
	       <author><last>Stevens</last><first>W.</first></author>
	</result>
	<result>
	       <title>Data on the Web</title>
	       <author><last>Abiteboul</last><first>Serge</first></author>
	</result>
	<result>
	       <title> Data on the Web</title>
	       <author><last>Buneman</last><first>Peter</first></author>
	</result>
	<result>
	       <title>Data on the Web</title>
	       <author><last>Suciu</last><first>Dan</first></author>
	</result>
</results>
</etalon>
</case>

<case id="1.1.9.3">
<descr>for each book in the bibliography, list the title and authors, grouped inside a "result" element.</descr>
<xquery><![CDATA[
<results>
   {
   for $b in document("bib.xml")/bib/book
   return
      <result>
	 { $b/title }
	 {
	 for $a in $b/author
	 return $a
	 }
      </result>
   }
</results>
]]></xquery>
<etalon>
<results>
  <result>
    <title>TCP/IP Illustrated</title>
    <author><last>Stevens</last><first>W.</first>
    </author>
  </result>
  <result>
    <title>Advanced Programming in the Unix environment</title>
    <author><last>Stevens</last><first>W.</first>
    </author>
  </result>
  <result>
    <title>Data on the Web</title>
    <author><last>Abiteboul</last><first>Serge</first>
    </author>
    <author><last>Buneman</last><first>Peter</first>
    </author>
    <author><last>Suciu</last><first>Dan</first>
    </author>
  </result>
  <result>
    <title>The Economics of Technology and Content for Digital TV</title>
  </result>
</results></etalon>
</case>

<case id="1.1.9.3a">
<descr>for each book in the bibliography with nonempty list of authors, list the title and authors, grouped inside a "result" element.</descr>
<xquery><![CDATA[
<results>
   {
   for $b in document("bib.xml")/bib/book
   return
     if ($b/author) then
      <result>
	 { $b/title }
	 {
	 for $a in $b/author
	 return $a
	 }
      </result>
     else ()
   }
</results>
]]></xquery>
<etalon>
<results>
  <result>
    <title>TCP/IP Illustrated</title>
    <author><last>Stevens</last><first>W.</first>
    </author>
  </result>
  <result>
    <title>Advanced Programming in the Unix environment</title>
    <author><last>Stevens</last><first>W.</first>
    </author>
  </result>
  <result>
    <title>Data on the Web</title>
    <author><last>Abiteboul</last><first>Serge</first>
    </author>
    <author><last>Buneman</last><first>Peter</first>
    </author>
    <author><last>Suciu</last><first>Dan</first>
    </author>
  </result>
</results></etalon>
</case>

<case id="1.1.9.4">
<descr>for each author in the bibliography, list the author's name and the titles of all books by that author, grouped inside a "result" element.</descr>
<xquery><![CDATA[
<results>
   {
     for $a in distinct(document("bib.xml")//author) sortby (.)
   return
      <result>
	 { $a }
	 {
	      for $b in document("bib.xml")/bib/book[author = $a]
	      return $b/title
	 }
      </result>
   }
</results>
]]></xquery>
<etalon>
<results>
    <result>
	<author><last>Abiteboul</last><first>Serge</first></author>
	<title>Data on the Web</title>
    </result>
    <result>
	<author><last>Buneman</last><first>Peter</first></author>
	<title>Data on the Web</title>
    </result>
    <result>
	<author><last>Stevens</last><first>W.</first></author>
	<title>TCP/IP Illustrated</title>
	<title>Advanced Programming in the Unix environment</title>
    </result>
    <result>
	<author><last>Suciu</last><first>Dan</first></author>
	  <title>Data on the Web</title>
    </result>
</results>
</etalon>
</case>

<case id="1.1.9.5">
<descr>for each book found at both bn.com and amazon.com, list the title of the book and its price from each source.</descr>
<xquery><![CDATA[
<books-with-prices>
  {
   for $b in document("bib.xml")//book,
       $a in document("reviews.xml")//entry
   where $b/title = $a/title
   return
      <book-with-prices>
	 { $b/title }
	 <price-amazon> { string($a/price) } </price-amazon>
	 <price-bn> { string($b/price) } </price-bn>
      </book-with-prices>
  }
</books-with-prices>
]]></xquery>
<etalon>
<books-with-prices>
    <book-with-prices>
      <title>TCP/IP Illustrated</title>
      <price-amazon>65.95</price-amazon>
      <price-bn>65.95</price-bn>
    </book-with-prices>

    <book-with-prices>
      <title>Advanced Programming in the Unix environment</title>
      <price-amazon>65.95</price-amazon>
      <price-bn>65.95</price-bn>
    </book-with-prices>

    <book-with-prices>
      <title>Data on the Web</title>
      <price-amazon>34.95</price-amazon>
      <price-bn>39.95</price-bn>
    </book-with-prices>
</books-with-prices>
</etalon>
</case>

<case id="1.1.9.6">
<descr>for each book that has at least one author, list the title and first two authors, and an empty "et-al" element if the book has additional authors.</descr>
<xquery><![CDATA[
<bib>
  {
   for $b in document("bib.xml")//book
   where count($b/author) > 0
   return
      <book>
	 { $b/title ,
	    for $a in $b/author[1 to 2]
	    return $a,
	    if (count($b/author) > 2) then <et-al/> else ()
	 }
      </book>
  }
</bib>
]]></xquery>
<etalon>
<bib>
    <book>
	<title>TCP/IP Illustrated</title>
	<author><last>Stevens</last><first>W.</first></author>
    </book>

    <book>
	<title>Advanced Programming in the Unix environment</title>
	<author><last>Stevens</last><first>W.</first></author>
    </book>

    <book>
	<title>Data on the Web</title>
	    <author><last>Abiteboul</last><first> Serge</first></author>
	    <author><last>Buneman</last><first>Peter</first></author>
	    <et-al/>
    </book>
</bib>
</etalon>
</case>

<case id="1.1.9.7">
<descr>List the titles and years of all books published by Addison-Wesley after 1991, in alphabetic order.</descr>
<xquery><![CDATA[
<bib>
   {
   for $b in document("bib.xml")//book
      [publisher = "Addison-Wesley" and @year > "1991"]
   return
      <book>
	 { $b/@year,
	    $b/title }
      </book> sortby (title)
   }
</bib>
]]></xquery>
<etalon>
<bib>
    <book year="1992">
	<title>Advanced Programming in the Unix environment</title>
    </book>
    <book year="1994">
	<title>TCP/IP Illustrated</title>
   </book>
</bib>
</etalon>
</case>

<case id="1.1.9.8">
<descr>Find books in which some element has a tag ending in "or" and the same element contains the string "Suciu" (at any level of nesting). for each such book, return the title and the qualifying element.</descr>
<xquery><![CDATA[
for $b in document("bib.xml")//book,
    $e in $b/*[contains(string(.), "Suciu")]
where ends-with(name($e), "or")
return
   <book>
      { $b/title, $e }
   </book>
]]></xquery>
<etalon>
<book>
    <title> Data on the Web </title>
    <author> <last> Suciu </last> <first> Dan </first> </author>
</book>
</etalon>
</case>

<case id="1.1.9.9">
<descr>
In the document "books.xml", find all section or chapter titles that contain
the word "XML", regardless of the level of nesting.</descr>
<xquery><![CDATA[
<results>
   {
     for $t in document("books.xml")//chapter/title
	     union document("books.xml")//section/title
   where contains($t, "XML")
   return $t
   }
</results>
]]></xquery>

<etalon>

<results>
	<title>XML</title>
	<title>XML and Semistructured Data</title>
</results>
</etalon>
</case>

<case id="1.1.9.9a">
<descr>
In the document "books.xml", find all section or chapter titles that contain
the word "XML", regardless of the level of nesting.</descr>
<xquery><![CDATA[
let $doc := document("books.xml")
return
<results>
   {
     for $t in $doc//chapter/title
	     union $doc//section/title
   where contains($t, "XML")
   return $t
   }
</results>
]]></xquery>

<etalon>

<results>
	<title>XML</title>
	<title>XML and Semistructured Data</title>
</results>
</etalon>
</case>

<case id="1.1.9.10">
<descr>
In the document "prices.xml", find the minimum price for each book, in the
form of a "minprice" element with the book title as its title attribute.</descr>
<xquery><![CDATA[
<results>
   {
      let $doc := document("prices.xml")
      for $t in distinct($doc/prices/book/title) sortby (.)
      let $p := $doc/prices/book[title = $t]/price
      return
	 <minprice title = { $t } >
	    { min($p) }
	 </minprice>
   }
</results>
]]></xquery>
<etalon>

<results>
    <minprice title="Advanced Programming in the Unix environment">65.95</minprice>
    <minprice title="Data on the Web">34.95</minprice>
    <minprice title="TCP/IP Illustrated">65.95</minprice>
</results>
</etalon>
</case>

<case id="1.1.9.10a">
<descr>
For the document "prices.xml", list every book with the minimum offered price for this book.</descr>
<xquery><![CDATA[
<results>
   {
      let $doc := document("prices.xml")
      for $book in $doc/prices/book
      let $t := $book//title, $p := $doc/prices/book[title = $t]/price
      return
	(
	  $book,
	 <minprice title = { string($t) } >
	    { if (not(empty($p))) then string(min($p)) else <unknown/> }
	 </minprice>
	)
   }
</results>
]]></xquery>
<etalon>
<results>
  <book>
    <title>Advanced Programming in the Unix environment</title>
    <source>www.amazon.com</source>
    <price>65.95</price>
  </book>
  <minprice title="Advanced Programming in the Unix environment">65.95</minprice>
  <book>
    <title>Advanced Programming in the Unix environment</title>
    <source>www.bn.com</source>
    <price>65.95</price>
  </book>
  <minprice title="Advanced Programming in the Unix environment">65.95</minprice>
  <book>
    <title>TCP/IP Illustrated</title>
    <source>www.amazon.com</source>
    <price>65.95</price>
  </book>
  <minprice title="TCP/IP Illustrated">65.95</minprice>
  <book>
    <title>TCP/IP Illustrated</title>
    <source>www.bn.com</source>
    <price>65.95</price>
  </book>
  <minprice title="TCP/IP Illustrated">65.95</minprice>
  <book>
    <title>Data on the Web</title>
    <source>www.amazon.com</source>
    <price>34.95</price>
  </book>
  <minprice title="Data on the Web">34.95</minprice>
  <book>
    <title>Data on the Web</title>
    <source>www.bn.com</source>
    <price>39.95</price>
  </book>
  <minprice title="Data on the Web">34.95</minprice>
</results>
</etalon>
</case>

<case id="1.1.9.11">
<descr>
for each book with an author, return the book with its title and authors. for
each book with an editor, return a reference with the book title and the
editor's affiliation. </descr>
<xquery><![CDATA[
<bib>
{
   for $b in document("bib.xml")/bib/book[author]
   return
      <book>
      {
	 $b/title,
	 $b/author
      }
      </book>,
   for $b in document("bib.xml")/bib/book[editor]
   return
      <reference>
	 {
	    $b/title,
	    <org> { string($b/editor/affiliation) } </org>
	 }
      </reference>
}
</bib>
]]></xquery>
<etalon>
<bib>
	<book>
	       <title>TCP/IP Illustrated</title>
	       <author><last>Stevens</last><first>W.</first></author>
	</book>

	<book>
	       <title>Advanced Programming in the Unix environment</title>
	       <author><last>Stevens</last><first>W.</first></author>
	</book>

	<book>
	       <title>Data on the Web</title>
	       <author><last>Abiteboul</last><first>Serge</first></author>
	       <author><last>Buneman</last><first>Peter</first></author>
	       <author><last>Suciu</last><first>Dan</first></author>
	</book>

	<reference>
		<title>The Economics of Technology and Content for Digital TV</title>
		<org>CITI</org>
	</reference>
</bib>
</etalon>
</case>

<case id="1.1.9.12">
<descr>
Find pairs of books that have different titles but the same set of authors
(possibly in a different order).</descr>
<xquery><![CDATA[
<bib>
{
   for $book1 in document("bib.xml")/bib/book,
       $book2 in document("bib.xml")/bib/book
   where $book1/title > $book2/title
   and unordered($book1/author) = unordered($book2/author)
   return
      <book-pair>
	 { $book1/title, $book2/title }
      </book-pair>
}
</bib>
]]></xquery>
<etalon>
<bib>
       <book-pair>
	       <title>TCP/IP Illustrated</title>
	       <title>Advanced Programming in the Unix environment</title>
       </book-pair>
</bib>
</etalon>
</case>

<case id="1.1.9.12a">
<descr>Find pairs of books that have different titles.</descr>
<xquery><![CDATA[
<bib>
{
   for $book1 in document("bib.xml")/bib/book,
       $book2 in document("bib.xml")/bib/book
   where $book1/title > $book2/title
   return
      <book-pair>
	 { $book1/title, $book2/title }
      </book-pair>
}
</bib>
]]></xquery>
<etalon>
<bib>
  <book-pair>
    <title>TCP/IP Illustrated</title>
    <title>Advanced Programming in the Unix environment</title>
  </book-pair>
  <book-pair>
    <title>TCP/IP Illustrated</title>
    <title>Data on the Web</title>
  </book-pair>
  <book-pair>
    <title>Data on the Web</title>
    <title>Advanced Programming in the Unix environment</title>
  </book-pair>
  <book-pair>
    <title>The Economics of Technology and Content for Digital TV</title>
    <title>TCP/IP Illustrated</title>
  </book-pair>
  <book-pair>
    <title>The Economics of Technology and Content for Digital TV</title>
    <title>Advanced Programming in the Unix environment</title>
  </book-pair>
  <book-pair>
    <title>The Economics of Technology and Content for Digital TV</title>
    <title>Data on the Web</title>
  </book-pair>
</bib>
</etalon>
</case>

<case id="1.2.4.1">
<descr>
Prepare a (nested) table of contents for Book1, listing all the sections and
their titles. Preserve the original attributes of each &lt;section&gt; element,
if any.</descr>
<xquery><![CDATA[
<toc>
{
   let $b := document("book1.xml")
   return filter(
       $b//section | $b//section/title | $b//section/title/text())
}
</toc>
]]></xquery>
<etalon><toc>
  <section id="intro" difficulty="easy">
    <title>Introduction</title>
    <section>
      <title>Audience</title>
    </section>
    <section>
      <title>Web Data and the Two Cultures</title>
    </section>
  </section>
  <section id="syntax" difficulty="medium">
    <title>A Syntax For Data</title>
    <section>
      <title>Base Types</title>
    </section>
    <section>
      <title>Representing Relational Databases</title>
    </section>
    <section>
      <title>Representing Object Databases</title>
    </section>
  </section>
</toc></etalon>
</case>

<case id="1.2.4.2">
<descr>
Prepare a (flat) figure list for Book1, listing all the figures and their
titles. Preserve the original attributes of each &lt;figure&gt; element, if
any.</descr>
<xquery><![CDATA[
<figlist>
{
   for $f in document("book1.xml")//figure
   return
      <figure> { $f/@*, $f/title } </figure>
}
</figlist>
]]></xquery>
<etalon>
<figlist>
  <figure height="400" width="400">
    <title>Traditional client/server architecture</title>
  </figure>
  <figure height="200" width="500">
    <title>Graph representations of structures</title>
  </figure>
  <figure height="250" width="400">
    <title>Examples of Relations</title>
  </figure>
</figlist>
</etalon>
</case>
<case id="1.2.4.3">
<descr>
How many sections are in Book1, and how many figures? </descr>
<xquery><![CDATA[
(
  <section_count>
    {
     count(document("book1.xml")//section)
    }
  </section_count> ,
  <figure_count>
    {
     count(document("book1.xml")//figure)
    }
  </figure_count>
)
]]></xquery>
<etalon>
<section_count> 7 </section_count>
<figure_count> 3 </figure_count>
</etalon>
</case>


<case id="1.2.4.4">
<descr>
How many top-level sections are in Book1? </descr>
<xquery><![CDATA[
<top_section_count>
   {
   count(document("book1.xml")/book/section)
   }
</top_section_count>
]]></xquery>
<etalon>
<top_section_count> 2 </top_section_count>
</etalon>
</case>

<case id="1.2.4.5">
<descr>
Make a flat list of the section elements in Book1. In place of its original
attributes, each section element should have two attributes, containing the
title of the section and the number of figures immediately contained in the
section. </descr>
<xquery><![CDATA[
<section_list>
   {
      for $s in document("book1.xml")//section
      let $f := $s/figure
      return
      <section title = { $s/title } figcount = { count($f) } > </section>
   }
</section_list>
]]></xquery>
<etalon>
<section_list>
  <section title="Introduction" figcount="0" />
  <section title="Audience" figcount="0" />
  <section title="Web Data and the Two Cultures" figcount="1" />
  <section title="A Syntax For Data" figcount="1" />
  <section title="Base Types" figcount="0" />
  <section title="Representing Relational Databases" figcount="1" />
  <section title="Representing Object Databases" figcount="0" />
</section_list>
</etalon>
</case>
<case id="1.2.4.6">
<descr>
Make a nested list of the section elements in Book1, preserving their
original attributes and hierarchy. Inside each section element, include the
title of the section and an element that includes the number of figures
immediately contained in the section. </descr>
<xquery><![CDATA[
define function section_summary( (: element :) $s) (: returns element :)
  {
    <section>
       {
         $s/@* ,
         $s/title,
       <figcount> {count($s/figure)} </figcount>,
       for $ss in $s/section
       return section_summary($ss)
       }
    </section>
  } ;
<toc>
{
   for $s in document("book1.xml")/book/section
   return section_summary($s)
}
</toc>
]]></xquery>
<etalon>
<toc>
  <section id="intro" difficulty="easy">
    <title>Introduction</title>
    <figcount>0</figcount>
    <section>
      <title>Audience</title>
      <figcount>0</figcount>
    </section>
    <section>
      <title>Web Data and the Two Cultures</title>
      <figcount>1</figcount>
    </section>
  </section>
  <section id="syntax" difficulty="medium">
    <title>A Syntax For Data</title>
    <figcount>1</figcount>
    <section>
      <title>Base Types</title>
      <figcount>0</figcount>
    </section>
    <section>
      <title>Representing Relational Databases</title>
      <figcount>1</figcount>
    </section>
    <section>
      <title>Representing Object Databases</title>
      <figcount>0</figcount>
    </section>
  </section>
</toc>
</etalon>
</case>

<case id="1.3.4.1">
<descr>
In the Procedure section of Report1, what Instruments were used in the second
Incision? </descr>
<xquery><![CDATA[
  for $s in document("report1.xml")//section[section.title = "Procedure"]
return $s//incision[2]/instrument

]]></xquery>
<etalon>
<instrument>electrocautery</instrument>
</etalon>
</case>

<case id="1.3.4.2">
<descr>
In the Procedure section of Report1, what are the first two Instruments to be
used? </descr>
<xquery><![CDATA[
for $s in document("report1.xml")//section[section.title = "Procedure"]
return ($s//instrument)[1 to 2]
]]></xquery>
<etalon>
<instrument>using electrocautery.</instrument>
<instrument>electrocautery</instrument>
</etalon>
</case>

<case id="1.3.4.3">
<descr>
In Report1, what Instruments were used in the first two Actions after the
second Incision? </descr>
<xquery><![CDATA[
let $i2 := (document("report1.xml")//incision)[2]
for $a in (document("report1.xml")//action after $i2)[1 to 2]
return $a//instrument
]]></xquery>
<etalon>
<instrument>Hasson trocar</instrument>
<instrument>trocar</instrument>
</etalon>
</case>

<case id="1.3.4.4">
<descr>
In Report1, find "Procedure" sections where no Anesthesia element occurs
before the first Incision</descr>
<xquery><![CDATA[
for $proc in document("report1.xml")//section[section.title="Procedure"]
where every $a in $proc//anesthesia satisfies $a after $proc//incision[1]
return $proc
]]></xquery>
<etalon>
</etalon>
</case>

<case id="1.3.4.5">
<descr>
In Report1, what happened between the first Incision and the second Incision?
</descr>
<xquery><![CDATA[
for $proc in document("report1.xml")//section[section.title="Procedure"],
    $bet  in $proc//* after ($proc//incision)[1] before ($proc//incision)[2]
return $bet
]]></xquery>
<etalon>
<action>#2 0 Maxon stay sutures were placed on each side of the midline.</action>
</etalon>
</case>

<case id="1.4.4.1">
<descr>
List the item number and description of all bicycles that currently have an
auction in progress, ordered by item number.</descr>
<xquery><![CDATA[
<result>
{
   for   $i in document("items.xml")//item_tuple
   where $i/start_date <= '1999-02-15'
     and $i/end_date >= '1999-02-15'
     and contains($i/description, "Bicycle")
   return
      <item_tuple>
	{
	 $i/itemno,
	 $i/description
	}
      </item_tuple> sortby (itemno)
}
</result>
]]></xquery>
<etalon>
<result>
  <item_tuple>
    <itemno>1003</itemno>
    <description>Old Bicycle</description>
  </item_tuple>
  <item_tuple>
    <itemno>1007</itemno>
    <description>Racing Bicycle</description>
  </item_tuple>
  <item_tuple>
    <itemno>1008</itemno>
    <description>Broken Bicycle</description>
  </item_tuple>
</result>
</etalon>
</case>

<case id="1.4.4.2">
<descr>
for all bicycles, list the item number, description, and highest bid (if
any), ordered by item number.</descr>
<xquery><![CDATA[
<result>
{
   for $i in document("items.xml")//item_tuple
   let $b := document("bids.xml")//bid_tuple[itemno = $i/itemno]
   where contains($i/description, "Bicycle")
   return
      <item_tuple>
	 { $i/itemno ,
	 $i/description ,
	 if (not(empty($b/bid)))
	 then
	   <high_bid> { max($b/bid) } </high_bid>
	 else
	   <no_bids/>
	 }
      </item_tuple> sortby (itemno)
}
</result>
]]></xquery>
<etalon>
<result>
  <item_tuple>
    <itemno>1001</itemno>
    <description>Red Bicycle</description>
    <high_bid>55</high_bid>
  </item_tuple>
  <item_tuple>
    <itemno>1003</itemno>
    <description>Old Bicycle</description>
    <high_bid>20</high_bid>
  </item_tuple>
  <item_tuple>
    <itemno>1007</itemno>
    <description>Racing Bicycle</description>
    <high_bid>225</high_bid>
  </item_tuple>
  <item_tuple>
    <itemno>1008</itemno>
    <description>Broken Bicycle</description>
    <no_bids />
  </item_tuple>
</result>
</etalon>
</case>

<case id="1.4.4.3">
<descr>
Find cases where a user with a rating worse (alphabetically, greater) than
"C" is offering an item with a reserve price of more than 1000.</descr>
<xquery><![CDATA[
<result>
{
   for $u in document("users.xml")//user_tuple,
       $i in document("items.xml")//item_tuple
   where $u/rating > "C"
     and $i/reserve_price > 1000
     and $i/offered_by = $u/userid
   return
      <warning>
	 {$u/name}
	 {$u/rating}
	 {$i/description}
	 {$i/reserve_price}
      </warning>
}
</result>
]]></xquery>
<etalon>
<result>
  <warning>
    <name>Dee Linquent</name>
    <rating>D</rating>
    <description>Helicopter</description>
    <reserve_price>50000</reserve_price>
  </warning>
</result>
</etalon>
</case>

<case id="1.4.4.4">
<descr>
List item numbers and descriptions of items that have no bids.</descr>
<xquery><![CDATA[
<result>
{
   for $i in document("items.xml")//item_tuple
   where not (
      some $b in document("bids.xml")//bid_tuple
	 satisfies $b/itemno = $i/itemno )
   return
      <no_bid_item>
	 {$i/itemno}
	 {$i/description}
      </no_bid_item>
}
</result>
]]></xquery>
<etalon>
<result>
  <no_bid_item>
    <itemno>1005</itemno>
    <description>Tennis Racket</description>
  </no_bid_item>
  <no_bid_item>
    <itemno>1006</itemno>
    <description>Helicopter</description>
  </no_bid_item>
  <no_bid_item>
    <itemno>1008</itemno>
    <description>Broken Bicycle</description>
  </no_bid_item>
</result>
</etalon>
</case>

<case id="1.4.4.5">
<descr>
for bicycle(s) offered by Tom Jones, list the item number, description,
highest bid (if any), and name of the highest bidder, ordered by item
number.</descr>
<xquery><![CDATA[
<result>
{
   for $seller  in document("users.xml")//user_tuple,
       $buyer   in document("users.xml")//user_tuple,
       $item    in document("items.xml")//item_tuple,
       $highbid in document("bids.xml")//bid_tuple
   where $seller/name = "Tom Jones"
     and $seller/userid = $item/offered_by
     and contains($item/description, "Bicycle")
     and $item/itemno = $highbid/itemno
     and $highbid/userid = $buyer/userid
     and $highbid/bid =
	   max(document("bids.xml")//bid_tuple
			    [itemno = $item/itemno]/bid)
   return
      <jones_bike>
	 {$item/itemno}
	 {$item/description}
	 <high_bid> {string($highbid/bid)} </high_bid>
	 <high_bidder> {string($buyer/name)} </high_bidder>
      </jones_bike> sortby (itemno)
}
</result>
]]></xquery>
<etalon>
<result>
  <jones_bike>
    <itemno>1001</itemno>
    <description>Red Bicycle</description>
    <high_bid>55</high_bid>
    <high_bidder>Mary Doe</high_bidder>
  </jones_bike>
</result>
</etalon>
</case>

<case id="1.4.4.6">
<descr>
for each item whose highest bid is more than twice its reserve price, list
the item number, description, reserve price, and highest bid.</descr>
<xquery><![CDATA[
<result>
{
   for $item in document("items.xml")//item_tuple
   let $b := document("bids.xml")//bid_tuple
		   [itemno = $item/itemno]
   where (not (empty($b))) and number($item/reserve_price) * 2 < max($b/bid)
   return
      <successful_item>
	 {$item/itemno}
	 {$item/description}
	 {$item/reserve_price}
	 <high_bid> {max($b/bid)} </high_bid>
      </successful_item>
}
</result>
]]></xquery>
<etalon>
<result>
  <successful_item>
    <itemno>1002</itemno>
    <description>Motorcycle</description>
    <reserve_price>500</reserve_price>
    <high_bid>1200</high_bid>
  </successful_item>
  <successful_item>
    <itemno>1004</itemno>
    <description>Tricycle</description>
    <reserve_price>15</reserve_price>
    <high_bid>40</high_bid>
  </successful_item>
</result>
</etalon>
</case>

<case id="1.4.4.7">
<descr>
Find the highest bid ever made for a bicycle or tricycle.</descr>
<xquery><![CDATA[
let $allbikes := document("items.xml")//item_tuple
		   [ contains(description, "Bicycle")
		     or contains(description, "Tricycle") ],
    $bikebids := document("bids.xml")//bid_tuple
		   [ itemno = $allbikes/itemno ]
return
  <high_bid>
     {max($bikebids/bid)}
  </high_bid>
]]></xquery>
<etalon>
<high_bid>225</high_bid>
</etalon>
</case>

<case id="1.4.4.8">
<descr>
How many items were actioned (auction ended) in March 1999?</descr>
<xquery><![CDATA[
let $item := document("items.xml")//item_tuple
       [xf:date(end_date) >= xf:date("1999-03-01")
	and xf:date(end_date) <= xf:date("1999-03-31")]
return
   <item_count>
      {count($item)}
   </item_count>
]]></xquery>
<etalon>
<item_count>3</item_count>
</etalon>
</case>

<case id="1.4.4.9">
<descr>
List the number of items auctioned each month in 1999 for which data is
available, ordered by month.
(Note that we are using xf:... functions because the standard month() and date() functions are not defined.)</descr>
<xquery><![CDATA[
<result>
{
   let $end_dates := document("items.xml")//item_tuple/end_date
      for $m in distinct( xf:get-months(xf:date($end_dates)) )
      let $item := document("items.xml")
	     //item_tuple[
		xf:get-years(xf:date(end_date)) = 1999 and
		xf:get-months(xf:date(end_date)) = $m]
      return
	 <monthly_result>
	    <month> {$m} </month>
	    <item_count> {count($item)} </item_count>
	 </monthly_result> sortby (month)
}
</result>
]]></xquery>
<etalon>
<result>
  <monthly_result>
    <month>1</month>
    <item_count>1</item_count>
  </monthly_result>
  <monthly_result>
    <month>2</month>
    <item_count>2</item_count>
  </monthly_result>
  <monthly_result>
    <month>3</month>
    <item_count>3</item_count>
  </monthly_result>
  <monthly_result>
    <month>4</month>
    <item_count>1</item_count>
  </monthly_result>
  <monthly_result>
    <month>5</month>
    <item_count>1</item_count>
  </monthly_result>
</result>
</etalon>
</case>

<case id="1.4.4.10">
<descr>
for each item that has received a bid, list the item number, the highest bid,
and the name of the highest bidder, ordered by item number.</descr>
<xquery><![CDATA[
<result>
{
   for $highbid in document("bids.xml")//bid_tuple,
       $user in document("users.xml")//user_tuple
   where $user/userid = $highbid/userid
     and $highbid/bid =
	    max(document("bids.xml")//bid_tuple
		   [itemno = $highbid/itemno]/bid)
   return
     <high_bid>
	{ $highbid/itemno }
	{ $highbid/bid }
	<bidder> { $user/name/text() } </bidder>
     </high_bid> sortby (itemno)
}
</result>
]]></xquery>
<etalon>
<result>
  <high_bid>
    <itemno>1001</itemno>
    <bid>55</bid>
    <bidder>Mary Doe</bidder>
  </high_bid>
  <high_bid>
    <itemno>1002</itemno>
    <bid>1200</bid>
    <bidder>Mary Doe</bidder>
  </high_bid>
  <high_bid>
    <itemno>1003</itemno>
    <bid>20</bid>
    <bidder>Jack Sprat</bidder>
  </high_bid>
  <high_bid>
    <itemno>1004</itemno>
    <bid>40</bid>
    <bidder>Tom Jones</bidder>
  </high_bid>
  <high_bid>
    <itemno>1007</itemno>
    <bid>225</bid>
    <bidder>Roger Smith</bidder>
  </high_bid>
</result>
</etalon>
</case>

<case id="1.4.4.11">
<descr>
List the item number and description of the item(s) that received the highest
bid ever recorded, and the amount of that bid.</descr>
<xquery><![CDATA[
let $highbid := max(document("bids.xml")//bid_tuple/bid)
return
<result>
{
   for $item in document("items.xml")//item_tuple,
       $b in document("bids.xml")//bid_tuple[itemno = $item/itemno]
   where $b/bid = $highbid
   return
      <expensive_item>
	 { $item/itemno }
	 { $item/description }
	 <high_bid> { $highbid } </high_bid>
      </expensive_item>
}
</result>
]]></xquery>
<etalon>
<result>
  <expensive_item>
    <itemno>1002</itemno>
    <description>Motorcycle</description>
    <high_bid>1200</high_bid>
  </expensive_item>
</result>
</etalon>
</case>

<case id="1.4.4.12">
<descr>
List the item number and description of the item(s) that received the largest
number of bids, and the number of bids it (or they) received.</descr>
<xquery><![CDATA[
define function bid_summary() (: returns list(element) :)
   {
   for $i in distinct( document("bids.xml")//itemno ) sortby (.)
   let $b := document("bids.xml")//bid_tuple[itemno = $i]
   return
      <bid_count>
	 { $i }
	 <nbids>{ count($b) }</nbids>
      </bid_count>
   } ;
<result>
{
   for $item in document("items.xml")//item_tuple,
       $bc   in bid_summary()[itemno = $item/itemno]
   where $bc/nbids = max(bid_summary()//nbids)
   return
      <popular_item>
	 { $item/itemno }
	 { $item/description }
	 <bid_count>{ $bc/nbids/text() }</bid_count>
      </popular_item>
}
</result>
]]></xquery>
<etalon>
<result>
  <popular_item>
    <itemno>1001</itemno>
    <description>Red Bicycle</description>
    <bid_count>5</bid_count>
  </popular_item>
  <popular_item>
    <itemno>1002</itemno>
    <description>Motorcycle</description>
    <bid_count>5</bid_count>
  </popular_item>
</result>
</etalon>
</case>

<case id="1.4.4.12a">
<descr>
For every item return its item number
and the number of bids it received.</descr>
<xquery><![CDATA[
define function bid_summary() (: returns list(element) :)
   {
   for $i in distinct( document("bids.xml")//itemno ) sortby (.)
   let $b := document("bids.xml")//bid_tuple[itemno = $i]
   return
      <bid_count>
	 { $i }
	 <nbids> { count($b) } </nbids>
      </bid_count>
   } ;
<result>
{
   for $item in document("items.xml")//item_tuple
   return bid_summary()[itemno = $item/itemno]
}
</result>
]]></xquery>
<etalon>
<result>
  <bid_count>
    <itemno>1001</itemno>
    <nbids>5 </nbids>
  </bid_count>
  <bid_count>
    <itemno>1002</itemno>
    <nbids>5 </nbids>
  </bid_count>
  <bid_count>
    <itemno>1003</itemno>
    <nbids>2 </nbids>
  </bid_count>
  <bid_count>
    <itemno>1004</itemno>
    <nbids>1 </nbids>
  </bid_count>
  <bid_count>
    <itemno>1007</itemno>
    <nbids>3 </nbids>
  </bid_count>
</result>
</etalon>
</case>

<case id="1.4.4.13">
<descr>
for each user who has placed a bid, give the userid, name, number of bids,
and average bid, in order by userid.</descr>
<xquery><![CDATA[
<result>
{
   for $uid in distinct( document("bids.xml")//userid ) sortby (.),
       $u in document("users.xml")//user_tuple[userid = $uid]
   let $b := document("bids.xml")//bid_tuple[userid = $uid]
   return
      <bidder>
	 { $u/userid }
	 { $u/name }
	 <bidcount> { count($b) } </bidcount>
	 <avgbid> { avg($b/bid) } </avgbid>
      </bidder> sortby (userid)
}
</result>
]]></xquery>
<etalon>
<result>
  <bidder>
    <userid>U01</userid>
    <name>Tom Jones</name>
    <bidcount>2</bidcount>
    <avgbid>220</avgbid>
  </bidder>
  <bidder>
    <userid>U02</userid>
    <name>Mary Doe</name>
    <bidcount>5</bidcount>
    <avgbid>387</avgbid>
  </bidder>
  <bidder>
    <userid>U03</userid>
    <name>Dee Linquent</name>
    <bidcount>2</bidcount>
    <avgbid>487</avgbid>
  </bidder>
  <bidder>
    <userid>U04</userid>
    <name>Roger Smith</name>
    <bidcount>5</bidcount>
    <avgbid>266</avgbid>
  </bidder>
  <bidder>
    <userid>U05</userid>
    <name>Jack Sprat</name>
    <bidcount>2</bidcount>
    <avgbid>110</avgbid>
  </bidder>
</result>
</etalon>
</case>

<case id="1.4.4.14">
<descr>
List item numbers and average bids for items that have received three or more
bids, in descending order by average bid.</descr>
<xquery><![CDATA[
<result>
{
   for $i in distinct( document("bids.xml")//itemno ) sortby (.)
   let $b := document("bids.xml")//bid_tuple[itemno = $i]
   where count($b) >= 3
   return
      <popular_item>
	 { $i }
	 <avgbid> { avg($b/bid) } </avgbid>
      </popular_item> sortby (avgbid descending)
}
</result>
]]></xquery>
<etalon>
<result>
  <popular_item>
    <itemno>1002</itemno>
    <avgbid>800</avgbid>
  </popular_item>
  <popular_item>
    <itemno>1001</itemno>
    <avgbid>45</avgbid>
  </popular_item>
  <popular_item>
    <itemno>1007</itemno>
    <avgbid>200</avgbid>
  </popular_item>
</result>
</etalon>
</case>

<case id="1.4.4.15">
<descr>
List names of users who have placed multiple bids of at least $100 each.</descr>
<xquery><![CDATA[
<result>
{
   for $u in document("users.xml")//user_tuple
   let $b := document("bids.xml")//bid_tuple
		[userid = $u/userid and bid >= 100]
   where count($b) > 1
   return <big_spender> {$u/name/text()} </big_spender>
}
</result>
]]></xquery>
<etalon>
<result>
  <big_spender>Mary Doe</big_spender>
  <big_spender>Dee Linquent</big_spender>
  <big_spender>Roger Smith</big_spender>
</result>
</etalon>
</case>

<case id="1.4.4.16">
<descr>
List all registered users in order by userid; for each user, include the
userid, name, and an indication of whether the user is active (has at least one
bid on record) or inactive (has no bid on record).</descr>
<xquery><![CDATA[
<result>
{
   for $u in document("users.xml")//user_tuple
   let $b := document("bids.xml")//bid_tuple[userid = $u/userid]
   return
      <user>
	 {$u/userid}
	 {$u/name}
	 {
	   if (empty($b)) then <status> {"inactive"} </status>
	     else <status> {"active"} </status>
         }
      </user> sortby (userid)
}
</result>
]]></xquery>
<etalon>
<result>
   <user>
      <userid>U01</userid>
      <name>Tom Jones</name>
      <status>active</status>
   </user>
   <user>
      <userid>U02</userid>
      <name>Mary Doe</name>
      <status>active</status>
   </user>
   <user>
      <userid>U03</userid>
      <name>Dee Linquent</name>
      <status>active</status>
   </user>
   <user>
      <userid>U04</userid>
      <name>Roger Smith</name>
      <status>active</status>
   </user>
   <user>
      <userid>U05</userid>
      <name>Jack Sprat</name>
      <status>active</status>
   </user>
   <user>
      <userid>U06</userid>
      <name>Rip Van Winkle</name>
      <status>inactive</status>
   </user>
</result>
</etalon>
</case>

<case id="1.4.4.17">
<descr>
List the names of users, if any, who have bid on every item.</descr>
<xquery><![CDATA[
<frequent_bidder>
{
   for $u in document("users.xml")//user_tuple
   where
      every $item in document("items.xml")//item_tuple satisfies
	 some $b in document("bids.xml")//bid_tuple satisfies
	    ($item/itemno = $b/itemno and $u/userid = $b/userid)
   return
      $u/name
}
</frequent_bidder>
]]></xquery>
<etalon>
<frequent_bidder />
</etalon>
</case>

<case id="1.4.4.18">
<descr>
List all users in alphabetic order by name. for each user, include
descriptions of all the items (if any) that were bid on by that user, in
alphabetic order. </descr>
<xquery><![CDATA[
<result>
{
   for $u in document("users.xml")//user_tuple
   return
      <user>
	 {$u/name}
	 {
	 for $b in distinct (document("bids.xml")//bid_tuple[userid = $u/userid]/itemno),
	     $i in document("items.xml")//item_tuple[itemno = $b]
	 return
	    <bid_on_item>
	       {$i/description/text()}
	    </bid_on_item> sortby (.)
         }
      </user> sortby (name)
}
</result>
]]></xquery>
<etalon>
<result>
   <user>
      <name>Dee Linquent</name>
      <bid_on_item>Motorcycle</bid_on_item>
      <bid_on_item>Racing Bicycle</bid_on_item>
   </user>
   <user>
      <name>Jack Sprat</name>
      <bid_on_item>Old Bicycle</bid_on_item>
      <bid_on_item>Racing Bicycle</bid_on_item>
   </user>
   <user>
      <name>Mary Doe</name>
      <bid_on_item>Motorcycle</bid_on_item>
      <bid_on_item>Red Bicycle</bid_on_item>
   </user>
   <user>
      <name>Rip Van Winkle</name>
   </user>
   <user>
      <name>Roger Smith</name>
      <bid_on_item>Motorcycle</bid_on_item>
      <bid_on_item>Old Bicycle</bid_on_item>
      <bid_on_item>Racing Bicycle</bid_on_item>
      <bid_on_item>Red Bicycle</bid_on_item>
   </user>
   <user>
      <name>Tom Jones</name>
      <bid_on_item>Motorcycle</bid_on_item>
      <bid_on_item>Tricycle</bid_on_item>
   </user>
</result>
</etalon>
</case>

<case id="1.5.4.1">
<descr>
Locate all paragraphs in the report (all "para" elements occurring anywhere
within the "report" element).</descr>
<xquery><![CDATA[
<result>
{document("sgml_intro.xml")//report//para}
</result>
]]></xquery>
<etalon>
<result>
  <para>With the ever-changing and growing global market, companies and
<!-- 7-->large organizations are searching for ways to become more viable and
<!-- 8-->competitive. Downsizing and other cost-cutting measures demand more
<!-- 9-->efficient use of corporate resources. One very important resource is
<!--10-->an organization's information.</para>
  <para>As part of the move toward integrated information management,
<!--12-->whole industries are developing and implementing standards for
<!--13-->exchanging technical information. This report describes how one such
<!--14-->standard, the Standard Generalized Markup Language (SGML), works as
<!--15-->part of an overall information management strategy.</para>
  <para>While SGML is a fairly recent technology, the use of
<!--21-->
    <emph>markup</emph>in computer-generated documents has existed for a
<!--22-->while.</para>
  <para>Markup is everything in a document that is not content. The
<!--28-->traditional meaning of markup is the manual <emph>marking</emph>up
<!--29-->of typewritten text to give instructions for a typesetter or
<!--30-->compositor about how to fit the text on a page and what typefaces to
<!--31-->use. This kind of markup is known as <emph>procedural markup</emph>.</para>
  <para>Most electronic publishing systems today use some form of
<!--35-->procedural markup. Procedural markup codes are good for one
<!--36-->presentation of the information.</para>
  <para>Generic markup (also known as descriptive markup) describes the
<!--40-->
    <emph>purpose</emph>of the text in a document. A basic concept of
<!--41-->generic markup is that the content of a document must be separate from
<!--42-->the style. Generic markup allows for multiple presentations of the
<!--43-->information.</para>
  <para>Industries involved in technical documentation increasingly
<!--47-->prefer generic over procedural markup schemes. When a company changes
<!--48-->software or hardware systems, enormous data translation tasks arise,
<!--49-->often resulting in errors.</para>
  <para>SGML defines a strict markup scheme with a syntax for defining
<!--54-->document data elements and an overall framework for marking up
<!--55-->documents.</para>
  <para>SGML can describe and create documents that are not dependent on
<!--57-->any hardware, software, formatter, or operating system. Since SGML documents
<!--58-->conform to an international standard, they are portable.</para>
  <para>You can break a typical document into three layers: structure,
<!--63-->content, and style. SGML works by separating these three aspects and
<!--64-->deals mainly with the relationship between structure and content.</para>
  <para>At the heart of an SGML application is a file called the DTD, or
<!--68-->Document Type Definition. The DTD sets up the structure of a document,
<!--69-->much like a database schema describes the types of information it
<!--70-->handles.</para>
  <para>A database schema also defines the relationships between the
<!--72-->various types of data. Similarly, a DTD specifies <emph>rules</emph>
<!--73-->to help ensure documents have a consistent, logical structure.</para>
  <para>Content is the information itself. The method for identifying
<!--77-->the information and its meaning within this framework is called
<!--78-->
    <emph>tagging</emph>. Tagging must
<!--79-->conform to the rules established in the DTD (see <xref xrefid="top4" />).</para>
  <para>SGML does not standardize style or other processing methods for
<!--84-->information stored in SGML.</para>
  <para>The Graphic Communications Association has been
<!--91-->instrumental in the development of SGML. GCA provides conferences,
<!--92-->tutorials, newsletters, and publication sales for both members and
<!--93-->non-members.</para>
  <para security="c">Exiled members of the former Soviet Union's secret
<!--95-->police, the KGB, have infiltrated the upper ranks of the GCA and are
<!--96-->planning the Final Revolution as soon as DSSSL is completed.</para>
</result>
</etalon>
</case>

<case id="1.5.4.2">
<descr>
Locate all paragraph elements in an introduction (all "para" elements
directly contained within an "intro" element). </descr>
<xquery><![CDATA[
<result>
{document("sgml_intro.xml")//intro/para}
</result>
]]></xquery>
<etalon>
<result>
  <para>With the ever-changing and growing global market, companies and 
<!-- 7-->large organizations are searching for ways to become more viable and 
<!-- 8-->competitive. Downsizing and other cost-cutting measures demand more 
<!-- 9-->efficient use of corporate resources. One very important resource is 
<!--10-->an organization's information.</para>
  <para>As part of the move toward integrated information management, 
<!--12-->whole industries are developing and implementing standards for 
<!--13-->exchanging technical information. This report describes how one such 
<!--14-->standard, the Standard Generalized Markup Language (SGML), works as 
<!--15-->part of an overall information management strategy.</para>
  <para>While SGML is a fairly recent technology, the use of 
<!--21-->
    <emph>markup</emph>in computer-generated documents has existed for a 
<!--22-->while.</para>
  <para>Markup is everything in a document that is not content. The 
<!--28-->traditional meaning of markup is the manual <emph>marking</emph>up 
<!--29-->of typewritten text to give instructions for a typesetter or 
<!--30-->compositor about how to fit the text on a page and what typefaces to 
<!--31-->use. This kind of markup is known as <emph>procedural markup</emph>.</para>
  <para>SGML defines a strict markup scheme with a syntax for defining 
<!--54-->document data elements and an overall framework for marking up 
<!--55-->documents.</para>
  <para>SGML can describe and create documents that are not dependent on 
<!--57-->any hardware, software, formatter, or operating system. Since SGML documents 
<!--58-->conform to an international standard, they are portable.</para>
  <para>You can break a typical document into three layers: structure, 
<!--63-->content, and style. SGML works by separating these three aspects and 
<!--64-->deals mainly with the relationship between structure and content.</para>
  <para>The Graphic Communications Association has been 
<!--91-->instrumental in the development of SGML. GCA provides conferences, 
<!--92-->tutorials, newsletters, and publication sales for both members and 
<!--93-->non-members.</para>
  <para security="c">Exiled members of the former Soviet Union's secret 
<!--95-->police, the KGB, have infiltrated the upper ranks of the GCA and are 
<!--96-->planning the Final Revolution as soon as DSSSL is completed.</para>
</result>
</etalon>
</case>

<case id="1.5.4.3">
<descr>
Locate all paragraphs in the introduction of a section that is in a chapter
that has no introduction (all "para" elements directly contained within an
"intro" element directly contained in a "section" element directly contained in
a "chapter" element. The "chapter" element must not directly contain an "intro"
element). </descr>
<xquery><![CDATA[
<result>
{
   for $c in document("sgml_intro.xml")//chapter
   where empty($c/intro)
   return $c/section/intro/para
}
</result>
]]></xquery>
<etalon>
<result>
  <para>The Graphic Communications Association has been 
<!--91-->instrumental in the development of SGML. GCA provides conferences, 
<!--92-->tutorials, newsletters, and publication sales for both members and 
<!--93-->non-members.</para>
  <para security="c">Exiled members of the former Soviet Union's secret 
<!--95-->police, the KGB, have infiltrated the upper ranks of the GCA and are 
<!--96-->planning the Final Revolution as soon as DSSSL is completed.</para>
</result>
</etalon>
</case>

<case id="1.5.4.4">
<descr>
Locate the second paragraph in the third section in the second chapter (the
second "para" element occurring in the third "section" element occurring in the
second "chapter" element occurring in the "report"). </descr>
<xquery><![CDATA[
<result>
{
   (((document("sgml_intro.xml")//chapter)[2]//section)[3]//para)[2]
}
</result>
]]></xquery>
<etalon>
<result>
  <para>At the heart of an SGML application is a file called the DTD, or
<!--68-->Document Type Definition. The DTD sets up the structure of a document,
<!--69-->much like a database schema describes the types of information it
<!--70-->handles.</para>
</result>
</etalon>
</case>

<case id="1.5.4.4a">
<descr>
This is an incorrect solution for the previous use case.
</descr>
<xquery><![CDATA[
<result>
{
   document("sgml_intro.xml")//chapter[2]//section[3]//para[2]
}
</result>
]]></xquery>
<etalon>
<result><para>A database schema also defines the relationships between the
<!--72--> various types of data. Similarly, a DTD specifies <emph>rules</emph>
<!--73--> to help ensure documents have a consistent, logical structure.</para></result>
</etalon>
</case>

<case id="1.5.4.5">
<descr>
Locate all classified paragraphs (all "para" elements whose "security"
attribute has the value "c").</descr>
<xquery><![CDATA[
<result>
{
  document("sgml_intro.xml")//para[@security = "c"]
}
</result>
]]></xquery>
<etalon>
<result>
  <para security="c">Exiled members of the former Soviet Union's secret 
<!--95-->police, the KGB, have infiltrated the upper ranks of the GCA and are 
<!--96-->planning the Final Revolution as soon as DSSSL is completed.</para>
</result>
</etalon>
</case>

<case id="1.5.4.6">
<descr>
List the short titles of all sections (the values of the "shorttitle"
attributes of all "section" elements, expressing each short title as the value
of a new element.) </descr>
<xquery><![CDATA[
<result>
{
   for $s in document("sgml_intro.xml")//section/@shorttitle
   return <stitle> {$s} </stitle>
}
</result>
]]></xquery>
<etalon>
<result>
  <stitle shorttitle="What is markup?" />
  <stitle shorttitle="What is SGML?" />
  <stitle shorttitle="How does SGML work?" />
</result>
</etalon>
</case>

<case id="1.5.4.7">
<descr>
Locate the initial letter of the initial paragraph of all introductions (the
first character in the content [character content as well as element content] of
the first "para" element contained in an "intro" element). </descr>
<xquery><![CDATA[
<result>
{
   for $i in document("sgml_intro.xml")//intro/para[1]
   return
      <letter>
	 {substring(string($i),1,1)}
      </letter>
}
</result>
]]></xquery>
<etalon>
<result>
  <letter>W</letter>
  <letter>W</letter>
  <letter>M</letter>
  <letter>S</letter>
  <letter>Y</letter>
  <letter>T</letter>
</result>
</etalon>
</case>

<case id="1.5.4.8">
<descr>
Locate all sections with a title that has "is SGML" in it (all "section"
elements that contain a "title" element that has the consecutive characters "is
SGML" in its content). The string can be interrupted by sub-elements. </descr>
<xquery><![CDATA[
<result>
{document("sgml_intro.xml")//section[contains(string(.//title), "is SGML")]}
</result>
]]></xquery>
<etalon>
<result>
  <section shorttitle="What is SGML?">
<!--51-->
    <title>What <emph>is</emph>SGML in the grand scheme of the universe, anyway?</title>
<!--52-->
    <intro>
<!--53-->
      <para>SGML defines a strict markup scheme with a syntax for defining 
<!--54-->document data elements and an overall framework for marking up 
<!--55-->documents.</para>
<!--56-->
      <para>SGML can describe and create documents that are not dependent on 
<!--57-->any hardware, software, formatter, or operating system. Since SGML documents 
<!--58-->conform to an international standard, they are portable.</para>
    </intro>
  </section>
  <section shorttitle="How does SGML work?">
<!--60-->
    <title>How is SGML and would you recommend it to your grandmother?</title>
<!--61-->
    <intro>
<!--62-->
      <para>You can break a typical document into three layers: structure, 
<!--63-->content, and style. SGML works by separating these three aspects and 
<!--64-->deals mainly with the relationship between structure and content.</para>
    </intro>
<!--65-->
    <topic topicid="top4">
<!--66-->
      <title>Structure</title>
<!--67-->
      <para>At the heart of an SGML application is a file called the DTD, or 
<!--68-->Document Type Definition. The DTD sets up the structure of a document, 
<!--69-->much like a database schema describes the types of information it 
<!--70-->handles.</para>
<!--71-->
      <para>A database schema also defines the relationships between the 
<!--72-->various types of data. Similarly, a DTD specifies <emph>rules</emph>
<!--73-->to help ensure documents have a consistent, logical structure.</para>
    </topic>
<!--74-->
    <topic topicid="top5">
<!--75-->
      <title>Content</title>
<!--76-->
      <para>Content is the information itself. The method for identifying 
<!--77-->the information and its meaning within this framework is called 
<!--78-->
        <emph>tagging</emph>. Tagging must 
<!--79-->conform to the rules established in the DTD (see <xref xrefid="top4" />).</para>
<!--80-->
      <graphic graphname="tagexamp" />
    </topic>
<!--81-->
    <topic topicid="top6">
<!--82-->
      <title>Style</title>
<!--83-->
      <para>SGML does not standardize style or other processing methods for 
<!--84-->information stored in SGML.</para>
    </topic>
  </section>
</result>
</etalon>
</case>

<case id="1.5.4.9">
<descr>
Same as (Q8a), but the string cannot be interrupted by sub-elements. </descr>
<xquery><![CDATA[
<result>
{document("sgml_intro.xml")//section[contains(.//title/text(), "is SGML")]}
</result>
]]></xquery>
<etalon>
<result>
  <section shorttitle="How does SGML work?">
<!--60-->
    <title>How is SGML and would you recommend it to your grandmother?</title>
<!--61-->
    <intro>
<!--62-->
      <para>You can break a typical document into three layers: structure, 
<!--63-->content, and style. SGML works by separating these three aspects and 
<!--64-->deals mainly with the relationship between structure and content.</para>
    </intro>
<!--65-->
    <topic topicid="top4">
<!--66-->
      <title>Structure</title>
<!--67-->
      <para>At the heart of an SGML application is a file called the DTD, or 
<!--68-->Document Type Definition. The DTD sets up the structure of a document, 
<!--69-->much like a database schema describes the types of information it 
<!--70-->handles.</para>
<!--71-->
      <para>A database schema also defines the relationships between the 
<!--72-->various types of data. Similarly, a DTD specifies <emph>rules</emph>
<!--73-->to help ensure documents have a consistent, logical structure.</para>
    </topic>
<!--74-->
    <topic topicid="top5">
<!--75-->
      <title>Content</title>
<!--76-->
      <para>Content is the information itself. The method for identifying 
<!--77-->the information and its meaning within this framework is called 
<!--78-->
        <emph>tagging</emph>. Tagging must 
<!--79-->conform to the rules established in the DTD (see <xref xrefid="top4" />).</para>
<!--80-->
      <graphic graphname="tagexamp" />
    </topic>
<!--81-->
    <topic topicid="top6">
<!--82-->
      <title>Style</title>
<!--83-->
      <para>SGML does not standardize style or other processing methods for 
<!--84-->information stored in SGML.</para>
    </topic>
  </section>
</result>
</etalon>
</case>

<case id="1.5.4.10">
<descr>
Locate all the topics referenced by a cross-reference anywhere in the report
(all the "topic" elements whose "topicid" attribute value is the same as an
"xrefid" attribute value of any "xref" element). </descr>
<xquery><![CDATA[
<result>
{
   let $d := document("sgml_intro.xml")
   for $id in $d//xref/@xrefid
   return $d//topic[@topicid = $id]
}
</result>
]]></xquery>
<etalon>
<result>
  <topic topicid="top4">
<!--66-->
    <title>Structure</title>
<!--67-->
    <para>At the heart of an SGML application is a file called the DTD, or 
<!--68-->Document Type Definition. The DTD sets up the structure of a document, 
<!--69-->much like a database schema describes the types of information it 
<!--70-->handles.</para>
<!--71-->
    <para>A database schema also defines the relationships between the 
<!--72-->various types of data. Similarly, a DTD specifies <emph>rules</emph>
<!--73-->to help ensure documents have a consistent, logical structure.</para>
  </topic>
</result>
</etalon>
</case>

<case id="1.5.4.11">
<descr>
Locate the closest title preceding the cross-reference ("xref") element whose
"xrefid" attribute is "top4" (the "title" element that would be touched last
before this "xref" element when touching each element in document order).</descr>
<xquery><![CDATA[
<result>
{
   let $d := document("sgml_intro.xml"),
       $x := $d//xref[@xrefid = "top4"],
       $t := $d//title before $x
   return $t[last()]
}
</result>
]]></xquery>
<etalon>Given xref on line 79, element whose start-tag is on line 75</etalon>
</case>

<case id="1.5.4.11a">
<descr>
Locate all title preceding the cross-reference ("xref") element whose
"xrefid" attribute is "top4" (the "title" element that would be touched last
before this "xref" element when touching each element in document order).</descr>
<xquery><![CDATA[
<result>
{
   let $d := document("sgml_intro.xml"),
       $x := $d//xref[@xrefid = "top4"],
       $t := $d//title before $x
   return $t
}
</result>
]]></xquery>
<etalon>
<result>
  <title>Getting started with SGML</title>
  <title>The business challenge</title>
  <title>Getting to know SGML</title>
  <title>What is markup, or everything you always wanted to know about 
<!--25-->document preparation but were afraid to ask?</title>
  <title>Procedural markup</title>
  <title>Generic markup</title>
  <title>Drawbacks of procedural markup</title>
  <title>What <emph>is</emph>SGML in the grand scheme of the universe, anyway?</title>
  <title>How is SGML and would you recommend it to your grandmother?</title>
  <title>Structure</title>
  <title>Content</title>
</result>
</etalon>
</case>

<case id="1.6.4.1">
<descr>
Find all news items where the name "Foobar Corporation" appears in the title.
</descr>
<xquery><![CDATA[
document("news.xml")//news_item/title[contains(./text(), "Foobar Corporation")]
]]></xquery>
<etalon>
<title>Foobar Corporation releases its new line of Foo products today</title>
<title>Foobar Corporation is suing Gorilla Corporation for patent infringement </title>
</etalon>
</case>

<case id="1.6.4.2">
<descr>
Find news items where the Foobar Corporation and one or more of its partners
are mentioned in the same paragraph and/or title. List each news item by its
title and date. </descr>
<xquery><![CDATA[
let $c := document("company.xml"),
    $n := document("news.xml"),
    $foobar_partners := $c//company[name = "Foobar Corporation"]//partner
for $item in $n//news_item
where
   some $t in $item//title satisfies
      (contains($t/text(), "Foobar Corporation")
       and some $partner in $foobar_partners satisfies
	     contains($t/text(), $partner/text())
      )
   or some $par in $item//par satisfies
      (contains($par/text(), "Foobar Corporation")
       and some $partner in $foobar_partners satisfies
	     contains($par/text(), $partner/text())
      )
return
   <news_item>
      {$item/title}
      {$item/date}
   </news_item>
]]></xquery>
<etalon>
<news_item>
   <title>Gorilla Corporation acquires YouNameItWeIntegrateIt.com</title>
   <date>1-20-2000</date>
</news_item>
<news_item>
   <title>Foobar Corporation releases its new line of Foo products today</title>
   <date>1-20-2000</date>
</news_item>
<news_item>
   <title>Foobar Corporation is suing Gorilla Corporation for patent infringement</title>
   <date>1-20-2000</date>
</news_item>
</etalon>
</case>

<case id="1.6.4.3">
<descr>
Find titles of news items where Foobar Corporation and one or more of its
partners are mentioned in the same sentence, but none of its competitors are
mentioned in the news item. (The "." character designates the end of a
sentence.) </descr>
<xquery><![CDATA[
let $c := document("company.xml"),
    $n := document("news.xml"),
    $foobar_partners := $c//company[name = "Foobar Corporation"]//partner,
    $foobar_competitors := $c//company[name = "Foobar Corporation"]//competitor
for $item in $n//news_item
where some $partner in $foobar_partners satisfies
   contains_in_same_sentence(string($item/content),
      "Foobar Corporation", $partner/text())
and not (some $competitor in $foobar_competitors satisfies
   contains( string($item/content), $competitor/text() ) )
return $item/title
]]></xquery>
<etalon>
<title>Foobar Corporation releases its new line of Foo products today </title>
</etalon>
</case>

<case id="1.6.4.4">
<descr>
Find news items where a company and one of its partners is mentioned in the
same news item and the news item is not authored by the company itself. </descr>
<xquery><![CDATA[
let $cd := document("company.xml"),
    $nd := document("news.xml")
for $item in $nd//news_item,
    $c in $cd//company
let $partners := $c//partner
where contains( string($item), $c/name/text() )
  and some $p in $partners satisfies contains( string($item), $p/text() )
  and $item/news_agent != $c/name
return $item
]]></xquery>
<etalon>
<news_item>
   <title> Gorilla Corporation acquires YouNameItWeIntegrateIt.com </title>
   <content>
      <par>
            Today, Gorilla Corporation announced that it will purchase
          YouNameItWeIntegrateIt.com. The shares of YouNameItWeIntegrateIt.com
          dropped $3.00 as a result of this announcement.
      </par>

      <par>
            As a result of this acquisition, the CEO of YouNameItWeIntegrateIt.com
          Bill Smarts resigned. He did not announce what he will do next.
          Sources close to YouNameItWeIntegrateIt.com hint that Bill Smarts
          might be taking a position in Foobar Corporation.
      </par>

      <par>
            YouNameItWeIntegrateIt.com is a leading systems integrator that enables
          <quote>brick and mortar</quote> companies to have a presence on the web.
      </par>

   </content>
   <date>1-20-2000</date>
   <author>Mark Davis</author>
   <news_agent>News Online</news_agent>
</news_item><news_item>
   <title>Foobar Corporation is suing Gorilla Corporation for patent infringement </title>
   <content>
      <par>
           In surprising developments today, Foobar Corporation announced that
         it is suing Gorilla Corporation for patent infringement. The patents
         that were mentioned as part of the lawsuit are considered to be the
         basis of Foobar Corporation&#39;s <quote>Wireless Foo</quote> line of
            products.
      </par>
      <par>
           The tension between Foobar and Gorilla Corporations has been increasing
         ever since the Gorilla Corporation acquired more than 40 engineers who
         have left Foobar Corporation, TheAppCompany Inc. and
         YouNameItWeIntegrateIt.com over the past 3 months. The engineers who
         have left the Foobar corporation and its partners were rumored to be
         working on the next generation of server products and applications
         which will directly compete with Foobar&#39;s Foo 20.9 servers. Most of the
         engineers have relocated to Hawaii where the Gorilla Corporation&#39;s
         server development is located.
      </par>
   </content>
   <date>1-20-2000</date>
   <news_agent>Reliable News Corporation</news_agent>
</news_item>
</etalon>
</case>

<case id="1.6.4.5">
<descr>
for each news item that is relevant to the Gorilla Corporation, create an
"item summary" element. The content of the item summary is the content of the
title, date, and first paragraph of the news item, separated by periods. A news
item is relevant if the name of the company is mentioned anywhere within the
content of the news item. </descr>
<xquery><![CDATA[
for $item in document("news.xml")//news_item
where contains( string($item/content), "Gorilla Corporation" )
return
   <item_summary>
    {
      $item/title/text(),
      ". ",
      $item/date/text(),
      ". ",
      string( ($item//par)[1] )
    }
   </item_summary>
]]></xquery>
<etalon>
<item_summary>Gorilla Corporation acquires YouNameItWeIntegrateIt.com. 1-20-2000.
            Today, Gorilla Corporation announced that it will purchase
          YouNameItWeIntegrateIt.com. The shares of YouNameItWeIntegrateIt.com
          dropped $3.00 as a result of this announcement.
      </item_summary><item_summary>Foobar Corporation is suing Gorilla Corporation for patent infringement. 1-20-2000.
           In surprising developments today, Foobar Corporation announced that
         it is suing Gorilla Corporation for patent infringement. The patents
         that were mentioned as part of the lawsuit are considered to be the
         basis of Foobar Corporation&#39;s Wireless Foo line of
            products.
      </item_summary>
</etalon>
</case>

<case id="1.6.4.6">
<descr>
Find news items where two company names and some form of the word "acquire"
appear in the title or in the same sentence in one of the paragraphs. A company
name is defined as the content of a &lt;name&gt;, &lt;partner&gt;, or
&lt;competitor&gt; element within a &lt;company&gt; element. </descr>
<xquery><![CDATA[
let $c := document("company.xml"),
    $n := document("news.xml"),
    $companies := distinct( $c//company/name/text()
		      union $c//company//partner/text()
		      union $c//company//competitor/text() ) sortby (.)
for $item in $n//news_item,
    $item_title in $item/title,
    $item_para in $item//para,
    $c1 in $companies,
    $c2 in $companies
where $c1 != $c2
  and contains_stems_in_same_sentence($item_title/text(), $c1, $c2, "acquire")
   or contains_stems_in_same_sentence($item_para/text(), $c1, $c2, "acquire")
return (distinct($item) sortby (.))
]]></xquery>
<etalon>The expected results are the news item elements with the
following titles: <!--</P>-->
<!--<UL>-->
  <!--<LI>-->
  Gorilla Corporation acquires YouNameItWeIntegrateIt.com <!--</P>-->
  <!--<LI>-->
  Foobar Corporation is suing Gorilla Corporation for patent infringement
  <!--</P>--><!--</LI>--><!--</UL>-->
</etalon>
</case>

<case id="1.7.4.1">
<descr>List all unique namespaces used in all elements of the sample data.</descr>
<xquery><![CDATA[
<Q1>
{
   distinct(
     for $n in document("auction.xml")//*
     return <ns>{namespace-uri($n)}</ns>
   ) sortby (.)
}
</Q1>
]]></xquery>
<etalon>
<Q1>
  <ns>http://www.AuctionMediatorCompany.com/AuctionWatch</ns>
  <ns>http://www.AuctionMediatorCompany.com/auctioneers#anyzone</ns>
  <ns>http://www.AuctionMediatorCompany.com/auctioneers#eachbay</ns>
  <ns>http://www.musicdatabase.org/music/records</ns>
</Q1>
</etalon>
</case>

<case id="1.7.4.1a">
<descr>List all unique namespaces used in all attributes of the sample data.</descr>
<xquery><![CDATA[
<Q1>
{
   distinct(
     for $a in document("auction.xml")//*/@*
     return <ns>{namespace-uri($a)}</ns>
   ) sortby (.)
}
</Q1>
]]></xquery>
<etalon>
<Q1>
  <ns>http://www.AuctionMediatorCompany.com/AuctionWatch</ns>
  <ns>http://www.AuctionMediatorCompany.com/auctioneers#anyzone</ns>
  <ns>http://www.AuctionMediatorCompany.com/auctioneers#yabadoo</ns>
  <ns>http://www.w3.org/1999/XMLSchema-datatypes</ns>
  <ns>http://www.w3.org/1999/xlink</ns>
  <ns>xml</ns>
</Q1>
</etalon>
</case>

<case id="1.7.4.1b">
<descr>List all unique namespaces used in both elements and attributes of the sample data.</descr>
<xquery><![CDATA[
<Q1>
{
   distinct(
     for $n in document("auction.xml")//*,
       $n-or-a in ($n , $n/@*)
     return <ns>{namespace-uri($n-or-a)}</ns>
   ) sortby (.)
}
</Q1>
]]></xquery>
<etalon>
<Q1>
  <ns>http://www.AuctionMediatorCompany.com/AuctionWatch</ns>
  <ns>http://www.AuctionMediatorCompany.com/auctioneers#anyzone</ns>
  <ns>http://www.AuctionMediatorCompany.com/auctioneers#eachbay</ns>
  <ns>http://www.AuctionMediatorCompany.com/auctioneers#yabadoo</ns>
  <ns>http://www.musicdatabase.org/music/records</ns>
  <ns>http://www.w3.org/1999/XMLSchema-datatypes</ns>
  <ns>http://www.w3.org/1999/xlink</ns>
  <ns>xml</ns>
</Q1>
</etalon>
</case>

<case id="1.7.4.2">
<descr>
Select the title of each record that is for sale.</descr>
<xquery><![CDATA[
declare namespace music = "http://www.musicdatabase.org/music/records";
<Q2>{document("auction.xml")//music:title}</Q2>
]]></xquery>
<etalon>
<Q2>
  <n0:title xmlns:n0="http://www.musicdatabase.org/music/records">In a Silent Way</n0:title>
  <n0:title xmlns:n0="http://www.musicdatabase.org/music/records">Think of One ...</n0:title>
</Q2>
</etalon>
</case>

<case id="1.7.4.3">
<descr>
Select all elements using datatypes from "XML Schema: Part 2" datatypes.</descr>
<xquery><![CDATA[
declare namespace dt = "http://www.w3.org/1999/XMLSchema-datatypes";
<Q3>{document("auction.xml")//*[@dt:*]}</Q3>
]]></xquery>
<etalon>
<Q3 xmlns:dt="http://www.w3.org/1999/XMLSchema-datatypes"
	xmlns:ma="http://www.AuctionMediatorCompany.com/AuctionWatch"
>
  <ma:Open dt:type="timeInstant">2000-03-21:07:41:34-05:00</ma:Open>
  <ma:Close dt:type="timeInstant">2000-03-23:07:41:34-05:00</ma:Close>
  <ma:Open dt:type="timeInstant">2000-03-19:17:03:00-04:00</ma:Open>
  <ma:Close dt:type="timeInstant">2000-03-29:17:03:00-04:00</ma:Close>
</Q3>
</etalon>
</case>

<case id="1.7.4.4">
<descr>
List the target URI's of all XLinks in the document.</descr>
<xquery><![CDATA[
declare namespace xlink = "http://www.w3.org/1999/xlink";
<Q4>
{
   for $hr in document("auction.xml")//@xlink:href
   return <link>{$hr}</link>
}
</Q4>
]]></xquery>
<etalon>
<Q4>
  <link>http://auction.anyzone.com/item/0321K372910</link>
  <link>http://auction.eachbay.com/members?get=RecordsRUs</link>
  <link>http://auction.anyzone.com/members/VintageRecordFreak</link>
  <link>http://auctions.yabadoo.com/auction/13143816</link>
  <link>http://auction.eachbay.com/showRating/user=VintageRecordFreak</link>
  <link>http://auction.eachbay.com/showRating/user=StarsOn45</link>
</Q4>
</etalon>
</case>

<case id="1.7.4.4a">
<descr>
List the target URI's of all XLinks in the document.</descr>
<xquery><![CDATA[
declare namespace xlink = "http://www.w3.org/1999/xlink";
<Q4>
{
   for $hr in document("auction.xml")//*/@xlink:href
   return <link>{string($hr)}</link>
}
</Q4>
]]></xquery>
<etalon>
<Q4>
  <link>http://auction.anyzone.com/item/0321K372910</link>
  <link>http://auction.eachbay.com/members?get=RecordsRUs</link>
  <link>http://auction.anyzone.com/members/VintageRecordFreak</link>
  <link>http://auctions.yabadoo.com/auction/13143816</link>
  <link>http://auction.eachbay.com/showRating/user=VintageRecordFreak</link>
  <link>http://auction.eachbay.com/showRating/user=StarsOn45</link>
</Q4>
</etalon>
</case>

<case id="1.7.4.5">
<descr>
Select all records that have a remark in German.</descr>
<xquery><![CDATA[
declare namespace music = "http://www.musicdatabase.org/music/records";
<Q5>{document("auction.xml")//music:record[music:remark/@xml:lang = "de"]}</Q5>
]]></xquery>
<etalon>
<Q5 xmlns:music="http://www.musicdatabase.org/music/records">
<music:record>
    <music:artist>Wynton Marsalis</music:artist>
    <music:title>Think of One ...</music:title>
    <music:recorded>1983</music:recorded>
    <music:label>Columbia Records</music:label>
    <music:remark xml:lang="en">
	Columbia Records 12" 33-1/3 rpm LP, #FC-38641, Stereo. The record is
	still clean and shiny and looks unplayed (looks like NM condition).
	The cover has very light surface and edge wear.
    </music:remark>
    <music:remark xml:lang="de">
	Columbia Records 12" 33-1/3 rpm LP, #FC-38641, Stereo. Die Platte
	ist noch immer sauber und gl&#19386;end und sieht ungespielt aus
	(NM Zustand). Das Cover hat leichte Abnutzungen an Oberfl&#18664;e und Ecken.
    </music:remark>
</music:record>
</Q5>
</etalon>
</case>

<case id="1.7.4.6">
<descr>
Select the closing time elements of all AnyZone auctions currently monitored.
</descr>
<xquery><![CDATA[
declare namespace ma = "http://www.AuctionMediatorCompany.com/AuctionWatch";
declare namespace anyzone="http://www.AuctionMediatorCompany.com/auctioneers#anyzone";
<Q6>
{document("auction.xml")//ma:Auction[@anyzone:ID]/ma:Schedule/ma:Close}</Q6>
]]></xquery>
<etalon>
<Q6>
  <n0:Close xmlns:n0="http://www.AuctionMediatorCompany.com/AuctionWatch" xmlns:n2="http://www.w3.org/1999/XMLSchema-datatypes" n2:type="timeInstant">2000-03-23:07:41:34-05:00</n0:Close>
</Q6>
</etalon>
</case>

<case id="1.7.4.7">
<descr>
Select the homepage of all auctions where both seller and high bidder are
registered at the same auctioneer.</descr>
<xquery><![CDATA[
declare namespace ma = "http://www.AuctionMediatorCompany.com/AuctionWatch";
<Q7>
{
   for $a in document("auction.xml")//ma:Auction
   let $seller_id := $a/ma:Trading_Partners/ma:Seller/*:ID,
       $buyer_id  := $a/ma:Trading_Partners/ma:High_Bidder/*:ID
   where namespace-uri($seller_id) = namespace-uri($buyer_id)
   return $a/ma:AuctionHomepage
}
</Q7>
]]></xquery>
<etalon>
<Q7>
  <ma:AuctionHomepage
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:ma="http://www.AuctionMediatorCompany.com/AuctionWatch"
    xlink:type="simple"
    xlink:href="http://auctions.yabadoo.com/auction/13143816" />
</Q7>
</etalon>
</case>

<case id="1.7.4.8">
<descr>
Select all traders (either seller or high bidder) without negative
comments</descr>
<xquery><![CDATA[
declare namespace ma = "http://www.AuctionMediatorCompany.com/AuctionWatch";
<Q8>
{
 (
   for $s in document("auction.xml")//ma:Trading_Partners/ma:Seller
   where $s/*:NegativeComments = 0
   return $s
 )
union
 (
   for $b in document("auction.xml")//ma:Trading_Partners/ma:High_Bidder
   where $b/*:NegativeComments = 0
   return $b
 )
}
</Q8>
]]></xquery>
<etalon>
<Q8 xmlns:ma="http://www.AuctionMediatorCompany.com/AuctionWatch"
	xmlns:eachbay="http://www.AuctionMediatorCompany.com/auctioneers#eachbay"
	xmlns:xlink="http://www.w3.org/1999/xlink" >
<ma:High_Bidder>
  <eachbay:ID>VintageRecordFreak</eachbay:ID>
  <eachbay:PositiveComments>232</eachbay:PositiveComments>
  <eachbay:NeutralComments>0</eachbay:NeutralComments>
  <eachbay:NegativeComments>0</eachbay:NegativeComments>
  <ma:MemberInfoPage xlink:type="simple"
		     xlink:href="http://auction.eachbay.com/showRating/user=VintageRecordFreak"
		     xlink:role="ma:MemberInfoPage" />
</ma:High_Bidder>
</Q8>
</etalon>
</case>

<case id="1.8.4.1">
<descr>Convert the sample document from "partlist" format to "parttree" format (see
DTD section for definitions). In the result document, part containment is
represented by containment of one &lt;part&gt; element inside another. Each part
that is not part of any other part should appear as a separate top-level element
in the output document. </descr>
<xquery><![CDATA[
define function one_level( (: element :) $p) (: returns element :)
   {
   <part>
      {$p/@partid}
      {$p/@name}
     {
      for $s in $p/parent::*/part[@partof = $p/@partid]
      return one_level($s)
     }
   </part>
   } ;
<parttree>
{
   for $p in document("partlist.xml")//part[not (@partof)]
   return one_level($p)
}
</parttree>
]]></xquery>
<etalon>
<parttree>
  <part partid="0" name="car">
    <part partid="1" name="engine">
      <part partid="3" name="piston"/>
    </part>
    <part partid="2" name="door">
      <part partid="4" name="window"/>
      <part partid="5" name="lock"/>
    </part>
  </part>
  <part partid="10" name="skateboard">
    <part partid="11" name="board"/>
    <part partid="12" name="wheel"/>
  </part>
  <part partid="20" name="canoe"/>
</parttree>
</etalon>
</case>

<case id="1.9.4.1">
<descr>
Find Martha's spouse. </descr>
<xquery><![CDATA[
<result>
{
   let $doc := document('census.xml')
   for $m in $doc//person[@name="Martha"]
   return shallow($m/@spouse => person)
}
</result>
]]></xquery>
<etalon>
<result>
  <person name="Joe" job="Painter" spouse="Martha" />
</result>
</etalon>
</case>

<case id="1.9.4.2">
<descr>Find Joe's children.</descr>
<xquery><![CDATA[
define function children( (: element :) $p) (: returns list(element) :)
   {
   shallow($p/person) union shallow($p/@spouse => person/person)
   }
;   
<result>
{
   let $doc := document('census.xml')
   for $j in $doc//person[@name = "Joe"]
   return children($j)
}
</result>
]]></xquery>
<etalon>
<result>
  <person name="Sam" job="Nurse" />
  <person name="Karen" job="Doctor" spouse="Steve" />
  <person name="Dave" job="Athlete" spouse="Susan" />
</result>
</etalon>
</case>

<case id="1.9.4.3">
<descr>
Find parents of athletes.</descr>
<xquery><![CDATA[
<result>
{
   let $doc := document('census.xml')
   for $p in $doc//person
   where $p/person/@job = "Athlete"
      or $p/@spouse => person/person/@job = "Athlete"
   return shallow($p)
}
</result>
]]></xquery>
<etalon>
<result>
  <person name="Joe" job="Painter" spouse="Martha" />
  <person name="Martha" job="Programmer" spouse="Joe" />
  <person name="John" job="Artist" />
</result>
</etalon>
</case>

<case id="1.9.4.3orig">
<descr>
This is the W3C Use Cases version of the query 1.9.4.3.
It will not report that John is a parent of Helen,
because FOR will build empty sequence for $s while $p is set to John,
so neither WHERE nor RETURN will be calculated.
</descr>
<xquery><![CDATA[
<result>
{
   let $doc := document('census.xml')
   for $p in $doc//person,
       $s in $p/@spouse => person
   where $p/person/@job = "Athlete"
      or $s/person/@job = "Athlete"
   return shallow($p)
}
</result>
]]></xquery>
<etalon>
<result>
  <person name="Joe" job="Painter" spouse="Martha" />
  <person name="Martha" job="Programmer" spouse="Joe" />
</result>
</etalon>
</case>

<case id="1.9.4.4">
<descr>
Find people who have the same job as one of their parents. </descr>
<xquery><![CDATA[
<result>
{
   let $doc := document('census.xml')
   for $p in $doc//person,
       $c in $p/person
   where $p/@job = $c/@job
      or $p/@spouse => person/@job = $c/@job
   return shallow($c)
}
</result>
]]></xquery>
<etalon>
<result>
  <person name="Susan" job="Pilot" spouse="Dave" />
  <person name="Jane" job="Doctor" spouse="Fred" />
</result>
</etalon>
</case>

<case id="1.9.4.5">
<descr>
List names of parents and children who have the same job, and their jobs.</descr>
<xquery><![CDATA[
<result>
{
   let $doc := document('census.xml')
   return
   (
   for  $p in $doc//person,
	$c in $p/person[@job = $p/@job]
   return <match
	     parent = {$p/@name}
	     child = {$c/@name}
	     job = {$c/@job}
	  /> ,
   for  $p in $doc//person,
	$c in $p/@spouse => person/person[@job = $p/@job]
   return <match
	     parent = {$p/@name}
	     child = {$c/@name}
	     job = {$c/@job}
	  />
   )
}
</result>
]]></xquery>
<etalon>
<result>
  <match parent="Mary" child="Susan" job="Pilot" />
  <match parent="Karen" child="Jane" job="Doctor" />
</result>
</etalon>
</case>

<case id="1.9.4.6">
<descr>
Find Bill's grandchildren. </descr>
<xquery><![CDATA[
<result>
{
   let $doc := document('census.xml')
   for $b in $doc//person[@name = "Bill"] ,
       $c in $b/person | $b/@spouse => person/person ,
       $g in $c/person | $c/@spouse => person/person
   return
       shallow($g)
}
</result>
]]></xquery>
<etalon>

<result>
  <person name="Sam" job="Nurse" />
  <person name="Karen" job="Doctor" spouse="Steve" />
  <person name="Dave" job="Athlete" spouse="Susan" />
  <person name="Susan" job="Pilot" spouse="Dave" />
</result>
</etalon>
</case>

<case id="1.9.4.7">
<descr>
List name-pairs of grandparents and grandchildren. </descr>
<xquery><![CDATA[
<result>
{
   let $doc := document('census.xml')
   for $b in $doc//person ,
       $c in $b/person | $b/@spouse => person/person ,
       $g in $c/person | $c/@spouse => person/person
   return
       <grandparent
	  name = {$b/@name}
	  grandchild = {$g/@name}
       />
}
</result>
]]></xquery>
<etalon>
<result>
  <grandparent name="Bill" grandchild="Sam" />
  <grandparent name="Bill" grandchild="Karen" />
  <grandparent name="Bill" grandchild="Dave" />
  <grandparent name="Bill" grandchild="Susan" />
  <grandparent name="Joe" grandchild="Fred" />
  <grandparent name="Joe" grandchild="Jane" />
  <grandparent name="Frank" grandchild="Sam" />
  <grandparent name="Frank" grandchild="Karen" />
  <grandparent name="Frank" grandchild="Dave" />
  <grandparent name="Frank" grandchild="Helen" />
  <grandparent name="Frank" grandchild="Steve" />
  <grandparent name="Martha" grandchild="Fred" />
  <grandparent name="Martha" grandchild="Jane" />
  <grandparent name="John" grandchild="Jane" />
</result>
</etalon>
</case>

<case id="1.9.4.8">
<descr>
Find Dave's parents-in-law (parents of his spouse, if any). </descr>
<xquery><![CDATA[
<result>
{
   let $doc := document('census.xml')
   for $s in $doc//person[@name = "Dave"]/@spouse => person,
       $sp in $s/.. | $s/../@spouse => person
   return shallow($sp)
}
</result>
]]></xquery>
<etalon>
<result>
  <person name="Mary" job="Pilot" />
</result>
</etalon>
</case>

<case id="1.9.4.9">
<descr>
Find people with no children.</descr>
<xquery><![CDATA[
define function children( (: element :) $p) (: returns list(element) :)
   {
   shallow($p/person) union shallow($p/@spouse => person/person)
   } ;
<result>
{
   let $doc := document('census.xml')
   for $p in $doc//person
   where empty(children($p))
   return shallow($p)
}
</result>
]]></xquery>
<etalon>

<result>
  <person name="Fred" job="Senator" spouse="Jane" />
  <person name="Susan" job="Pilot" spouse="Dave" />
  <person name="Dave" job="Athlete" spouse="Susan" />
  <person name="Helen" job="Athlete" />
  <person name="Jane" job="Doctor" spouse="Fred" />
</result>
</etalon>
</case>

<case id="1.9.4.10">
<descr>
Find single parents (people with children but no spouse) </descr>
<xquery><![CDATA[
<result>
{
   let $doc := document('census.xml')
   for $p in $doc//person[person]
   where empty($p/@spouse => person)
   return shallow($p)
}
</result>
]]></xquery>
<etalon>

<result>
  <person name="Bill" job="Teacher" />
  <person name="Sam" job="Nurse" />
  <person name="Mary" job="Pilot" />
  <person name="Frank" job="Writer" />
  <person name="John" job="Artist" />
</result>
</etalon>
</case>

<case id="1.9.4.11">
<descr>
List the names of all Joe's descendants. Show each descendant as an element
with the descendant's name as content and his or her marital status and number
of children as attributes. Sort the descendants in descending order by number of
children, and secondarily in alphabetical order by name.
</descr>
<xquery><![CDATA[
define function descrip( (: element :) $e) (: returns element :)
   {
   let $kids := $e/* union $e/@spouse => person/* ,
       $mstatus := if ($e[@spouse]) then "Yes" else "No"
   return
      <person married = {$mstatus} kids = {count($kids)}>
	 {string($e/@name)}
      </person>
   } ;
define function descendants( (: element :) $e) (: returns list(element) :)
   {
   let $children := ($e/* union $e/@spouse => person/*)
   return
     ($children union descendants ($children))
   } ;
let $doc := document('census.xml')
return
descrip(descendants($doc//person[@name = "Joe"]))
   sortby (@kids descending, .)
]]></xquery>
<etalon>
<person married="Yes" kids="1">Karen</person>
<person married="No" kids="1">Sam</person>
<person married="Yes" kids="0">Dave</person>
<person married="Yes" kids="0">Fred</person>
<person married="Yes" kids="0">Jane</person>
</etalon>
</case>

<case id="1.9.4.11orig">
<descr>
List the names of all Joe's descendants. Show each descendant as an element
with the descendant's name as content and his or her marital status and number
of children as attributes. Sort the descendants in descending order by number of
children, and secondarily in alphabetical order by name.
(The proposed solution is invalid because every person is in list of its own descendants.)
</descr>
<xquery><![CDATA[
define function descrip( (: element :) $e) (: returns element :)
   {
   let $kids := $e/* union $e/@spouse => person/* ,
       $mstatus := if ($e[@spouse]) then "Yes" else "No"
   return
      <person married = {$mstatus} nkids = {count($kids)}>
	 {string($e/@name)}
      </person>
   } ;
define function descendants( (: element :) $e) (: returns list(element) :)
   {
   if (empty($e/* union $e/@spouse => person/*))
   then $e
   else $e union descendants($e/* union $e/@spouse => person/*)
   } ;
let $doc := document('census.xml')
return
descrip(descendants($doc//person[@name = "Joe"]))
   sortby (@nkids descending, .)
]]></xquery>
<etalon>
<person married="Yes" nkids="3">Joe</person>
<person married="Yes" nkids="1">Karen</person>
<person married="No" nkids="1">Sam</person>
<person married="Yes" nkids="0">Dave</person>
<person married="Yes" nkids="0">Fred</person>
<person married="Yes" nkids="0">Jane</person>
</etalon>
</case>

</cases>

